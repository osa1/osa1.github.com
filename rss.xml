<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - All posts</title>
    <link href="http://osa1.net/rss.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/rss.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-09-19T00:00:00Z</updated>
    <entry>
    <title>Quick rant: K Framework is broken</title>
    <link href="http://osa1.net/posts/2013-09-19-k-framework-broken.html" />
    <id>http://osa1.net/posts/2013-09-19-k-framework-broken.html</id>
    <published>2013-09-19T00:00:00Z</published>
    <updated>2013-09-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="quick-rant-k-framework-is-broken">Quick Rant: K Framework is broken</h2>
<p>In this short rant I’ll demonstrate how K Framework is broken and how you can avoid the problem. If you don’t know what is K Framework or don’t use it, you probably want to ignore this post.</p>
<p>Let’s think this completely useless K module:</p>
<pre><code>module TEST

  syntax Exp ::= &quot;nilExp&quot;
               | return(Exp) [strict]

  syntax Val ::= &quot;nil&quot;

  syntax KResult ::=  Val

  rule nilExp =&gt; nil ... [nil]

endmodule</code></pre>
<p>and this TEST program:</p>
<pre><code>return(nilExp)</code></pre>
<p>what do you think this program has in K cell when it gets stuck? It’s not really hard to guess. Since we annotate <code>return(Exp)</code> syntax with <code>strict</code>, it’s argument gets evaluated according to our <code>nil</code> rule and then it gets stuck. At this point K cell will be:</p>
<pre><code>&lt;k&gt;
    return ( nil )
&lt;/k&gt;</code></pre>
<p>which may not be very surprising for you, but there’s something wrong going on here. In our syntax declaration we defined argument or <code>return</code> to be an <code>Exp</code>, but in the term in our K cell it’s <code>Val</code>.</p>
<p>At this point you can say that this is how heating/cooling works an there’s nothing wrong here but then we have another problem: there’s no way for the user to write rules that does exactly what heating/cooling rules do. In our example above you’d expect from strictness annotation to generate rules like this:</p>
<pre><code>rule return(E:Exp) =&gt; E ~&gt; return(HOLE)
rule V:Val ~&gt; return(HOLE) =&gt; return(V)</code></pre>
<p>but this is not a valid rule and it fails with the this error message:</p>
<pre><code>[Error] Critical: type error: unexpected term &#39;V:Val &#39; of sort &#39;Val&#39;, expected sort &#39;Exp&#39;.
        File: /home/omer/K/lua-semantics/test/test.k
        Location: (11,35,11,36)</code></pre>
<p>and what’s more confusing is that even though K generated rule somehow generates the term <code>return(Val)</code>, you cannot match it in your rules because this term is actually ill-typed:</p>
<pre><code>rule return(V:Val) =&gt; .
...
[Error] Critical: type error: unexpected term &#39;V:Val &#39; of sort &#39;Val&#39;, expected sort &#39;Exp&#39;.
        File: /home/omer/K/lua-semantics/test/test.k
        Location: (11,10,11,15)</code></pre>
<p>which means there’s no way for you to work on this term. This time you’re stuck :-p</p>
<p>We discussed this on k-user mailing list a bit but there isn’t really a solution – we only have a workaround. Here’s the reason of this problem(quoted from mailing list <a href="http://lists.cs.uiuc.edu/pipermail/k-user/2013-September/000475.html">discussion</a>):</p>
<blockquote>
<p>Your grammar is only enforced during parsing.</p>
<p>After the definition is compiled, return is just a label that may be applied to a list of children.</p>
<p>In particular, the automatically generated cooling rule only puts a side condition that enforces IsKResult, which nil passes.</p>
</blockquote>
<p>Wow, this sounds like really broken to me. Anyway, only solution I could find to this is to add <code>Val</code> syntactic category to a member of <code>Exp</code> syntactic category. This is an obvious solution, but very bad one also. Because by having distinguished <code>Val</code> and <code>Exp</code> syntactic categories what I’m trying to do is to force my program to get stuck as soon as possible when something went wrong, instead of continuing evaluation and get stuck at a point where very very far from where the error actually occured.</p>
<p>Rest of this post is also sent to k-list mailing list and contains my ideas on implementing strictness annotations. These ideas may be wrong – I’m only a beginner K user.</p>
<hr />
<p>This is how I’d design strictness annotations(but I’m probably wrong since I’m just a beginner in K).</p>
<p>Let’s say I have this syntax:</p>
<pre><code>syntax Exp ::= P(Exp, Exp, Exp) [strict]</code></pre>
<p>for intermediate steps while fully evaluating this expression, I’d design the K framework so that these syntax and rules would be automatically generated:</p>
<pre><code>syntax K ::= P__rw_1(Val, Exp, Exp) [strict]
           | P__rw_2(Exp, Val, Exp) [strict]
           | P__rw_3(Exp, Exp, Val) [strict]

rule P(E1, E2, E3) =&gt; E1 ~&gt; P__rw_1(HOLE, E2, E3)
rule P(E1, E2, E3) =&gt; E2 ~&gt; P__rw_1(E1, HOLE, E3)
rule P(E1, E2, E3) =&gt; E3 ~&gt; P__rw_1(E1, E2, HOLE)

rule V:Val ~&gt; P__rw_1(HOLE, E2, E3) =&gt; P__rw_1(V, E2, E3)
rule V:Val ~&gt; P__rw_2(E1, HOLE, E3) =&gt; P__rw_2(E1, V, E3)
rule V:Val ~&gt; P__rw_3(E1, E2, HOLE) =&gt; P__rw_3(E1, E2, V)</code></pre>
<p>and then same rule generation scheme applies to <code>P__rw_1</code>, <code>P__rw_2</code>, <code>P__rw_3</code> too. In the end we’ll end up with:</p>
<pre><code>syntax K ::= P__rw(Val, Val, Val)</code></pre>
<p>and this would give the user full control of evaluation with strongly typed manner. (ie. without fighting with K framework parser)</p>
<p>(<code>strict[n]</code>, <code>seqstrict</code> etc. rules are specialized cases of this general strictness rule generation scheme)</p>]]></summary>
</entry>
<entry>
    <title>On proof automations -- part 2</title>
    <link href="http://osa1.net/posts/2013-09-17-proof-automation-2.html" />
    <id>http://osa1.net/posts/2013-09-17-proof-automation-2.html</id>
    <published>2013-09-17T00:00:00Z</published>
    <updated>2013-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://adam.chlipala.net/">Adam Chilpala’s</a> <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> has a great discussion on writing automated proofs and readability of proofs. Highly recommended. Chapter 16(page 319 on current revision).</p>
<p>I think one key thing to realize about interactive theorem proving is that there is no perfect, or maybe even good, solution to the problem of proof representation. Tactics help, but without automation tactic based proofs are just too fragile(every change in definitions implies changes in proofs) and verbose. But automated proofs are very hard to read, and it’s very hard to modify automated proofs for changes. CPDT book has a great example of this. Let’s think of this proof(I’ll skip the definitions, just think some simple arithmetic expressions language just like you could find in any elementary programming language theory book)</p>
<pre class="coq"><code>Theorem eval_times : forall k e,
    eval (times k e) = k * eval e.
Proof.
  induction e as [| ? IHe1 ? IHe 2]; [
    trivial
    | simpl; rewrite IHe1; rewrite IHe2; rewrite mult_plus_distr_l; trivial ].
Qed.</code></pre>
<p>And now let’s say you added one more constructor to arithmetic expression syntax. How to change this proof to adopt the changes? I don’t think there’s a way to do that without first writing the version without automation. And that brings us back to my first post.</p>
<p>I think the reason why I think too much about this stuff instead of writing some proofs is that I look for elegance and simplicity in my programs. And only if necessary I try to make my programs efficient(fast, small, whatever). After some simple trivial proofs that I did for learning I never found my proofs satisfactory. They are either very very long and repetitive or very hard to understand and modify. It’s very hard to find a sweet-spot in proofs that is not very repetitive and long and still possible to read and understand.</p>
<p>You can always apply methods you learned to make your programs easier to read and modify, like moving some code to a new function with a useful name and formal parameters etc. but in the case of proofs it’s also very hard to find what pieces are considered worthy to be a lemma and what would be useful name for it.</p>
<p>My ideas about proof automation is changed from “no way I use them” to “okay they can be very useful for eliminating repetition without adding obscurity to the proof” in one day. I’ll continue writing Coq proofs for while and probably add new posts on this topic later.</p>]]></summary>
</entry>
<entry>
    <title>On proof automations</title>
    <link href="http://osa1.net/posts/2013-09-11-proof-automation.html" />
    <id>http://osa1.net/posts/2013-09-11-proof-automation.html</id>
    <published>2013-09-11T00:00:00Z</published>
    <updated>2013-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working with constructive systems, at the lowest level you can directly construct proof objects by writing programs. But for realistic scenarios, this is probably too hard to do. Coq and Idris like languages provide an alternative way to construct proof objects: tactics. Tactics provide a way to derive proofs in a way that is somewhat like informal proofs given in spoken languages. But theorems you’re trying to prove is already too complex, and in some parts, very repetitive.</p>
<p>That <em>tactics</em> Coq like theorem provers provide also help you construct proofs with some automation commands. For instance, you can apply same steps several times, until you prove some subgoals. Or you can search for a proof by applying some steps in different combinations.</p>
<p>What doesn’t make sense to me is that in general you cannot really use that automation methods before manually writing long and hard proof by hand and showing that your theorem is really a theorem and it indeed has some repetitive parts.</p>
<p>And at this point you’re probably better off leaving the proof as-is because replacing explicit steps with some magic commands(I’ll come to this point later) only makes the proof harder to read, without any other advantages.</p>
<p>I have similar ideas for <code>auto</code> tactic. What it does is that it searches for a proof by applying different combinations of <code>apply</code> and <code>intros</code> tactics(with some limitations – it only uses apply for hypothesis and hint database which you generate while defining inductive definitions).</p>
<p>Now my problem with <code>auto</code> is that you can only use it when you absolutely sure that your theorem is indeed a theorem – that is, it has a proof. And how can you know that your theorem is correct? The only way to know this is to write a proof for it. Now let’s say <code>auto</code> tactic fails, and when this happens it can’t really say anything. Why did it fail? It may be because your proof is actually too long and it searched for a while but couldn’t find a proof(you can specify search depth as an optional parameter of <code>auto</code> tactic). Or maybe your hint base is not good enough. Or maybe your theorem is not actually a theorem and you cannot prove it.</p>
<p>So both proof search tactics and repetition elimination tactics have this same common problem: you cannot know that they work before writing the proof itself. And automation generally makes the proof unreadable.</p>
<p>Adam Chilpala’s “Certified Programming with Dependent Types” book encourages that automated way of proving. You have that complicated theorem that you don’t even understand what it is saying? No problem, <code>crush</code> tactic(which is not standard, distributed with CPDT book) will prove it for you in one command.</p>
<p>I’m not saying that <code>crush</code> like tactics are necessarily bad and you shouldn’t use it. I’d probably use it in real world when I need a proof that <code>crush</code> can generate and I don’t have time or motivation to do it myself.</p>
<p>And repetition elimination tactics are useful when you have a syntax tree with 15 constructors and you’re proving some theorem that’s relevant with only one of that constructors – 14 subgoals can be easily proved by some clever use of <code>;</code> operator in Coq.</p>
<p>What I’m saying that is several things:</p>
<ul>
<li>Automated proofs can make proofs harder to read and most of the time you already need to have written the long proof to see that it has repetitive parts or at least it is provable. (certainly there are cases where you’ll find yourself trying to prove something wrong)</li>
<li>Once a long proof is written, there is little or no need to remove that proof and replace it with an automated version. (one reason to do that is to have same proof working even after some inductive definitions is expanded/changed)</li>
<li>Most importantly, <code>crush</code> like automation tactics are pure black magic and doesn’t really teach you anthing. As a hobbyist who self-study all this, I prefer learning the principles instead of scripts and magic commands and black boxes.</li>
</ul>
<p>For this reasons I’m trying to use proof automation as little as possible.</p>]]></summary>
</entry>
<entry>
    <title>Internet</title>
    <link href="http://osa1.net/posts/2013-08-29-internet.html" />
    <id>http://osa1.net/posts/2013-08-29-internet.html</id>
    <published>2013-08-29T00:00:00Z</published>
    <updated>2013-08-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://i.imgur.com/dx7sVXj.jpg">Şunu</a> görüp, önceki bazı tecrübe ve gözlemlerle beraber üzerinde biraz düşündükten sonra internetin anlamını çözdüğünü düşündüm:</p>
<p>“muhtemelen hepsi uydurma ama yine de güzel”</p>]]></summary>
</entry>
<entry>
    <title>MANTI - Prolog implementation in 515 lines of Haskell</title>
    <link href="http://osa1.net/posts/2013-07-31-announce-manti.html" />
    <id>http://osa1.net/posts/2013-07-31-announce-manti.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/osa1/MANTI">MANTI</a> is a pure Prolog implementation in 515 lines of Haskell. It’s only implements pure parts, meaning it doesn’t have cuts, IO predicates, non-pure arithmetic(<code>is</code> structures in modern Prolog implementation) or other structures that break logical reasoning of Prolog programs.</p>
<p>Here are some example Prolog programs that currently runs under MANTI: (you can find these in <code>tests/</code> folder in source repository)</p>
<ul>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/einstein.pl">Einstein’s riddle</a> – also called Zebra Puzzle. You can see problem definition in <a href="http://en.wikipedia.org/wiki/Zebra_Puzzle">Wikipedia - Zebra Puzzle</a>.</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/nqueens.pl">N-queens problem</a> (not that it takes some time to solve it for board bigger than 5x5, reasons for that slowness explained below)</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/zurg.pl">Escape from Zurg puzzle</a> - you can see a paper with definition of this problem <a href="http://web.engr.oregonstate.edu/~erwig/zurg/">here</a>.</li>
</ul>
<p>My aim while writing MANTI was to make it as simple as possible, yet a complete Prolog implementation that is capable to solve some real problems. For this reasons, it doesn’t have arithmetic, list structures and list operations built-in. Instead, arithmetic is implemented using <a href="http://en.wikipedia.org/wiki/Peano_axioms">Peano definitions</a>, you can see the implementation <a href="https://github.com/osa1/MANTI/blob/master/tests/peano.pl">here</a>. List operations are also implemented in MANTI itself, you can see definitions <a href="https://github.com/osa1/MANTI/blob/master/tests/list.pl">here</a>. List syntax is nothing special, it’s just a syntactic sugar that destructs to ordinary Prolog functors(you can see parser for list syntax <a href="https://github.com/osa1/MANTI/blob/master/src/Parser.hs#L80">here</a>).</p>
<p>For these reasons(and probably others, for instance, unification and <code>not</code> connective are implemented in most inefficient ways possible), it’s very slow. Also, there’s no way to disable occurs check without recompiling MANTI.</p>
<p>It’s mostly done and I don’t think I’ll work more on that. I hope you find MANTI useful(for learning purposes or others).</p>]]></summary>
</entry>
<entry>
    <title>Dinamik programlama hakkında</title>
    <link href="http://osa1.net/posts/2013-07-30-dp-hakkinda.html" />
    <id>http://osa1.net/posts/2013-07-30-dp-hakkinda.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı, inanılmaz yoğun olduğum bir dönemde, acele içerisinde, kulakta müzik ile, 1 saat içerisinde yazılmış bir dinamik programlama tutorialıdır. Belki bir fayda sağlar diye bloguma da koymak istedim. Aslında bir ders kapsamında yazıldı(anlatım kısmı daha önceden yapılmıştı, rapor yazamamıştım).</p>
<p>Yanlışlık görürseniz lütfen yorum kısmında belirtin.</p>
<hr />
<h2 id="giriş">Giriş</h2>
<p>Dinamik programlama, problemlerin bazı özellikleri sağlaması şartıyla, çözümlerin kompleksliğini düşürmeyi amaçlayan bir programlama yöntemidir.</p>
<p>Bir problemin şu iki şartı sağladığını düşünelim:</p>
<ul>
<li>Büyük problemin optimal çözümü aynı problemin küçük örneklerinin optimal çözümlerine bağldır.</li>
<li>Bu küçük problemler büyük problemin çözümü sırasında defalarca çözülmektedir.</li>
</ul>
<p>Bu durumda küçük problemlerin çözümlerini bir şekilde saklayarak problemlerin yeniden çözülmesi önlenmiş olur ve sonuçta daha verimli bir algoritma elde etmiş oluruz.</p>
<p>Basit ve klasik bir örnek ile başlayalım,</p>
<p>(her bir örnek birbirinden farklı çözüm ve düşünme tekniklerini içermekte)</p>
<h2 id="örnek-1-para-üstü-problemi">Örnek 1: Para üstü problemi</h2>
<p>Elimizde farklı değerlerde bozuk paralar var, N para üstünü en az miktarda bozuk para vererek tamamlamak istiyoruz. Elimizde 1 değerinde bozuk para var, dolayısıyla her miktarda para üstünü verebiliriz.</p>
<p>Öncelikle bu çözüm için aç gözlü bir algoritmanın neden çalışmayacağını gözlemleyelim(diğer türlü çözüm aç gözlü bir algoritma olurdu).</p>
<p>37 para üstü vermek istiyoruz ve elimizde 10, 9 ve 1 değerlerinde bozukluklar var. Aç gözlü bir algoritma bu miktarı şöyle tamamlayacaktır:</p>
<pre><code>10 - 10 - 10 - 1 - 1 - 1 - 1 - 1 - 1 - 1 -- toplamda 10 bozuk para.</code></pre>
<p>Fakat aslında daha iyi bir çözüm mevcut:</p>
<pre><code>10 - 9 - 9 - 9 -- toplamda 4 para.</code></pre>
<p>Aç gözlü algoritmanın bu problem için çalışmadığını gözlemlemiş olduk. Dinamik programlamaya geçmeden önce ikinci adım olarak bu problemin optimal çözümünü(yani en az miktarda bozuk para ile çözecek çözüm) bulan özyineli bir algoritma yazalım.</p>
<p>N değerinde para üstü tamamlamaya çalışıyor olalım ve A, B, C, … diye isimlendirdiğimiz bozuk paralarımız olsun. Bu durumda optimal çözüm için ya A değerinde bir bozuk para verip, N - A para üstünü tamamlamaya çalışırız(özyineleme), veya B değerinde bir bozuk para verip, N - B para üstünü tamamlamaya çalışırız(özyineleme) … ta ki tüm paraları deneyene kadar. Bu çözümün C++ programı şeklinde ifade edilmiş hali şöyle:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> findMinCoin(<span class="dt">const</span> vector&lt;<span class="dt">unsigned</span>&gt; &amp;coins, <span class="dt">unsigned</span> amount)
{
  <span class="kw">if</span> (amount == <span class="dv">0</span>)
    <span class="kw">return</span> <span class="dv">0</span>;

  <span class="dt">int</span> result = -<span class="dv">1</span>;

  <span class="kw">for</span> (<span class="dt">unsigned</span> coin : coins) {
    <span class="kw">if</span> (amount &gt;= coin) {
      <span class="dt">int</span> r = findMinCoin(coins, amount - coin) + <span class="dv">1</span>;
      <span class="kw">if</span> (result == -<span class="dv">1</span> || r &lt; result)
        result = r;
    }
  }

  <span class="kw">return</span> result;
}</code></pre>
<p>Bu özyineli çözüm bize dinamik programlama yapabilmek için aradığımız iki şarttan birini sağladığımızı söylüyor.</p>
<p><code>findMinCoin</code>in optimal çözümü bulduğunu varsayalım. <code>amount - coin</code> kısmı bize alt problemlerin çözümünü aradığımızı gösteriyor, ve bu çözümü yine <code>findMinCoin</code> aradığımızdan ve <code>findMinCoin</code> optimal çözümü bulduğundan, dinamik programlama yapabilmemiz için gereken ilk şartı sağlamış oluyoruz.</p>
<p>Diyelim ki varsayımımız yanlıştı ve <code>findMinCoin</code> optimal çözümü bulmuyordu. Bu durumda zaten çözümümüz yanlış oluyor, çünkü <code>findMinCoin</code>i asıl problemimizin optimal çözümünü bulmak için çağırıyoruz.</p>
<p>Dinamik programlamanın ikinci şartı için problemin hangi alt problemin kaç kere çağırıldığını farketmemiz gerekiyor. Bunun için şöyle bir gözlem yapalım:</p>
<p>Para üstümüz 37 ve paralarımız 10, 9 ve 1 (ilk örnek). 37’den 25’e gitmenin çok yolu var, bunlardan bazıları:</p>
<pre><code>10 - 1 - 1
9 - 1 - 1 - 1
1 - 1 - 1 - 1 …. - 1 (12 tane)</code></pre>
<p>Tüm bu durumlar için 25 para üstünü tamamlamayı çözen alt problemimiz paylaşılacak. <code>findMinCoin(coins, 25)</code> çağrısının en azından 3 kere yapıldığını göstermiş olduk. Daha pek çok alt problemin paylaşıldığı benzer bir şekilde kolayca gözlemlenebilir.</p>
<p>Bu durumda, neden <code>findMinCoin(coins, 25)</code> çağrısının cevabını bir yerde saklayıp, gerektiğinde yeniden çözmek yerine cevabı sakladığımız yerden okuyup vermiyoruz? Bu arada tüm özyineli çağrılar için <code>coins</code> parametresinin hep aynı olduğuna dikkat.</p>
<p>Bu dönüş değerlerinin bir yerde saklanıp, yeniden hesaplanmamasına <em>memoization</em> adı veriliyor ve dinamik programlama yapmanın en temel yöntemlerinden biri.</p>
<p>Öncelikle memoization’ın bize ne kazandıracağını farkedelim. İlk çözümümüzde her bir para üstü için problemimiz bozuk para sayısı kadar özyineli çağrı yapacak.</p>
<p>M para üstümüz olsun ve N tane bozuk paramız olsun. Bu durumda M için N tane özyineli çağrı yapılacak. Kabaca, elimizdeki en küçük paranın 1 olduğunu düşündüğümüzde, bu özyineli çağrılar M kere yapılacak. Her seviyede N özyineli çağrı bize O(M ^ N) kompleksliğinde bir algoritma verecektir.</p>
<p>Her bir alt problemi memozation yardımıyla bir kere çözdüğümüz durumda ise, tamamlamak istediğimiz para üstümüz M olduğundan ve M - 1 alt probleme sahip olduğumuzdan O(M*N) bir komplekslik elde edeceğiz.</p>
<p>Örnek implementasyon şöyle:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> findMinCoin(vector&lt;<span class="dt">int</span>&gt; table, <span class="dt">const</span> vector&lt;<span class="dt">unsigned</span>&gt; &amp;coins, <span class="dt">unsigned</span> amount)
{
  <span class="kw">if</span> (table[amount] != -<span class="dv">1</span>)
    <span class="co">// problem daha onceden cozulmus, cevaba tablodan bak</span>
    <span class="kw">return</span> table[amount];

  <span class="co">// problem henuz cozulmemis, coz</span>
  <span class="kw">for</span> (<span class="dt">unsigned</span> coin : coins) {
    <span class="kw">if</span> (amount &gt;= coin) {
      <span class="dt">int</span> r = <span class="dv">1</span> + findMinCoin(table, coins, amount - coin);
      <span class="kw">if</span> (table[amount] == -<span class="dv">1</span> || r &lt; table[amount])
        table[amount] = r;
    }
  }

  <span class="kw">return</span> table[amount];
}</code></pre>
<p>Bu noktada özyineli çağrı yapmadan yapılabilecek alternatif bir çözüm için şunu farketmek gerekir: 0 para üstü için cevap zaten belli. 1 para üstü için cevabımızı sadece 1 değerinde bozuk para verip, 0 alt problemi için tabloya bakarak çözebiliriz. Diyelim ki 10 için çözüyoruz, 1 para verip 9 için cevaba tablodan bakmak isteriz, veya 9 para verip 1 için tabloya bakmak isteriz, veya 10 para verip 0 için tabloya bakmak isteriz vs. Yani aslında tabloda bir M değerinden önceki tüm değerler için cevap belliyse, kolayca o değerler arasından gerekli değerlere bakarak tabloda M’i doldurabiliriz. Bu da bizi 0. elemandan başlayarak tüm tabloyu adımlayarak doldurmayı içeren şu çözüme götürür:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> fillMinCoin(<span class="dt">const</span> vector&lt;<span class="dt">unsigned</span>&gt; &amp;coins, vector&lt;<span class="dt">int</span>&gt; &amp;tbl, <span class="dt">unsigned</span> amount)
{
  <span class="kw">for</span> (<span class="dt">unsigned</span> coin : coins)
    <span class="kw">if</span> (amount &gt;= coin &amp;&amp;
        (tbl[amount - coin] + <span class="dv">1</span> &lt; tbl[amount]
         || tbl[amount] == -<span class="dv">1</span>))
      tbl[amount] = tbl[amount - coin] + <span class="dv">1</span>;
}</code></pre>
<p>Daha sonra bu tablodan gerekli elemana bakarak cevabı öğrenmiş oluruz. Bu şekilde bir çözüm dinamik programlamanın doğasını bize daha iyi gösteriyor. Dinamik programlama temelde tablolamaya dayanıyor.</p>
<h2 id="örnek-2-en-uzun-artan-altdizi-problemi">Örnek 2: En uzun artan altdizi problemi</h2>
<p>İki harf dizisi(string) düşünelim. En uzun artan altdizi, şu şekilde tanımlanmıştır:</p>
<p>A1 A2 A3 … AN</p>
<p>Her bir harf hem ilk dizide hem ikinci dizide bulunmakta, ve herhangi bir A N-1, A N için A N - 1 ilk dizide A N’den önce bulunmakta ve A N - 1 ikinci dizide A N’den önce bulunmaktadır.</p>
<p>Örnek:</p>
<pre><code>String 1: cbeb
String 2: fdceb

Cevap: ceb</code></pre>
<p>olacaktır. c harfi birinci dizide ilk eleman, ikinci dizide 3. eleman olarak bulunuyor, e ilk dizide 3., ikinci dizide 4. eleman, b harfi ilk dizide 4. eleman, ikinci dizide 5. eleman olarak bulunmakta.</p>
<p>Bir probleme dinamik programlamanın uygulanabileceğini görmek için önce başta anlatılan iki şart kontrol edilmelidir. Bunun için güzel bir yolun problemin özyineli bir çözümünü yapmak olduğunu daha önceden anlatmıştık. Şimdi bu sorunu özyineli bir şekilde nasıl çözebileceğimize bakalım. Girdilerimiz S1 ve S2 olsun:</p>
<ul>
<li>Herhangi birinin boş string olması dorumunda cevabımız boş string olacaktır.</li>
<li>Diğer durumda, S1 ve S2’nin son harflerini düşünelim:</li>
<li>Eğer bu harfler aynı ise, cevabımıza dahil olacak bir harfi bulduk demektir. Problemin geriye kalanı S1 ve S2 stringlerinin son harfleri çıkarılmış halleri için çözülmeli ve bu son harf cevaba eklenmelidir.</li>
<li>Eğer harfler farklı ise, iki ayrı alt problem elde ederiz: ya S1 stringinin tamamı ve S2’nin son harfi hariç olan kısmı bize en uzun cevabı verecektir, veya S1 stringinin en son harfi hariç kısmı ile S2’nin tamamı en uzun cevabı verecektir. İkisini de çözeriz ve daha uzun olan cevap çözümümüz olur.</li>
</ul>
<p>Bu çözümün Haskell implementasyonu şu şekilde: (sadelik açısından bu kısım C++ ile yazılmadı, dinamik programlama hali C++ ile verilecek)</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">solve ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
solve s1 s2
  <span class="fu">|</span> <span class="fu">null</span> s1 <span class="fu">||</span> <span class="fu">null</span> s2 <span class="fu">=</span> <span class="st">&quot;&quot;</span>
solve s1 s2 <span class="fu">=</span>
    <span class="kw">let</span> (h1, t1) <span class="fu">=</span> <span class="fu">splitAt</span> (<span class="fu">length</span> s1 <span class="fu">-</span> <span class="dv">1</span>) s1
        (h2, t2) <span class="fu">=</span> <span class="fu">splitAt</span> (<span class="fu">length</span> s2 <span class="fu">-</span> <span class="dv">1</span>) s2
     <span class="kw">in</span> <span class="kw">if</span> t1 <span class="fu">==</span> t1 
          <span class="kw">then</span> solve h1 h2 <span class="fu">++</span> t1
          <span class="kw">else</span>
            <span class="kw">let</span> result1  <span class="fu">=</span> solve h1 s2
                result2  <span class="fu">=</span> solve s1 h2
             <span class="kw">in</span> <span class="kw">if</span> <span class="fu">length</span> result1 <span class="fu">&gt;</span> <span class="fu">length</span> result2
                  <span class="kw">then</span> result1
                  <span class="kw">else</span> result2</code></pre>
<p>Çözümün kompleksliğini düşünelim: Birbirine eşit olmayan M ve N uzunluğunda iki string düşünelim, M ve N - 1 uzunluğunda, M - 1 ve N uzunluğunda ve M - 1, N - 1 uzunluğunda stringler için özyineli çağrılar yapılacak. Her birinden yine 3 farklı özyineli çağrı ve toplamda M + N seviyede her seviyede 3 çağrı yapılacağından O((M + N) ^ 3) kompleksliğinde bir algoritmamız olur.</p>
<p>Dinamik programlamanın mümkün olduğunu görmek için fonksiyonun iki string girdimizin ilk kaç harfi üzerinden çağırıldığını bir ağaç üzerinden takip etmek yeterli olacaktır.</p>
<p>Bu durumda stringlerin ilk kaç harfi için çözümü bulduğumuzu iki boyutlu bir tabloda tutabiliriz. Örneğin tablodaki (3, 5) elemanı bize ilk stringin ilk 3 elemanı, ikinci stringin ilk 5 elemanı için bulduğumuz çözümü verecektir.</p>
<p>Yazıyı kısa tutmak adına bu noktadan sonra direkt olarak adımlayarak tablo doldurma şeklinde düşünelim. Problemin M ve N harflik hali için (M - 1, N), (M - 1, N - 1) ve (M, N - 1) lik hallerini çözmemiz gerekecek. Tablo üzerinde düşündüğümüzde, eğer tabloyu satır satır doldurursak, her bir sonraki adımda gerekli önceki adımları zaten elde etmiş olduğumuz görülebilir.</p>
<p>Burada tabloda tutacağımız her bir değer iki şeyi göstermeli, 1) string uzunluğu cinsinden cevap 2) o adıma geldiğimizde eğer iki stringin de son harflerini cevaba katıyorsak, bu stringin hangi harf olduğu.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> solve(table &amp;tbl,
    <span class="dt">const</span> string &amp;str1, <span class="dt">const</span> string &amp;str2)
{
  <span class="kw">for</span> (us i = <span class="dv">0</span>; i &lt; str1.size(); i++)
    <span class="kw">if</span> (str2[<span class="dv">0</span>] == str1[i])
      tbl(i, <span class="dv">0</span>) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(&#39; &#39;, <span class="dv">1</span>);
    <span class="kw">else</span>
      tbl(i, <span class="dv">0</span>) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(&#39; &#39;, <span class="dv">0</span>);

  <span class="kw">for</span> (us i = <span class="dv">0</span>; i &lt; str2.size(); i++)
    <span class="kw">if</span> (str1[<span class="dv">0</span>] == str2[i])
      tbl(<span class="dv">0</span>, i) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(&#39; &#39;, <span class="dv">1</span>);
    <span class="kw">else</span>
      tbl(<span class="dv">0</span>, i) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(&#39; &#39;, <span class="dv">0</span>);

  <span class="kw">for</span> (us i = <span class="dv">1</span>; i &lt; str1.size(); i++)
    <span class="kw">for</span> (us j = <span class="dv">1</span>; j &lt; str2.size(); j++)
      <span class="kw">if</span> (str1[i] == str2[j])
        tbl(i, j) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(str1[i], tbl(i - <span class="dv">1</span>, j - <span class="dv">1</span>)-&gt;second + <span class="dv">1</span>);
      <span class="kw">else</span> {
        us s1 = tbl(i - <span class="dv">1</span>, j)-&gt;second;
        us s2 = tbl(i, j - <span class="dv">1</span>)-&gt;second;

        <span class="kw">if</span> (s1 &gt; s2)
          tbl(i, j) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(&#39; &#39;, s1);
        <span class="kw">else</span>
          tbl(i, j) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(&#39; &#39;, s2);
      }
}</code></pre>
<p>Bu çözümdeki iç içe iki for döngüsü tablonun tamamını bir turda ve her bir adım için 3 işlemde doldurduğumuzu gösteriyor ve çözümümüz dolayısıyla O(M*N).</p>
<p>Bu problemin alıştırması <a href="http://www.spoj.com/SPOJ/problems/TLCS/">http://www.spoj.com/SPOJ/problems/TLCS/</a> adresinden yapılabilir.</p>
<h2 id="aşağıdan-yukarıya-ve-yukarıdan-aşağıya-çözümler">Aşağıdan-yukarıya ve yukarıdan-aşağıya çözümler</h2>
<p>Bu noktada iki farklı dinamik programlama tekniği görmüş olduk. Biri memoization, biri ise adımlayarak tablo doldurma. Aralarında birkaç temel farklılık var.</p>
<p>Memoization çözümünde tabloyu nasıl dolduracağımızı düşünmemize gerek kalmadı. Eğer tabloda cevap bulunmamışsa, o yerdeki cevabın bulunması için özyineli çağrı yapıldı. Bu şekilde çözüme “yukarıdan-aşağı (top-down)” diyoruz.</p>
<p>İkinci çözüm yöntemimiz adımlayarak tablo doldurmaydı. Bu çözümün güzel yanı özyineli çağrı yapılmaması, fakat dezavantajı tabloyu nasıl bir sırayla dolduracağımızı düşünüp bulmamızı gerektirmesi. Diğer türlü, tabloda bir sonraki konumu doldururken aradığımız bir cevaba ulaşamayabiliriz.</p>
<p>Komplekslik olarak aralarında bir fark yok. Şahsi görüşüm memoization çözümünün daha güzel olduğu yönünde. Sebebi de yukarıda bahsettiğim gibi, tablo doldurma sırasını düşünmemize gerek olmaması.</p>
<h2 id="bir-soru-barkod">Bir soru: Barkod</h2>
<p>Sorunun tanımını orjinal kaynaktan okuyabilirsiniz: <a href="http://codeforces.com/problemset/problem/225/C">http://codeforces.com/problemset/problem/225/C</a></p>
<p>Her bir kolonu tamamen beyaza ve tamamen siyaha boyamanın masraflarını biliyor olalım.</p>
<p>N. kolonu beyaza boyamak istediğimizi düşünelim, en az A en fazla B genişliğinde kolonlar istiyor olalım. Bu durumda X = [A … B] aralığı için N - X. kolonun siyah, [N - X + 1 … N] aralığındaki kolonların beyaz olması bize bir cevap verir(renklerin tam tersi olma durumu 2. bir cevap).</p>
<p>Burada farkedilmesi gereken şen, N - X. kolonun siyah olması aslında bir alt problem, ve en doğal ifade edilme şeklide bir özyineli fonksiyon ile olur.</p>
<p>Peki alt problemler paylaşılıyor mu? Şöyle düşünelim, en az 5, en fazla 10 genişliğinde kolonlar istiyor olalım ve şu anda 15. kolonu boyuyor olalım. Bu durumda 10, 9, 8, 7, … 6. kolona kadar olan kısımlar için aynı problemi yeniden çözeceğiz. 16. kolon için ise 19, 9, … 7. kolona kadar olan kısımları bir yeniden çözmemiz gerekecek. Ciddi miktarda alt problem paylaşılıyor.</p>
<p>Herhangi bir kolon için sadece o kolondan önceki kolonların cevabına ihtiyaç duyuyor olmamız tek boyutlu bir tabloda dinamik programlama yapabileceğimizi gösteriyor. Bu durumda şöyle bir cevap elde ediyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">unsigned</span> us;
...
<span class="dt">void</span> solveDP(vector&lt;<span class="dt">int</span>&gt; &amp;tblWhites, vector&lt;<span class="dt">int</span>&gt; &amp;tblBlacks,
             <span class="dt">const</span> vector&lt;us&gt; &amp;colWhites, <span class="dt">const</span> vector&lt;us&gt; &amp;colBlacks,
             us idx, <span class="dt">const</span> us min, <span class="dt">const</span> us max)
{
  <span class="kw">if</span> (idx &lt; max) {
    tblWhites[idx] = sumInclusive(colBlacks, <span class="dv">0</span>, idx);
    tblBlacks[idx] = sumInclusive(colWhites, <span class="dv">0</span>, idx);
  }

  <span class="dt">const</span> us startIdx = idx &lt; max ? <span class="dv">0</span> : idx - max;
  <span class="dt">const</span> us endIdx   = idx - min;

  <span class="kw">for</span> (us i = startIdx; i &lt;= endIdx; i++) {
    <span class="kw">if</span> (tblBlacks[i] != -<span class="dv">1</span>) {
      us cost = tblBlacks[i] + sumInclusive(colBlacks, i + <span class="dv">1</span>, idx);
      <span class="kw">if</span> (tblWhites[idx] == -<span class="dv">1</span> || cost &lt; <span class="kw">static_cast</span>&lt;us&gt;(tblWhites[idx]))
        tblWhites[idx] = cost;
    }

    <span class="kw">if</span> (tblWhites[i] != -<span class="dv">1</span>) {
      us cost = tblWhites[i] + sumInclusive(colWhites, i + <span class="dv">1</span>, idx);
      <span class="kw">if</span> (tblBlacks[idx] == -<span class="dv">1</span> || cost &lt; <span class="kw">static_cast</span>&lt;us&gt;(tblBlacks[idx]))
        tblBlacks[idx] = cost;
    }
  }
}</code></pre>
<h2 id="bir-soru-two-out-of-three">Bir soru: “Two out of three”</h2>
<p>Bu soru önceki sorudan daha ilginç olmamakla beraber, memoization/tablolama yapma şekli biraz değişik olduğundan anlatmak istedim: <a href="http://codeforces.com/problemset/problem/82/D">http://codeforces.com/problemset/problem/82/D</a> .</p>
<p>Sıradaki son 3 elemandan 2 elemanın sürekli azalacağını biliyoruz, ve alt problem bu iki eleman hariç elemanlar için çözülecek. Fakat bu 3 elemandan seçilmeyen elemanı memoization işleminde nasıl kullanabiliriz? Sıradan ayrılan iki insan alt problemin sıradaki ilk 2 eleman hariç olan kısmı olduğunu gösteriyor. 3 kişiden seçilmeyen bir kişi de algoritmaya ekstra bir parametre olarak verildiğinde karşımıza şöyle bir sonuç çıkıyor:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve(<span class="dt">int</span> lastElem, <span class="dt">int</span> offset, <span class="dt">const</span> vector&lt;<span class="dt">int</span>&gt; &amp;ppl,
    matrix&lt;<span class="dt">int</span>&gt; &amp;tbl, matrix&lt;<span class="dt">int</span>&gt; &amp;steps)
{
  <span class="kw">if</span> (lastElem &gt;= <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(ppl.size()))
    <span class="kw">return</span> <span class="dv">0</span>;
  <span class="kw">if</span> (offset &gt;= <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(ppl.size()))
    <span class="kw">return</span> ppl[lastElem];

  <span class="kw">if</span> (tbl(lastElem, offset) != -<span class="dv">1</span>)
    <span class="kw">return</span> tbl(lastElem, offset);

  <span class="dt">int</span> tmp[<span class="dv">3</span>];
  tmp[<span class="dv">0</span>] = max(ppl[lastElem], ppl[offset]) + solve(offset + <span class="dv">1</span>, offset + <span class="dv">2</span>, ppl, tbl, steps);
  tmp[<span class="dv">1</span>] = max(ppl[lastElem], ppl[offset + <span class="dv">1</span>]) + solve(offset, offset + <span class="dv">2</span>, ppl, tbl, steps);
  tmp[<span class="dv">2</span>] = max(ppl[offset], ppl[offset + <span class="dv">1</span>]) + solve(lastElem, offset + <span class="dv">2</span>, ppl, tbl, steps);

  <span class="dt">int</span> idmin = min_element(tmp, tmp + <span class="dv">3</span>) - tmp;
  steps(lastElem, offset) = idmin;

  <span class="kw">return</span> tbl(lastElem, offset) = tmp[idmin];
}</code></pre>
<p>Alt problemlerin nasıl paylaşıldığı daha önceden anlatıldığı gibi görülebilir.</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: My first academic work is now open source</title>
    <link href="http://osa1.net/posts/2013-07-22-sqml-open-sourced.html" />
    <id>http://osa1.net/posts/2013-07-22-sqml-open-sourced.html</id>
    <published>2013-07-22T00:00:00Z</published>
    <updated>2013-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Our work at Ozyegin University with Prof. Baris Aktemur is now open source.</p>
<ul>
<li>Home page: <a href="http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/">http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/</a></li>
<li>Github repository: <a href="https://github.com/ozusrl/SubtypedQuotedML">https://github.com/ozusrl/SubtypedQuotedML</a></li>
</ul>
<p>If you have trouble compiling/running it, please file an issue at Github page.</p>]]></summary>
</entry>
<entry>
    <title>Non-local returns in functional programs</title>
    <link href="http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html" />
    <id>http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html</id>
    <published>2013-07-21T00:00:00Z</published>
    <updated>2013-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s say we want to get nth visited element in depth-first traversal of a tree. Doing this is almost too easy in a language with statements(all imperative languages, some functional ones): Just run the depth-first traversal algorithm with explicit stack, and use <code>return</code> when you visit nth node.</p>
<p>In an expression language(Haskell, some Lisp languages) this is somewhat tricky.</p>
<p>Since I almost always prefer simplest possible solution of a problem, this would be my first attempt in a real-world situation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Branch</span> [<span class="dt">Tree</span> a]
    <span class="fu">|</span> <span class="dt">Leaf</span> a

<span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> [a]

<span class="ot">dfsNth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth tree n <span class="fu">=</span> listToMaybe <span class="fu">.</span> <span class="fu">drop</span> n <span class="fu">$</span> toList tree</code></pre>
<p>One concern about this function may be that the complexity of list generation. It’s hard to predict complexity of this function, but traversing the whole tree just to get first element of it would be costly anyway.</p>
<p>But thanks to lazy evaluation, this function still not very bad. Because only required parts of the intermediate list will be generated. To see why you can do two things: 1) Just place some <code>Debug.Trace.trace</code> calls in <code>toList</code> function and see how many times a leaf node is visited and 2) evaluate this function by hand and observe unevaluated thunks.</p>
<p>Let’s just do the first one, since it’s easier:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> trace <span class="st">&quot;leaf node visited&quot;</span> [a]

<span class="fu">...</span>

testTree <span class="fu">=</span> <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">1</span>, <span class="dt">Leaf</span> <span class="dv">2</span> ], <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">3</span> ], <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">4</span> ] ] ] ]</code></pre>
<pre><code>ghci&gt; dfsNth testTree 0
leaf node visited
Just 1

ghci&gt; dfsNth testTree 1
leaf node visited
leaf node visited
Just 2

ghci&gt; dfsNth testTree 10
leaf node visited
leaf node visited
leaf node visited
leaf node visited
Nothing</code></pre>
<hr />
<p>Other solutions are still worth exploring. When I think of “returning in the middle of a function” in Haskell, I always think <code>Either</code>. It’s monad definition is a great fit for this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">Either</span> e) <span class="kw">where</span>
    <span class="fu">return</span>        <span class="fu">=</span> <span class="kw">Right</span>
    <span class="kw">Left</span>  l <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Left</span> l
    <span class="kw">Right</span> r <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k r</code></pre>
<p>So when <code>Left data</code> used in monadic bind(<code>&gt;&gt;=</code>), second parameter just ignored and <code>Left data</code> is returned. Just like returning in the middle of a function in imperative setting, by ignoring rest of statements.</p>
<p>Using monad instance of Either, we can easily implement our function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dfsNth&#39; ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth&#39; tree n <span class="fu">=</span>
    <span class="kw">case</span> iter tree n <span class="kw">of</span>
      <span class="kw">Left</span> a  <span class="ot">-&gt;</span> <span class="kw">Just</span> a
      <span class="kw">Right</span> i <span class="ot">-&gt;</span> <span class="kw">Nothing</span>
  <span class="kw">where</span>
<span class="ot">    iter ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> a <span class="dt">Int</span>
    iter (<span class="dt">Branch</span> []) n     <span class="fu">=</span> <span class="fu">return</span> n
    iter (<span class="dt">Branch</span> (b<span class="fu">:</span>bs)) n <span class="fu">=</span> <span class="kw">do</span>
      n&#39; <span class="ot">&lt;-</span> iter b n
      iter (<span class="dt">Branch</span> bs) n&#39;
    iter (<span class="dt">Leaf</span> a) <span class="dv">0</span> <span class="fu">=</span> <span class="kw">Left</span> a
    iter <span class="dt">Leaf</span>{}   n <span class="fu">=</span> <span class="fu">return</span> (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<p>It works exactly like our first implementation, but without generating an intermediate list.</p>
<h2 id="exceptions-and-either-monad">Exceptions and Either monad</h2>
<p>If I were using OCaml, I’d probably implement this function using an exception.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">exception</span> <span class="dt">NonLocal</span> <span class="kw">of</span> <span class="dt">int</span>

<span class="kw">type</span> &#39;a tree =
  | <span class="dt">Branch</span> <span class="kw">of</span> (&#39;a tree) <span class="dt">list</span>
  | <span class="dt">Leaf</span>   <span class="kw">of</span> &#39;a

<span class="kw">let</span> dfs_nth tree n =
  <span class="kw">let</span> <span class="kw">rec</span> iter tree n =
    <span class="kw">match</span> tree <span class="kw">with</span>
    | <span class="dt">Branch</span> [] -&gt;
        n
    | <span class="dt">Branch</span> (b :: bs) -&gt;
        iter (<span class="dt">Branch</span> bs) (iter b n)
    | <span class="dt">Leaf</span> a -&gt;
        <span class="kw">if</span> n = 0 <span class="kw">then</span> raise (<span class="dt">NonLocal</span> a) <span class="kw">else</span> n - 1
  <span class="kw">in</span>
  <span class="kw">try</span>
    iter tree n;
    <span class="dt">None</span>
  <span class="kw">with</span>
    | <span class="dt">NonLocal</span> a -&gt; <span class="dt">Some</span> a</code></pre>
<p>An interesting thing to realize here is that this solution is very similar to our Haskell solution. In Haskell, Either is an instance of <code>MonadError</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Error</span> e <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span>
    throwError             <span class="fu">=</span> <span class="kw">Left</span>
    <span class="kw">Left</span>  l <span class="ot">`catchError`</span> h <span class="fu">=</span> h l
    <span class="kw">Right</span> r <span class="ot">`catchError`</span> _ <span class="fu">=</span> <span class="kw">Right</span> r</code></pre>
<p>This means if you replace <code>Left</code>s with <code>throwError</code> (just like <code>raise</code> in OCaml code), you have a similar solution with OCaml.</p>
<p>This doesn’t mean exceptions are same thing as Either types in functional programming. There are just too many differences that I won’t delve into in this post. With an exception, you can return from arbitrary deep contexts(ie. function calls), which is not easily possible with Either types. This is why exceptions sometimes referred as <em>non-local returns</em>.</p>
<p>We discussed this stuff over OCaml IRC channel, and smart people over there gave me some really good insights about non-local returns and exceptions. I’ll probably delve into details in another blog post. I’m especially interested in functional solutions that we can have in Haskell.</p>
<p>For the curious, for now I’ll just leave these two links here: (I haven’t read that links yet, but they’re probably related)</p>
<ul>
<li><a href="https://ocaml.janestreet.com/?q=node/91">https://ocaml.janestreet.com/?q=node/91</a></li>
<li><a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html</a></li>
</ul>
<p>Several other ideas also discussed at IRC channel, some of them were using delimited continuations, or passing a handler function as parameter and just calling it instead of raising an exception. I’ll continue investigating this stuff later.</p>
<p>I also came across this <a href="http://stackoverflow.com/questions/6915701/is-non-local-return-in-scala-new">StackOverflow post</a> that explains how Scala’s non-local returns implemented as exceptions internally. Interesting stuff.</p>]]></summary>
</entry>
<entry>
    <title>Apparently I'm not going to Jane Street</title>
    <link href="http://osa1.net/posts/2013-07-16-jane-street-interview-2.html" />
    <id>http://osa1.net/posts/2013-07-16-jane-street-interview-2.html</id>
    <published>2013-07-16T00:00:00Z</published>
    <updated>2013-07-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had written about my first interview experience <a href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html">here</a>. After that interview, we did two more interviews with Jane Street, the last one was done yesterday.</p>
<p>Today I’ve got an email saying that I’ve failed.</p>
<p>I won’t write about last two interviews because I’m asked to not to write about questions.</p>
<p>Now I’m looking for Haskell jobs for my last internship and I just applied to Galois. I’ll keep posting updates here. Wish me luck.</p>
<p><em>EDIT: I got response to my job application email from Galois, saying that they would not be able to sponsor me for my visa application. Which means I’m still looking for jobs.</em></p>]]></summary>
</entry>
<entry>
    <title>fmap fix return</title>
    <link href="http://osa1.net/posts/2013-07-07-fmap-fix-return.html" />
    <id>http://osa1.net/posts/2013-07-07-fmap-fix-return.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While floating across the internets, I came across a blog with title <code>fmap fix return</code>. I immediately run ghci and queried it’s type:</p>
<pre class="ghci"><code>ghci&gt; :t fmap fix return
fmap fix return :: a -&gt; a</code></pre>
<p>We know that only value with type <code>forall a. a -&gt; a</code> (other than bottom) is identity function(<code>id</code> in Haskell). I found it very interesting, <code>fmap fix return</code> gives us identity function!</p>
<p>I got a pen and paper and started evaluating expressions to understand how does that give us the identity function.</p>
<p>First, let’s note our actors:</p>
<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- instance specific implementation

fix  :: (a -&gt; a) -&gt; a
fix f = let x = f x in x

return :: Monad m =&gt; a -&gt; m a
-- instance specific implementation</code></pre>
<p>A very important thing to realize at this point is which monad and functor instances are used for <code>return</code> and <code>fmap</code>. To realize this, observe that we get a function as return value of <code>fmap</code>. Which means <code>Functor f =&gt; f b</code> is <code>a -&gt; a</code>, or written in a different style to see it’s functor property: <code>((-&gt;) a) a</code>, so our functor here is <code>(-&gt;) a</code>.</p>
<p>After that, we need to look up functor and monad instances for <code>(-&gt;) a</code>. Since it’s 2:30 AM here, I wanted to derive that too.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
     <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>It’s very easy to derive just by looking specialized version of <code>fmap</code>s type for <code>((-&gt;) a)</code>: <code>fmap :: (a1 -&gt; b) -&gt; (a -&gt; a1) -&gt; (a -&gt; b)</code>.</p>
<p>We can easily prove that it satisfies functor laws:</p>
<pre><code>fmap id f
= id . f
= f

fmap (p . q) &lt;-&gt; (fmap p) . (fmap q)
(fmap p) . (fmap q) f
= fmap p . (q . f)
= p . q . f
= fmap (p . q) f</code></pre>
<p>Monad instance can also be derived from types of <code>return</code> and <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
    <span class="fu">return</span>   <span class="fu">=</span> <span class="fu">const</span>
    f <span class="fu">&gt;&gt;=</span> fn <span class="fu">=</span> \r <span class="ot">-&gt;</span> fn (f r) r</code></pre>
<p>(I found Monad instance of <code>((-&gt;) a)</code> very interesting, especially the <code>&gt;&gt;=</code> part. I couldn’t come up with a problem that makes use of this instance, I’ll investigate that after some sleep)</p>
<p>It satisfies monad laws:</p>
<pre><code>-- left identity
return a &gt;&gt;= f
= const a &gt;&gt;= f
= \r -&gt; f ((const a) r) r
= \r -&gt; f a r
= f a

-- right identity
m &gt;&gt;= return
= \r -&gt; return (m r) r
= \r -&gt; (const (m r) r)
= \r -&gt; m r
= m

-- associativity
(m &gt;&gt;= f) &gt;&gt;= g &lt;-&gt; m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

let&#39;s first write `p` for `m &gt;&gt;= f`

= p &gt;&gt;= g
= \r1 -&gt; g (p r1) r1

let&#39;s also evaluaute p

p = m &gt;&gt;= f
= \r2 -&gt; f (m r2) r2

substitute new p

= \r1 -&gt; g ((\r2 -&gt; f (m r2) r2) r1) r1
= \r1 -&gt; g (f (m r1) r1) r1
= \r -&gt; g (f (m r) r) r

now let&#39;s also evaluate right hand side of equation

m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
= m &gt;&gt;= (\x -&gt; (    f x &gt;&gt;= g    )) -- just added a paren for clarity
= m &gt;&gt;= (\x -&gt; (\r -&gt; g (f x r) r))

let write `p` for `\x -&gt; (\r -&gt; g (f x r) r)`

= m &gt;&gt;= p
= \r1 -&gt; p (m r1) r1

put p back

= \r1 -&gt; (\x -&gt; (\r -&gt; g (f x r) r)) (m r1) r1
= \r1 -&gt; (\r -&gt; g (f (m r1) r)) r1
= \r1 -&gt; g (f (m r1) r1)</code></pre>
<p>For those who have no idea what’s above, I’m basically proving some equalities by substituting expressions with their equivalents. This is a benefit for working on a purely functional language, which means referential transparency.</p>
<p>OK, now with these <code>return</code> and <code>fmap</code> implementations in mind, let’s evaluate <code>fmap fix return</code>:</p>
<pre><code>fmap fix return
= fix . return
= \r -&gt; fix (return r)
= \r -&gt; fix (const r)
= \r -&gt; (\f = let x = f x in x) (const r)
= \r -&gt; let x = (const r) x in x

since `const a _ = a`, we have x = r here

= \r -&gt; r</code></pre>
<p>.. which is the identity function.</p>
<p>Thus <code>fmap fix return</code> demystified.</p>]]></summary>
</entry>

</feed>
