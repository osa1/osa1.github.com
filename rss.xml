<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - All posts</title>
    <link href="http://osa1.net/rss.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/rss.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-09-08T00:00:00Z</updated>
    <entry>
    <title>Proving sorting correct</title>
    <link href="http://osa1.net/posts/2014-09-08-proving-sorting-correct.html" />
    <id>http://osa1.net/posts/2014-09-08-proving-sorting-correct.html</id>
    <published>2014-09-08T00:00:00Z</published>
    <updated>2014-09-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

I've been working on proving some sorting algorithms correct in Coq. After 600 lines of Coq proofs, I managed to prove correctness of <a href="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>, <a href="http://en.wikipedia.org/wiki/Selection_sort">selection sort</a>, and a weird sorting algorithm called <a href="http://austingwalters.com/everyday-algorithms-pancake-sort/">pancake sort</a>. This post is a <a href="https://github.com/osa1/blog/blob/master/theories/SortingCorrect.v">literate Coq file</a> which you can download and execute in a Coq IDE, step by step. To keep the post shorter and easier to read and make it more like an exercise, I hided most of the proofs in HTML version.

<div class="paragraph"> </div>

Goals of this post are:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Provide some guidance for starters who are interested in proving algorithms correct.

</li>
<li> Demonstrate how to prove properties of functions with accumulators and functions that work on list indexes, instead of elements of the list.

</li>
<li> Demonstrate how to use &quot;timeout&quot; arguments to convince Coq that a function is really terminating on all inputs.

</li>
</ul>
A note before starting: I deliberately ignored advanced proof automation tools and go with more primitive way of proving. This is for two reasons: 1) I don't like magic, and since I don't understand underlying mechanics of advanced proofs tactics like <span class="inlinecode"><span class="id" type="var">crush</span></span>, it's magic to me 2) They're sometimes so powerful, they get in your way to understand what's really happening in the proof.

<div class="paragraph"> </div>

If you're reading this post as an exercise and filling the proofs yourself, that should not be a problem for you. Otherwise you may find my proofs more verbose than what's necessary.

<div class="paragraph"> </div>

Let's start with standard stuff: imports. These are for some list helpers, list syntax, Peano definitions + functions etc. Just standard stuff. Only exception is the <span class="inlinecode"><span class="id" type="var">Permutation</span></span> library, which I'll soon explain why it's necessary.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#"><span class="id" type="library">List</span></a>.<br />
<span class="id" type="keyword">Import</span> <span class="id" type="var">ListNotations</span>.<br />
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list_scope</span>.<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Arith.Arith.html#"><span class="id" type="library">Arith</span></a>.<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.omega.Omega.html#"><span class="id" type="library">Omega</span></a>.<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#"><span class="id" type="library">Permutation</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Our goal is to define some sorting algorithms and then prove them correct, but for that we first need to define what we mean by for a sorting algorithm to be &quot;correct&quot;. For some functions definition of correctness may be tricky to give, but in the context of sorting I think it's obvious:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Result should be a permutation of it's parameter.

</li>
<li> Result should be in sorted order.

</li>
</ul>
Definition of a &quot;permutation&quot; is defined in the <span class="inlinecode"><span class="id" type="var">Permutation</span></span> library we've just included, and it comes with lots of very useful lemmas. I suggest you to go to <span class="inlinecode"><span class="id" type="var">Permutation</span></span> library's documentation(you can go to the docs by clicking <span class="inlinecode"><span class="id" type="var">Permutation</span></span> link in the imports part above) and just skim through the definition and lemmas, and convince yourself that the definition is really enough to show that two lists are really a permutation.

<div class="paragraph"> </div>

For being sorted, we need to define what does that mean.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="sorted"><span class="id" type="inductive">sorted</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br />
| <a name="Sorted_nil"><span class="id" type="constructor">Sorted_nil</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
| <a name="Sorted_singleton"><span class="id" type="constructor">Sorted_singleton</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br />
| <a name="Sorted_cons"><span class="id" type="constructor">Sorted_cons</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Again, convince yourself that <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> really encodes what we intuitively know about being sorted. Main property that should hold for any <span class="inlinecode"><span class="id" type="var">l</span></span> that is <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> is that for any consecutive elements <span class="inlinecode"><span class="id" type="var">a</span></span> and <span class="inlinecode"><span class="id" type="var">b</span></span> in the list, <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" type="var">b</span></span> should hold, which our third constructor shows.

<div class="paragraph"> </div>

Using <span class="inlinecode"><span class="id" type="var">Permutation</span></span> and <span class="inlinecode"><span class="id" type="var">sorted</span></span>, we can define what does being correct for a sorting algorithm mean:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> (<span class="id" type="var">algo</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) :=<br />
| <a name="sorting_correct_intro"><span class="id" type="constructor">sorting_correct_intro</span></a> :<br />
    (<span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<span class="id" type="var">algo</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<span class="id" type="var">algo</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>)) → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <span class="id" type="var">algo</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Note that in both definition of <span class="inlinecode"><span class="id" type="var">sorted</span></span> and <span class="inlinecode"><span class="id" type="var">Sorting_correct</span></span>, we used list of nats instead of any lists of ordered elements. This is really just to make definitions and proofs simpler. Generalization may be done as an exercise.

<div class="paragraph"> </div>

Now with those definitions, we can prove our first and easiest-to-prove algorithm.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Insertion sort</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

We define insertion sort as a right fold:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="insert"><span class="id" type="definition">insert</span></a> (<span class="id" type="var">i</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br />
  | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Arith.Compare_dec.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <span class="id" type="var">h</span> <span class="id" type="keyword">then</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> <span class="id" type="keyword">else</span> <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <span class="id" type="var">t</span><br />
  <span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="insertion_sort"><span class="id" type="definition">insertion_sort</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#fold_right"><span class="id" type="definition">fold_right</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now if we could show that <span class="inlinecode"><span class="id" type="var">insert</span></span> <span class="inlinecode"><span class="id" type="var">h</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> on list <span class="inlinecode"><span class="id" type="var">h</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">t</span></span> returns a permutation, we could easily show that insertion sort returns a permutation, because all it does is to call <span class="inlinecode"><span class="id" type="var">insert</span></span> on list elements, using <span class="inlinecode"><span class="id" type="var">fold_right</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="insert_perm"><span class="id" type="lemma">insert_perm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use <span class="inlinecode"><span class="id" type="var">insert_perm</span></span> and transitivity, symmetry and reflexivity of <span class="inlinecode"><span class="id" type="var">Permutation</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="Permutation_insertion_sort"><span class="id" type="lemma">Permutation_insertion_sort</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort"><span class="id" type="definition">insertion_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

To show that it returns sorted, we use a similar approach. We first show that if <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>, then <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode">(<span class="id" type="var">insert</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span>. Empty and singleton lists are sorted by definition. Using these facts, we can easily prove that insertion sort really return sorted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 star. You need to use some lemmas about <span class="inlinecode"><span class="id" type="var">leb</span></span> that are already included. Use <span class="inlinecode"><span class="id" type="keyword">SearchAbout</span></span> <span class="inlinecode"><span class="id" type="var">leb</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="insert_sorted_preserve"><span class="id" type="lemma">insert_sorted_preserve</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">l</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 star. Use <span class="inlinecode"><span class="id" type="var">insert_sorted_preserve</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="insertion_sort_sorted"><span class="id" type="lemma">insertion_sort_sorted</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort"><span class="id" type="definition">insertion_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

With permutation and sorted properties proved, we can show that our insertion sort implementation is correct:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="insertion_sort_correct"><span class="id" type="lemma">insertion_sort_correct</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort"><span class="id" type="definition">insertion_sort</span></a>.<br />
<span class="id" type="keyword">Proof</span>.<br />
  <span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort_sorted"><span class="id" type="lemma">insertion_sort_sorted</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Permutation_insertion_sort"><span class="id" type="lemma">Permutation_insertion_sort</span></a>.<br />
<span class="id" type="keyword">Qed</span>.<br />

<br />
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Selection sort</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Next, we move to selection sort. This one is significantly harder and most stuff we define in this section will be used in the next section.

<div class="paragraph"> </div>

Before implementing the algorithm, we need some auxiliary functions. <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> is both used in selection sort and pancake sort. As you can imagine from the name, it returns index of one of the smallest elements in a list.

<div class="paragraph"> </div>

Note that it's very very hard to reason about this definition. The reason is that we're using index of a list, instead of head/tail of it. Simple induction-based proofs that we do before simply don't work on this definition.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">min</span> <span class="id" type="var">min_idx</span> <span class="id" type="var">cur_idx</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a><br />
  | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Arith.Compare_dec.html#leb"><span class="id" type="definition">leb</span></a> <span class="id" type="var">h</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min"><span class="id" type="variable">min</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">h</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#cur_idx"><span class="id" type="variable">cur_idx</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#cur_idx"><span class="id" type="variable">cur_idx</span></a>)<br />
                           <span class="id" type="keyword">else</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min"><span class="id" type="variable">min</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#cur_idx"><span class="id" type="variable">cur_idx</span></a>)<br />
  <span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="find_min_idx"><span class="id" type="definition">find_min_idx</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ 0<br />
  | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">h</span> 0 1<br />
  <span class="id" type="keyword">end</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

An invariant of <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span>:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="find_min_idx_len_inv"><span class="id" type="lemma">find_min_idx_len_inv</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span> <span class="id" type="var">m</span> <span class="id" type="var">mi</span> <span class="id" type="var">ci</span> <span class="id" type="var">r</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#mi"><span class="id" type="variable">mi</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#ci"><span class="id" type="variable">ci</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#r"><span class="id" type="variable">r</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#mi"><span class="id" type="variable">mi</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#ci"><span class="id" type="variable">ci</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#r"><span class="id" type="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#ci"><span class="id" type="variable">ci</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Make sure you understand what it's saying. We need this lemma to eliminate some impossible cases in proofs.

<div class="paragraph"> </div>

We also need a &quot;membership&quot; predicate. This is used to express the idea of &quot;for all elements in the list ...&quot;, which is expressed in Coq like <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">e</span>,</span> <span class="inlinecode"><span class="id" type="var">member</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">→</span> <span class="inlinecode">...</span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="member"><span class="id" type="inductive">member</span></a> {<span class="id" type="var">A</span>} : <span class="id" type="var">A</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">A</span> → <span class="id" type="keyword">Prop</span> :=<br />
| <a name="Member_head"><span class="id" type="constructor">Member_head</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>)<br />
| <a name="Member_tail"><span class="id" type="constructor">Member_tail</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Again, convince yourself that this really expresses that idea. Here's a property of member:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="member_preserved_by_perm"><span class="id" type="lemma">member_preserved_by_perm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) <span class="id" type="var">l'</span> <span class="id" type="var">e</span>,<br />
  <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now using <span class="inlinecode"><span class="id" type="var">member</span></span>, we can express correctness of <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> and prove it. Note that this is a very hard exercise. I couldn't solve it for a week, and even after that period I couldn't solve it without help from Coq IRC channel. Feel free to cheat by looking the source of this post.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
</div>

<div class="doc">
***** Exercise: 5 stars. <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> really returns index of smallest element. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="find_min_idx_correct"><span class="id" type="lemma">find_min_idx_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx"><span class="id" type="definition">find_min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now, in selection sort, we run several operations on argument. One of them is <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> which we already defined. Another one of them is <span class="inlinecode"><span class="id" type="tactic">replace</span></span> operation, which replaces nth element in a list with given element. Here's a definition and some properties:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="replace"><span class="id" type="definition">replace</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">idx</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">e</span> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
  | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒<br />
      <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#idx"><span class="id" type="variable">idx</span></a> <span class="id" type="keyword">with</span><br />
      | 0 ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span><br />
      | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">idx'</span> ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <span class="id" type="var">t</span> <span class="id" type="var">idx'</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a><br />
      <span class="id" type="keyword">end</span><br />
  <span class="id" type="keyword">end</span>.<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. First part of correctness proof of <span class="inlinecode"><span class="id" type="tactic">replace</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="replace_nth"><span class="id" type="lemma">replace_nth</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> <span class="id" type="var">e</span> <span class="id" type="var">l'</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
  <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>.<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. Second part of correctness proof of <span class="inlinecode"><span class="id" type="tactic">replace</span></span>. <span class="inlinecode"><span class="id" type="tactic">replace</span></span> preserves length of the list. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="replace_len"><span class="id" type="lemma">replace_len</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> (<span class="id" type="var">e</span> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
  <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Using <span class="inlinecode"><span class="id" type="tactic">replace</span></span>, we can define <span class="inlinecode"><span class="id" type="var">selection_sort</span></span>. Note that our naive implementation doesn't convince Coq that it terminates on all input. An easy workaround is to add a <span class="inlinecode"><span class="id" type="var">step</span></span> parameter. Observing that selection sort algorithm terminates in <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> steps, where <span class="inlinecode"><span class="id" type="var">l</span></span> is the input, we can define this:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">step</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#step"><span class="id" type="variable">step</span></a> <span class="id" type="keyword">with</span><br />
  | 0       ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">step'</span> ⇒<br />
      <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
      | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
      | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒<br />
          <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">h</span> 0 1 <span class="id" type="keyword">with</span><br />
          | 0     ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">step'</span><br />
          | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">min</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <span class="id" type="var">min</span> <span class="id" type="var">t</span> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <span class="id" type="var">t</span> <span class="id" type="var">min</span> <span class="id" type="var">h</span>) <span class="id" type="var">step'</span><br />
          <span class="id" type="keyword">end</span><br />
      <span class="id" type="keyword">end</span><br />
  <span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="selection_sort"><span class="id" type="definition">selection_sort</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> := <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

We have all we need to prove permutation property. It's still not easy though. I'm putting an extra lemma here as a tip.

</div>
<div class="code">

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="replace_perm_head"><span class="id" type="lemma">replace_perm_head</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> →<br />
  <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 3 stars. Use <span class="inlinecode"><span class="id" type="var">replace_perm_head</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="Permutation_selection_sort"><span class="id" type="lemma">Permutation_selection_sort</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort"><span class="id" type="definition">selection_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Proving sorted property is again, not easy. I'm putting some lemmas as pointers. Lemmas are very easy to prove, leaving only the master theorem as a challange.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="member_replace"><span class="id" type="lemma">member_replace</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#x"><span class="id" type="variable">x</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#y"><span class="id" type="variable">y</span></a>) →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>.<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use <span class="inlinecode"><span class="id" type="var">member_replace</span></span> and <span class="inlinecode"><span class="id" type="var">find_min_idx_correct</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="swap_min_replace"><span class="id" type="lemma">swap_min_replace</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span> <span class="id" type="var">min_idx</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx"><span class="id" type="definition">find_min_idx</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a>) → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="sorted_min_tail"><span class="id" type="lemma">sorted_min_tail</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>) →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use <span class="inlinecode"><span class="id" type="var">member_preserved_by_perm</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="min_preserved_by_perm"><span class="id" type="lemma">min_preserved_by_perm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">m</span> <span class="id" type="var">l</span> <span class="id" type="var">l'</span>,<br />
  <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>) →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 4 stars. Selection sort returns sorted. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="selection_sort_sorted"><span class="id" type="lemma">selection_sort_sorted</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort"><span class="id" type="definition">selection_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. Show that selection sort is correct. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="selection_sort_correct"><span class="id" type="lemma">selection_sort_correct</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort"><span class="id" type="definition">selection_sort</span></a>.<br />

<br />
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">Pancake sort</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

This is getting harder and harder. We'll define pancake sort in terms of <span class="inlinecode"><span class="id" type="var">rev_at</span></span> which reverses a list at given index and <span class="inlinecode"><span class="id" type="var">map_rest</span></span> which is like <span class="inlinecode"><span class="id" type="var">map</span></span>, but applies the function to the rest of the list.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="rev_at"><span class="id" type="definition">rev_at</span></a> {<span class="id" type="var">A</span>} <span class="id" type="var">idx</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#idx"><span class="id" type="variable">idx</span></a> <span class="id" type="keyword">with</span><br />
  | 0      ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">idx'</span> ⇒<br />
      <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
      | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
      | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <span class="id" type="var">idx'</span> <span class="id" type="var">t</span><br />
      <span class="id" type="keyword">end</span><br />
  <span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="map_rest_aux"><span class="id" type="definition">map_rest_aux</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">timeout</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
  <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#timeout"><span class="id" type="variable">timeout</span></a> <span class="id" type="keyword">with</span><br />
  | 0 ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a><br />
  | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">timeout'</span> ⇒<br />
      <span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
      | <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
      | <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest_aux"><span class="id" type="definition">map_rest_aux</span></a> <span class="id" type="var">t</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> <span class="id" type="var">timeout'</span><br />
      <span class="id" type="keyword">end</span><br />
  <span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="map_rest"><span class="id" type="definition">map_rest</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest_aux"><span class="id" type="definition">map_rest_aux</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Two things to note: 1) <span class="inlinecode"><span class="id" type="var">rev_at</span></span> returns the original list if <span class="inlinecode"><span class="id" type="var">idx</span></span> is larger than <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">-</span> <span class="inlinecode">1</span>. 2) <span class="inlinecode"><span class="id" type="var">map_rest</span></span> only works as expected if <span class="inlinecode"><span class="id" type="var">f</span></span> preserves length of it's argument in it's return value.

<div class="paragraph"> </div>

There's a very useful property that we need to show before showing that pancake sort returns a permutation: if <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> returns a permutation, than <span class="inlinecode"><span class="id" type="var">map_rest</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode"><span class="id" type="var">f</span></span> returns a permutation:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 stars. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Permutation_map_rest"><span class="id" type="lemma">Permutation_map_rest</span></a> :<br />
  <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> (<span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
  (<span class="id" type="keyword">∀</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>)) →<br />
  (<span class="id" type="keyword">∀</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest"><span class="id" type="definition">map_rest</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a>)).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Using this definition we can define pancake sort:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Definition</span> <a name="flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
  <span class="id" type="keyword">let</span> <span class="id" type="var">min_idx</span> := <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx"><span class="id" type="definition">find_min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">in</span><br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> 0 (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="pancake_sort"><span class="id" type="definition">pancake_sort</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> := <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest"><span class="id" type="definition">map_rest</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Showing permutation property is actually very easy. All we need is two simple lemmas:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 stars. Use already included standard permutation lemmas. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Permutation_rev_at"><span class="id" type="lemma">Permutation_rev_at</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">n</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
  <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use transitivity of permutation and <span class="inlinecode"><span class="id" type="var">Permutation_rev_at</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Permutation_flip_pancakes"><span class="id" type="lemma">Permutation_flip_pancakes</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. Use <span class="inlinecode"><span class="id" type="var">Permutation_flip_pancakes</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="Permutation_pancake_sort"><span class="id" type="lemma">Permutation_pancake_sort</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sort"><span class="id" type="definition">pancake_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now the hard part. I needed a lot of lemmas for showing sorted property. I'm listing lemmas I used in no particular order.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 stars. Smallest element is still smallest in a permutation. I found this a bit tricky. You may need to use another lemma we defined. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="min_permutation"><span class="id" type="lemma">min_permutation</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">l</span>,<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e'</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a>) →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">l'</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
    (<span class="id" type="keyword">∀</span> <span class="id" type="var">e'</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a>)).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. <span class="inlinecode"><span class="id" type="var">flip_pancakes</span></span> preserves the length. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="flip_pancakes_len"><span class="id" type="lemma">flip_pancakes_len</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />

<br />
</div>

<div class="doc">
***** Exercise: 4 stars. We can use <span class="inlinecode"><span class="id" type="var">rev_at</span></span> to move smallest element to the end of the list, and then to the beginning of the list. Very tricky. Feel free to cheat. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="rev_at_n"><span class="id" type="lemma">rev_at_n</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> 0 (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> →<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> 0.<br />

<br />

<br />
</div>

<div class="doc">
***** Exercise: 3 stars. <span class="inlinecode"><span class="id" type="var">flip_pancakes</span></span> moves smallest element to the head of the list. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="flip_pancakes_min"><span class="id" type="lemma">flip_pancakes_min</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span> <span class="id" type="var">h'</span> <span class="id" type="var">t'</span>,<br />
  <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h'"><span class="id" type="variable">h'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t'"><span class="id" type="variable">t'</span></a> →<br />
  (<span class="id" type="keyword">∀</span> <span class="id" type="var">e'</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t'"><span class="id" type="variable">t'</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h'"><span class="id" type="variable">h'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl2/stdlib/Coq.Init.Peano.html#:nat_scope:x_'&lt;='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 4 stars. You need a lot of lemmas we defined before, and it's a very long proof. Still not as hard as <span class="inlinecode"><span class="id" type="var">find_min_idx_correct</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="pancake_sorted"><span class="id" type="lemma">pancake_sorted</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sort"><span class="id" type="definition">pancake_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

And finally, our master theorem:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="pancake_sort_correct"><span class="id" type="lemma">pancake_sort_correct</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sort"><span class="id" type="definition">pancake_sort</span></a>.<br />
<span class="id" type="keyword">Proof</span>.<br />
  <span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">intro</span>. <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sorted"><span class="id" type="lemma">pancake_sorted</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Permutation_pancake_sort"><span class="id" type="lemma">Permutation_pancake_sort</span></a>.<br />
<span class="id" type="keyword">Qed</span>.<br />

<br />
</div>

<div class="doc">
<a name="lab4"></a><h1 class="section">Notes and lessons learned</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Implementation of algorithms are not what you'd expect to have in an imperative language. Rather than mutable arrays with O(1) access, I used classic functional style, using persistent linked lists. While that doesn't affect runtime asymptotic complexities of sorting algorithms I used, it causes a lot of redundant allocations and worse iteration performance. Even the OCaml/Haskell extractions are not usable.

<div class="paragraph"> </div>

Still, proving on those purely functional definitions were very hard. The reason is that once you move away from basic &quot;induction of subterm&quot; style proofs, proving gets very hard very fast. Specifically, I found working on indexes and accumulators very hard.

<div class="paragraph"> </div>

As a next step, I'm hoping to define an imperative language in Coq, like IMP of Software Foundations but with mutable arrays, and prove same algorithms defined in that language correct.

<div class="paragraph"> </div>


</div>
<div class="code">
</div>
]]></summary>
</entry>
<entry>
    <title>Tartışma</title>
    <link href="http://osa1.net/posts/2014-07-29-tartisma.html" />
    <id>http://osa1.net/posts/2014-07-29-tartisma.html</id>
    <published>2014-07-29T00:00:00Z</published>
    <updated>2014-07-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Birkaç tip insanla ne pahasına olursa olsun tartışmak istemiyorum. Ne iddia ediyorlarsa haklılar.</p>
<ol style="list-style-type: decimal">
<li>Heyecanlananlar, sesini yükseltenler, sinirlenenler, gaza gelenler. Hatta gaza gelen kesim ölene kadar benden uzak dursa keşke.</li>
<li><a href="http://staffhome.ecm.uwa.edu.au/~00043886/humour/invalid.proofs.html#1.1Proofbyexample">“Proof by example”</a> ispat tekniğini benimseyenler. Özellikle bunu insanlara uyguladığında gerzekliğin sınırları zorlanmış oluyor. “Ankaralı iki arkadaşım var ikisi de şöyleydi, o zaman büyün Ankaralılar öyledir”. Her geçen gün bunun ne kadar fazla uygulandığına hayret etmekteyim. (günlük hayatta karşılaştıklarımız bu kadar bariz olmadığından çoğu zaman iki taraf da argümanın geçersizliğini hiçbir zaman farkedemiyor)</li>
<li>Pire için yorgan yakanlar. Kimsenin kusursuz olmasını bekleyemezsin, yiğidi öldür hakkını yeme demişler.</li>
<li>Dedikodu, desteksiz atanlar. Duyduğun işine gelen şeyleri doğru kabul edenler.</li>
<li>Haksız olmayı göze alamayanlar. Tartışmanın amacı orta yolu bulmak, hatalı olanların hatalarının farkında olması değil midir? Bir spor olarak tartışanlar.</li>
</ol>
<p>Umarım bu hatalara ben de yapmıyorumdur, gerçekten çok uğraşıyorum bunun için.</p>
<p>Bu sebeplerden, Türkiye’de mutlu, üretken, sağlıklı olmanın sırrını siyasetten uzak durmak olarak görüyorum. Üniversitede sınıf arkadaşlarım bana “apolitik” derlerdi, ne anlama geldiği hakkında halen daha pek fikrim yok, ama o zamanlar “vaktini öldürmemek için çaba sarfeden” olarak yorumlardım :)</p>]]></summary>
</entry>
<entry>
    <title>Two awesome blogs</title>
    <link href="http://osa1.net/posts/2014-07-20-two-awesome-blogs.html" />
    <id>http://osa1.net/posts/2014-07-20-two-awesome-blogs.html</id>
    <published>2014-07-20T00:00:00Z</published>
    <updated>2014-07-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just want to link this two awesome blogs here. I’ve been spending my last couple of weekends trying to read every single post in those blogs.</p>
<ul>
<li><a href="http://existentialtype.wordpress.com">Robert Harper’s blog</a>: About programming language semantics, type theory, type systems, sometimes HoTT and constructive mathematics related stuff.</li>
<li><a href="http://math.andrej.com">Andrej Bauer’s blog</a>: About maths and computation. I don’t understand 80% of the posts(hopefully this will change). Rest of them is about constructive mathematics/proofs, Coq, sometimes Haskell and types.</li>
</ul>
<p>Bonus content:</p>
<ul>
<li><a href="http://poleiro.info/">http://poleiro.info/</a> is a great blog with beginner-intermediate level Coq posts. I hope the author keeps new posts coming.</li>
<li><a href="http://homotopytypetheory.org/2012/08/18/a-master-thesis-on-homotopy-type-theory/">A master thesis on HoTT</a>: I just started reading this and it looks like easy to understand even for people with not much understanding of type theory or related topics, like me. The author was a student of Andrej Bauer.</li>
</ul>
<p>Side note: I’ll hopefully publish a blog post about verification of a somewhat weird and useless sorting algorithm soon.</p>]]></summary>
</entry>
<entry>
    <title>Coq exercises for beginners</title>
    <link href="http://osa1.net/posts/2014-07-12-fun-coq-exercises.html" />
    <id>http://osa1.net/posts/2014-07-12-fun-coq-exercises.html</id>
    <published>2014-07-12T00:00:00Z</published>
    <updated>2014-07-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<style>
.solution {
  background-color: rgb(245, 245, 245);
  padding-left: 1em;
}
</style>


<p>Formalizing abstractions/data structures and proving theorems about them in Coq is so much fun. I made up some simple exercises that consist of encoding some abstractions and laws we know from algebra and functional programming and then proving that some particular set + some operations on that set obeys the laws.</p>
<p>Using my amazing(!) JavaScript skills, I set up some “show/hide answer” buttons after each exercise. Exercises are easy, but the latter ones are relatively harder. Some abstractions/laws are inspired by Haskell.</p>
<p>Please note that I’m a beginner so my solutions probably have some flaws if you want to use them in large-scale verified programs :) I’m currently learning about typeclasses and records of Coq and I’m open to suggestions for improvements.</p>
<p>In exercises, when we talk that an abstraction should obey some laws, you need to enforce it in construction. e.g. You need to make constructors in a way that user would have to prove that the data structure + operations obey the laws.</p>
<pre class="coq"><code>Require Import List.
Import ListNotations.

Open Scope list_scope.</code></pre>
<h1 id="exercise-1">Exercise 1</h1>
<p>A <a href="http://en.wikipedia.org/wiki/Semigroup">semigroup</a> is a set together with an associative binary function. For example, natural numbers and addition function form a semigroup, because we know/can prove that addition function is associative. More precisely: (in Coq syntax)</p>
<pre class="coq"><code>forall (n1 n2 n3 : nat), n1 + (n2 + 3) = (n1 + n2) + n3.</code></pre>
<p>Encode semigroups in Coq.</p>
<div id="ex-div-1.1" class="solution">
<pre class="coq"><code>Inductive semigroup (A : Type) (Op : A -&gt; A -&gt; A) : Prop :=
| Semigroup_intro :
    (forall (a1 a2 a3 : A), Op a1 (Op a2 a3) = Op (Op a1 a2) a3) -&gt; semigroup A Op.</code></pre>
</div>
<button id="ex-btn-1.1"></button>

<p>Now prove that lists together with append operation form a semigroup. Use standard Coq lists and <code>app</code> function.</p>
<div id="ex-div-1.2" class="solution">
<pre class="coq"><code>Theorem list_semigroup : forall A, semigroup (list A) (@app A).
Proof.
  intro. apply Semigroup_intro. intros.
  induction a1.
  + reflexivity.
  + simpl. f_equal. induction a2; auto.
Qed.</code></pre>
</div>
<button id="ex-btn-1.2"></button>


<h1 id="exercise-2">Exercise 2</h1>
<p>A <a href="http://en.wikipedia.org/wiki/Monoid">monoid</a> is a semigroup with an identity element. In our addition example, identity element is 0, because when applied to the monoid function(addition) as first or second argument, results is the other argument:</p>
<pre class="coq"><code>forall (n : nat), 0 + n = n /\ n + 0 = n.</code></pre>
<p>Encode monoids in Coq.</p>
<div id="ex-div-2.1" class="solution">
<pre class="coq"><code>Inductive monoid A Op (sg : semigroup A Op) (U : A) : Prop :=
| Monoid_intro :
    semigroup A Op -&gt; (forall (a : A), Op U a = Op a U /\ Op U a = a) -&gt; monoid A Op sg U.</code></pre>
</div>
<button id="ex-btn-2.1"></button>

<p>Now prove that lists with empty list as unit element together with the proof that lists are monoids as we proved in previous exercise, form a monoid.</p>
<div id="ex-div-2.2" class="solution">
<pre class="coq"><code>Theorem list_monoid : forall A, monoid (list A) (@app A) (@list_semigroup A) [].
Proof.
  intro. apply Monoid_intro. apply list_semigroup.
  intro. split.
  + rewrite app_nil_r. reflexivity.
  + reflexivity.
Qed.</code></pre>
</div>
<button id="ex-btn-2.2"></button>

<h1 id="exercise-3">Exercise 3</h1>
<p>In this exercise and exercise 4, we’ll be talking about Haskell definitions of abstractions, instead of algebra definitions. (although they may coincide)</p>
<p>A functor is a type with one argument(in Haskell terms, a type with kind <code>* -&gt; *</code>) and a function, together with some laws. If you’re unfamiliar with functors of Haskell, you may want to skip this, or read <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#Functor">Typeclassopedia</a>.</p>
<p>A Coq definition would use these to encode functors:</p>
<ul>
<li>Functor type: <code>F : Type -&gt; Type</code></li>
<li>Functor operation: <code>forall t1 t2, (t1 -&gt; t2) -&gt; f t1 -&gt; f t2</code> (let’s call it fmap)</li>
</ul>
<p>A functor should obey these laws:</p>
<ul>
<li><code>fmap id = id</code></li>
<li><code>fmap (fun x =&gt; g (h x)) = fun x =&gt; (fmap g (fmap h x))</code></li>
</ul>
<p>Encode functors in Coq.</p>
<div id="ex-div-3.1" class="solution">
<pre class="coq"><code>Inductive functor (F : Type -&gt; Type) : (forall t1 t2, (t1 -&gt; t2) -&gt; f t1 -&gt; f t2) -&gt; Prop :=
| Functor_intro
    (fmap : forall t1 t2, (t1 -&gt; t2) -&gt; F t1 -&gt; F t2)
    (l1   : forall t f, fmap t t id f = f)
    (l2   : forall t1 t2 t3, forall (f : F t1) (p : t2 -&gt; t3) (q : t1 -&gt; t2),
              fmap t1 t3 (fun a =&gt; p (q a)) f = fmap t2 t3 p (fmap t1 t2 q f)) :
    functor F fmap.</code></pre>
</div>
<button id="ex-btn-3.1"></button>

<p>Now prove that lists with standard map function form a functor.</p>
<div id="ex-div-3.2" class="solution">
<pre class="coq"><code>Theorem list_functor : functor list map.
Proof.
  apply Functor_intro.
  + intros. induction f. reflexivity. simpl. rewrite IHf. reflexivity.
  + intros. induction f. reflexivity. simpl. f_equal. apply IHf.
Qed.</code></pre>
</div>
<button id="ex-btn-3.2"></button>

<h1 id="exercise-4">Exercise 4</h1>
<p>A monad is a functor with two more operations; let’s call <code>bind</code> and <code>lift</code> and some more laws. In Coq syntax: (<code>F</code> is our functor type)</p>
<ul>
<li>bind: <code>forall t1 t2, F t1 -&gt; (t1 -&gt; F t2) -&gt; F t2</code></li>
<li>lift: <code>forall t, t -&gt; F t</code></li>
</ul>
<p>Laws:</p>
<ul>
<li>Left identity: <code>forall t1 t2 a f, bind t1 t2 (lift t1 a) f = f a</code></li>
<li>Right identity: <code>right_id : forall t m, bind t t m (lift t) = m</code></li>
<li>Associativity: <code>forall t1 t2 t3 m f g, bind t2 t3 (bind t1 t2 m f) g = bind t1 t3 m (fun x =&gt; bind t2 t3 (f x) g)</code></li>
</ul>
<p>Encode monads in Coq.</p>
<div id="ex-div-4.1" class="solution">
<pre class="coq"><code>Inductive monad : (Type -&gt; Type) -&gt; Prop :=
| Monad_intro
    (F        : Type -&gt; Type)
    (fmap     : forall t1 t2, (t1 -&gt; t2) -&gt; F t1 -&gt; F t2)
    (Fp       : functor F fmap)
    (lift     : forall t, t -&gt; F t)
    (bind     : forall t1 t2, F t1 -&gt; (t1 -&gt; F t2) -&gt; F t2)
    (left_id  : forall t1 t2 a f, bind t1 t2 (lift t1 a) f = f a)
    (right_id : forall t m, bind t t m (lift t) = m)
    (assoc    : forall t1 t2 t3 m f g,
                  bind t2 t3 (bind t1 t2 m f) g = bind t1 t3 m (fun x =&gt; bind t2 t3 (f x) g)) :
    monad F.</code></pre>
</div>
<button id="ex-btn-4.1"></button>

<p>Now prove that lists form a monad. You need to figure out what functions to use for <code>lift</code> and <code>bind</code>.</p>
<div id="ex-div-4.2" class="solution">
<p><code>lift</code> function:</p>
<pre class="coq"><code>(* I couldn&#39;t find this in stdlib so let&#39;s define *)
Definition singleton (A : Type) (x : A) := [x].</code></pre>
<p>For <code>bind</code>, you can use standard <code>flat_map</code> function, but it’s argument order is reversed. So instead I rolled my own version:</p>
<pre class="coq"><code>Fixpoint concat {A : Type} (l : list (list A)) : list A :=
  match l with
  | []     =&gt; []
  | h :: t =&gt; app h (concat t)
  end.

(* I don&#39;t like argument order of flat_map in stdlib ... *)
Definition concatMap (A : Type) (B : Type) (l : list A) (f : A -&gt; list B) : list B :=
  concat (map f l).</code></pre>
<p>Now most involved proof in this exercises: (still very easy)</p>
<pre class="coq"><code>Theorem list_monad : monad list.
Proof.
  apply Monad_intro with (fmap := map) (lift := singleton) (bind := concatMap).
  + apply list_functor.
  + intros. unfold concatMap. simpl. rewrite app_nil_r. reflexivity.
  + intros. unfold concatMap. induction m.
    - reflexivity.
    - simpl. f_equal. apply IHm.
  + intros. induction m as [|h t].
    - reflexivity.
    - unfold concatMap in *. simpl. rewrite &lt;- IHt. 
      assert (forall A (l1 : list (list A)) (l2 : list (list A)),
                concat l1 ++ concat l2 = concat (l1 ++ l2)) as H.
        intros. induction l1; auto.
          simpl. rewrite &lt;- app_assoc. rewrite IHl1. auto.
      rewrite H. f_equal. rewrite map_app. reflexivity.
Qed.</code></pre>
</div>
<button id="ex-btn-4.2"></button>

<h1 id="exercise-5">Exercise 5</h1>
<p>Prove that standard <code>option</code> type with some operations form a semigroup, monoid, functor and monad. You need to find relevant operations.</p>
<p>What restrictions do you need on <code>option</code>s type argument? (<code>A</code> in <code>option A</code>) Does it need to form a monoid for <code>option</code> to form a monoid?</p>
<div id="ex-div-5.1" class="solution">
<pre class="coq"><code>Definition map_option (A B : Type) (f : A -&gt; B) (opt : option A) :=
  match opt with
  | None =&gt; None
  | Some t =&gt; Some (f t)
  end.

Definition append_option A OpA (sg : semigroup A OpA) (a b : option A) : option A :=
  match a, b with
  | None, None =&gt; None
  | None, Some b&#39; =&gt; Some b&#39;
  | Some a&#39;, None =&gt; Some a&#39;
  | Some a&#39;, Some b&#39; =&gt; Some (OpA a&#39; b&#39;)
  end.

Theorem option_semigroup : forall A OpA (sg : semigroup A OpA),
  semigroup (option A) (append_option A OpA sg).
Proof.
  intros. apply Semigroup_intro. intros. destruct a1.
  + destruct a2.
    - destruct a3.
      * simpl. f_equal. inversion sg. apply H.
      * simpl. reflexivity.
    - destruct a3; simpl; reflexivity.
  + destruct a2; destruct a3; auto.
Qed.

Theorem option_monoid : forall A OpA (sg : semigroup A OpA),
  monoid (option A) (append_option A OpA sg) (option_semigroup A OpA sg) None.
Proof.
  intros. apply Monoid_intro. apply option_semigroup.
  intros. split. auto. destruct a; auto.
Qed.

Definition option_map A B (f : A -&gt; B) (o : option A) : option B :=
  match o with
  | None =&gt; None
  | Some a =&gt; Some (f a)
  end.

Theorem option_functor : functor option option_map.
Proof.
  apply Functor_intro; intros; destruct f; auto.
Qed.

Definition option_bind A B (o1 : option A) (f : A -&gt; option B) : option B :=
  match o1 with
  | None =&gt; None
  | Some a =&gt; f a
  end.

Theorem option_monad : monad option.
Proof.
  apply Monad_intro with (fmap := option_map) (lift := Some) (bind := option_bind).
  + apply option_functor.
  + intros. auto.
  + intros. destruct m; auto.
  + intros. destruct m; auto.
Qed.</code></pre>
</div>
<button id="ex-btn-5.1"></button>


<h1 id="exercise-6">Exercise 6</h1>
<p>I only have a partial solution to this one and it’s not strictly a Coq exercise, but it’s still fun :)</p>
<p>A <a href="http://en.wikipedia.org/wiki/Group_(mathematics)">group</a> is a monoid with inverse element of every element. In Coq syntax:</p>
<pre class="coq"><code>forall e, exists e_i -&gt; op e e_1 = U</code></pre>
<p>where <code>op</code> is monoid operation and <code>U</code> is unit of monoid.</p>
<p>Can you come up with a data structure that forms a group?</p>
<div id="ex-div-6.1" class="solution">
<p>Someone at Coq IRC channel suggested diffs. Do you think a diff could form a group? What would associative operation, unit element, and inverse elements be?</p>
<div id="ex-div-6.2" class="solution">
<p>Diffs don’t form a group. Composing two diffs is the merge operation, which is partial function. We can’t always merge two diffs. (merge conflicts)</p>
So I don’t have an answer to this exercise, If you know examples to this one, please write at comments :)
</div>
<button id="ex-btn-6.2"></button>

</div>
<button id="ex-btn-6.1"></button>



<script>
function showMsg(exNum) {
  return "Show solution (ex. " + exNum + ")";
}

function hideMsg(exNum) {
  return "Hide solution (ex. " + exNum + ")";
}

function setUpShowHide(exNum) {
  var div = document.getElementById("ex-div-" + exNum);
  var btn = document.getElementById("ex-btn-" + exNum);
  btn.innerHTML = showMsg(exNum);
  btn.onclick = function() {
    if (div.style.display !== 'none') {
      div.style.display = 'none';
      btn.innerHTML = showMsg(exNum);
    } else {
      div.style.display = 'block';
      btn.innerHTML = hideMsg(exNum);
    }
  }
  div.style.display = 'none';
}

setUpShowHide(1.1);
setUpShowHide(1.2);
setUpShowHide(2.1);
setUpShowHide(2.2);
setUpShowHide(3.1);
setUpShowHide(3.2);
setUpShowHide(4.1);
setUpShowHide(4.2);
setUpShowHide(5.1);
setUpShowHide(6.2);
setUpShowHide(6.1);
</script>

]]></summary>
</entry>
<entry>
    <title>A complicated proof of a simple theorem</title>
    <link href="http://osa1.net/posts/2014-07-10-complicated-proof-simple-thm.html" />
    <id>http://osa1.net/posts/2014-07-10-complicated-proof-simple-thm.html</id>
    <published>2014-07-10T00:00:00Z</published>
    <updated>2014-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s that time of the year again in which I’m suddenly very interested about verification and interactive theorem proving. I’m currently working on proving properties of some well-known algorithms.</p>
<p>At least in the beginning even the simplest properties may turn out to be very hard to prove. In this post I’m going to give an example of a very simple theorem which turns out to be hard to prove for beginners like me.</p>
<p>Let’s say I want to divide peano nats by 10. I can define <code>div10</code> in two ways: 1) I can implement a function that directly divides by 10 2) I can implement <code>div2</code> and <code>div5</code> and use those two to implement <code>div10</code>:</p>
<pre class="coq"><code>(* first definition *)
Fixpoint div10 (n : nat) : nat :=
  match n with
  | S (S (S (S (S (S (S (S (S (S n&#39;))))))))) =&gt; S (div10 n&#39;)
  | _ =&gt; 0
  end.

(* second definition *)
Fixpoint div5 (n : nat) : nat :=
  match n with
  | S (S (S (S (S n&#39;)))) =&gt; S (div5 n&#39;)
  | _ =&gt; 0
  end.

Fixpoint div2 (n : nat) : nat :=
  match n with
  | S (S n&#39;) =&gt; S (div2 n&#39;)
  | _ =&gt; 0
  end.

Definition div10&#39; (n : nat) : nat := div5 (div2 n).</code></pre>
<p>It may be obvious enough that those two definitions are equal(in the sense that they always terminate and given same arguments they return same values) but as an exercise let’s try to prove it:</p>
<pre class="coq"><code>Theorem divs_eq : forall n, div10 n = div10&#39; n.</code></pre>
<p>It’s obvious that we need to do induction on n, but unfortunately that leads to very complicated induction hypothesis and I can’t make any use of them:</p>
<pre class="coq"><code>Proof.
  unfold div10&#39;. intro.
  do 10 (induction n; auto). simpl. f_equal. 
Abort.</code></pre>
<p>At this point goal is same as our original goal, but induction hypothesis are about a hundred lines long so I can’t make any use of it. (and I don’t understand why induction hypothesis getting that big)</p>
<p>It turns out that by using a different induction scheme we can easily prove this. Instead of using standard induction scheme of nats “prove P 0, assume P n and prove P (S n)” we can use “prove P 0, P 1, … P 9, assume P n and prove P (10 + n)”:</p>
<pre class="coq"><code>Definition nat10ind : forall (P : nat -&gt; Prop),
  P 0 -&gt; P 1 -&gt; P 2 -&gt; P 3 -&gt; P 4 -&gt; P 5 -&gt; P 6 -&gt; P 7 -&gt; P 8 -&gt; P 9 -&gt;
  (forall n, P n -&gt; P (10 + n)) -&gt; forall n, P n.

  intros.
  assert (P n /\ P (1 + n) /\ P (2 + n) /\ P (3 + n) /\ P (4 + n) /\ P (5 + n) /\
          P (6 + n) /\ P (7 + n) /\ P (8 + n) /\ P (9 + n)).
  + induction n.
    - simpl. repeat split; assumption.
    - repeat (match goal with H : _ /\ _ |- _ =&gt; destruct H end).
      repeat split; try assumption.
      apply H9. assumption.
  + destruct H10. assumption.
Defined.</code></pre>
<p>Now our main theorem is very easy to prove:</p>
<pre class="coq"><code>Theorem divs_eq : forall n, div10 n = div10&#39; n.
Proof.
  unfold div10&#39;. intro.
  induction n using nat10ind; auto.
  simpl. f_equal. assumption.
Qed.</code></pre>
<p>One thing that I found weird in <code>nat10ind</code> definition is that the expression <code>match goal with ...</code> is kind of special in that <code>goal</code> is not an identifier that represents some part of the context. Rather, <code>match goal with ...</code> is a special syntax to pattern match against the whole context, with hypothesis and goals<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. <code>H : _ /\ _ |- _</code> part is then matching for any hypothesis with form <code>_ /\ _</code> and binding it to <code>H</code>, ignoring the current goal(RHS of turnstile shown as <code>|-</code>).</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>See <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#sec447">tacexpr_1 production</a> of Coq expression syntax in reference manual for details.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Stack traces in GHCJS</title>
    <link href="http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html" />
    <id>http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html</id>
    <published>2014-06-20T00:00:00Z</published>
    <updated>2014-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m about to finish the first part of my GSoC project and as a part of my project I have implemented stack traces for GHCJS. Currently <code>GHC.Stack</code> functions should work in GHCJS, except for some cases I explain below.</p>
<p>As a demo, I set up <a href="http://osa1.net/files/stacktrace.jsexe/index.html">this page</a>, it runs the Haskell program rendered on the page (some part of the code is copied from Simon Marlow’s <a href="http://www.youtube.com/watch?v=J0c4L-AURDQ">“Why can’t I get stack traces?” presentation</a>). Output is printed to the console. You should be seeing something like this:</p>
<div class="figure">
<img src="http://osa1.net/images/ghcjs-stacktrace.png" />
</div>
<p>My main goal is to implement profiling features of GHC (cost-centres, SCC annotations, reporting allocations/ticks etc.) for GHCJS. It turns out that cost-centre stacks and call stacks are same thing. <code>GHC.Stack.currentCallStack</code> returns the current cost-centre stack, and cost attribution is done to current call-stack(or current cost-centre stack, since they’re exactly the same thing). Similarly, <code>GHC.Stack.whoCreated</code> returns the cost centre stack that was active when the heap object was created.</p>
<p><a href="https://github.com/osa1/ghcjs/compare/ghcjs:master...work3">20 changed files with 810 additions and 527 deletions</a> later, I had <code>GHC.Stack</code> working. You won’t need to do anything different once it’s merged into GHCJS, but for now it requires some effort to install. It also still has some bugs and differences from GHC version. Rest of the post explains how to test it, bugs, and differences from GHC.</p>
<h1 id="how-to-use">How to use</h1>
<p>Because of a horrible bug(see bugs section), you need a 32bit system to use profiling features of GHCJS. You should clone my fork of <a href="https://github.com/osa1/ghcjs">GHCJS</a> and <a href="https://github.com/osa1/shims">shims</a>. For GHCJS, switch to <code>work3</code> branch(that 3 represents how many times I started from scratch :) and for shims switch to <code>work2</code> branch. You need to install <a href="https://github.com/ghcjs/Cabal">modified Cabal for GHCJS</a>. After installing Cabal, install GHCJS and run <code>ghcjs-boot --init -q --prof</code>. This takes about 20 minutes on my system and compiles <code>base</code> and some other libraries. <code>--prof</code> is used to generate profiled versions of libraries.</p>
<p>After GHCJS has been booted, replace ~/.ghcjs/&lt;your platform&gt;/shims folder with my fork of shims(make sure you switched to work2 branch). Now you should be able to compile and run programs with profiling options of GHC. For example, to compile and run the example program given above, run <code>ghcjs stacktrace.hs -prof -fprof-auto</code> and then run generated <code>stacktrace.jsexe/all.js</code> using nodejs. Enabling profiling gives you a debug executable, with more metadata (object names) and longer (non-renamed) variable names.</p>
<h1 id="differences">Differences</h1>
<p>Because GHCJS represents some objects as unboxed numbers and currently we don’t associate any cost-centres with this type of objects, <code>whoCreated</code> returns an empty list. If there’s demand, we can disable unboxing with a command line switch and <code>whoCreated</code> on these values would work. In the example program, second and third lines are printing empty lists because of this.</p>
<h1 id="bugs">Bugs</h1>
<p>Currently we discovered two bugs:</p>
<ol style="list-style-type: decimal">
<li><p>There’s a horrible bug happening outside of GHCJS code, see my <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">blog post</a> and <a href="http://www.haskell.org/pipermail/ghc-devs/2014-May/005059.html">ghc-devs mail</a>. Because of this bug, booting GHCJS with profiling enabled is resulting with a segfault on 64bit systems. I’m developing this project on a 32bit VM, running on a VPS :) I need to make some more progress before tracking this bug.</p></li>
<li><p>We’re having a bug that makes stack traces sometimes a bit different than the ones generated by GHC compiled programs. For example, the example program should have printed this stack trace:</p>
<pre><code>Main.errorM.\ (stacktrace.hs:13:22-54)
Main.errorM (stacktrace.hs:13:1-54)
Main.foo.\.\ (stacktrace.hs:27:23-30)
Main.foo.\ (stacktrace.hs:27:16-33)
Main.foo (stacktrace.hs:27:1-36)
Main.bar (stacktrace.hs:24:1-20)
Main.runM.(...) (stacktrace.hs:16:20-31)
Main.runM (stacktrace.hs:16:1-36)
Main.main (stacktrace.hs:(29,1)-(38,36))
Main.CAF (&lt;entire-module&gt;)</code></pre>
<p>.. but <code>runM</code> calls are missing in GHCJS output. I have no idea what could be the reason for this and I’m currently working to fix this. After fixing this, I think we’ll have exactly same stack traces as the ones produced by GHC compiled programs.</p></li>
</ol>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>I’d like to thank my mentor Luite Stegeman for answering my endless questions, helping me understanding GHC and GHCJS internals and reviewing this blog post.</p>]]></summary>
</entry>
<entry>
    <title>Dependency boundaries and orphan instances</title>
    <link href="http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html" />
    <id>http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>According to the <a href="http://www.haskell.org/haskellwiki/Package_versioning_policy">PVP</a>(Package Versioning Policy), adding a non-orphan instance is not a breaking change and a minor version number should be bumped(<code>C</code> in <code>A.B.C</code>) in case of a non-orphan instance implementation.</p>
<p>This means that if you’re implementing an orphan instance, you should specify minor upper bound of the package that defines the typeclass. Otherwise if the package implements the typeclass for the type in the future, you’re package will be broken.</p>
<p>I want to add <code>StackValue a =&gt; StackValue [a]</code> instance in hslua, but that breaks Pandoc because it implements that instance without using a newtype(an orphan instance) and hslua dependency upper bound is specified as <code>&lt; 0.4</code>.</p>
<p>Good news is that bergmark at Freenode #haskell told me that now it’s possible to change dependency ranges on Hackage without pushing a new version, so there’s an easy fix that’ll keep package working.</p>]]></summary>
</entry>
<entry>
    <title>Tercüme</title>
    <link href="http://osa1.net/posts/2014-06-03-tercume.html" />
    <id>http://osa1.net/posts/2014-06-03-tercume.html</id>
    <published>2014-06-03T00:00:00Z</published>
    <updated>2014-06-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A. Einstein ve L. Infeld’in “Fiziğin Evrimi” kitabının Öner Ünalan tarafından tercüme edilmiş halinin çok eski bir baskısını(baskı yılı yazmıyor, fakat kitabın arkasında “30 lira” yazmakta) okuyorum ve yabancı kelimelerin tercümesi hakkında çok güzel bir “çevirmen notuna” denk geldim.</p>
<p>Çevirmen “inertia” kelimesinin Türkçe karşılığı olarak neden “eylemsizlik” değil de “süredurum” kullandığını şu şekilde açıklıyor:<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Inert: Eylemsiz - süreduran</li>
<li>Inertia: Eylemsizlik - süredurum</li>
<li>Noninert: Eylemli (?) - süredurmayan</li>
<li>Inertial: ? - süredurumlu, süredurumsal</li>
<li>Noninertial: ? - süredurumsuz.</li>
</ul>
<p>Dolayısıyla “süredurum” kelimesi “inertia”ya daha iyi bir karşılık gibi çünkü aynı kökten türemiş yabancı kelimelerin Türkçe karşılıkları da kelimenin kökünün Türkçe karşılığından türemiş kelimeler olmuş oluyor.</p>
<p>Değişik ortamlarda değişik insanlardan “bilgisayar” kelimesinin kötü bir tercüme olduğunu duymuştum. Hiçbir zaman neden öyle düşündüklerini sormadım belki ama hep o kadar da kötü olmadığını düşünmüşümdür. Yukarıdaki teknik ile “bilgisayar” kelimesinin ne kadar yeterli olduğuna bakalım:</p>
<ul>
<li>Computer: Bilgisayar</li>
<li>Compute: Bilgisaymak (kullanılan: hesaplamak)</li>
<li>Computing: Bilgisayma (kullanılan: hesaplama)</li>
<li>Computable: Bilgisayılabilir (kullanılan: hesaplanabilir)</li>
<li>Computability: Bilgisayılabilirlik (kullanılan: hesaplanabilirlik)</li>
<li>Non-computable: Bilgisayılamaz (kullanılan: hesaplanılamaz)</li>
</ul>
<p>“Bilgisayar” kelimesini beğenmeyenlerin aklında böyle birşey var mıydı emin değilim, fakat görünüşe göre “bilgisayar” gerçekten korkunç bir tercüme, olması gereken kelime “hesaplayıcı”ymış gibi görünüyor. Gerçi durum burada biraz daha farklı. “Bilgisay-” kökünden türemiş alternatifler her kelime için var, fakat 1) hiçbiri anlam olarak eşleşmiyor<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> 2) hiçbiri günümüzde kullanılmıyor(çok şükür).</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Bugün Türkçe fizik kitaplarında hep “eylemsizlik” diye geçer.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>“Bilgi saymak” ile bir alakamız yok ve hatta bilgi saymanın ne kadar anlamlı bir fiil olduğu da tartışmaya açık. Benim aklımda hiçbir şey canlanmıyor mesela “bilgi saymak” deyince.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>GHC RTS notes</title>
    <link href="http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html" />
    <id>http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html</id>
    <published>2014-05-30T00:00:00Z</published>
    <updated>2014-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://news.ycombinator.com/item?id=7818768">Someone on HN</a> shared <a href="http://stanford.edu/~adebray/240h_notes.pdf">this class notes</a> of Stanford’s “Functional Systems in Haskell” class. Most of the stuff is very basic but sections 16 and 17 are very useful for me since they’re related with GHC internals which I’m currently studying.</p>
<p>You can see slides of Section 17 <a href="http://ezyang.tumblr.com/post/87048816817/cs240h-lecture-on-the-ghc-runtime-system">here</a>.</p>
<p>These are probably only up-to-date reading materials about GHC RTS you can find. (unless you count source code as a reading material ;_; )</p>
<p>Some other useful GHC Wiki pages that I find useful: (validness of these for current GHC is not guaranteed, but theoretic stuff should be still valid)</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps">PrimOps</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply">Function calls</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#ThreadStateObjects">The layout of heap objects</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Stack">Layout of the stack</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution">The Haskell Execution Model</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode">STG by example</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode">Debugging GHC-compiled code with gdb</a> (I hope you don’t really need this!)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/RuntimeSystem">Debugging the runtime system</a> (same as above)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">The Garbage Collector</a></li>
<li><a href="http://www.mono-project.com/Generational_GC">Generational GC page of Mono project</a> – not really Haskell, but I think it’s a good source to understand GC concepts that is related with GHC’s GC implementation.</li>
</ul>
<p>Now I can close my browser tabs in peace…</p>
<p>Bonus content: Here’s a <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">horror story</a> that is probably related with a GHC RTS bug and making progress in my work impossible.</p>
<p>EDIT: Someone on GHC IRC channel shared <a href="http://arashrouhani.com/papers/master-thesis.pdf">his masters thesis about GHC stack traces</a>, even if you’re not interested in stack traces I think it contains lots of useful information about GHC compilation pipeline.</p>]]></summary>
</entry>
<entry>
    <title>The GHC bug that ruined my day</title>
    <link href="http://osa1.net/posts/2014-05-27-worst-bug.html" />
    <id>http://osa1.net/posts/2014-05-27-worst-bug.html</id>
    <published>2014-05-27T00:00:00Z</published>
    <updated>2014-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just came across a very serious GHC bug that prevents me from making progress on my GHCJS project. It looks like it’s very hard to come up with a minimal program that reproduces the bug. Here’s a very long way to reproduce it:</p>
<ul>
<li><p>Install <a href="https://github.com/ghcjs/Cabal">patched Cabal for GHCJS</a>.</p></li>
<li><p>Clone <a href="https://github.com/osa1/ghcjs">my fork of GHCJS</a>, switch to <code>work</code> branch and install it.</p></li>
<li><p>Delete <code>~/.ghcjs</code> folder if you already have one.</p></li>
<li><p>Run <code>ghcjs-boot --init --prof -v</code> and wait for it to fail with segmentation fault while compiling profiling object files for <code>base</code> library. Segmentation fault is reported as <code>ExitFailure (-11)</code> by Cabal.</p></li>
<li><p>Since we run <code>ghcjs-boot</code> in verbose mode(using <code>-v</code> parameter), at this point it should have printed what command it was running when the error occured. It should be a very very long command, starting with something like <code>/home/omer/.cabal/bin/ghcjs --make -fbuilding-cabal-package -O -prof ...</code>. Copy that command because that’s how we reproduce the error.</p></li>
<li><p>Now to trace the bug, we need to compile GHCJS for debugging. Note that booting GHCJS with debugging build takes forever, so we first installed GHCJS and built some libraries using that fast build. To compile for debugging, first run <code>cabal clean</code> and then <code>cabal install --disable-executable-stripping --ghc-options=-debug</code>.</p></li>
<li><p>Move to <code>~/.ghcjs/&lt;your platform&gt;/ghcjs-boot/boot/base</code> and run the command you copied from <code>ghcjs-boot</code> verbose output when the error happened for first time. You should get the same error very fast.</p></li>
<li><p>At that point you can use gdb and friends. On my system gdb backtrace gives this:</p></li>
</ul>
<pre><code>[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
Detaching after fork from child process 3382.
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
Detaching after fork from child process 3383.
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
Detaching after fork from child process 3384.
[ 51 of 202] Compiling GHC.Fingerprint[boot] ( GHC/Fingerprint.hs-boot, dist/build/GHC/Fingerprint.js_p_o-boot )
Detaching after fork from child process 3385.
[ 55 of 202] Compiling GHC.IO.Exception[boot] ( GHC/IO/Exception.hs-boot, dist/build/GHC/IO/Exception.js_p_o-boot )
Detaching after fork from child process 3386.
[ 75 of 202] Compiling Foreign.C.Types  ( Foreign/C/Types.hs, dist/build/Foreign/C/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x000000000425f776 in scavenge_mutable_list1 (bd=0x7fffe5c02a00, gen=0x4d1fd48) at rts/sm/Scav.c:1400
#2  0x000000000425fa13 in scavenge_capability_mut_Lists1 (cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x0000000004256b66 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2,
    cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x00000000042454a3 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d32b60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x0000000004243de4 in schedule (initialCapability=0x4cfe5c0 &lt;MainCapability&gt;, task=0x4d32b60)
    at rts/Schedule.c:553
#6  0x0000000004246436 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x000000000423e9b4 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x477f850, ret=0x0) at rts/RtsAPI.c:500
#8  0x0000000004241666 in real_main () at rts/RtsMain.c:63
#9  0x0000000004241759 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x477f850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Thanks to Luite Stegeman for helping me with debugging. We could reproduce this error on 64bit Linux and 64bit OS X. I don’t know how to track down this bug but it just made making progress in my project impossible.</p>
<hr />
<p>EDIT: I just found a workaround: run GHCJS with <code>+RTS -G1</code>. I was reading code of functions in the backtrace and I realized some RTS parameters are used. By playing with them changing randomly, I found this. Some details about this parameter is explained in <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">GHC Trac GC section</a>(see “generational gc” parts). Unfortunately with this RTS parameter GHCJS runs at least 100x slower(at least in debug build) so even though I can boot GHCJS with my changes it’s not very usable since I sometimes boot it 10 times a day in this stage of the development.</p>
<hr />
<p>EDIT 2: My workaround did not work great – now compilation is failing in some other stage:</p>
<pre><code>Failed to install base-4.7.0.0
Last 10 lines of the build log ( /home/omer/.cabal/logs/base-4.7.0.0.log ):
[  4 of 202] Compiling Unsafe.Coerce    ( Unsafe/Coerce.hs, dist/build/Unsafe/Coerce.js_p_o )
[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
[  8 of 202] Compiling GHC.Err          ( GHC/Err.lhs, dist/build/GHC/Err.js_p_o )
[  9 of 202] Compiling GHC.Base         ( GHC/Base.lhs, dist/build/GHC/Base.js_p_o )
[ 10 of 202] Compiling Data.Maybe       ( Data/Maybe.hs, dist/build/Data/Maybe.js_p_o )
[ 11 of 202] Compiling GHC.List         ( GHC/List.lhs, dist/build/GHC/List.js_p_o )
[ 12 of 202] Compiling GHC.Num          ( GHC/Num.lhs, dist/build/GHC/Num.js_p_o )
[ 13 of 202] Compiling GHC.Show         ( GHC/Show.lhs, dist/build/GHC/Show.js_p_o )
cabal: Error: some packages failed to install:
base-4.7.0.0 failed during the building phase. The exception was:
ExitFailure (-11)</code></pre>
<p>However, when I tried to run the command that led to this segfault in gdb to see if it gives a different backtrace, it worked fine and no segfaults happened.</p>
<hr />
<p>EDIT 3: There has been some changes in GHCJS codegen and I wanted to try to reproduce this bug using that new codegen, hoping that it may be a workaround for the segfault(I rebased my patches for new version). It’s still happening, but now in different file:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x00000000042565e6 in scavenge_mutable_list1 (bd=0x7fffe5800c40, gen=0x4d17d48) at rts/sm/Scav.c:1400
#2  0x0000000004256883 in scavenge_capability_mut_Lists1 (cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x000000000424d9d6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x000000000423c313 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d2ab60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x000000000423ac54 in schedule (initialCapability=0x4cf6340 &lt;MainCapability&gt;, task=0x4d2ab60)
    at rts/Schedule.c:553
#6  0x000000000423d2a6 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x0000000004235824 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#8  0x00000000042384d6 in real_main () at rts/RtsMain.c:63
#9  0x00000000042385c9 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Backtrace is same. I think it’s interesting that this problem is happening while compiling <code>Types</code> modules in 2/3 of the cases(<code>Foreign.C.Types</code> and <code>System.Posix.Types</code>). As far as I can see this two modules are using <code>INTEGRAL_TYPE</code> extensively, which creates a newtype and implements <code>Read</code> and <code>Show</code> instances. Other problematic module, <code>GHC.Show</code> also implements same instances, but does that manually instead of calling <code>INTEGRAL_TYPE</code>. I wonder if it could be related with that.</p>
<hr />
<p>EDIT 4: When I run GHCJS using <code>--no-native</code>, it failed with an assertion error rather than a segfault:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )
ghcjs: internal error: ASSERTION FAILED: file rts/sm/Scav.c, line 1400

    (GHC version 7.8.2 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug

Program received signal SIGABRT, Aborted.
0x00007ffff687f849 in raise () from /lib64/libc.so.6
(gdb) bt
#0  0x00007ffff687f849 in raise () from /lib64/libc.so.6
#1  0x00007ffff6880cd8 in abort () from /lib64/libc.so.6
#2  0x0000000004238a27 in rtsFatalInternalErrorFn (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;, 
    ap=0x7fffffffbe58) at rts/RtsMessages.c:170
#3  0x000000000423865f in barf (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;) at rts/RtsMessages.c:42
#4  0x00000000042386c2 in _assertFail (filename=0x4559fbd &quot;rts/sm/Scav.c&quot;, linenum=1400) at rts/RtsMessages.c:57
#5  0x00000000042565e9 in scavenge_mutable_list1 (bd=0x7fffe7402dc0, gen=0x4d15d88) at rts/sm/Scav.c:1400
#6  0x0000000004256873 in scavenge_capability_mut_Lists1 (cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#7  0x000000000424d9c6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#8  0x000000000423c303 in scheduleDoGC (pcap=0x7fffffffc188, task=0x4d28ba0, force_major=rtsFalse)
    at rts/Schedule.c:1650
#9  0x000000000423ac44 in schedule (initialCapability=0x4cf49c0 &lt;MainCapability&gt;, task=0x4d28ba0)
    at rts/Schedule.c:553
#10 0x000000000423d296 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2b0) at rts/Schedule.c:2346
#11 0x0000000004235814 in rts_evalLazyIO (cap=0x7fffffffc2b0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#12 0x00000000042384c6 in real_main () at rts/RtsMain.c:63
#13 0x00000000042385b9 in hs_main (argc=238, argv=0x7fffffffc438, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#14 0x0000000000408ea7 in main ()</code></pre>
<p>Not passing <code>--not-native</code> is resulting with a segfault and same backtrace as before.</p>]]></summary>
</entry>

</feed>
