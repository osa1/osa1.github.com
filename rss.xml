<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - All posts</title>
    <link href="http://osa1.net/rss.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/rss.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-07-16T00:00:00Z</updated>
    <entry>
    <title>Apparently I'm not going to Jane Street</title>
    <link href="http://osa1.net/posts/2013-07-16-jane-street-interview-2.html" />
    <id>http://osa1.net/posts/2013-07-16-jane-street-interview-2.html</id>
    <published>2013-07-16T00:00:00Z</published>
    <updated>2013-07-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had written about my first interview experience <a href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html">here</a>. After that interview, we did two more interviews with Jane Street, the last one was done yesterday.</p>
<p>Today I’ve got an email saying that I’ve failed.</p>
<p>I won’t write about last two interviews because I’m asked to not to write about questions.</p>
<p>Now I’m looking for Haskell jobs for my last internship and I just applied to Galois. I’ll keep posting updates here. Wish me luck.</p>
<p><em>EDIT: I got response to my job application email from Galois, saying that they would not be able to sponsor me for my visa application. Which means I’m still looking for jobs.</em></p>]]></summary>
</entry>
<entry>
    <title>fmap fix return</title>
    <link href="http://osa1.net/posts/2013-07-07-fmap-fix-return.html" />
    <id>http://osa1.net/posts/2013-07-07-fmap-fix-return.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While floating across the internets, I came across a blog with title <code>fmap fix return</code>. I immediately run ghci and queried it’s type:</p>
<pre class="ghci"><code>ghci&gt; :t fmap fix return
fmap fix return :: a -&gt; a</code></pre>
<p>We know that only value with type <code>forall a. a -&gt; a</code> (other than bottom) is identity function(<code>id</code> in Haskell). I found it very interesting, <code>fmap fix return</code> gives us identity function!</p>
<p>I got a pen and paper and started evaluating expressions to understand how does that give us the identity function.</p>
<p>First, let’s note our actors:</p>
<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- instance specific implementation

fix  :: (a -&gt; a) -&gt; a
fix f = let x = f x in x

return :: Monad m =&gt; a -&gt; m a
-- instance specific implementation</code></pre>
<p>A very important thing to realize at this point is which monad and functor instances are used for <code>return</code> and <code>fmap</code>. To realize this, observe that we get a function as return value of <code>fmap</code>. Which means <code>Functor f =&gt; f b</code> is <code>a -&gt; a</code>, or written in a different style to see it’s functor property: <code>((-&gt;) a) a</code>, so our functor here is <code>(-&gt;) a</code>.</p>
<p>After that, we need to look up functor and monad instances for <code>(-&gt;) a</code>. Since it’s 2:30 AM here, I wanted to derive that too.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
     <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>It’s very easy to derive just by looking specialized version of <code>fmap</code>s type for <code>((-&gt;) a)</code>: <code>fmap :: (a1 -&gt; b) -&gt; (a -&gt; a1) -&gt; (a -&gt; b)</code>.</p>
<p>We can easily prove that it satisfies functor laws:</p>
<pre><code>fmap id f
= id . f
= f

fmap (p . q) &lt;-&gt; (fmap p) . (fmap q)
(fmap p) . (fmap q) f
= fmap p . (q . f)
= p . q . f
= fmap (p . q) f</code></pre>
<p>Monad instance can also be derived from types of <code>return</code> and <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
    <span class="fu">return</span>   <span class="fu">=</span> <span class="fu">const</span>
    f <span class="fu">&gt;&gt;=</span> fn <span class="fu">=</span> \r <span class="ot">-&gt;</span> fn (f r) r</code></pre>
<p>(I found Monad instance of <code>((-&gt;) a)</code> very interesting, especially the <code>&gt;&gt;=</code> part. I couldn’t come up with a problem that makes use of this instance, I’ll investigate that after some sleep)</p>
<p>It satisfies monad laws:</p>
<pre><code>-- left identity
return a &gt;&gt;= f
= const a &gt;&gt;= f
= \r -&gt; f ((const a) r) r
= \r -&gt; f a r
= f a

-- right identity
m &gt;&gt;= return
= \r -&gt; return (m r) r
= \r -&gt; (const (m r) r)
= \r -&gt; m r
= m

-- associativity
(m &gt;&gt;= f) &gt;&gt;= g &lt;-&gt; m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

let&#39;s first write `p` for `m &gt;&gt;= f`

= p &gt;&gt;= g
= \r1 -&gt; g (p r1) r1

let&#39;s also evaluaute p

p = m &gt;&gt;= f
= \r2 -&gt; f (m r2) r2

substitute new p

= \r1 -&gt; g ((\r2 -&gt; f (m r2) r2) r1) r1
= \r1 -&gt; g (f (m r1) r1) r1
= \r -&gt; g (f (m r) r) r

now let&#39;s also evaluate right hand side of equation

m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
= m &gt;&gt;= (\x -&gt; (    f x &gt;&gt;= g    )) -- just added a paren for clarity
= m &gt;&gt;= (\x -&gt; (\r -&gt; g (f x r) r))

let write `p` for `\x -&gt; (\r -&gt; g (f x r) r)`

= m &gt;&gt;= p
= \r1 -&gt; p (m r1) r1

put p back

= \r1 -&gt; (\x -&gt; (\r -&gt; g (f x r) r)) (m r1) r1
= \r1 -&gt; (\r -&gt; g (f (m r1) r)) r1
= \r1 -&gt; g (f (m r1) r1)</code></pre>
<p>For those who have no idea what’s above, I’m basically proving some equalities by substituting expressions with their equivalents. This is a benefit for working on a purely functional language, which means referential transparency.</p>
<p>OK, now with these <code>return</code> and <code>fmap</code> implementations in mind, let’s evaluate <code>fmap fix return</code>:</p>
<pre><code>fmap fix return
= fix . return
= \r -&gt; fix (return r)
= \r -&gt; fix (const r)
= \r -&gt; (\f = let x = f x in x) (const r)
= \r -&gt; let x = (const r) x in x

since `const a _ = a`, we have x = r here

= \r -&gt; r</code></pre>
<p>.. which is the identity function.</p>
<p>Thus <code>fmap fix return</code> demystified.</p>]]></summary>
</entry>
<entry>
    <title>Shen.hs FFI</title>
    <link href="http://osa1.net/posts/2013-06-29-shenhs-ffi.html" />
    <id>http://osa1.net/posts/2013-06-29-shenhs-ffi.html</id>
    <published>2013-06-29T00:00:00Z</published>
    <updated>2013-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Shen.hs now has a simple way to call Haskell functions. As an example, I removed some non-standard KLambda functions from <a href="https://github.com/osa1/Shen.hs/blob/master/src/KLambda/Fun.hs"><code>Fun.hs</code></a>(standard primitive functions are defined there). Instead, they live in a <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs">separate module</a> now, and I load them in run-time when I’m debugging.</p>
<h2 id="how-it-works">How it works</h2>
<p>Shen.hs is now exports it’s modules as a library. This is required to allow writing Shen.hs functions in Haskell.</p>
<p><code>KLambda.Types</code> module export all required type information to start writing Shen.hs functions in Haskell. All your functions should have the type <code>KlFun1</code>. To make converting Haskell functions with higher arity(ie. <code>KlFun2</code>, <code>KlFun3</code>) to <code>KlFun1</code>, all <code>KlFun</code> instances now have a <code>mkFun1 :: a -&gt; KlFun1</code> method.</p>
<p>As an example, <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs"><code>Debug.hs</code></a> module functions with types <code>KlFun2</code>, <code>KlFun3</code> etc. To call them from within Shen.hs, they are all wrapped with <code>mkFun1</code> function.</p>
<p>After defining functions with type <code>KlFun1</code> and compiling it, you should call <code>dynload</code> primitive to load functions. Here’s an example session that demonstrates loading and using debugging functions:</p>
<pre><code>$ Shen.hs --shen &quot;/home/omer/Shen/hs_yeni/K Lambda&quot;
loading file: /home/omer/Shen/hs_yeni/K Lambda/toplevel.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/core.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sys.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sequent.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/yacc.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/reader.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/prolog.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/track.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/load.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/writer.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/macros.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/declarations.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/t-star.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/types.kl ...loaded.

Shen 2010, copyright (C) 2010 Mark Tarver
released under the Shen license
www.shenlanguage.org, version 12
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan


(0-) (cd &quot;/home/omer/Shen/hs_yeni/dynload_test&quot;)
&quot;/home/omer/Shen/hs_yeni/dynload_test/&quot;

(1-) (dynload &quot;Debug.o&quot; &quot;debug1F&quot;)
&lt;function&gt;

(2-) (debug1F &quot;calling haskell function -- &quot; 1 2)
calling haskell function -- 1 :: TyNum

2

(3-)</code></pre>
<p>Note that you need both <code>.hi</code> and <code>.o</code> files to be able to load the library dynamically.</p>
<h2 id="status-of-shen.hs">Status of Shen.hs</h2>
<p>Before this additional feature I had fixed a bug and now Shen.hs fails in 8 tests in Test Suite distributed with Shen source. All errors are related and probably there is only one bug. Unfortunately narrowing bug’s scope is very hard at this point. Pull requests are welcome.</p>
<p>If you encounter any bugs please open an issue in <a href="https://github.com/osa1/Shen.hs">Github repository</a>.</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: Shen.hs -- Haskell port of Shen</title>
    <link href="http://osa1.net/posts/2013-06-21-ann-shen-hs.html" />
    <id>http://osa1.net/posts/2013-06-21-ann-shen-hs.html</id>
    <published>2013-06-21T00:00:00Z</published>
    <updated>2013-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m copying <a href="https://groups.google.com/forum/?hl=en#!topic/qilang/GKVN4E_ntWw">my email</a> sent to Shen mailing list:</p>
<blockquote>
<p>Hi all,</p>
<p>I had started writing a port of Shen in Haskell some time ago. Unfortunately it never reached a stable state. And now I can’t spare enough time to fix bugs and improve performance. So I thought maybe it’s a good time to announce it and wait for contributions.</p>
<p>By ‘not stable’ I don’t mean it’s in a terrible state. For example, Shen test suite runs with following results:</p>
<pre><code>passed ... 94.0 
failed ...34.0 
pass rate ...73.4375% </code></pre>
<p>.. it’s not hopelessly bad. It probably has one or two deadly bugs and that causes dozens of tests to fail.</p>
<p>Anyway, that’s it for now. Github repository is here: <a href="https://github.com/osa1/Shen.hs">https://github.com/osa1/Shen.hs</a> .</p>
<p>If you try please tell me your thoughts!</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>My first interview experience: Jane Street</title>
    <link href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html" />
    <id>http://osa1.net/posts/2013-06-20-first-interview-jane-street.html</id>
    <published>2013-06-20T00:00:00Z</published>
    <updated>2013-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A few hours ago I had my first interview ever. I had applied to Jane Street’s software development internship position last Sunday(16 June), and they returned to me on Monday(17 June), and we had an interview today(20 June). It was overall a very good experience.</p>
<p>I should say I’m a bit sad about this interview, because I couldn’t answer the questions with details I could answer and I gave wrong answers to some questions that I know very well. Still, I think I wasn’t bad in general. What happens next will be clear in few days.</p>
<p>We started with some generic personal questions like what I know, what I write, why did I applied to this internship etc. and I couldn’t give good answers even to this questions. For example, at some point I’m asked “what do you like about functional programs”, if you sit next to me in a class and ask me same question, I can give you a 50-minute lecture, but while at interview I just couldn’t do that.</p>
<p>Anyway, we then moved to technical question.</p>
<p>As for first question I’m asked to list 5 unix programs with 2 letters. I immediately listed <code>vi</code> and <code>ls</code>, after some thought I added <code>sh</code>, <code>ld</code>, <code>ln</code> and <code>nm</code>. I’m asked for what does <code>ld</code> do, and I wrongly answered “shows dynamically loaded libraries of an ELF binary”. My interviewer later asked me if I ever used that command, lol. It was funny that I said yes and explained how I used it, haha. The program I explained here is actually <code>ldd</code>, and <code>ld</code> is actually a linker(and I knew it very well, even though I have never called it manually). I also gave wrong answer to <code>nm</code>, I said “it shows string in a binary”, which was wrong because that what <code>strings</code> does. I should have said “shows symbols in a binary”. And I use these tools frequently!</p>
<p>For second question I’m asked “how would I count a list of files in a folder and it’s subfolders”. I said I’m not that good in shell environment so I wrote a small Python program instead. This was easy. (btw, I made a mistake even in this code by first writing a Python program that prints file paths instead of counting files, haha. Later I’m warned and I fixed the code :-D )</p>
<p>For third question I’m asked to tell what I know about garbage collectors and garbage collection techniques. I said the purpose of garbage collectors, and then mentioned reference counting technique. Later I’m asked to list some languages that does and doesn’t have automatic garbage collection.</p>
<p>Fourth question was to write and explain a <code>map</code> function that works on lists. It was trivial.</p>
<p>Fifth question was to write and explain <code>fold</code> function. I mentioned both left and right folds, wrote <code>foldl</code> in Haskell syntax and said that it’s a tail recursive process. At this point I’m also asked why is it tail recursive and what does tail recursive mean.</p>
<p>I think one nice question at this part is that the question of “does being tail-recursive matters in Haskell, because it’s lazy by default”. I think my interviewer wanted to test me if I understand orthogonality of laziness and tail recursion.</p>
<p>Last question, which I failed to give a correct answer was “you have a 5-sided fair dice, and you want to make a fair choice between 7 choices, how can you do it?”. Now this is by no means a hard question and I solved harder problems, but at that time I just couldn’t answer it.</p>
<p>One interesting observation I made while I’m trying to solve this problem was that thinking in a language and translating ideas to another one at the same time is hard. After few seconds of silence my interviewer asked me to say what I’m thinking. I was bad at this.</p>
<p>Anyway, I think I did good enough. I’ll post on updates, wish me luck :-) .</p>
<p><strong>EDIT: I’ve just got an email from Jane Street, we will make another interview, this time with someone from NY office :-)</strong></p>]]></summary>
</entry>
<entry>
    <title>Type checking with Prolog</title>
    <link href="http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html" />
    <id>http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html</id>
    <published>2013-06-13T00:00:00Z</published>
    <updated>2013-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There is a deep relation between a type inference system and a logic programming system. I don’t fully understand this relation. <a href="http://stackoverflow.com/questions/13899586/haskells-type-system-and-logic-programming-how-to-port-prolog-programs-to-typ">This question</a> I asked at StackOverflow a few months ago gives some tips, but doesn’t explain much.</p>
<p>I could finally spare some time and play with a type checker implementation in Prolog. What I had in mind before starting writing this code was that having a unification mechanism at hand should make type checking easier.</p>
<p>Indeed that is the case, as you’ll see shortly. Type inference is harder, and I also explain the reason and how could it be done.</p>
<hr />
<p>I will not formally define the type system here, but I think it can be seen as a simple Damas-Hindley-Milner style type system.</p>
<p>This implementation basically embeds type definitions in Prolog. This is what makes this implementation simple. You can always implement a fully-featured type system in Prolog just like you can do it in any other language. What I’m trying to show here that it’s very simple to do when there is a way to implement types as rules in Prolog.</p>
<p>Here’s knowledge base of types:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">nat(o)<span class="kw">.</span>
nat(s(<span class="dt">N</span>)) <span class="kw">:-</span> nat(<span class="dt">N</span>)<span class="kw">.</span>

bool(<span class="kw">true</span>)<span class="kw">.</span>
bool(<span class="kw">false</span>)<span class="kw">.</span>

type(<span class="dt">A</span><span class="kw">,</span> nat) <span class="kw">:-</span> nat(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span>
type(<span class="dt">A</span><span class="kw">,</span> bool) <span class="kw">:-</span> bool(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span>
type(id<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)) <span class="kw">:-</span> <span class="kw">!.</span>
type(add<span class="kw">,</span> arrow(nat<span class="kw">,</span> arrow(nat<span class="kw">,</span> nat))) <span class="kw">:-</span> <span class="kw">!.</span>
type(not<span class="kw">,</span> arrow(bool<span class="kw">,</span> bool)) <span class="kw">:-</span> <span class="kw">!.</span>
type(const<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> arrow(<span class="er">_, </span><span class="dt">A</span>)))<span class="kw">.</span></code></pre>
<p>Implementing type definitions as rules in a Prolog system is what makes this implementation simple. Here <code>id</code> is a function with type <code>forall a. a -&gt; a</code>, <code>add</code> is <code>nat -&gt; nat</code>, <code>not</code> is <code>bool -&gt; bool</code>, and <code>const</code> is <code>forall a b. a -&gt; b -&gt; a</code>.</p>
<p>Type checking of function applications is also simple:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">R</span>))<span class="kw">,</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></code></pre>
<p>And we’re done. This much code is enough for type checking polymorphic functions. Here are some examples:</p>
<pre><code>?- type(app(id, false), T).
T = bool.

?- type(app(id, o), T).
T = nat.

?- type(app(add, o), T).
T = arrow(nat, nat).

?- type(app(app(add, o), s(o)), T).
T = nat.

?- type(app(app(add, o), false), T).
false.

?- type(app(app(const, false), o), T).
T = bool.

?- type(app(app(const, false), true), T).
T = bool.</code></pre>
<p>One major limitation of this implementation is that there is no way to implement monomorphic functions. To do this, we should somehow have two different kinds of Prolog variables, one for polymorphic variables and one for monomorphic ones.</p>
<p>Since there’s no way to directly express this in Prolog, I had to extend this code with a typing environment. In the implementation above, if parameter of a function is an atom and not a variable, then it’s looked in a global environment.</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">var</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% polymorphic parameter</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">,</span>
    <span class="dt">R</span> <span class="kw">=</span> <span class="dt">B</span><span class="kw">,</span>
    <span class="kw">!.</span>

type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span>
    get<span class="er">_</span><span class="dt">type</span>(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span>
    <span class="co">% type already exists in environment</span>
    <span class="kw">!,</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span>
    type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span>
    <span class="kw">!.</span>

type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span>
    <span class="co">% type doesn&#39;t exist in environment</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span>
    add<span class="er">_</span><span class="dt">type</span>(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span>
    type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span>
    <span class="kw">!.</span></code></pre>
<p>First rule is for polymorphic parameters, only difference from the first code is <code>var(A)</code>, which ensures the parameter type is a variable.</p>
<p>Second rule does a similar check, but this time to ensure the parameter is an atom and not a variable. After that, type of this parameter is looked from an environment and checked against it. The third rule is when a type is not found in the environment. In that case, a new type is added to the environment.</p>
<p>Note that first cut is required in second rule. Because otherwise, when a type checking fails, third rule would be executed and a new type would be added to the environment.</p>
<p>Here are environment operations:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">init<span class="er">_</span><span class="dt">state</span>(<span class="dt">Name</span>) <span class="kw">:-</span>
    empty<span class="er">_</span><span class="dt">assoc</span>(<span class="dt">A</span>)<span class="kw">,</span>
    nb<span class="er">_</span><span class="dt">setval</span>(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>

add<span class="er">_</span><span class="dt">type</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span>
    nb<span class="er">_</span><span class="dt">getval</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span>
    put<span class="er">_</span><span class="dt">assoc</span>(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">,</span>
    nb<span class="er">_</span><span class="dt">setval</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">.</span>

get<span class="er">_</span><span class="dt">type</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span>
    nb<span class="er">_</span><span class="dt">getval</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span>
    get<span class="er">_</span><span class="dt">assoc</span>(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span>)<span class="kw">.</span></code></pre>
<p>Environment operations get a environment name to keep the state local. ie. you can be sure your state is local if name of the state is not used somewhere else :-)</p>
<p>This helper is used to get type of a term when term is an atom, and it’s type is available in environment. Otherwise it returns the term itself.</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>) <span class="kw">:-</span> get<span class="er">_</span><span class="dt">type</span>(types<span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>)<span class="kw">.</span>
type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span></code></pre>
<p>An example monomorphic function rule:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(mono<span class="er">_</span><span class="dt">id</span><span class="kw">,</span> arrow(mono<span class="er">_</span><span class="dt">id</span><span class="er">__</span><span class="dt">a</span><span class="kw">,</span> mono<span class="er">_</span><span class="dt">id</span><span class="er">__</span><span class="dt">a</span>)) <span class="kw">:-</span> <span class="kw">!.</span></code></pre>
<p>It should be guaranteed by the programmer that <code>mono_id__a</code> atom is only used for <code>mono_id</code> function.</p>
<p>Here are some examples for checking monomorphic functions(others work as before):</p>
<pre><code>?- init_state(types).
true.

?- type(app(mono_id, o), T).
T = nat.

?- type(app(mono_id, s(o)), T).
T = nat.

?- type(app(mono_id, false), T).
false.

?- init_state(types).
true.

?- type(app(mono_id, false), T).
T = bool.

?- type(app(mono_id, o), T).
false.</code></pre>
<p>This code should demonstrate how easy it’s to implement a type checker when there’s a way to express typing rules as Prolog rules. We had type checker for polymorphic and monomorphic functions in 57 lines of Prolog.</p>
<p>For type inference, we need to generate new rules in runtime. I’m looking for ways to do this. <code>assert/1</code> and <code>dynamic/1</code> predicates make this possible, but I still couldn’t find a way to generate fresh Prolog variables(like <code>gensym</code>, but for variables). I’ll update this post later.</p>]]></summary>
</entry>
<entry>
    <title>lcl -- Lua Container Library and The One Data Structure to Rule Them All</title>
    <link href="http://osa1.net/posts/2013-06-08-lcl-and-one-data-structure.html" />
    <id>http://osa1.net/posts/2013-06-08-lcl-and-one-data-structure.html</id>
    <published>2013-06-08T00:00:00Z</published>
    <updated>2013-06-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><strong>Note: Sorry for organization of this post. We were talking about this stuff over #lua IRC channel for an hour, and before that I had worked on various bugs and I’m incredibly tired now.</strong></p>
<p>I’ve been working with an experimental Lua library lately. It had started as a learning exercise, and after first iteration, it turned out to be an experiment about Lua’s internals, dynamic linking, and data structures.</p>
<p>Lua Container Lib(lcl or liblcl for short) is a Lua library to use C++ STL containers from within Lua. It’s compiled to a single <code>.so</code>(or <code>.dll</code>) and it can be loaded from Lua 5.1.5, 5.2.2, LuaJIT 2.0.2 and Love2D with <code>package.loadlib</code> standard function. It provides some STL containers with an object-oriented interface.</p>
<p>You can see the source <a href="https://github.com/osa1/lcl">here</a>. There isn’t any tutorials yet, I think it’s simple enough to learn it from examples, see <code>tests/</code> folder.</p>
<p>For now, it only contains set and deque containers, but it should be very easy to add more. Also, not all operations on sets and deques are supported yet. Again, this should also be very easy to add. Current code base should have all kinds of code to implement more containers/operations on containers by just looking for others’ implementations. Pull requests are welcome!</p>
<p><code>tests/</code> folder also have a simple benchmark. Output of benchmark is in files <code>benchmark.output</code> and <code>benchmark.output_luajit</code>. I think most people find the output interesting. Before explaining what’s going on in that benchmark, here are some stuff I learned while developing this library:</p>
<h2 id="lessons-learned">Lessons learned</h2>
<p>Lua has some rules about the use of C API, but when you don’t follow the rules, you don’t immediately get caught. For instance, you should return the number of elements placed to the stack in your C functions. I had a bug in my code and one of my functions was returning 1 even though it returns with an empty stack. Nevertheless, the library worked fine until I tried it with LuaJIT.</p>
<p>LuaJIT is more picky about that rules and it fails in strange ways. Sometimes my program was failing with strange memory allocation errors, but program was still running. In the best case, I was getting a segmentation fault.</p>
<p>After several hours of debugging and some help from mailing list(see my mail <a href="http://www.freelists.org/post/luajit/cant-load-so-with-packageloadlib-undefined-symbol-error">here</a>) I could solve it. Best helper was the <code>LUA_USE_APICHECK</code> debug macro. It’s added to Lua in somewhere between Lua 5.1.5 and 5.2.2. When you compile Lua with <code>LUA_USE_APICHECK</code> defined, Lua makes some assertions in code to make sure stack is in correct state. You should always develop C libraries to Lua with this enabled.</p>
<p>Now, as for benchmarks; two things can be seen immediately from benchmarks: 1) All operations on STL containers are slower 2) LuaJIT is awesome.</p>
<p>Let’s first start from second point. LuaJIT is awesome. It’s best thing happened to Lua. It’s binary compatible with Lua 5.1.5, which means with minimal effort, you can gain some real performance benefits. You can see the difference by comparing <code>benchmark.output</code> and <code>benchmark.output_luajit</code> files. All I had to do was to run program with LuaJIT instead of Lua.</p>
<p>Now, as for STL containers .. Before starting this project, I was considering having a better performance for specialized data structures, ie. STL deques should be faster than Lua tables used as deques. As can be seen from benchmarks, that’s not the case. I made a simplest possible deque implementation possible in Lua(you can see it <a href="https://github.com/osa1/lcl/blob/master/tests/deque.lua">here</a>) and it’s still faster than STL deque(with minor difference).</p>
<p>I think there are several reasons for that.</p>
<p>There is no way to get a Lua value out of Lua interpreter. Lua C API deliberately avoid this because this may lead to memory leaks or memory corruptions.</p>
<p>You can only have a reference to a Lua value, and in that case, that value has to be written in some table. <a href="http://www.lua.org/manual/5.2/manual.html#luaL_ref"><code>luaL_ref</code></a> creates a reference and writes it to a Lua table, and then return that reference(as an <code>int</code>). Generally, you would use global register at <code>LUA_REGISTRYINDEX</code> to save Lua values.</p>
<p>This implies that you cannot have a container with insertion faster than Lua table insertion. Because every insertion also have to insert to a Lua table. This table is generally the global register at index <code>LUA_REGISTRYINDEX</code>. For example, when I add 1000000 elements to a set, all those elements is also added to the register.</p>
<p>You can see that STL deque insertions time is almost the same as Lua implementation’s. The reason for this is that even though STL deque insertion is O(1) with a minimal constant factor, you have to insert to a Lua table like explained above.</p>
<p>In case of set data structure: STL’s set implementation is generally a kind of tree, and elements are stored in sorted order(this makes possible to use STL sets as heaps like I did in <a href="https://github.com/osa1/lcl/blob/master/tests/dynload.lua"><code>dynload.lua</code></a> example). This causes extra O(log N) function calls for comparisons, where N is number of elements in tree. ie. when a new element added, it’s place is determined by comparing it with elements at each level and then moving down to next level in tree. In case of Lua tables, all insertions are amortized O(1) and no comparison functions are called.</p>
<p>These are my explanations to reasons of why STL operations are slower.</p>
<p>Still, I don’t think adding C/C++ containers in Lua is completely pointless. Significant memory savings may be possible with C/C++ containers. For example, 32 flags can be held in a 32bit integer in C/C++, but to do this in Lua, you need to use a double for every flag, and a table. A double is 8 bytes in my 64bit machine. And with 32 flags it costs you 32*8 = 256 bytes. In C/C++ you can have it with only 4 bytes.</p>
<p>There may be also performance advantages for really complex algorithms, but I don’t have a particular example in mind.</p>]]></summary>
</entry>
<entry>
    <title>Compiling Love2D with LuaJIT</title>
    <link href="http://osa1.net/posts/2013-06-08-compiling-love2d-with-luajit.html" />
    <id>http://osa1.net/posts/2013-06-08-compiling-love2d-with-luajit.html</id>
    <published>2013-06-08T00:00:00Z</published>
    <updated>2013-06-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For some reason, I couldn’t load my dynamic library(compiled to <code>.so</code>) in Love2D linked with Lua 5.1.5. It was failing with <code>undefined symbol: lua_getfield</code> error. Interesting point is that I could load same library from directly in Lua 5.1.5 interpreter, which is the same thing as Love2D’s Lua interpreter. They’re compiled with same headers and linked with same object files.</p>
<p>I wasted several hours trying to compile Love2D with LuaJIT with the hope of loading my library from Love2D. I had tried loading my library from several different Lua versions before, Lua 5.1.5, Lua 5.2.5 and LuaJIT 2.0.2, and everything had worked perfectly. So I was expecting it to work with Love2D’s Lua interpreter too.</p>
<p>The problem was that Love2D’s configure script was not using environment variables to look for headers/object files. I was using same environment variables to build some other programs that use LuaJIT, and only Love2D had that problem.</p>
<p>To overcome this, I had to install LuaJIT to <code>/usr/</code>. There no way to compile Love2D with LuaJIT other than installing LuaJIT to <code>/usr/</code>. Installing <code>/usr/local/</code> doesn’t work. Setting environment variables(<code>LDFLAGS</code>, <code>LIBS</code> and <code>CPPFLAGS</code>) doesn’t work.</p>
<p>After that, I could compile Love2D. But that wasn’t enough because then generated executable was failing with <code>libluajit-5.1.so.2: cannot open shared object file: No such file or directory</code>. The reason of this error is latest version of LuaJIT generates a library file with different name: <code>libluajit-5.1.so.2.0.2</code>. This makes sense, I think most C/C++ libraries use same naming conventions.</p>
<p>Thankfully, renaming it works. Just rename that so file with required file.</p>
<p>I’m working on some Lua libraries written in C++, and testing gets painful when you can’t be sure which libraries you’re library is linked against. For this reason I don’t install Lua to <code>/usr</code> or <code>/usr/local</code>, and manually specify header/object file locations while compiling my library. So I removed all LuaJIT files from <code>/usr/lib</code>, <code>/usr/include</code>, etc. But to make Love2D work, I need <code>libluajit-5.1.so.2</code>. So I created a <code>lib</code> folder in my home dir, moved LuaJIT file there, and add that folder to <code>$LD_LIBRARY_PATH</code> environment variable. With this, I had a Love2D working with latest LuaJIT.</p>
<p>Hope this helps other people who want LuaJIT enabled Love2D on Linux.</p>]]></summary>
</entry>
<entry>
    <title>Implicit casts</title>
    <link href="http://osa1.net/posts/2013-05-25-implicit-casts.html" />
    <id>http://osa1.net/posts/2013-05-25-implicit-casts.html</id>
    <published>2013-05-25T00:00:00Z</published>
    <updated>2013-05-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote a C++ code like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> max_number_of_something = -<span class="dv">1</span>;
set&lt;some_type&gt; s;

...

<span class="kw">if</span> (s.size() &gt; max_number_of_something)
    max_number_of_something = s.size();</code></pre>
<p>The problem with this code is that this conditional will never be taken, and no errors will be raised either. This is because type of <code>s.size()</code> is unsigned and in the expression <code>s.size() &gt; max_number_of_something</code>, <code>max_number_of_something</code> will be casted to unsigned, implicitly. So <code>-1</code> is now <code>4294967295</code> and no other 32bit unsigned integer is bigger than that number.</p>
<p>Another reason to not to like weak typing and implicit type casts.</p>]]></summary>
</entry>
<entry>
    <title>A converter from Lua tables to JavaScript objects</title>
    <link href="http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html" />
    <id>http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html</id>
    <published>2013-05-06T00:00:00Z</published>
    <updated>2013-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote a simple Haskell program to convert some data encoded as Lua tables to JavaScript objects/arrays to be used in another project of mine:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span>           Language.Lua.Parser
<span class="kw">import</span>           Language.Lua.Types

<span class="kw">import</span> <span class="kw">qualified</span> Language.ECMAScript3.Syntax       <span class="kw">as</span> JS
<span class="kw">import</span>           Language.ECMAScript3.PrettyPrint  (renderExpression)

<span class="kw">import</span>           System.Environment                (getArgs)
<span class="kw">import</span>           Control.Monad
<span class="kw">import</span>           Prelude                           <span class="kw">hiding</span> (exp)

<span class="ot">unsupported ::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
unsupported <span class="fu">=</span> <span class="fu">error</span> <span class="fu">.</span> (<span class="st">&quot;unsupported exp: &quot;</span> <span class="fu">++</span>) <span class="fu">.</span> <span class="fu">show</span>

<span class="kw">class</span> <span class="dt">ToJsExp</span> a <span class="kw">where</span>
<span class="ot">    toJsExp ::</span> a <span class="ot">-&gt;</span> <span class="dt">JS.Expression</span> ()

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Exp</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Nil</span> _) <span class="fu">=</span> <span class="dt">JS.NullLit</span> ()
    toJsExp (<span class="dt">Bool</span> _ bool) <span class="fu">=</span> <span class="dt">JS.BoolLit</span> () bool
    toJsExp (<span class="dt">Number</span> _ num) <span class="fu">=</span> <span class="dt">JS.NumLit</span> () (<span class="fu">read</span> num)
    toJsExp (<span class="dt">String</span> _ str) <span class="fu">=</span> <span class="dt">JS.StringLit</span> () str
    toJsExp (<span class="dt">TableConst</span> _ table) <span class="fu">=</span> toJsExp table
    toJsExp unsupportedexp <span class="fu">=</span> unsupported (<span class="fu">fmap</span> (<span class="fu">const</span> ()) unsupportedexp)

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Table</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Table</span> _ fields)
      <span class="fu">|</span> <span class="fu">all</span> arrField fields <span class="fu">=</span>
          <span class="dt">JS.ArrayLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">Field</span> _ <span class="fu">exp</span>) <span class="ot">-&gt;</span> toJsExp <span class="fu">exp</span>) fields
      <span class="fu">|</span> <span class="fu">all</span> objField fields <span class="fu">=</span>
          <span class="dt">JS.ObjectLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">NamedField</span> _ (<span class="dt">Name</span> _ name) <span class="fu">exp</span>) <span class="ot">-&gt;</span> (<span class="dt">JS.PropId</span> () (<span class="dt">JS.Id</span> () name), toJsExp <span class="fu">exp</span>)) fields
      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> unsupported (<span class="fu">map</span> (<span class="fu">fmap</span> (<span class="fu">const</span> ())) fields)

      <span class="kw">where</span>
        arrField <span class="dt">Field</span>{} <span class="fu">=</span> <span class="kw">True</span>
        arrField _       <span class="fu">=</span> <span class="kw">False</span>

        objField <span class="dt">NamedField</span>{} <span class="fu">=</span> <span class="kw">True</span>
        objField _            <span class="fu">=</span> <span class="kw">False</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    contents <span class="ot">&lt;-</span> <span class="fu">readFile</span> (<span class="fu">head</span> args)
    <span class="kw">case</span> parseText <span class="fu">exp</span> contents <span class="kw">of</span>
      <span class="kw">Left</span> err <span class="ot">-&gt;</span> <span class="fu">print</span> err
      <span class="kw">Right</span> result <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> renderExpression <span class="fu">$</span> toJsExp result</code></pre>
<p>It uses <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>, a Lua parser and pretty-printer which I wrote to use in some other project of mine(a static analysis tool for Lua, I have big plans about it) and <a href="http://hackage.haskell.org/package/language-ecmascript">language-ecmascript</a>, JavaScript parser and pretty-printer.</p>]]></summary>
</entry>

</feed>
