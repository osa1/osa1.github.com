<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - All posts</title>
    <link href="http://osa1.net/rss.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/rss.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-12-30T00:00:00Z</updated>
    <entry>
    <title>Fun C compile time assertion trick</title>
    <link href="http://osa1.net/posts/2013-12-30-fun-c-compile-time-trick.html" />
    <id>http://osa1.net/posts/2013-12-30-fun-c-compile-time-trick.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s been long time since I wrote an interesting post but I still don’t have anything interesting and short enough for me to explain in a blog post. Anyway, here’s a fun C compile time assertion trick that I found in libSDL 2 codebase:</p>
<p>In C we have <code>typedef</code> which can be used for defining type synonyms. This code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> test;</code></pre>
<p>Defines <code>test</code> as type synonym for int, and then you can replace <code>int</code>s in variable declarations with <code>test</code>.</p>
<p>Interestingly, you can also use illegal type names for typedefs, like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> foo[<span class="dv">10</span>];</code></pre>
<p>This is funny, because you can’t use <code>foo[10]</code> as type of a variable, so I don’t understand why this syntax is allowed. I think the reason is that a <code>typedef</code> is just like declaration and shares same syntax with it, so this is allowed. Still, this declaration looks pretty useless to me.</p>
<p>Anyway, apparently there are some other interesting uses of <code>typedef</code>s. This code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> foo[-<span class="dv">1</span>];</code></pre>
<p>fails with:</p>
<pre><code>test.c:13:17: error: &#39;foo&#39; declared as an array with a negative size
typedef int foo[-1];
                ^~</code></pre>
<p>Furthermore, there are some expression-like C syntax that are actually evaluated at compile time<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. For example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> foo[<span class="dv">3-4</span>];</code></pre>
<p>Here <code>3-4</code> looks like an expression, but it’s actually evaluated at compile-time and thus this code fails with same error as above.</p>
<p>Using this two tricks, we can have some king of compile-time assertions, like libSDL people use:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define COMPILE_TIME_ASSERT(name, x) \</span>
  <span class="kw">typedef</span> <span class="dt">int</span> dummy_ ## name[(x) * <span class="dv">2</span> - <span class="dv">1</span>]

<span class="kw">typedef</span> <span class="dt">uint16_t</span> Uint16;

COMPILE_TIME_ASSERT(uint16, <span class="kw">sizeof</span>(Uint16) == <span class="dv">2</span>);</code></pre>
<p>This code checks in compile time if <code>Uint16</code> really represents 2 bytes in memory and it fails to compile if it doesn’t. Interesting part here is that <code>(x) * 2 - 1</code> expression evaluated at compile-time.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>These are called <em>constant expressions</em> and specified in C11 standard(<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">draft</a>) section 6.6.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Note that the <code>x</code> here will be already replaced with some other expression, passed with macro call.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Testing assembly programs using Haskell, QuickCheck (and FFI)</title>
    <link href="http://osa1.net/posts/2013-11-14-testing-asm-using-haskell.html" />
    <id>http://osa1.net/posts/2013-11-14-testing-asm-using-haskell.html</id>
    <published>2013-11-14T00:00:00Z</published>
    <updated>2013-11-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been studying 64bit calling conventions for x64 family recently. To do this, I was writing some function in assembly and then calling my functions from a C program to be sure that parameter passing and returning values are working correctly.</p>
<p>It generally works fine, and linking C program with assembly programs are easy enough. Today I got the idea of using Haskell + QuickCheck to test my assembly programs, this way I could also be more confident that not only parameter passing/return values work correctly, but my implementation of algorithm in assembly is also correct.</p>
<p>Linking assembly programs with a Haskell program is surprisingly easy. In the rest of this post, I’ll explain how to compile and link power function written in assembly to test program written in Haskell.</p>
<p>Here’s a power function that works on 64bit unsigned numbers, implemented using x64 ABI conventions:</p>
<pre class="assembly"><code>section .text
global power
power:
	mov rbx, rdi        ; move first parameter to rbx
	mov rcx, rsi        ; move second parameter to rcx

	cmp rcx, 0          ; return 1 if power is 0
	je end_power_one

	mov rax, rbx        ; move result to rax for multiplication

power_loop_start:
	cmp rcx, 1
	je end_power

	mul rbx
	dec rcx
	jmp power_loop_start

end_power_one:
	mov rax, 1

end_power:
	ret</code></pre>
<p>This is written using <a href="http://www.nasm.us/">Netwide Assembler</a>(best assembly syntax, IMO). Since we’re working on 64bit system, we need to compile it to <code>elf64</code> format:</p>
<pre><code>nasm -f elf64 power_lib.s -o power_lib.o</code></pre>
<p>Once we have our compiled file for power function, we need to declare it in Haskell as a foreign function, using correct types. A short tour in <code>Foreign.C.Types</code> library showed that <code>CULong</code> type is actually a newtype wrapper around <code>Word64</code>, which is 64bit unsigned number type:</p>
<pre><code>ghci&gt; :m + Foreign.C.Types 
ghci&gt; :info CULong
newtype CULong = CULong GHC.Word.Word64
        -- Defined in `Foreign.C.Types&#39;</code></pre>
<p>(not that this part should be different on 32bit systems – eg. on 32bit system you should see <code>CULong GHC.Word.Word32</code> instead of <code>Word64</code>)</p>
<p>We also need a <code>Arbitrary</code> instance for <code>CULong</code> type to be able to use QuickCheck on this type. Since <code>CULong</code> is just a newtype wrapper over <code>Word64</code>, and <code>Word64</code> already has instance defined in QuickCheck library, we can have that for free. In the end, our test code is:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Foreign.C.Types
<span class="kw">import</span> Test.QuickCheck

foreign <span class="kw">import</span> ccall &quot;power&quot;
<span class="ot">    power ::</span> <span class="dt">CULong</span> <span class="ot">-&gt;</span> <span class="dt">CULong</span> <span class="ot">-&gt;</span> <span class="dt">CULong</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">CULong</span> <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="fu">fmap</span> <span class="dt">CULong</span> arbitrary
    shrink (<span class="dt">CULong</span> i) <span class="fu">=</span> <span class="fu">map</span> <span class="dt">CULong</span> <span class="fu">$</span> shrink i

test_prop b p <span class="fu">=</span> power b p <span class="fu">==</span> b <span class="fu">^</span> p

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> quickCheck test_prop</code></pre>
<p>and that’s it. Very simple, 16 lines of code. To compile this, I also wrote a Makefile:</p>
<pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">power:</span><span class="dt"> power_test.hs power_lib.o</span>
	ghc --make <span class="ch">$^</span>

<span class="dv">power_lib.o:</span><span class="dt"> power_lib.s</span>
	nasm -f elf64 <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">clean:</span>
	<span class="ch">-</span><span class="fu">rm power_lib.o</span>
	<span class="ch">-</span><span class="fu">rm power_test power_test.hi power_test.o</span></code></pre>
<p>(this may be helpful to see how compilation work)</p>
<p>I think this is also a good demonstration of how easy it is to interact with foreign functions in Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Observability of bottom values</title>
    <link href="http://osa1.net/posts/2013-11-03-observability-of-nulls.html" />
    <id>http://osa1.net/posts/2013-11-03-observability-of-nulls.html</id>
    <published>2013-11-03T00:00:00Z</published>
    <updated>2013-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While ranting about how much I hate about null values in Java(and other langauges) on Haskell IRC channel, someone in the channel reminded me that we have <code>undefined</code> in Haskell, which is actually similar to null values in some sense.</p>
<p>The difference between Haskell’s <code>undefined</code> and null values in other languages is that Haskell’s <code>undefined</code> is <em>unobservable</em>. This means you can’t test for a value being <code>undefined</code> or not in Haskell, but you can test for null values in Java and other languages.</p>
<p>This means you can’t rely on some values being <code>undefined</code> or not. This makes it only useful for 1) unreachable code and 2) filling some parts in the code for now just to make it compile and later complete that parts(and I’m using <code>undefined</code> for this purpose very often).</p>
<p>This is what makes Haskell’s <code>undefined</code> a useful feature, while null values is clearly <em>Considered Harmful</em>™.</p>]]></summary>
</entry>
<entry>
    <title>Memoized parsing in continuation-passing style</title>
    <link href="http://osa1.net/posts/2013-10-21-memoized-parsing-cps.html" />
    <id>http://osa1.net/posts/2013-10-21-memoized-parsing-cps.html</id>
    <published>2013-10-21T00:00:00Z</published>
    <updated>2013-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Continuations are truly magical things. They’re the “ultimate abstractions of control flow”. Even without using any fancy language features like <code>call/cc</code>, you can have seriously cool and mind-boggling programs.</p>
<p>In <a href="http://arxiv.org/pdf/cmp-lg/9504016">“Memoization in Top-Down Parsing”</a> paper, Mark Johnson builds up from memoizing top-down parsers and describes a way to handle left recursion in top-down parsers by combining memoization techniques with continuations.</p>
<p>I ported the code to Lua to experiment, you can see it <a href="https://gist.github.com/osa1/7089333">here</a>. Most interesting part is the memoized CPS parser generator from a normal CPS parser function:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> memo<span class="ot">(</span><span class="kw">parser</span><span class="ot">)</span>
    <span class="co">-- WARNING: this function is badly implemented in the sense that</span>
    <span class="co">-- if you parser generated by this function on two different streams</span>
    <span class="co">-- it will generate wrong results</span>
    <span class="kw">local</span> <span class="kw">tbl</span> <span class="ot">=</span> <span class="ot">{}</span>
    <span class="kw">return</span> <span class="kw">function</span> <span class="ot">(</span><span class="kw">stream</span><span class="ot">,</span> <span class="kw">idx</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
        <span class="kw">if</span> <span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">]</span> <span class="ot">==</span> <span class="kw">nil</span> <span class="kw">then</span>
            <span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">]</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">results</span> <span class="ot">=</span> <span class="ot">{},</span> <span class="kw">conts</span> <span class="ot">=</span> <span class="ot">{}</span> <span class="ot">}</span>
            <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">conts</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
            parser<span class="ot">(</span><span class="kw">stream</span><span class="ot">,</span> <span class="kw">idx</span><span class="ot">,</span> <span class="kw">function</span> <span class="ot">(</span><span class="kw">parse_result</span><span class="ot">)</span>
                <span class="co">-- check if same parse_result is already in the table</span>
                <span class="kw">local</span> <span class="kw">exists</span> <span class="ot">=</span> <span class="kw">false</span>
                <span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">result</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">results</span><span class="ot">)</span> <span class="kw">do</span>
                    <span class="kw">if</span> <span class="kw">result</span> <span class="ot">==</span> <span class="kw">parse_result</span> <span class="kw">then</span> <span class="co">-- TODO: this equality is probably wrong</span>
                        <span class="kw">exists</span> <span class="ot">=</span> <span class="kw">true</span>
                        <span class="kw">break</span>
                    <span class="kw">end</span>
                <span class="kw">end</span>
 
                <span class="kw">if</span> <span class="kw">not</span> <span class="kw">exists</span> <span class="kw">then</span>
                    <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">results</span><span class="ot">,</span> <span class="kw">parse_result</span><span class="ot">)</span>
                    <span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">cont</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">conts</span><span class="ot">)</span> <span class="kw">do</span>
                        cont<span class="ot">(</span><span class="kw">parse_result</span><span class="ot">)</span>
                    <span class="kw">end</span>
                <span class="kw">end</span>
            <span class="kw">end</span><span class="ot">)</span>
        <span class="kw">else</span>
            <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">conts</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
            <span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">result</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">results</span><span class="ot">)</span> <span class="kw">do</span>
                cont<span class="ot">(</span><span class="kw">result</span><span class="ot">)</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
        <span class="kw">return</span> <span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">]</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>(btw, I found porting this code to a purely functional setting very hard thing to do. If you find a way to do this, please send me your code. Thanks.)</p>
<p>This piece of code didn’t make sense to me for a while. I think the key to understand this function is to find answer to this question:</p>
<p>How is this different from keeping a set of productions visited without consuming any input from input stream and when you come to the same production, just failing instead of trying to parse? Because trying to derive same production without consuming any input means you’ll end up with infinite loop.</p>
<p>This function different in that it accounts for parsing same production after following a different path of production. Think this CFG as an example:</p>
<pre><code>T ::= T + T
    | int</code></pre>
<p>In order to derive first production, it first needs to parse a <code>T</code>. But then it will be already noted that it was already trying to parse <code>T</code>, and add the continuation to the list of continuations to be called when a T at input position 1 is parsed.</p>
<p>While trying alternatives, it will parse an <code>int</code>, and derive <code>T -&gt; int</code> at input position 1. And since it had saved the continuations to call when it successfully parse a <code>T</code> at location 1, it will call this continuations and thus parsing will continue.</p>
<p>I hope this helps other people to understand the trick.</p>]]></summary>
</entry>
<entry>
    <title>Half-baked idea: Abstract interpretation for code completion</title>
    <link href="http://osa1.net/posts/2013-10-16-abstract-interpretation-completion.html" />
    <id>http://osa1.net/posts/2013-10-16-abstract-interpretation-completion.html</id>
    <published>2013-10-16T00:00:00Z</published>
    <updated>2013-10-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had this idea about implementing code completion on dynamic languages. Statically inferring information in dynamic languages is hard and never accurate enough. In my opinion, we should take a step towards dynamically checking the code by having some kind of abstract interpretation of the language that allows us infer required information and then running programs in this interpretation.</p>
<p>I didn’t figure out the details yet. I just wanted to write here as a TODO.</p>]]></summary>
</entry>
<entry>
    <title>Destansı tesadüf</title>
    <link href="http://osa1.net/posts/2013-10-10-destansi-tesaduf.html" />
    <id>http://osa1.net/posts/2013-10-10-destansi-tesaduf.html</id>
    <published>2013-10-10T00:00:00Z</published>
    <updated>2013-10-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün, şu sıralar bir araştırma labında çalıştığım okulumda<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> bir startup etkinliği vardı, 10 civarında startup gelip stand açtılar, tshirt dağıtıp CV topladılar ve tanıtım yaptılar. Buralarda sık sık olan bir olay.</p>
<p>Normalde rastgele yazılım mühendisliği işleri ile ilgilenmediğimden benim pek ilgimi çekemiyor bu gibi şeyler, yine de bir gözatıyorum, çünkü geçen sefer <a href="http://www.spacex.com/">SpaceX</a>’i kaçırmıştım ve hala kendimi affedemedim :p . Her neyse, gezinirken bir şirket gözüme çarptı, salonda önünde tek bir öğrenci bile olmayan tek stand bunlarındı ve açıklamalarına bir göz gezdirdiğimde şöyle anahtar kelimeler gözüme çarptı: “runtime verification”, “correctness”, “LLVM”, “NASA” …</p>
<p>Birkaç saat sonra okuldan çıkarken bir yandan kendi kendime düşünüyorum “havalı olmayan şeye merak sararak 1-0 yenik başlamışız abi zaten” diye haueh. Bu ekibin önünden geçerken yine kimsenin olmaması artık beni rahatsız etmiş olacak herhalde ki bir anda durup adama selam verdim, ne iş yapıyorsunuz dedim. Adam bana benim üzerinde çalıştığım şeyleri anlatmaya başladı :) . Lafını kesip benim zaten bu işleri yaptığımı ve şu labda çalıştığımı falan söyleyince, adam demesin mi “bu senin hocanın startup’ı” diye …</p>
<p>Hocamın startupının olduğunu ve benim geliştirdiğim araç ile çalıştıklarını bu şekilde öğrenmiş oldum.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://fsl.cs.illinois.edu/index.php/Main_Page">University of Illinois at Urbana-Champaign, Formal Systems Lab</a><a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Parametric polymorphism and unboxed representations</title>
    <link href="http://osa1.net/posts/2013-10-09-parametric-polymorphism-and-unboxed-repr.html" />
    <id>http://osa1.net/posts/2013-10-09-parametric-polymorphism-and-unboxed-repr.html</id>
    <published>2013-10-09T00:00:00Z</published>
    <updated>2013-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post was written 5 months ago – I just found it in my Github Gist archive and realized it’s not published. I’m publishing it now.</p>
<hr />
<p>It’s just occurred to me that we can’t have parametric polymorphism for unboxed values, unless that unboxed values share same layout in memory, or you duplicate polymorphic definition for each instance. This may be obvious for most of you but I just realized this while working on a Java project and found it interesting.</p>
<p>I think this is also the reason why we can’t instantiate generics in Java with primitive types.</p>
<p>Here’s an explanation:</p>
<p>Let’s think this C++ code:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> test2
{
  <span class="dt">int</span> a, b;
  test2(<span class="dt">int</span> a, <span class="dt">int</span> b) : a(a), b(b) {}
};

<span class="kw">struct</span> test3
{
  <span class="dt">int</span> a, b, c;
  test3(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c) : a(a), b(b), c(c) {}
};

<span class="dt">void</span> f2() {}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T f3(T t)
{
  t.a = <span class="dv">20</span>;
  <span class="kw">return</span> t;
}

<span class="dt">int</span> main()
{
  test2 t2(<span class="dv">1</span>, <span class="dv">2</span>);
  test3 t3(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  f3&lt;test2&gt;(t2);
  f3&lt;test3&gt;(t3);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>The key thing to realize here is that I’m passing parameter by value, ie. values are copied to function stack frame. But this function is still polymorphic on parameter type. This is possible in C++ because for each distinct instance of <code>f3</code>, a specialized code will be generated. To observe this, I put a breakpoint to that <code>f3</code> function and looked to disassembly output.</p>
<pre><code>        18	T f3(T t)
0x400af6  &lt;+0x0000&gt;         push   rbp
0x400af7  &lt;+0x0001&gt;         mov    rbp,rsp
0x400afa  &lt;+0x0004&gt;         mov    QWORD PTR [rbp-0x10],rdi
        19	{
        20	  t.a = 20;
0x400afe  &lt;+0x0008&gt;         mov    DWORD PTR [rbp-0x10],0x14
        21	  return t;
0x400b05  &lt;+0x000f&gt;         mov    rax,QWORD PTR [rbp-0x10]
        22	}
0x400b09  &lt;+0x0013&gt;         pop    rbp
0x400b0a  &lt;+0x0014&gt;         ret</code></pre>
<p>And this is for second call:</p>
<pre><code>        18	T f3(T t)
0x400b0b  &lt;+0x0000&gt;         push   rbp
0x400b0c  &lt;+0x0001&gt;         mov    rbp,rsp
0x400b0f  &lt;+0x0004&gt;         mov    rdx,rdi
0x400b12  &lt;+0x0007&gt;         mov    eax,esi
0x400b14  &lt;+0x0009&gt;         mov    QWORD PTR [rbp-0x20],rdx
0x400b18  &lt;+0x000d&gt;         mov    DWORD PTR [rbp-0x18],eax
        19	{
        20	  t.a = 20;
0x400b1b  &lt;+0x0010&gt;         mov    DWORD PTR [rbp-0x20],0x14
        21	  return t;
0x400b22  &lt;+0x0017&gt;         mov    rax,QWORD PTR [rbp-0x20]
0x400b26  &lt;+0x001b&gt;         mov    QWORD PTR [rbp-0x10],rax
0x400b2a  &lt;+0x001f&gt;         mov    eax,DWORD PTR [rbp-0x18]
0x400b2d  &lt;+0x0022&gt;         mov    DWORD PTR [rbp-0x8],eax
0x400b30  &lt;+0x0025&gt;         mov    rax,QWORD PTR [rbp-0x10]
0x400b34  &lt;+0x0029&gt;         mov    edx,DWORD PTR [rbp-0x8]
        22	}
0x400b37  &lt;+0x002c&gt;         pop    rbp
0x400b38  &lt;+0x002d&gt;         ret</code></pre>
<p>So what happened here is two new functions is generated from the definition, one with type <code>test2 f3(test2)</code> and one with type <code>test3 f3(test3)</code>. This gives a great opportunity, for instance, we can have this function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T someFun(T arg1, T arg2)
{
  <span class="kw">return</span> arg1 + arg2;
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">const</span> <span class="dt">char</span> *argv[])
{
  std::cout &lt;&lt; someFun&lt;<span class="dt">int</span>&gt;(<span class="dv">1</span>, <span class="dv">2</span>) &lt;&lt; std::endl;
  std::cout &lt;&lt; someFun&lt;<span class="dt">float</span>&gt;(<span class="fl">1.4</span>, <span class="dv">2</span>) &lt;&lt; std::endl;

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>..which is impossible to have in Java, without manually overloading the method definition.</p>
<p>(An off-topic but interesting note: I was expecting <code>SP</code> to be set here, but here it’s not set. I think the reason is that the compiler is clever enough to see there is no recursive calls, so no need to set <code>SP</code>, when I added a dummy function call in the middle of <code>f3</code>, <code>SP</code> is got set)</p>
<p>So in a way, C++ generics are gives us the most general way for parametric polymorphism. For any type you instantiated the template with, it generates a specialized definition. And if that definition is accepted by type checker, you’re fine.</p>
<p>This also why we don’t need a template definition like <code>template &lt;class C : HasY&gt;</code>. Because that <code>HasY</code> information is completely redundant. If specialized code is well-typed, than it’s OK.</p>
<p>This is also one of the reasons why compiling C++ programs takes that long.</p>]]></summary>
</entry>
<entry>
    <title>On proof automations -- part 3</title>
    <link href="http://osa1.net/posts/2013-09-23-proof-automation-3.html" />
    <id>http://osa1.net/posts/2013-09-23-proof-automation-3.html</id>
    <published>2013-09-23T00:00:00Z</published>
    <updated>2013-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Over the past several days I learned few things that changed my ideas about proof automation. See my first two posts about proof automation here: <a href="/posts/2013-09-11-proof-automation.html">#1</a> <a href="/posts/2013-09-17-proof-automation-2.html">#2</a></p>
<p>First, it’s really possible to use proof automation without first writing the whole proof. After started working on theorems defined on more complex languages, I realized one thing: Most of the cases of inductions/inversions are trivial to solve. Generally you only interested in one or two cases, while you have in total 20 cases. Why not use automation to eliminate 18 cases automatically? Proving that parts manually only makes it more obscure.</p>
<p>Second thing I learned is that automations like <code>auto</code>, <code>eauto</code>, <code>iauto</code> never perform <code>rewrite</code>, <code>subst</code>, case analysis(<code>inversion</code>, <code>destruct</code>, maybe others?) and induction. I think this is very important point, because this means that your proofs still have to resemble the structure of your non-automated proofs(i.e. structure of your terms). Which prevents your proofs from being too much magical.</p>
<p>Now let’s work on an example to see how some automation is good thing. I’ll prove progress property of STLC(simply-typed lambda calculus), as defined in <a href="www.cis.upenn.edu/~bcpierce/sf/">Software Foundations</a> chapter <a href="http://www.cis.upenn.edu/~bcpierce/sf/Stlc.html">Stlc</a>.</p>
<p>Here’s an initial version without using any kind of automation.</p>
<pre class="coq"><code>Theorem progress_no_auto : forall t T,
     empty |- t \in T -&gt;
     value t \/ exists t&#39;, t ==&gt; t&#39;.
Proof.
  intros t T TD. remember (@empty ty).
  (* induction on typing derivation *)
  has_type_cases (induction TD) Case.
  Case &quot;T_Var&quot;.
    (* this case is impossible because vars are not well-typed in empty env,
       find a contradiction *)
    rewrite Heqp in H. inversion H.
  Case &quot;T_Abs&quot;.
    (* lambdas are values *)
    left. apply v_abs.
  Case &quot;T_App&quot;.
    (* well-typed applications should take a step *)
    right. destruct IHTD1. assumption.
    SCase &quot;t1 is a value&quot;. destruct IHTD2. assumption.
      SSCase &quot;t2 is a value&quot;.
        (* t1 should be a lambda *)
        inversion TD1; subst; inversion H. (* inversion on typing derivation of t1,
                                              most cases can be eliminated with inversion H,
                                              because t1 can only be lambda expression to be well-typed *)
        SSSCase &quot;t1 is tabs&quot;. eexists. apply ST_AppAbs. assumption.
      SSCase &quot;t2 can take a step&quot;.
        inversion H0. eexists. apply ST_App2. assumption. apply H1.
    SCase &quot;t1 can take a step&quot;. inversion H. eexists. apply ST_App1. apply H0.
  Case &quot;T_True&quot;. left. constructor.
  Case &quot;T_False&quot;. left. constructor.
  Case &quot;T_If&quot;.
    (* well-typed T_If can always take a step *)
    destruct IHTD1. assumption.
    SCase &quot;t1 is value&quot;. inversion H; subst.
      SSCase &quot;t1 is a lambda&quot;. inversion TD1.
      SSCase &quot;t1 is ttrue&quot;. right. exists t2. constructor.
      SSCase &quot;t1 is tfalse&quot;. right. exists t3. constructor.
    SCase &quot;t1 can take a step&quot;. inversion H; subst. right.
      exists (tif x0 t2 t3). constructor. assumption.
Qed.</code></pre>
<p>I leave comments to explain what’s going on. The point here is not to get shortest proof, but to show with some automation proofs could be more readable.</p>
<p>When you look to this proof you can realize that our interesting cases are:</p>
<ul>
<li><code>T_Var</code> case, in which we need to show that it’s impossible.</li>
<li><code>T_App</code> and <code>T_If</code> cases, in which we need to use induction hypothesis.</li>
</ul>
<p><code>T_Abs</code>, <code>T_True</code> and <code>T_False</code> cases are completely trivial and we don’t want to make our proof harder to write, read and maintain more.</p>
<p>Second thing to realize that, if you count <code>;</code> operator as a automation, then it makes me using automation even in that proof. In the case of <code>T_App</code>, I’m eliminating all cases of <code>t1</code>(because for <code>T_App</code> to be well-typed, <code>t1</code> can only be a lambda abstraction – other cases should be eliminated with contradictions) with <code>inversion H; subst.</code>. Without <code>;</code> operator, I would have to write this:</p>
<pre class="coq"><code>inversion TD1; subst.
SSSCase &quot;t1 is tvar&quot;. inversion H.
SSSCase &quot;t1 is tabs&quot;. eexists. apply ST_AppAbs. assumption.
SSSCase &quot;t1 is tapp&quot;. inversion H.
SSSCase &quot;t1 is tif&quot;. inversion H.</code></pre>
<p>and when the language gets bigger, more cases with just <code>inversion H</code> would follow.</p>
<p>Now here’s an automated version:</p>
<pre class="coq"><code>Theorem progress : forall t T,
     empty |- t \in T -&gt;
     value t \/ exists t&#39;, t ==&gt; t&#39;.
Proof with eauto.
  intros t T TD. remember (@empty ty). has_type_cases (induction TD) Case; auto.
  Case &quot;T_Var&quot;. rewrite Heqp in H. inversion H.
  Case &quot;T_App&quot;. right. destruct IHTD1...
    SCase &quot;t1 is a value&quot;. destruct IHTD2...
      SSCase &quot;t2 is a value&quot;. inversion TD1; subst; try (solve by inversion)...
      SSCase &quot;t2 can take a step&quot;. inversion H0; subst...
    SCase &quot;t1 can take a step&quot;. inversion H; subst...
  Case &quot;T_If&quot;. right. destruct IHTD1. assumption.
    SCase &quot;t1 is a value&quot;. inversion H; subst; eauto.
      SSCase &quot;t1 is tabs&quot;. solve by inversion.
    SCase &quot;t1 can take a step&quot;. inversion H...
Qed.</code></pre>
<p>IMO this proof is a lot more simple and readable. It eliminates all trivial cases and only leave us with interesting ones. And even in that cases we simply finished with <code>...</code> or explicitly running <code>auto</code>/<code>eauto</code>.</p>]]></summary>
</entry>
<entry>
    <title>TIL - Haskell 98 doesn't have principal typing property</title>
    <link href="http://osa1.net/posts/2013-09-20-til-haskell-principal-typing.html" />
    <id>http://osa1.net/posts/2013-09-20-til-haskell-principal-typing.html</id>
    <published>2013-09-20T00:00:00Z</published>
    <updated>2013-09-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After hearing the term “polymorphic recursion” at <a href="http://fsl.cs.illinois.edu/index.php/Main_Page">FSL</a> meeting today, I just searched for it in Wikipedia(I never heard that term before). It’s explained with a Haskell code, with a note saying that:</p>
<blockquote>
<p>In Haskell, unlike for most other functions definitions, the type signature cannot be omitted.</p>
</blockquote>
<p>.. and that code is Haskell 98 compliant. For a long time I thought Haskell 98 has principal typing property – but apparently I was wrong. I wrote that in Haskell IRC channel and there were other people who were thinking same.</p>
<p>People at IRC channel also said that SML bans polymorphic recursion and have principal typing. Nice to know.</p>]]></summary>
</entry>
<entry>
    <title>Quick rant: K Framework is broken</title>
    <link href="http://osa1.net/posts/2013-09-19-k-framework-broken.html" />
    <id>http://osa1.net/posts/2013-09-19-k-framework-broken.html</id>
    <published>2013-09-19T00:00:00Z</published>
    <updated>2013-09-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="quick-rant-k-framework-is-broken">Quick Rant: K Framework is broken</h2>
<p>In this short rant I’ll demonstrate how K Framework is broken and how you can avoid the problem. If you don’t know what is K Framework or don’t use it, you probably want to ignore this post.</p>
<p>Let’s think this completely useless K module:</p>
<pre><code>module TEST

  syntax Exp ::= &quot;nilExp&quot;
               | return(Exp) [strict]

  syntax Val ::= &quot;nil&quot;

  syntax KResult ::=  Val

  rule nilExp =&gt; nil ... [nil]

endmodule</code></pre>
<p>and this TEST program:</p>
<pre><code>return(nilExp)</code></pre>
<p>what do you think this program has in K cell when it gets stuck? It’s not really hard to guess. Since we annotate <code>return(Exp)</code> syntax with <code>strict</code>, it’s argument gets evaluated according to our <code>nil</code> rule and then it gets stuck. At this point K cell will be:</p>
<pre><code>&lt;k&gt;
    return ( nil )
&lt;/k&gt;</code></pre>
<p>which may not be very surprising for you, but there’s something wrong going on here. In our syntax declaration we defined argument or <code>return</code> to be an <code>Exp</code>, but in the term in our K cell it’s <code>Val</code>.</p>
<p>At this point you can say that this is how heating/cooling works an there’s nothing wrong here but then we have another problem: there’s no way for the user to write rules that does exactly what heating/cooling rules do. In our example above you’d expect from strictness annotation to generate rules like this:</p>
<pre><code>rule return(E:Exp) =&gt; E ~&gt; return(HOLE)
rule V:Val ~&gt; return(HOLE) =&gt; return(V)</code></pre>
<p>but this is not a valid rule and it fails with the this error message:</p>
<pre><code>[Error] Critical: type error: unexpected term &#39;V:Val &#39; of sort &#39;Val&#39;, expected sort &#39;Exp&#39;.
        File: /home/omer/K/lua-semantics/test/test.k
        Location: (11,35,11,36)</code></pre>
<p>and what’s more confusing is that even though K generated rule somehow generates the term <code>return(Val)</code>, you cannot match it in your rules because this term is actually ill-typed:</p>
<pre><code>rule return(V:Val) =&gt; .
...
[Error] Critical: type error: unexpected term &#39;V:Val &#39; of sort &#39;Val&#39;, expected sort &#39;Exp&#39;.
        File: /home/omer/K/lua-semantics/test/test.k
        Location: (11,10,11,15)</code></pre>
<p>which means there’s no way for you to work on this term. This time you’re stuck :-p</p>
<p>We discussed this on k-user mailing list a bit but there isn’t really a solution – we only have a workaround. Here’s the reason of this problem(quoted from mailing list <a href="http://lists.cs.uiuc.edu/pipermail/k-user/2013-September/000475.html">discussion</a>):</p>
<blockquote>
<p>Your grammar is only enforced during parsing.</p>
<p>After the definition is compiled, return is just a label that may be applied to a list of children.</p>
<p>In particular, the automatically generated cooling rule only puts a side condition that enforces IsKResult, which nil passes.</p>
</blockquote>
<p>Wow, this sounds like really broken to me. Anyway, only solution I could find to this is to add <code>Val</code> syntactic category to a member of <code>Exp</code> syntactic category. This is an obvious solution, but very bad one also. Because by having distinguished <code>Val</code> and <code>Exp</code> syntactic categories what I’m trying to do is to force my program to get stuck as soon as possible when something went wrong, instead of continuing evaluation and get stuck at a point where very very far from where the error actually occured.</p>
<p>Rest of this post is also sent to k-list mailing list and contains my ideas on implementing strictness annotations. These ideas may be wrong – I’m only a beginner K user.</p>
<hr />
<p>This is how I’d design strictness annotations(but I’m probably wrong since I’m just a beginner in K).</p>
<p>Let’s say I have this syntax:</p>
<pre><code>syntax Exp ::= P(Exp, Exp, Exp) [strict]</code></pre>
<p>for intermediate steps while fully evaluating this expression, I’d design the K framework so that these syntax and rules would be automatically generated:</p>
<pre><code>syntax K ::= P__rw_1(Val, Exp, Exp) [strict]
           | P__rw_2(Exp, Val, Exp) [strict]
           | P__rw_3(Exp, Exp, Val) [strict]

rule P(E1, E2, E3) =&gt; E1 ~&gt; P__rw_1(HOLE, E2, E3)
rule P(E1, E2, E3) =&gt; E2 ~&gt; P__rw_1(E1, HOLE, E3)
rule P(E1, E2, E3) =&gt; E3 ~&gt; P__rw_1(E1, E2, HOLE)

rule V:Val ~&gt; P__rw_1(HOLE, E2, E3) =&gt; P__rw_1(V, E2, E3)
rule V:Val ~&gt; P__rw_2(E1, HOLE, E3) =&gt; P__rw_2(E1, V, E3)
rule V:Val ~&gt; P__rw_3(E1, E2, HOLE) =&gt; P__rw_3(E1, E2, V)</code></pre>
<p>and then same rule generation scheme applies to <code>P__rw_1</code>, <code>P__rw_2</code>, <code>P__rw_3</code> too. In the end we’ll end up with:</p>
<pre><code>syntax K ::= P__rw(Val, Val, Val)</code></pre>
<p>and this would give the user full control of evaluation with strongly typed manner. (ie. without fighting with K framework parser)</p>
<p>(<code>strict[n]</code>, <code>seqstrict</code> etc. rules are specialized cases of this general strictness rule generation scheme)</p>]]></summary>
</entry>

</feed>
