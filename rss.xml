<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - All posts</title>
    <link href="http://osa1.net/rss.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/rss.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-01-17T00:00:00Z</updated>
    <entry>
    <title>Güncelleme</title>
    <link href="http://osa1.net/posts/2014-01-17-guncelleme.html" />
    <id>http://osa1.net/posts/2014-01-17-guncelleme.html</id>
    <published>2014-01-17T00:00:00Z</published>
    <updated>2014-01-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Biraz hayatımda neler olup bittiğinden bahsedeceğim, son birkaç ayda önemli olduğunu düşündüğüm birkaç şey oldu. Uzun süredir de Türkçe blog yazmamıştım, arayı açmayalım :P</p>
<p>Maddeler halinde, hayatımın son 5-6 aylık dönemi: (sıralama rastgele)</p>
<ul>
<li>An itibari ile okulumda geçirdiğim son dönemdeyim. Benle aynı girişli herhangi bir öğrencinin mezun olması gereken dönemde yani, gecikme falan olmayacak inşallah.</li>
<li>Bu dönem iki ders alıyorum, birisi bitirme projesi dersi, birisi de matematik bölümünden cebir dersi. Sonunda “öğrenmenin yaşı yok, zararın neresinden dönersen …” mantığı ile korkumu yendim ve matematikten bir ders aldım, ve çok memnunum. Dersi anlamakta ve problemleri çözmekte hiçbir sıkıntı yaşamıyorum(ders MAT 3xx kodlu olunca insan bir an tereddüt ediyor, yapabilir miyim diye). Sınıf zaten çok az kişi, hoca da bilgisayar meselelerine ilgili ve öğrencilerle ilgileniyor. Çok süper şeyler yapabiliriz bu ders kapsamında diye düşünüyorum, ama aklımda çok net fikirler yok. Temel cebir kounlarını anladıktan sonra kategorilere geçiş yapmayı hedefliyorum. Bundan sonra eğer akademik ortamda vakit geçirecek olursam kesinlikle matematiğe daha fazla zaman ayırmalıyım. Eğer ders alma imkanım olursa kesinlikle matematik dersleri alacağımdır diye düşünmekteyim.</li>
<li>Bitirme projesini daha önce 14 hafta Özyeğin Üniversitesi’nde beraber çalıştığımız hocam Barış Aktemur danışmanlığında yapıyorum(kendisinin başka okulda olması sorun olmadı). Detaylarından şimdilik bahsedemeyeceğim ama <a href="https://gist.github.com/osa1/f34ec1101e65b490e3b6">şurada</a> bir özet var. Özetin özeti: Programlama dili teorisi ile alaklı işler.</li>
<li>Adımı Rust 0.9 katkıcıları listesine yazdırmaktan gurur duyuyorum: <a href="https://mail.mozilla.org/pipermail/rust-dev/2014-January/007753.html">duyuru maili</a>. Gerçi adımı değil nickimi yazmışlar, neden bilmiyorum. Adımı tercih ederdim.</li>
<li>Derleyici implementasyonuna meraklı arkadaşlar Rust’ı kaçırmasınlar. Yeni bir proje olduğu için çok fazla “low-hanging fruit” var, kolayca katkı yapabilirsiniz ve çok şey öğrenirsiniz. Camia çok aktif ve yardımsever.</li>
<li>Haftaya Pazartesi(20 Ocak) günü saat 15:30’da Amfi 2’de programlama dilleri dersini ben anlatacağım. İstediğimi anlatmakta özgürüm ve çok faydalı olacağına inandığım bir konuşma hazırlamaktayım. TOBB ETÜ’de olan varsa beklerim. Dersten sonra sunumu buraya koyacağım.</li>
<li>1 Eylül - 25 Aralık tarihleri arasında University of Illinois at Urbana-Champaign’de, Formal Systems Lab’da staj yaptım. Labımızda geliştirilen K Framework’e hatırı sayılır katkılar yaptığımı düşünüyorum. Çok zor günler de geçirmekle beraber, hayatımın bazı en güzel ve ilginç günlerini geçirdiğimi söyleyebilirim. Yine ABD’deyken 3 yere doktora başvurusunda bulundum. Not ortalamam rezalet(2.71) olduğundan UIUC gibi “iyi”(ne anlama geliyor bilmiyorum) yerelere başvuramıyorum ama yine de çok güçlü programlama dili ekipleri olan yerlere başvurdum: Indiana University, University of Pennsylvania ve Portland State University. IU ekibi ile bir etkinlikte yüz yüze görüştük ve hocalar çok ilgilendiler. Bir tanesi ile sonradan mail üzerinden görüştük ve CVmden ve niyet mektubumdan çok etkilenmiş gözüktü. Tavsiye mektuplarımın da süper olduğunu varsayarsak kabul şansım not ortalamama rağmen epey yüksek diye düşünüyorum. Hayırlısı artık :-)</li>
<li>ABD’deyken iş görüşmelerini yaptığımız <a href="http://www.soostone.com/">Soostone</a>’da Ocak başında işe başladım. Şimdilik yarı zamanlı çalışıyorum. Soostone olarak bir miktar front-end JavaScript kısımları hariç tüm işlerimizi Haskell ile yapıyoruz. JS kısımları da gelecekte Fay veya GHCJS yardımıyla Haskell’a geçirilecek(bilmeyenler için, ben Fay’in 3 ana geliştiricisinden biriyim). Hobi olarak başlayan Haskell serüvenim süper gitti diyebiliriz. Hatta diyebilirim ki zamanında Haskell’a ciddi vakit ayırmak hayatımda yaptığım en mantıklı hareketlerden biri oldu, fakat bu konu çok uzar, o yüzden şimdilik burada keseyim.</li>
</ul>
<p>Şimdilik aklıma gelenler bunlar. Aslında düşündüm de, böyle madde madde özetler geçmek güzel oluyormuş, belki gelecekte devam ettirmeliyim.</p>
<p>Bu arada not: Okulumda son sınıfta olup bitirme projemle ilgilenen varsa ekibime beklerim(gerçi şimdi düşündüm de, bu blogu okuyan birileri var mı ondan bile emin değilim :-). Şu anda tek kişiyim, konuyu biliyor olmanıza gerek yok, ilgilenmeniz yeterli.</p>]]></summary>
</entry>
<entry>
    <title>Combining digestive-functors and heist with Snap (continued from last tutorial)</title>
    <link href="http://osa1.net/posts/2014-01-04-combining-df-heist-snap-cont.html" />
    <id>http://osa1.net/posts/2014-01-04-combining-df-heist-snap-cont.html</id>
    <published>2014-01-04T00:00:00Z</published>
    <updated>2014-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s an high-level overview of last post:</p>
<ul>
<li>We used digestive-functors for handling form validation and digestive-functors-heist for rendering Heist templates with digestive-funtors forms.</li>
<li>A digestive-functor form has type <code>Form v m a</code> where <code>v</code> is type of error messages, <code>m</code> is the monad type that are used in validation functions, <code>a</code> is return type of a valid form. In our example, <code>a</code> was <code>User</code> since our form was to create a <code>User</code> object. In order to render HTML from a <code>Form</code>, we had to generate a <code>View v</code> object, using <code>getForm</code> or <code>postForm</code> functions from digestive-functors package(<code>Text.Digestive.View</code> module). Once we had a our <code>View</code>, we can use <code>digestiveSplices</code> function from digestive-functors-heist package to get Heist splices of our form. (note: for some type mismatch problem, we had to use <code>bindDigestiveSplices</code> to bind our splices to a Heist state directly, instead of getting splices using <code>digestiveSplices</code> and then binding using some Heist functions) The rest is related with Hesit template rendering.</li>
<li>In Heist site, we had to create a HeistState object which keeps track of compiled and interpreted splices, template paths and some other things.</li>
<li>We then rendered our forms using <code>renderTemplate</code>, binding our form splices to HeistState using <code>bindDigestiveSplices</code>.</li>
</ul>
<p>In this post, I’m going to add some functionalities from Snap to serve HTML pages from a server and handle routing and POST request processing. Our forms will be served at root and when we submit our form, we will be informed whether user creating was successful or what was the problem.</p>
<p>Recommended way fo starting a Snap applcation is by using <code>snap init</code> command. It creates a cabal project structure with <code>Application.hs</code>, <code>Site.hs</code> and <code>Main.hs</code>. According to Snap docs, we only rarely need to touch <code>Main.hs</code>. The other two files are used to create a new Snaplet, and only function we need to provide to <code>Main</code> module is <code>app :: SnapletInit App App</code> for some <code>App</code> type.</p>
<p>In this post I’m assuming you created a Snap project using <code>snap init</code> command and have <code>Main.hs</code> file. You don’t need <code>Application.hs</code> file and in this post we’ll be writing <code>Site.hs</code> file.</p>
<p>Required for some Snap features</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell     #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Tut2</span> (app) <span class="kw">where</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Applicative        (Applicative (..), (&lt;$&gt;))
<span class="ot">&gt;</span> <span class="kw">import</span>           Data.Maybe                 (isJust)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Text                  <span class="kw">as</span> T</code></pre>
<p>from `digestive-functors’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive</code></pre>
<p>from `digestive-functors-heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Heist       (bindDigestiveSplices)</code></pre>
<p>from <code>lens</code> package, required for Snaplets</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Lens</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Snap.Snaplet
<span class="ot">&gt;</span> <span class="kw">import</span>           Snap.Snaplet.Heist</code></pre>
<p>from <code>bytestring</code> package, required for some Snap functions</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString            <span class="kw">as</span> B</code></pre>
<p>from <code>digestive-functors-snap</code> package, required for form rendering, we had handled that using <code>getForm</code> and <code>postForm</code> from <code>Text.Digestive.Heist</code> before.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Snap        (runForm)</code></pre>
<p><code>snap init</code> creates a project with only this code in <code>Application.hs</code>:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span>
<span class="ot">&gt;</span>     { _<span class="ot">heist ::</span> <span class="dt">Snaplet</span> (<span class="dt">Heist</span> <span class="dt">App</span>)
<span class="ot">&gt;</span>     }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> makeLenses <span class="ch">&#39;&#39;</span><span class="dt">App</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">HasHeist</span> <span class="dt">App</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     heistLens <span class="fu">=</span> subSnaplet heist</code></pre>
<p>In this post I’m copying this code to <code>Site.hs</code> and removing <code>Application.hs</code> file. Here, I only changed the definition of <code>App</code>. Since our application is minimal, we only need Heist Snaplet nested in our App. When we need other functionalities in the future(like database access), we will extend this definition for new Snaplets.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; app ::</span> <span class="dt">SnapletInit</span> <span class="dt">App</span> <span class="dt">App</span></code></pre>
<p>First type parameter of SnapletInit is for type of parent Snaplet. In our case, we don’t have a parent Snaplet but I guess this is what you do in that case. Second type is currently initialized Snaplet’s type.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> app <span class="fu">=</span> makeSnaplet <span class="st">&quot;app&quot;</span> <span class="st">&quot;An snaplet example application&quot;</span> <span class="kw">Nothing</span> <span class="fu">$</span> <span class="kw">do</span></code></pre>
<p>Type of <code>makeSnaplet</code> is really helpful to understand what’s going on at the level of types:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">makeSnaplet
<span class="ot">  ::</span> <span class="dt">T.Text</span>                  <span class="co">-- ^ Default ID of the Snaplet, I have no idea where is this used.</span>
     <span class="ot">-&gt;</span> <span class="dt">T.Text</span>               <span class="co">-- ^ Description of the Snaplet, again, no idea where is this used.</span>
     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">IO</span> <span class="fu">FilePath</span>)  <span class="co">-- ^ Root folder for Snaplet&#39;s filesystem content. In case your Snaplet works on files.</span>
     <span class="ot">-&gt;</span> <span class="dt">Initializer</span> b v v    <span class="co">-- ^ Initializer for the Snaplet.</span>
     <span class="ot">-&gt;</span> <span class="dt">SnapletInit</span> b v      <span class="co">-- ^ SnapletInit is an opaque type for internal use. It&#39;s needed for embedding our snaplet to other snaplets.</span></code></pre>
<p>We’re nesting Heist snaplet provided by <code>Snap.Snaplet.Heist</code> from <code>snap</code> package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    h <span class="ot">&lt;-</span> nestSnaplet <span class="st">&quot;&quot;</span> heist <span class="fu">$</span> heistInit <span class="st">&quot;templates&quot;</span></code></pre>
<p>self explanatory, see definition below</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    addRoutes routes
<span class="ot">&gt;</span>    <span class="fu">return</span> <span class="fu">$</span> <span class="dt">App</span> h
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;    routes ::</span> [(<span class="dt">B.ByteString</span>, <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ())]</code></pre>
<p>routes are how we handle requests. <code>Handler</code> type takes 3 arguments, but I’m yet to figure out what do these arguments mean. I guess these are same as arguments in <code>SnapletInit</code> type, except the last one is for return values of Handler functions.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    routes <span class="fu">=</span> [ (<span class="st">&quot;/&quot;</span>, mainHandler) ]</code></pre>
<p><code>mainHandler</code> is our handler function. Thanks to <code>runForm</code> function provided by <code>Text.Digestive.Snap</code>, we don’t need to anything because it handles POST/GET requests and renders form templates depending on request data. <code>heistLocal</code> function is provided by <code>Snap.Snaplet.Heist</code> and runs a handler action(in our case, this is <code>render &quot;user_form&quot;</code>) on a modified Heist state. We’re modifying Heist state by binding our user form splices using <code>bindDigestiveSplices</code> as we did in previous post.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mainHandler ::</span> <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ()
<span class="ot">&gt;</span> mainHandler <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     (formView, maybeUser) <span class="ot">&lt;-</span> runForm <span class="st">&quot;userform&quot;</span> userForm
<span class="ot">&gt;</span>     heistLocal (bindDigestiveSplices formView) <span class="fu">$</span> render <span class="st">&quot;user_form&quot;</span></code></pre>
<p>This is some code from previous post.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     {<span class="ot"> uUsername ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uEmail    ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uKarma    ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     } <span class="kw">deriving</span> (<span class="kw">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; userForm ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">T.Text</span> m <span class="dt">User</span>
<span class="ot">&gt;</span> userForm <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;$&gt;</span> <span class="st">&quot;username&quot;</span>  <span class="fu">.:</span> text <span class="kw">Nothing</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span>     <span class="fu">.:</span> check <span class="st">&quot;invalid email&quot;</span> validateEmail (text <span class="kw">Nothing</span>)
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> pure <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     validateEmail ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>     validateEmail <span class="fu">=</span> isJust <span class="fu">.</span> T.find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)</code></pre>
<p>As last thing, we need to copy our template file to <code>snaplets/heist/templates</code>. This is because of the way Snap handles Snaplets. I think what happens is for every Snaplet nested in a Snap application, Snap creates a folder in <code>snaplets/snaplet_name</code> and later when that Snaplet requires some filesystem operations, all paths are handled relative to this directory.</p>
<p>After that, if you compile and run the application, you can see our form at http://0.0.0.0:8000 and you can test error messages.</p>]]></summary>
</entry>
<entry>
    <title>Quick digestive-functors and heist tutorial</title>
    <link href="http://osa1.net/posts/2014-01-03-quick-digestive-f-heist-tut.html" />
    <id>http://osa1.net/posts/2014-01-03-quick-digestive-f-heist-tut.html</id>
    <published>2014-01-03T00:00:00Z</published>
    <updated>2014-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>EDIT: I just found this awesome <a href="http://softwaresimply.blogspot.com/2011/04/heist-in-60-seconds.html">“Heist in 60 seconds”</a> post in Hesit’s author’s blog, strongly recommended.</p>
<p>I’m currently learning some web programming related libraries for Haskell and I’m very, very confused because of the need for using more than 20 libraries for even the simplest CRUD webapp. In the end I’ll be using Snap, Heist, Digestive-functors, Persistent, Esqueleto and glue libraries to combine all of this together. After wasting several hours trying to learn all of them at once, I decided to move gradually from simplest parts. In this short tutorial, I’ll explain how to create forms using digestive-functors, render them in HTML and run some validation procedures.</p>
<p>This post is written in Literate Haskell, except for the last part, which contains a Heist template for rendering our forms in HTML.</p>
<p>In my opinition, there are two problems for starters of Haskell web programming in Snap. First, Snap lacks some important web development functionalities and for that you need to use separate libraries. This includes form generation and rendering, database operations and probably many others. (on the other hand, we have very high quality libraries so this part may not be a problem, depending on your point of view)</p>
<p>Second, while using other libraries you realize that most of the time documentation is not very good and some important details for starters are missing, when that happens you end up diving into the source code and open source examples.</p>
<p>Anyway, I hope this post serves as an example for using Digestive-functors and Heist together for handling user inputs.</p>
<p>A note before starting: I don’t understand how compiled splices of Heist works, I tried using them but for some reason I couldn’t make it working. So in this post I’ll be using interpreted splices only.</p>
<p>Let’s start with some langauge extensions. You’ll see why this extension is needed below</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></code></pre>
<p>This one is required for pattern matching against Text values</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings   #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></code></pre>
<p>Even though our program doesn’t do anything interesting, we still need to use about 10 libraries. I’m showing the package name when a non-standard(e.g. the ones distributed with Haskell Platform) module is imported.</p>
<p>from `blaze-builder’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Blaze.ByteString.Builder   (toByteString)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Applicative        (Applicative (..), (&lt;$&gt;), (&lt;*&gt;))
<span class="ot">&gt;</span> <span class="kw">import</span>           Control.Monad.IO.Class     (MonadIO)</code></pre>
<p>from `either’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Monad.Trans.Either (EitherT, runEitherT)</code></pre>
<p>from `bytestring’ package, needed for putStrLn function on bytestrings</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString.Char8      <span class="kw">as</span> BS (putStrLn)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Data.Maybe                 (isJust)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Text                  <span class="kw">as</span> T</code></pre>
<p>from `heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Heist
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Heist.Interpreted          <span class="kw">as</span> HI</code></pre>
<p>from `digestive-functors’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive</code></pre>
<p>from `digestive-functors-heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Heist       (bindDigestiveSplices)</code></pre>
<p>In this program, we’ll have one data type that represents a User in our app. I’m planning to extend this post later on to add CRUD database operations on same data type.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     {<span class="ot"> uUsername ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uEmail    ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uKarma    ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     } <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p><code>userForm</code> is a digestive-functors form for User type, which is used for creating new User and modifying existing User.</p>
<p>In the return type:</p>
<ul>
<li>First argument of Form(Text) is type of textual information printed to user. This is used for error messages and probably some other stuff</li>
<li>Second argument is the Monad type that validator of this form operates on.</li>
<li>Third argument is return type of this form. Form return types are used when combining forms using applicative instance. For example, a form that asks user for a text can be used to get a text value.</li>
</ul>
<p><code>.:</code> operator is used to assign a name to form fields. This names are later used in templates, POST request environments and probably in some other places.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; userForm ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">T.Text</span> m <span class="dt">User</span>
<span class="ot">&gt;</span> userForm <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;$&gt;</span> <span class="st">&quot;username&quot;</span>  <span class="fu">.:</span> text <span class="kw">Nothing</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span>     <span class="fu">.:</span> check <span class="st">&quot;invalid email&quot;</span> validateEmail (text <span class="kw">Nothing</span>)
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> pure <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     <span class="co">-- in our example, we don&#39;t need to use `m` monad for validation. if we</span>
<span class="ot">&gt;</span>     <span class="co">-- were to need that, we could use `checkM` instead of `check`, and</span>
<span class="ot">&gt;</span>     <span class="co">-- then use a validation function with type `T.Text -&gt; m Bool` for same m.</span>
<span class="ot">&gt;     validateEmail ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>     validateEmail <span class="fu">=</span> isJust <span class="fu">.</span> T.find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)</code></pre>
<p>For generating HTML using Heist, we need to maintain <code>HeistState</code> type, which keeps track of information that is needed for rendering templates.</p>
<p>In the code below, `m’ is called “runtime monad” and represents the monad type that rendering functions operate on. We will see an example use later.</p>
<p>I’m using <code>ScopedTypeVariables</code> extension to share type parameter <code>m</code> with type declarations in <code>where</code> part. This is only optional, since I could always use <code>let</code> or just inline the <code>heistConfig</code> definition.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; initHeistState ::</span> forall m<span class="fu">.</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> (<span class="dt">HeistState</span> m)
<span class="ot">&gt;</span> initHeistState <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     st <span class="ot">&lt;-</span> runEitherT <span class="fu">$</span> initHeist heistConfig
<span class="ot">&gt;</span>     <span class="kw">case</span> st <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Left</span> errors <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="fu">$</span> <span class="fu">unlines</span> errors
<span class="ot">&gt;</span>       <span class="kw">Right</span> state <span class="ot">-&gt;</span> <span class="fu">return</span> state
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     heistConfig ::</span> <span class="dt">HeistConfig</span> m
<span class="ot">&gt;</span>     <span class="co">-- In HeistConfig, we need to specify what load-time, compile-time and</span>
<span class="ot">&gt;</span>     <span class="co">-- run-time splices will be available. We also have options for</span>
<span class="ot">&gt;</span>     <span class="co">-- attibute splices(QUESTION: why we don&#39;t have time distinction in</span>
<span class="ot">&gt;</span>     <span class="co">-- attribute splices?) and locations of template files.</span>
<span class="ot">&gt;</span>     heistConfig <span class="fu">=</span> <span class="dt">HeistConfig</span>
<span class="ot">&gt;</span>       {
<span class="ot">&gt;</span>       <span class="co">-- default interpreted splices consists of</span>
<span class="ot">&gt;</span>       <span class="co">-- `apply`, `bind`, `ignore` and `markdown` splices</span>
<span class="ot">&gt;</span>         hcInterpretedSplices <span class="fu">=</span> defaultInterpretedSplices
<span class="ot">&gt;</span>       <span class="co">-- this is same as default interpreted splices</span>
<span class="ot">&gt;</span>       , hcLoadTimeSplices <span class="fu">=</span> defaultLoadTimeSplices
<span class="ot">&gt;</span>       <span class="co">-- I&#39;m not using compiled splices because of the reason explained</span>
<span class="ot">&gt;</span>       <span class="co">-- in first paragraphs</span>
<span class="ot">&gt;</span>       , hcCompiledSplices <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="co">-- .. also here.</span>
<span class="ot">&gt;</span>       , hcAttributeSplices <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="co">-- list of template locations. A template location is an</span>
<span class="ot">&gt;</span>       <span class="co">-- IO action that either returns a list of error strings,</span>
<span class="ot">&gt;</span>       <span class="co">-- or a map from template locations to template files.</span>
<span class="ot">&gt;</span>       <span class="co">-- We&#39;re using `loadTemplates` from Heist package for loading</span>
<span class="ot">&gt;</span>       <span class="co">-- templates from a folder. Subfolders are also traversed.</span>
<span class="ot">&gt;</span>       , hcTemplateLocations <span class="fu">=</span> [loadTemplates <span class="st">&quot;templates&quot;</span>]
<span class="ot">&gt;</span>       }</code></pre>
<p>This is our function to render form templates written in Heist template format using digestive-functors forms. Digestive-functors forms are not directly renderable, instead we need a <code>View</code> object generated from <code>Form</code> using <code>getForm</code> or <code>postForm</code> from <code>Text.Digestive.View</code> (<code>digestive-functors</code> package).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; renderForm ::</span> <span class="dt">HeistState</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">View</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> renderForm hs formView <span class="fu">=</span> <span class="kw">do</span></code></pre>
<p>Because of a problem, we can’t use <code>digestiveSplices form</code> to get splices and then bind them manually using <code>bindSplices</code>. I think this is because of a type mismatch caused by current versions of digestive-functors-heist and heist libraries. So we need to use <code>bindDigestiveSplices</code> from <code>Text.Digestive.Heist</code> (<code>digestive-functors-heist</code> package).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     maybeBuilder <span class="ot">&lt;-</span> HI.renderTemplate (bindDigestiveSplices formView hs) <span class="st">&quot;user_form&quot;</span>
<span class="ot">&gt;</span>     <span class="kw">case</span> maybeBuilder <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Nothing</span> <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>         <span class="co">-- This happens when wrong template name is given to `renderTemplate`.</span>
<span class="ot">&gt;</span>         <span class="fu">error</span> <span class="st">&quot;template is not rendered&quot;</span>
<span class="ot">&gt;</span>       <span class="kw">Just</span> (builder, mimeType) <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         <span class="co">-- here `builder` has type `Blaze.ByteString.Builder.Builder` from</span>
<span class="ot">&gt;</span>         <span class="co">-- `blaze-builder` package. It&#39;s used to efficiently build</span>
<span class="ot">&gt;</span>         <span class="co">-- ByteStrings.</span>
<span class="ot">&gt;</span>         BS.putStrLn (toByteString builder)
<span class="ot">&gt;</span>         <span class="fu">print</span> mimeType</code></pre>
<p>I’m just printing stuff, since this app is mostly for learning purposes.</p>
<p>In main function, I do three things:</p>
<ol style="list-style-type: decimal">
<li>Just render the form on empty POST request environment. This just renders the form without filling HTML fields with values.</li>
<li>Render form with invalid email address. This fills HTML fields with values form POST request environment, and renders an error message after email field saying that email is invalid. This validation part was handled in <code>validateEmail</code> function above, and error message was specified in <code>userForm</code> function.</li>
<li>Render the form with valid values.</li>
</ol>
<p>After rendering the HTML code, I’m just printing it. Also, form rendering function(<code>postForm</code>) returns an optional User object depending on the validness of information from POST request. I’m also printing that User object.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     hs <span class="ot">&lt;-</span> initHeistState
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- we need to dynamically bind splices related with form generation</span>
<span class="ot">&gt;</span>     <span class="co">-- while rendering `user_form` heist template. for that we need to use</span>
<span class="ot">&gt;</span>     <span class="co">-- `Heist.Interpreter` functions to modify interpereted splices of our</span>
<span class="ot">&gt;</span>     <span class="co">-- heist state.</span>
<span class="ot">&gt;</span>     <span class="fu">--</span>
<span class="ot">&gt;</span>     <span class="co">-- To get form splices, we need to pass some POST or GET request as</span>
<span class="ot">&gt;</span>     <span class="co">-- ByteString to `Text.Digestive.View.getForm` or `postForm`. Then we</span>
<span class="ot">&gt;</span>     <span class="co">-- can use `Text.Digestive.Heist.digestiveSplices` to get required</span>
<span class="ot">&gt;</span>     <span class="co">-- splices to render form.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Here the type T.Text comes from first argument of userForm&#39;s return</span>
<span class="ot">&gt;</span>     <span class="co">-- type</span>
<span class="ot">&gt;</span>     (formView, maybeUser) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm (<span class="fu">const</span> <span class="fu">$</span> <span class="fu">return</span> [])
<span class="ot">&gt;                                ::</span> <span class="dt">IO</span> (<span class="dt">View</span> <span class="dt">T.Text</span>, <span class="dt">Maybe</span> <span class="dt">User</span>)
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser
<span class="ot">&gt;</span>     renderForm hs formView
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Case 2, POST request with invalid email address</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> env path <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> path <span class="kw">of</span>
<span class="ot">&gt;</span>                               [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;username&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;testuser&quot;</span>]
<span class="ot">&gt;</span>                               [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;email&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;invalidemail&quot;</span>]
<span class="ot">&gt;</span>                               _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span>     (formView&#39;, maybeUser&#39;) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm env
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser&#39;
<span class="ot">&gt;</span>     renderForm hs formView&#39;
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Case 3, POST request with valid email address and username</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> env&#39; path <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> path <span class="kw">of</span>
<span class="ot">&gt;</span>                                [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;username&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;testuser&quot;</span>]
<span class="ot">&gt;</span>                                [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;email&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;valid@email.com&quot;</span>]
<span class="ot">&gt;</span>                                _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span>     (formView&#39;&#39;, maybeUser&#39;&#39;) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm env&#39;
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser&#39;&#39;
<span class="ot">&gt;</span>     renderForm hs formView&#39;&#39;</code></pre>
<p>Now our program is almost complete, only detail left is the Heist template file. We specified the template path in <code>initHeistState</code> as <code>templates</code> folder, and we’re rendering Heist template named <code>user_form</code> in <code>renderForm</code>. So the template file we need should be <code>templates/user_form.tpl</code>.</p>
<p>Here’s the template file:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;dfForm&gt;</span>
    <span class="kw">&lt;dfLabel</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/dfLabel&gt;</span>
    <span class="kw">&lt;dfInputText</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;dfErrorList</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span> <span class="kw">/&gt;</span>

    <span class="kw">&lt;dfLabel</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/dfLabel&gt;</span>
    <span class="kw">&lt;dfInputText</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;dfErrorList</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span> <span class="kw">/&gt;</span>

    <span class="kw">&lt;dfInputSubmit</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/dfForm&gt;</span></code></pre>
<p>One problem here is that there’s no way to know which tags to put in template file. I wrote this file mostly by looking to source code of <code>bindDigestiveSplices</code>, trial-and-error, and some open source examples.</p>
<p>Output should be something like: (after creating the template file, see below)</p>
<p>Case 1:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Nothing</span></code></pre>
<p>because POST request environment is not valid, so it’s not possible to create a User object.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> method=</span><span class="st">&#39;POST&#39;</span><span class="ot"> enctype=</span><span class="st">&#39;application/x-www-form-urlencoded&#39;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.username&#39;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> value</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.email&#39;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> value</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;ul&gt;&lt;li&gt;</span>invalid email<span class="kw">&lt;/li&gt;&lt;/ul&gt;</span>

    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;submit&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre>
<p>User form is generated without filling any values and no error messages.</p>
<p>Case 2:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Nothing</span></code></pre>
<p>because email information in POST request environment is invalid.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> method=</span><span class="st">&#39;POST&#39;</span><span class="ot"> enctype=</span><span class="st">&#39;application/x-www-form-urlencoded&#39;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.username&#39;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> value=</span><span class="st">&#39;testuser&#39;</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.email&#39;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> value=</span><span class="st">&#39;invalidemail&#39;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;ul&gt;&lt;li&gt;</span>invalid email<span class="kw">&lt;/li&gt;&lt;/ul&gt;</span>

    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;submit&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre>
<p>User form is generated with fields filled and an error message is rendered.</p>
<p>Case 3:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Just</span> (<span class="dt">User</span> {uUsername <span class="fu">=</span> <span class="st">&quot;testuser&quot;</span>, uEmail <span class="fu">=</span> <span class="st">&quot;valid@email.com&quot;</span>, uKarma <span class="fu">=</span> <span class="dv">0</span>})</code></pre>
<p>Since form data is valid, a User object is created.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> method=</span><span class="st">&#39;POST&#39;</span><span class="ot"> enctype=</span><span class="st">&#39;application/x-www-form-urlencoded&#39;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.username&#39;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> value=</span><span class="st">&#39;testuser&#39;</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.email&#39;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> value=</span><span class="st">&#39;valid@email.com&#39;</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;submit&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre>
<p>.. and for is created with values filled, no error messages is rendered.</p>
<p>Note the form and input ids and names. The name passed to <code>postForm</code> is used as prefix of generated HTML elements, and thus also used in POST request environments.</p>
<p>I hope this post helps starters with digestive-functors and heist.</p>]]></summary>
</entry>
<entry>
    <title>Fun C compile time assertion trick</title>
    <link href="http://osa1.net/posts/2013-12-30-fun-c-compile-time-trick.html" />
    <id>http://osa1.net/posts/2013-12-30-fun-c-compile-time-trick.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s been long time since I wrote an interesting post but I still don’t have anything interesting and short enough for me to explain in a blog post. Anyway, here’s a fun C compile time assertion trick that I found in libSDL 2 codebase:</p>
<p>In C we have <code>typedef</code> which can be used for defining type synonyms. This code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> test;</code></pre>
<p>Defines <code>test</code> as type synonym for int, and then you can replace <code>int</code>s in variable declarations with <code>test</code>.</p>
<p>Interestingly, you can also use illegal type names for typedefs, like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> foo[<span class="dv">10</span>];</code></pre>
<p>This is funny, because you can’t use <code>foo[10]</code> as type of a variable, so I don’t understand why this syntax is allowed. I think the reason is that a <code>typedef</code> is just like declaration and shares same syntax with it, so this is allowed. Still, this declaration looks pretty useless to me.</p>
<p>Anyway, apparently there are some other interesting uses of <code>typedef</code>s. This code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> foo[-<span class="dv">1</span>];</code></pre>
<p>fails with:</p>
<pre><code>test.c:13:17: error: &#39;foo&#39; declared as an array with a negative size
typedef int foo[-1];
                ^~</code></pre>
<p>Furthermore, there are some expression-like C syntax that are actually evaluated at compile time<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. For example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> foo[<span class="dv">3-4</span>];</code></pre>
<p>Here <code>3-4</code> looks like an expression, but it’s actually evaluated at compile-time and thus this code fails with same error as above.</p>
<p>Using this two tricks, we can have some king of compile-time assertions, like libSDL people use:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define COMPILE_TIME_ASSERT(name, x) \</span>
  <span class="kw">typedef</span> <span class="dt">int</span> dummy_ ## name[(x) * <span class="dv">2</span> - <span class="dv">1</span>]

<span class="kw">typedef</span> <span class="dt">uint16_t</span> Uint16;

COMPILE_TIME_ASSERT(uint16, <span class="kw">sizeof</span>(Uint16) == <span class="dv">2</span>);</code></pre>
<p>This code checks in compile time if <code>Uint16</code> really represents 2 bytes in memory and it fails to compile if it doesn’t. Interesting part here is that <code>(x) * 2 - 1</code> expression evaluated at compile-time.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>These are called <em>constant expressions</em> and specified in C11 standard(<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">draft</a>) section 6.6.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Note that the <code>x</code> here will be already replaced with some other expression, passed with macro call.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Testing assembly programs using Haskell, QuickCheck (and FFI)</title>
    <link href="http://osa1.net/posts/2013-11-14-testing-asm-using-haskell.html" />
    <id>http://osa1.net/posts/2013-11-14-testing-asm-using-haskell.html</id>
    <published>2013-11-14T00:00:00Z</published>
    <updated>2013-11-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been studying 64bit calling conventions for x64 family recently. To do this, I was writing some function in assembly and then calling my functions from a C program to be sure that parameter passing and returning values are working correctly.</p>
<p>It generally works fine, and linking C program with assembly programs are easy enough. Today I got the idea of using Haskell + QuickCheck to test my assembly programs, this way I could also be more confident that not only parameter passing/return values work correctly, but my implementation of algorithm in assembly is also correct.</p>
<p>Linking assembly programs with a Haskell program is surprisingly easy. In the rest of this post, I’ll explain how to compile and link power function written in assembly to test program written in Haskell.</p>
<p>Here’s a power function that works on 64bit unsigned numbers, implemented using x64 ABI conventions:</p>
<pre class="assembly"><code>section .text
global power
power:
	mov rbx, rdi        ; move first parameter to rbx
	mov rcx, rsi        ; move second parameter to rcx

	cmp rcx, 0          ; return 1 if power is 0
	je end_power_one

	mov rax, rbx        ; move result to rax for multiplication

power_loop_start:
	cmp rcx, 1
	je end_power

	mul rbx
	dec rcx
	jmp power_loop_start

end_power_one:
	mov rax, 1

end_power:
	ret</code></pre>
<p>This is written using <a href="http://www.nasm.us/">Netwide Assembler</a>(best assembly syntax, IMO). Since we’re working on 64bit system, we need to compile it to <code>elf64</code> format:</p>
<pre><code>nasm -f elf64 power_lib.s -o power_lib.o</code></pre>
<p>Once we have our compiled file for power function, we need to declare it in Haskell as a foreign function, using correct types. A short tour in <code>Foreign.C.Types</code> library showed that <code>CULong</code> type is actually a newtype wrapper around <code>Word64</code>, which is 64bit unsigned number type:</p>
<pre><code>ghci&gt; :m + Foreign.C.Types 
ghci&gt; :info CULong
newtype CULong = CULong GHC.Word.Word64
        -- Defined in `Foreign.C.Types&#39;</code></pre>
<p>(not that this part should be different on 32bit systems – eg. on 32bit system you should see <code>CULong GHC.Word.Word32</code> instead of <code>Word64</code>)</p>
<p>We also need a <code>Arbitrary</code> instance for <code>CULong</code> type to be able to use QuickCheck on this type. Since <code>CULong</code> is just a newtype wrapper over <code>Word64</code>, and <code>Word64</code> already has instance defined in QuickCheck library, we can have that for free. In the end, our test code is:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Foreign.C.Types
<span class="kw">import</span> Test.QuickCheck

foreign <span class="kw">import</span> ccall &quot;power&quot;
<span class="ot">    power ::</span> <span class="dt">CULong</span> <span class="ot">-&gt;</span> <span class="dt">CULong</span> <span class="ot">-&gt;</span> <span class="dt">CULong</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">CULong</span> <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="fu">fmap</span> <span class="dt">CULong</span> arbitrary
    shrink (<span class="dt">CULong</span> i) <span class="fu">=</span> <span class="fu">map</span> <span class="dt">CULong</span> <span class="fu">$</span> shrink i

test_prop b p <span class="fu">=</span> power b p <span class="fu">==</span> b <span class="fu">^</span> p

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> quickCheck test_prop</code></pre>
<p>and that’s it. Very simple, 16 lines of code. To compile this, I also wrote a Makefile:</p>
<pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">power:</span><span class="dt"> power_test.hs power_lib.o</span>
	ghc --make <span class="ch">$^</span>

<span class="dv">power_lib.o:</span><span class="dt"> power_lib.s</span>
	nasm -f elf64 <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">clean:</span>
	<span class="ch">-</span><span class="fu">rm power_lib.o</span>
	<span class="ch">-</span><span class="fu">rm power_test power_test.hi power_test.o</span></code></pre>
<p>(this may be helpful to see how compilation work)</p>
<p>I think this is also a good demonstration of how easy it is to interact with foreign functions in Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Observability of bottom values</title>
    <link href="http://osa1.net/posts/2013-11-03-observability-of-nulls.html" />
    <id>http://osa1.net/posts/2013-11-03-observability-of-nulls.html</id>
    <published>2013-11-03T00:00:00Z</published>
    <updated>2013-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While ranting about how much I hate about null values in Java(and other langauges) on Haskell IRC channel, someone in the channel reminded me that we have <code>undefined</code> in Haskell, which is actually similar to null values in some sense.</p>
<p>The difference between Haskell’s <code>undefined</code> and null values in other languages is that Haskell’s <code>undefined</code> is <em>unobservable</em>. This means you can’t test for a value being <code>undefined</code> or not in Haskell, but you can test for null values in Java and other languages.</p>
<p>This means you can’t rely on some values being <code>undefined</code> or not. This makes it only useful for 1) unreachable code and 2) filling some parts in the code for now just to make it compile and later complete that parts(and I’m using <code>undefined</code> for this purpose very often).</p>
<p>This is what makes Haskell’s <code>undefined</code> a useful feature, while null values is clearly <em>Considered Harmful</em>™.</p>]]></summary>
</entry>
<entry>
    <title>Memoized parsing in continuation-passing style</title>
    <link href="http://osa1.net/posts/2013-10-21-memoized-parsing-cps.html" />
    <id>http://osa1.net/posts/2013-10-21-memoized-parsing-cps.html</id>
    <published>2013-10-21T00:00:00Z</published>
    <updated>2013-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Continuations are truly magical things. They’re the “ultimate abstractions of control flow”. Even without using any fancy language features like <code>call/cc</code>, you can have seriously cool and mind-boggling programs.</p>
<p>In <a href="http://arxiv.org/pdf/cmp-lg/9504016">“Memoization in Top-Down Parsing”</a> paper, Mark Johnson builds up from memoizing top-down parsers and describes a way to handle left recursion in top-down parsers by combining memoization techniques with continuations.</p>
<p>I ported the code to Lua to experiment, you can see it <a href="https://gist.github.com/osa1/7089333">here</a>. Most interesting part is the memoized CPS parser generator from a normal CPS parser function:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> memo<span class="ot">(</span><span class="kw">parser</span><span class="ot">)</span>
    <span class="co">-- WARNING: this function is badly implemented in the sense that</span>
    <span class="co">-- if you parser generated by this function on two different streams</span>
    <span class="co">-- it will generate wrong results</span>
    <span class="kw">local</span> <span class="kw">tbl</span> <span class="ot">=</span> <span class="ot">{}</span>
    <span class="kw">return</span> <span class="kw">function</span> <span class="ot">(</span><span class="kw">stream</span><span class="ot">,</span> <span class="kw">idx</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
        <span class="kw">if</span> <span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">]</span> <span class="ot">==</span> <span class="kw">nil</span> <span class="kw">then</span>
            <span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">]</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">results</span> <span class="ot">=</span> <span class="ot">{},</span> <span class="kw">conts</span> <span class="ot">=</span> <span class="ot">{}</span> <span class="ot">}</span>
            <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">conts</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
            parser<span class="ot">(</span><span class="kw">stream</span><span class="ot">,</span> <span class="kw">idx</span><span class="ot">,</span> <span class="kw">function</span> <span class="ot">(</span><span class="kw">parse_result</span><span class="ot">)</span>
                <span class="co">-- check if same parse_result is already in the table</span>
                <span class="kw">local</span> <span class="kw">exists</span> <span class="ot">=</span> <span class="kw">false</span>
                <span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">result</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">results</span><span class="ot">)</span> <span class="kw">do</span>
                    <span class="kw">if</span> <span class="kw">result</span> <span class="ot">==</span> <span class="kw">parse_result</span> <span class="kw">then</span> <span class="co">-- TODO: this equality is probably wrong</span>
                        <span class="kw">exists</span> <span class="ot">=</span> <span class="kw">true</span>
                        <span class="kw">break</span>
                    <span class="kw">end</span>
                <span class="kw">end</span>
 
                <span class="kw">if</span> <span class="kw">not</span> <span class="kw">exists</span> <span class="kw">then</span>
                    <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">results</span><span class="ot">,</span> <span class="kw">parse_result</span><span class="ot">)</span>
                    <span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">cont</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">conts</span><span class="ot">)</span> <span class="kw">do</span>
                        cont<span class="ot">(</span><span class="kw">parse_result</span><span class="ot">)</span>
                    <span class="kw">end</span>
                <span class="kw">end</span>
            <span class="kw">end</span><span class="ot">)</span>
        <span class="kw">else</span>
            <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">conts</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
            <span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">result</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">].</span><span class="kw">results</span><span class="ot">)</span> <span class="kw">do</span>
                cont<span class="ot">(</span><span class="kw">result</span><span class="ot">)</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
        <span class="kw">return</span> <span class="kw">tbl</span><span class="ot">[</span><span class="kw">idx</span><span class="ot">]</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>(btw, I found porting this code to a purely functional setting very hard thing to do. If you find a way to do this, please send me your code. Thanks.)</p>
<p>This piece of code didn’t make sense to me for a while. I think the key to understand this function is to find answer to this question:</p>
<p>How is this different from keeping a set of productions visited without consuming any input from input stream and when you come to the same production, just failing instead of trying to parse? Because trying to derive same production without consuming any input means you’ll end up with infinite loop.</p>
<p>This function different in that it accounts for parsing same production after following a different path of production. Think this CFG as an example:</p>
<pre><code>T ::= T + T
    | int</code></pre>
<p>In order to derive first production, it first needs to parse a <code>T</code>. But then it will be already noted that it was already trying to parse <code>T</code>, and add the continuation to the list of continuations to be called when a T at input position 1 is parsed.</p>
<p>While trying alternatives, it will parse an <code>int</code>, and derive <code>T -&gt; int</code> at input position 1. And since it had saved the continuations to call when it successfully parse a <code>T</code> at location 1, it will call this continuations and thus parsing will continue.</p>
<p>I hope this helps other people to understand the trick.</p>]]></summary>
</entry>
<entry>
    <title>Half-baked idea: Abstract interpretation for code completion</title>
    <link href="http://osa1.net/posts/2013-10-16-abstract-interpretation-completion.html" />
    <id>http://osa1.net/posts/2013-10-16-abstract-interpretation-completion.html</id>
    <published>2013-10-16T00:00:00Z</published>
    <updated>2013-10-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had this idea about implementing code completion on dynamic languages. Statically inferring information in dynamic languages is hard and never accurate enough. In my opinion, we should take a step towards dynamically checking the code by having some kind of abstract interpretation of the language that allows us infer required information and then running programs in this interpretation.</p>
<p>I didn’t figure out the details yet. I just wanted to write here as a TODO.</p>]]></summary>
</entry>
<entry>
    <title>Destansı tesadüf</title>
    <link href="http://osa1.net/posts/2013-10-10-destansi-tesaduf.html" />
    <id>http://osa1.net/posts/2013-10-10-destansi-tesaduf.html</id>
    <published>2013-10-10T00:00:00Z</published>
    <updated>2013-10-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün, şu sıralar bir araştırma labında çalıştığım okulumda<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> bir startup etkinliği vardı, 10 civarında startup gelip stand açtılar, tshirt dağıtıp CV topladılar ve tanıtım yaptılar. Buralarda sık sık olan bir olay.</p>
<p>Normalde rastgele yazılım mühendisliği işleri ile ilgilenmediğimden benim pek ilgimi çekemiyor bu gibi şeyler, yine de bir gözatıyorum, çünkü geçen sefer <a href="http://www.spacex.com/">SpaceX</a>’i kaçırmıştım ve hala kendimi affedemedim :p . Her neyse, gezinirken bir şirket gözüme çarptı, salonda önünde tek bir öğrenci bile olmayan tek stand bunlarındı ve açıklamalarına bir göz gezdirdiğimde şöyle anahtar kelimeler gözüme çarptı: “runtime verification”, “correctness”, “LLVM”, “NASA” …</p>
<p>Birkaç saat sonra okuldan çıkarken bir yandan kendi kendime düşünüyorum “havalı olmayan şeye merak sararak 1-0 yenik başlamışız abi zaten” diye haueh. Bu ekibin önünden geçerken yine kimsenin olmaması artık beni rahatsız etmiş olacak herhalde ki bir anda durup adama selam verdim, ne iş yapıyorsunuz dedim. Adam bana benim üzerinde çalıştığım şeyleri anlatmaya başladı :) . Lafını kesip benim zaten bu işleri yaptığımı ve şu labda çalıştığımı falan söyleyince, adam demesin mi “bu senin hocanın startup’ı” diye …</p>
<p>Hocamın startupının olduğunu ve benim geliştirdiğim araç ile çalıştıklarını bu şekilde öğrenmiş oldum.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://fsl.cs.illinois.edu/index.php/Main_Page">University of Illinois at Urbana-Champaign, Formal Systems Lab</a><a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Parametric polymorphism and unboxed representations</title>
    <link href="http://osa1.net/posts/2013-10-09-parametric-polymorphism-and-unboxed-repr.html" />
    <id>http://osa1.net/posts/2013-10-09-parametric-polymorphism-and-unboxed-repr.html</id>
    <published>2013-10-09T00:00:00Z</published>
    <updated>2013-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post was written 5 months ago – I just found it in my Github Gist archive and realized it’s not published. I’m publishing it now.</p>
<hr />
<p>It’s just occurred to me that we can’t have parametric polymorphism for unboxed values, unless that unboxed values share same layout in memory, or you duplicate polymorphic definition for each instance. This may be obvious for most of you but I just realized this while working on a Java project and found it interesting.</p>
<p>I think this is also the reason why we can’t instantiate generics in Java with primitive types.</p>
<p>Here’s an explanation:</p>
<p>Let’s think this C++ code:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> test2
{
  <span class="dt">int</span> a, b;
  test2(<span class="dt">int</span> a, <span class="dt">int</span> b) : a(a), b(b) {}
};

<span class="kw">struct</span> test3
{
  <span class="dt">int</span> a, b, c;
  test3(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c) : a(a), b(b), c(c) {}
};

<span class="dt">void</span> f2() {}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T f3(T t)
{
  t.a = <span class="dv">20</span>;
  <span class="kw">return</span> t;
}

<span class="dt">int</span> main()
{
  test2 t2(<span class="dv">1</span>, <span class="dv">2</span>);
  test3 t3(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  f3&lt;test2&gt;(t2);
  f3&lt;test3&gt;(t3);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>The key thing to realize here is that I’m passing parameter by value, ie. values are copied to function stack frame. But this function is still polymorphic on parameter type. This is possible in C++ because for each distinct instance of <code>f3</code>, a specialized code will be generated. To observe this, I put a breakpoint to that <code>f3</code> function and looked to disassembly output.</p>
<pre><code>        18	T f3(T t)
0x400af6  &lt;+0x0000&gt;         push   rbp
0x400af7  &lt;+0x0001&gt;         mov    rbp,rsp
0x400afa  &lt;+0x0004&gt;         mov    QWORD PTR [rbp-0x10],rdi
        19	{
        20	  t.a = 20;
0x400afe  &lt;+0x0008&gt;         mov    DWORD PTR [rbp-0x10],0x14
        21	  return t;
0x400b05  &lt;+0x000f&gt;         mov    rax,QWORD PTR [rbp-0x10]
        22	}
0x400b09  &lt;+0x0013&gt;         pop    rbp
0x400b0a  &lt;+0x0014&gt;         ret</code></pre>
<p>And this is for second call:</p>
<pre><code>        18	T f3(T t)
0x400b0b  &lt;+0x0000&gt;         push   rbp
0x400b0c  &lt;+0x0001&gt;         mov    rbp,rsp
0x400b0f  &lt;+0x0004&gt;         mov    rdx,rdi
0x400b12  &lt;+0x0007&gt;         mov    eax,esi
0x400b14  &lt;+0x0009&gt;         mov    QWORD PTR [rbp-0x20],rdx
0x400b18  &lt;+0x000d&gt;         mov    DWORD PTR [rbp-0x18],eax
        19	{
        20	  t.a = 20;
0x400b1b  &lt;+0x0010&gt;         mov    DWORD PTR [rbp-0x20],0x14
        21	  return t;
0x400b22  &lt;+0x0017&gt;         mov    rax,QWORD PTR [rbp-0x20]
0x400b26  &lt;+0x001b&gt;         mov    QWORD PTR [rbp-0x10],rax
0x400b2a  &lt;+0x001f&gt;         mov    eax,DWORD PTR [rbp-0x18]
0x400b2d  &lt;+0x0022&gt;         mov    DWORD PTR [rbp-0x8],eax
0x400b30  &lt;+0x0025&gt;         mov    rax,QWORD PTR [rbp-0x10]
0x400b34  &lt;+0x0029&gt;         mov    edx,DWORD PTR [rbp-0x8]
        22	}
0x400b37  &lt;+0x002c&gt;         pop    rbp
0x400b38  &lt;+0x002d&gt;         ret</code></pre>
<p>So what happened here is two new functions is generated from the definition, one with type <code>test2 f3(test2)</code> and one with type <code>test3 f3(test3)</code>. This gives a great opportunity, for instance, we can have this function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T someFun(T arg1, T arg2)
{
  <span class="kw">return</span> arg1 + arg2;
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">const</span> <span class="dt">char</span> *argv[])
{
  std::cout &lt;&lt; someFun&lt;<span class="dt">int</span>&gt;(<span class="dv">1</span>, <span class="dv">2</span>) &lt;&lt; std::endl;
  std::cout &lt;&lt; someFun&lt;<span class="dt">float</span>&gt;(<span class="fl">1.4</span>, <span class="dv">2</span>) &lt;&lt; std::endl;

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>..which is impossible to have in Java, without manually overloading the method definition.</p>
<p>(An off-topic but interesting note: I was expecting <code>SP</code> to be set here, but here it’s not set. I think the reason is that the compiler is clever enough to see there is no recursive calls, so no need to set <code>SP</code>, when I added a dummy function call in the middle of <code>f3</code>, <code>SP</code> is got set)</p>
<p>So in a way, C++ generics are gives us the most general way for parametric polymorphism. For any type you instantiated the template with, it generates a specialized definition. And if that definition is accepted by type checker, you’re fine.</p>
<p>This also why we don’t need a template definition like <code>template &lt;class C : HasY&gt;</code>. Because that <code>HasY</code> information is completely redundant. If specialized code is well-typed, than it’s OK.</p>
<p>This is also one of the reasons why compiling C++ programs takes that long.</p>]]></summary>
</entry>

</feed>
