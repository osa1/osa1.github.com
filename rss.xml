<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - All posts</title>
    <link href="http://osa1.net/rss.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/rss.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2020-06-30T00:00:00Z</updated>
    <entry>
    <title>8 years of Haskell</title>
    <link href="http://osa1.net/posts/2020-06-30-8-years-of-haskell.html" />
    <id>http://osa1.net/posts/2020-06-30-8-years-of-haskell.html</id>
    <published>2020-06-30T00:00:00Z</published>
    <updated>2020-06-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>21 Jun 2020 was my last day at Well-Typed and as a GHC maintainer/developer. On 22nd I joined the programming language team at <a href="https://dfinity.org/">DFINITY</a> to work on the <a href="https://sdk.dfinity.org/docs/language-guide/motoko.html">Motoko programming language</a>.</p>
<p>Here’s the summary of my 8 years writing Haskell pretty much non-stop:</p>
<ul>
<li><p>In 2012 I wrote <a href="https://github.com/osa1/dolap-chat">my first Haskell program</a>, which was a chat server. I was reading <a href="http://book.realworldhaskell.org/">“Real World Haskell”</a> and <a href="http://learnyouahaskell.com/">“Learn You a Haskell for Great Good!”</a> at the time and applying what I learned on this project.</p></li>
<li><p>In the same year I implemented <a href="https://github.com/osa1/toylisp">my first programming language in Haskell</a>. I don’t remember much about this project, I think it may be just a few extensions over the excellent Haskell tutorial <a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">“Write Yourself a Scheme in 48 hours”</a>.</p></li>
<li><p>Also in 2012 I made a <a href="https://github.com/faylang/fay/commits?author=osa1">few commits</a> to the programming language Fay. This was my first contribution to an open source compiler not written by me.</p></li>
<li><p>In 2013 I worked on four PL implementations, two of which were implemented from scratch in Haskell: A <a href="https://github.com/osa1/MANTI">Prolog implementation</a> and a <a href="https://github.com/osa1/Shen.hs">K Lambda interpreter</a>.</p>
<p>The other two projects were: <a href="https://github.com/ozusrl/SubtypedQuotedML">A multi-stage ML-like language written in OCaml</a>, and K Framework (in Java).</p></li>
<li><p>In 2014 I was accepted to Google Summer of Code to work on <a href="https://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html">adding stack traces to GHCJS</a>. The project was successful, and I made <a href="https://github.com/ghcjs/ghcjs/graphs/contributors">88 commits</a> to GHCJS during this period.</p>
<p>This was my first introduction to GHC. I made only <a href="https://gitlab.haskell.org/ghc/ghc/commit/b3d9636af37cfafbc947b69dff5747065f437804">one commit</a> to GHC during this time, but I started reading the RTS and code generator to be able to implement cost-centre stacks in GHCJS, which taught me a lot.</p></li>
<li><p>Also in 2014, I briefly worked at a startup where I wrote Haskell.</p></li>
<li><p>In 2015 I joined Indiana University to do PhD in programming languages. In my first semester I worked on the paper <a href="http://ezyang.com/papers/ezyang15-cnf.pdf">“Efficient Communication and Collection with Compact Normal Forms”</a> which was about a GHC extension. The paper was published the same year at ICFP.</p></li>
<li><p>In the same year I briefly worked on a <a href="https://github.com/osa1/rho-torrent">torrent client in Haskell</a>.</p></li>
<li><p>According to git logs, 2015 was the year where I started making some larger commits to GHC. I think I made a few dozen commits that year. What was happening in the background is that I was working on unboxed sums. At Haskell Implementors Workshop in 2015 my advisor gave a presentation on <a href="https://osa1.net/posts/2015-11-13-data-repr-1.html">efficiency of data representation in Haskell</a>. I don’t remember how the story developed, but I think we also talked to a few people at ICFP on how to improve the situation, and one of the idea that came up was unboxed sums. IIRC I started working on it soon after returning from ICFP.</p>
<p>The first somewhat working version was implemented as a plugin, using lots of unsafe coercions under the hood. It was good enough to run some examples.</p></li>
<li><p>(In 2015, I also studied various metaprogramming and partial evaluation ideas quite extensively. If you look at my blog posts published in 2015 you’ll see a lot of related blog posts. There are also a few related git repositories in my Github page. I also gave a related talk at HIW 2015.)</p></li>
<li><p>Early 2016, I don’t remember what I was doing in too much detail. I remember taking an advanced OS class around that time and enjoying it very much. This was also the time where I started to realize that the tools I’m using (mostly GHC) is full of bugs, and are very slow and inefficient. I kept studying program transformation ideas, with the goal of making Haskell “fast”. I also started using C more, partly for the OS class, but also in my hobby projects. For example, the first commit of <a href="https://github.com/osa1/tiny">tiny</a> was made in January 2016 and <a href="https://github.com/osa1/tiny/commit/06accfabf941cb17c7efbb37dc55ed0c33dedc20">the code was in C</a>.</p></li>
<li><p>In mid-2016 I left Bloomington for Cambridge, UK, for an internship at Microsoft Research with SPJ. We mainly worked on implementing unboxed sums properly in the compiler (instead of as a hacky plugin), but I also did a lot of GHC maintenance work there with supervision of SPJ.</p>
<p>Unboxed sums was merged <a href="https://gitlab.haskell.org/ghc/ghc/-/commit/714bebff44076061d0a719c4eda2cfd213b7ac3d">during my time at MSR</a>.</p>
<p>In the rest of the internship I did a lot of reading, did GHC maintenance, and biked around Cambridge.</p></li>
<li><p>Most importantly, during my time at MSR I realized that I’m no longer interested in academic research. I don’t enjoy writing papers. I don’t feel like pushing a field forward while most of the tools I use every day are badly broken, inefficient, usually both. I started having job interviews while I was in the UK. I visited two companies for interviews, one in London, another one in Cambridge.</p>
<p>I also emailed my advisor, saying that I don’t want to come back to Bloomington.</p></li>
<li><p>Job interviews went badly, and I was back at Indiana University. Rest of the 2016 was pretty horrible. I was depressed. I had no interest in research. I still <a href="https://dl.acm.org/doi/pdf/10.1145/2851141.2851142">helped publishing a paper</a>, but I did not enjoy the process.</p>
<p>I still spent my last semester somewhat productively. I took enough classes this semester to leave IU with a masters degree, instead of empty handed (I was a PhD student, not masters). I also had some good job interviews and met good people from the Haskell community.</p>
<p>By the end of 2016 I accepted a job offer and left IU with masters degree to write Haskell for a startup.</p></li>
<li><p>In 2017 I worked for this startup for a year. I wrote lots of networking and concurrent code, and learned a lot about these topics and exception handling in Haskell. Until this my Haskell experience was mainly in the context of compilers, so this was quite educational for me.</p>
<p>I left the company at the end of that year to join Well-Typed to work on GHC full-time.</p></li>
<li><p>My time at Well-Typed was great, but also full of challenges, mainly related to working remotely.</p>
<p>I worked on GHC between 30 and 40 hours a week (some weeks as little as 24 hours, but no less than that). Few weeks after I joined I started working on <a href="https://osa1.net/posts/2018-10-22-gc-work-presented.html">a new garbage collector</a> with a colleague. When I joined the project there were only type definitions in header files, and almost no code. I implemented the first sequential prototype of the new collector. After that we started collaborating more closely with my colleague while implementing the concurrent version. We found many bugs in both the design and implementation, and sorted out many edge cases during this time. I thoroughly enjoyed working on this project, even though it was clearly the most challenging project I ever worked on.</p>
<p>After the garbage collector I kept working as a maintainer until I left the company on a Sunday, Jun 21st, 2020. I made my last commit to <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3478">a merge request</a> that I was working on 21st.</p></li>
<li><p>On 22 Jun 2020 I joined <a href="https://dfinity.org/">DFINITY</a> to work on the <a href="https://sdk.dfinity.org/docs/language-guide/motoko.html">Motoko programming language</a>, and this is where the story ends.</p></li>
</ul>
<p>At the time of this writing I have 383 commits to GHC and I’m the 14th contributor with most commits. It feels bad to leave a project that I liked and contributed so much, but it’s also the right thing to do. After the GC was merged I started spending my time less and less productively, for many reasons, and I had lost my motivation to improve Haskell-the-language and GHC. Perhaps I can write more about these in another post.</p>]]></summary>
</entry>
<entry>
    <title>gdb breakpoints with conditions on backtrace</title>
    <link href="http://osa1.net/posts/2020-04-25-breakpoint-backtrace-conditionals.html" />
    <id>http://osa1.net/posts/2020-04-25-breakpoint-backtrace-conditionals.html</id>
    <published>2020-04-25T00:00:00Z</published>
    <updated>2020-04-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Being able so specify conditions in gdb breakpoints is quite useful. For example, if I’m interested in <code>mmap(NULL, ...)</code> calls I can do</p>
<pre><code>break mmap if addr == 0</code></pre>
<p>and gdb doesn’t break on <code>mmap</code> when the <code>addr == 0</code> condition doesn’t hold.</p>
<p>I’ve used this many times to great effect, but it’s not always sufficient, sometimes I need to break not when a variable or argument has a specific value but the function is called (directly or indirectly) from another function. For example, when debugging a GHC RTS issue I sometimes want to inspect <code>mmap</code> calls made by the garbage collector.</p>
<p>As far as I know this is not possible using the standard <code>break</code> syntax, but gdb provides a <a href="https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html">Python API</a> that allows setting breakpoints with conditions implemented in Python. Using this API it’s takes a few lines to implement this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> FrameBp(gdb.Breakpoint):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, spec, <span class="op">*</span>args, frame<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kwargs):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>        <span class="va">self</span>.frame <span class="op">=</span> frame</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        <span class="bu">super</span>(FrameBp, <span class="va">self</span>).<span class="fu">__init__</span>(spec, <span class="op">*</span>args, <span class="op">**</span>kwargs)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="kw">def</span> stop (<span class="va">self</span>):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        frame <span class="op">=</span> gdb.selected_frame().older()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="cf">while</span> frame:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>            <span class="cf">if</span> frame.name() <span class="op">==</span> <span class="va">self</span>.frame:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>            frame <span class="op">=</span> frame.older()</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">False</span></span></code></pre></div>
<p>When calling the constructor the first argument is the breakpoint specifier, which is basically the part after <code>break ...</code> in gdb’s break command. The <code>frame</code> argument is the function we look for before actually breaking. We only break if the function exists in the backtrace. Here’s an example use:</p>
<pre><code>&gt;&gt;&gt; python FrameBp(&quot;mmap&quot;, frame=&quot;GarbageCollect&quot;)
Breakpoint 1 at 0x7f3366243f00: file ../sysdeps/unix/sysv/linux/mmap64.c, line 44.</code></pre>
<p>This will only break on <code>mmap</code> if the backtrace has <code>GarbageCollect</code> at some point. An example backtrace when the breakpoint is hit:</p>
<pre><code>Breakpoint 1, __GI___mmap64 (addr=0x4200200000, len=1048576, prot=3, flags=50, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:44
44        if (offset &amp; MMAP_OFF_MASK)

&gt;&gt;&gt; bt
#0  __GI___mmap64 (addr=0x4200200000, len=1048576, prot=3, flags=50, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:44

...

#19 0x0000000003022c83 in GarbageCollect (collect_gen=0, do_heap_census=false, deadlock_detect=false, gc_type=0, cap=0x37ef500
&lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:449

...</code></pre>
<p>With some effort you could probably turn this into a proper gdb command and run it without the <code>python ...</code> part, but so far this works good enough for me.</p>]]></summary>
</entry>
<entry>
    <title>New blog post published on Well-Typed's blog</title>
    <link href="http://osa1.net/posts/2020-03-25-new-blog-post.html" />
    <id>http://osa1.net/posts/2020-03-25-new-blog-post.html</id>
    <published>2020-03-25T00:00:00Z</published>
    <updated>2020-03-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently published a new post on <a href="http://blog.well-typed.com/">Well-Typed’s blog</a>: <a href="http://www.well-typed.com/blog/2020/03/functions-in-compact-regions/">“The problem with adding functions to compact regions”</a>.</p>
<p>It’s also shared on <a href="https://twitter.com/welltyped/status/1242765765658447873">Twitter</a> and <a href="https://www.reddit.com/r/haskell/comments/foob2l/the_problem_with_adding_functions_to_compact/">/r/haskell</a>. If you have any questions/comments feel free to ping me in any of these places, or add a comment below!</p>]]></summary>
</entry>
<entry>
    <title>Knot-tying: two more examples, and an alternative</title>
    <link href="http://osa1.net/posts/2020-02-27-knot-tying-an-alternative.html" />
    <id>http://osa1.net/posts/2020-02-27-knot-tying-an-alternative.html</id>
    <published>2020-02-27T00:00:00Z</published>
    <updated>2020-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="/posts/2020-02-21-knot-tying-why-how-opinions.html">previous post</a> we’ve looked at a representation of expressions in a programming language, what the representation makes easy and where we have to use knot-tying.</p>
<p>In this post I’m going to give two more examples, using the same expression representation from the previous post, and then talk about how to implement our passes using a different representation, without knot-tying.</p>
<h1 id="example-attaching-typing-information-to-ids">Example: attaching typing information to Ids</h1>
<p>Previously we attached arity and unfolding information to <code>Id</code>s. Now suppose that our language is typed, and up to some point our transformations rely on typing information. Similar to arity and unfolding fields we add one more field to <code>Id</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  { <span class="op">..</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  ,<span class="ot"> idType ::</span> <span class="dt">Maybe</span> <span class="dt">Type</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>The <code>Maybe</code> part is because when we no longer need the types we want to be able to clear the type fields to make the AST smaller. While we have only one heap object per <code>Id</code>, in an average program there’s still a lot of different <code>Id</code>s, and <code>Type</code> representation can get quite large, so this is worthwhile. This makes the working set smaller, which causes less GC work and improves compiler performance.</p>
<p>In our cyclic AST representation the only way to implement this without losing sharing is with a full-pass over the entire program, using knot-tying. The code is similar to the ones in the previous post.</p>
<h1 id="example-attaching-unfoldings-to-ids">Example: attaching unfoldings to Ids</h1>
<p>Remember that in the previous post we represented the AST as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  }</span></code></pre></div>
<p>In this representation if I have a recursive definition like</p>
<pre><code>let fac = \x . if x then x * fac (x - 1) else 1 in fac 5</code></pre>
<p>In <code>fac</code> used in lambda body I want to be able to do <code>idUnfolding</code> and get the definition of this lambda. So the lambda refers to the <code>Id</code> for <code>fac</code>, and <code>fac</code> refers to the lambda in its <code>idUnfolding</code> field, forming a cycle.</p>
<p>In this representation only way to implement this is with knot-tying. An implementation that maintains a map from binders to their RHSs to update unfoldings of <code>Id</code>s in occurrence position does not work, because when we update an occurrence of the binder in its own RHS (i.e. in a recursive <code>let</code>) we end up invalidating the <code>RHS</code> that we’ve added to the map.</p>
<p>Here’s a knot-tying implementation that adds unfoldings (only the interesting bits):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>addUnfoldings <span class="ot">=</span> go M.empty</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    go ids e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (M.lookup (idName <span class="fu">id</span>) ids))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>      <span class="dt">Let</span> bndr rhs body <span class="ot">-&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>          ids&#39; <span class="ot">=</span> M.insert (idName bndr) bndr&#39; ids</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>          rhs&#39; <span class="ot">=</span> go ids&#39; rhs</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; }</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>          <span class="dt">Let</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; } rhs&#39; (go ids&#39; body)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>      <span class="op">...</span></span></code></pre></div>
<p>As before we tie the knot in <code>let</code> case and use it in <code>Id</code> case.</p>
<p>It’s also possible to initialize <code>idUnfolding</code> fields when parsing, using monadic knot-tying (<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Fix.html">MonadFix</a>). Full code is shown at the end of this post, but the interesting bit is when parsing <code>let</code>s and <code>Id</code>s:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">parseLet ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>parseLet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;let&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    id_name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;=&#39;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    (<span class="fu">id</span>, rhs) <span class="ot">&lt;-</span> mfix <span class="op">$</span> \ <span class="op">~</span>(id_, _rhs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>      modify (Map.insert id_name id_)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>      rhs <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>      <span class="fu">return</span> (<span class="dt">Id</span>{ idName <span class="ot">=</span> id_name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }, rhs)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;in&quot;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Let</span> <span class="fu">id</span> rhs body)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span class="ot">parseId&#39; ::</span> <span class="dt">Parser</span> <span class="dt">Id</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>parseId&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>    id_map <span class="ot">&lt;-</span> get</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>    <span class="kw">let</span> def <span class="ot">=</span> <span class="dt">Id</span>{ idName <span class="ot">=</span> name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>    <span class="fu">return</span> (fromMaybe def (Map.lookup name id_map))</span></code></pre></div>
<p>The idea is very similar. When parsing a <code>let</code> we add a thunk for the binder with correct unfolding to a map. The map is then used when parsing <code>Id</code>s in the RHS and body of the <code>let</code>.</p>
<h1 id="an-alternative">An alternative</h1>
<p>A well-known way of associating information with identifiers in a compiler is by using a “symbol table”. Instead of adding information about <code>Id</code>s directly in the <code>Id</code> fields, we maintain a table (or multiple tables) that map <code>Id</code>s to the relevant information. Here’s one way to do this in our language:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">String</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">IdInfo</span> <span class="ot">=</span> <span class="dt">IdInfo</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  {<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  }</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SymTbl</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">IdInfo</span></span></code></pre></div>
<p>In this representation we have to refer to the table for <code>idArity</code> or <code>idUnfolding</code>. That’s slightly more work than the previous representation where we could simply use the fields of an <code>Id</code>, but a lot of other things become much simpler and efficient.</p>
<p>Here’s <code>dropUnusedBindings</code> in this representation (only the interesting bits, full code is at the end of this post):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> <span class="dt">Expr</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="fu">fmap</span> <span class="fu">snd</span> <span class="op">.</span> go Set.empty</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    go free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>        <span class="kw">if</span> Set.member bndr free2 <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>          setIdArity bndr (countLambdas e1&#39;)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>          <span class="fu">return</span> (Set.delete bndr (Set.union free1 free2), <span class="dt">Let</span> bndr e1&#39; e2&#39;)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>        <span class="kw">else</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>          <span class="fu">return</span> (free2, e2&#39;)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>      <span class="op">...</span></span></code></pre></div>
<p>Our pass is now stateful (updates the symbol table) and written in monadic style. Knot-tying is gone. We update the symbol table after processing a <code>let</code> RHS. Because <code>Id</code>s no longer have the arity information we don’t need to update anything other than the symbol table.</p>
<p>It’s now trivial to implement <code>addUnfoldings</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>addUnfoldings e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="dt">IdE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>      addUnfoldings body</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>    <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>      addUnfoldings e3</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>    <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>      setIdUnfolding bndr e1</span></code></pre></div>
<p>Doing it during parsing is also trivial, and shown in the full code at the end of this post. Updating typing information when we no longer need them is simply</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">dropTypes ::</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>dropTypes <span class="ot">=</span> modify (Map.map (\id_info <span class="ot">-&gt;</span> id_info{ idType <span class="ot">=</span> <span class="dt">Nothing</span> }))</span></code></pre></div>
<p>We could also maintain a separate table for typing information, in which case all we had to do would be to stop using that table.</p>
<p>Easy!</p>
<h1 id="final-remarks">Final remarks</h1>
<p>Cyclic AST representation in a purely functional language necessitates knot-tying and relies on lazy evaluation. A well-known alternative is using symbol tables. It works across languages (does not rely on lazy evaluation) and keeps the code simple.</p>
<p>Cyclic representations make using the information easier, while symbol tables make updating easier. Code for updating the information is shown above and the previous post. For using the information, compare:</p>
<pre><code>-- Get the information in a cyclic representation
... (idUnfolding id) ...

-- Get the information using a symbol table
arity &lt;- getIdUnfolding id</code></pre>
<p>To me the monadic version is not too bad in terms of verbosity or convenience, especially because Haskell makes state passing so easy.</p>
<p>Some of the problems with knot-tying is as explained at the end of the <a href="/posts/2020-02-21-knot-tying-why-how-opinions.html">previous post</a>. What I did not mention in the previous post is the problems with efficiency, which are demonstrated better in this post.</p>
<ul>
<li><p>In the “typing information” example, with the cyclic representation I need to copy the entire AST to update every single <code>Id</code> occurrence and binder. With the symbol table I need to update just the table, which is much smaller than the AST.</p></li>
<li><p>In the unfolding example, with the cyclic representation I again need to copy the entire AST or use <code>MonadFix</code> if I’m doing it in parsing. With a symbol table the pass does not update the AST, only updates the table. If I’m doing it in parsing then I simply add an entry to the table after parsing a <code>let</code>. (full code at the end of this post)</p></li>
</ul>
<p>In use sites, <code>getIdArity</code> (a map lookup) does more work than <code>idArity</code> (just follows a pointer). While I don’t have any benchmarks on this, I doubt that this is bad enough to make cyclic representation and knot-tying preferable.</p>
<p>Examples in these two posts are inspired by GHC:</p>
<ul>
<li>GHC keeps information about <code>Id</code>s in an <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FbasicTypes%2FVar.hs#L251"><code>Id</code> field</a> with type <code>IdInfo</code>.</li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FbasicTypes%2FIdInfo.hs#L242-275"><code>IdInfo</code></a> type holds information like arity and unfolding.</li>
<li>For type information <code>Id</code> has another field: <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FbasicTypes%2FVar.hs#L248"><code>varType</code></a>.</li>
<li>The process of throwing away information that are no longer needed is called “zapping”. It happens in many places in GHC, one example is the tidying pass (prepares code for interface file generation) that <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FGHC%2FIface%2FTidy.hs#L1210">zaps unfoldings</a>.</li>
<li>Knot-tying is used in many places in the compiler, <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2Fmain%2FUpdateCafInfos.hs#L36">here’s an example</a> where we use knot-tying to update <code>IdInfo</code>s with code generator-generated information.</li>
</ul>
<p>In the first post I mostly argued that knot-tying makes things more complicated, and in this post I showed that knot-tying is necessary because of the cyclic representation. If we want to do the same without knot-tying we either have to introduce mutable references (e.g. <code>IORef</code>s) in our AST (not shown in this post), or have to use a non-cyclic representation with symbol tables.</p>
<p>Between these two representations, I think non-cyclic representation with symbol tables is a better choice.</p>
<details>
<p><summary>Full code (knot-tying)</summary></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">-- Tried with GHC 8.6.4</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a><span class="co">-- mtl-2.2</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a><span class="co">-- containers-0.6</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a><span class="co">-- megaparsec-7.0</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a><span class="co">-- pretty-show-1.10</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true"></a>  }</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true"></a></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">Id</span> name arity _) <span class="ot">=</span> <span class="st">&quot;(Id &quot;</span> <span class="op">++</span> <span class="fu">show</span> name <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="fu">show</span> arity <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true"></a></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true"></a><span class="co">-- Initializing unfolding fields in parse time via MonadFix</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true"></a></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">IdMap</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true"></a></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">String</span> <span class="dt">String</span> (<span class="dt">State</span> <span class="dt">IdMap</span>)</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true"></a></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true"></a><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true"></a>parseExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true"></a>    exprs <span class="ot">&lt;-</span> some <span class="op">$</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true"></a>      choice <span class="op">$</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true"></a>      <span class="fu">map</span> (\p <span class="ot">-&gt;</span> p <span class="op">&lt;*</span> space)</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true"></a>        [ parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true"></a>          parseLet, try parseId ]</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true"></a>    <span class="fu">return</span> (foldl1&#39; <span class="dt">App</span> exprs)</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true"></a></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true"></a>parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true"></a>  parseLet,<span class="ot"> parseId ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true"></a></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true"></a>parseParens <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;(&#39;</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true"></a>    space</span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true"></a>    expr <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true"></a>    <span class="fu">return</span> expr</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true"></a></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true"></a>parseIf <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;if&quot;</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true"></a>    space</span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true"></a>    condE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true"></a></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;then&quot;</span></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true"></a>    space</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true"></a>    thenE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;else&quot;</span></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true"></a>    space</span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true"></a>    elseE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IfE</span> condE thenE elseE)</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true"></a></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true"></a>parseLam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;\\&#39;</span></span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true"></a>    space</span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true"></a>    <span class="fu">id</span> <span class="ot">&lt;-</span> parseId&#39;</span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true"></a>    space</span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;.&#39;</span></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true"></a>    space</span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Lam</span> <span class="fu">id</span> body)</span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true"></a></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true"></a>parseInt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true"></a>    chars <span class="ot">&lt;-</span> some digitChar</span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IntE</span> (<span class="fu">read</span> chars))</span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true"></a></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true"></a>parseLet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;let&quot;</span></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true"></a>    space</span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true"></a>    id_name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true"></a>    space</span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;=&#39;</span></span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true"></a>    space</span>
<span id="cb11-107"><a href="#cb11-107" aria-hidden="true"></a></span>
<span id="cb11-108"><a href="#cb11-108" aria-hidden="true"></a>    (<span class="fu">id</span>, rhs) <span class="ot">&lt;-</span> mfix <span class="op">$</span> \ <span class="op">~</span>(id_, _rhs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-109"><a href="#cb11-109" aria-hidden="true"></a>      modify (Map.insert id_name id_)</span>
<span id="cb11-110"><a href="#cb11-110" aria-hidden="true"></a>      rhs <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-111"><a href="#cb11-111" aria-hidden="true"></a>      <span class="fu">return</span> (<span class="dt">Id</span>{ idName <span class="ot">=</span> id_name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }, rhs)</span>
<span id="cb11-112"><a href="#cb11-112" aria-hidden="true"></a></span>
<span id="cb11-113"><a href="#cb11-113" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;in&quot;</span></span>
<span id="cb11-114"><a href="#cb11-114" aria-hidden="true"></a>    space</span>
<span id="cb11-115"><a href="#cb11-115" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-116"><a href="#cb11-116" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Let</span> <span class="fu">id</span> rhs body)</span>
<span id="cb11-117"><a href="#cb11-117" aria-hidden="true"></a></span>
<span id="cb11-118"><a href="#cb11-118" aria-hidden="true"></a>parseId <span class="ot">=</span> <span class="dt">IdE</span> <span class="op">&lt;$&gt;</span> parseId&#39;</span>
<span id="cb11-119"><a href="#cb11-119" aria-hidden="true"></a></span>
<span id="cb11-120"><a href="#cb11-120" aria-hidden="true"></a><span class="ot">kws ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span></span>
<span id="cb11-121"><a href="#cb11-121" aria-hidden="true"></a>kws <span class="ot">=</span> Set.fromList [<span class="st">&quot;if&quot;</span>, <span class="st">&quot;then&quot;</span>, <span class="st">&quot;else&quot;</span>, <span class="st">&quot;let&quot;</span>, <span class="st">&quot;in&quot;</span>]</span>
<span id="cb11-122"><a href="#cb11-122" aria-hidden="true"></a></span>
<span id="cb11-123"><a href="#cb11-123" aria-hidden="true"></a><span class="ot">parseIdName ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb11-124"><a href="#cb11-124" aria-hidden="true"></a>parseIdName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-125"><a href="#cb11-125" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> some letterChar</span>
<span id="cb11-126"><a href="#cb11-126" aria-hidden="true"></a>    guard (<span class="fu">not</span> (Set.member name kws))</span>
<span id="cb11-127"><a href="#cb11-127" aria-hidden="true"></a>    <span class="fu">return</span> name</span>
<span id="cb11-128"><a href="#cb11-128" aria-hidden="true"></a></span>
<span id="cb11-129"><a href="#cb11-129" aria-hidden="true"></a><span class="ot">parseId&#39; ::</span> <span class="dt">Parser</span> <span class="dt">Id</span></span>
<span id="cb11-130"><a href="#cb11-130" aria-hidden="true"></a>parseId&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-131"><a href="#cb11-131" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb11-132"><a href="#cb11-132" aria-hidden="true"></a>    id_map <span class="ot">&lt;-</span> get</span>
<span id="cb11-133"><a href="#cb11-133" aria-hidden="true"></a>    <span class="kw">let</span> def <span class="ot">=</span> <span class="dt">Id</span>{ idName <span class="ot">=</span> name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb11-134"><a href="#cb11-134" aria-hidden="true"></a>    <span class="fu">return</span> (fromMaybe def (Map.lookup name id_map))</span>
<span id="cb11-135"><a href="#cb11-135" aria-hidden="true"></a></span>
<span id="cb11-136"><a href="#cb11-136" aria-hidden="true"></a><span class="ot">testPgm ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-137"><a href="#cb11-137" aria-hidden="true"></a>testPgm pgm <span class="ot">=</span></span>
<span id="cb11-138"><a href="#cb11-138" aria-hidden="true"></a>    <span class="kw">case</span> evalState (runParserT parseExpr <span class="st">&quot;&quot;</span> pgm) Map.empty <span class="kw">of</span></span>
<span id="cb11-139"><a href="#cb11-139" aria-hidden="true"></a>      <span class="dt">Left</span> (<span class="ot">err_bundle ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span></span>
<span id="cb11-140"><a href="#cb11-140" aria-hidden="true"></a>        <span class="fu">error</span> (errorBundlePretty err_bundle)</span>
<span id="cb11-141"><a href="#cb11-141" aria-hidden="true"></a>      <span class="dt">Right</span> expr <span class="ot">-&gt;</span></span>
<span id="cb11-142"><a href="#cb11-142" aria-hidden="true"></a>        expr</span>
<span id="cb11-143"><a href="#cb11-143" aria-hidden="true"></a></span>
<span id="cb11-144"><a href="#cb11-144" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> [<span class="dt">Char</span>] <span class="kw">where</span></span>
<span id="cb11-145"><a href="#cb11-145" aria-hidden="true"></a>    showErrorComponent x <span class="ot">=</span> x</span>
<span id="cb11-146"><a href="#cb11-146" aria-hidden="true"></a></span>
<span id="cb11-147"><a href="#cb11-147" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb11-148"><a href="#cb11-148" aria-hidden="true"></a><span class="co">-- Initializing unfoldings with knot-tying</span></span>
<span id="cb11-149"><a href="#cb11-149" aria-hidden="true"></a></span>
<span id="cb11-150"><a href="#cb11-150" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-151"><a href="#cb11-151" aria-hidden="true"></a>addUnfoldings <span class="ot">=</span> go Map.empty</span>
<span id="cb11-152"><a href="#cb11-152" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-153"><a href="#cb11-153" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-154"><a href="#cb11-154" aria-hidden="true"></a>    go ids e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb11-155"><a href="#cb11-155" aria-hidden="true"></a></span>
<span id="cb11-156"><a href="#cb11-156" aria-hidden="true"></a>      <span class="co">-- Interesting bits ------------------------------------------------------</span></span>
<span id="cb11-157"><a href="#cb11-157" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb11-158"><a href="#cb11-158" aria-hidden="true"></a>        <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (Map.lookup (idName <span class="fu">id</span>) ids))</span>
<span id="cb11-159"><a href="#cb11-159" aria-hidden="true"></a></span>
<span id="cb11-160"><a href="#cb11-160" aria-hidden="true"></a>      <span class="dt">Let</span> bndr rhs body <span class="ot">-&gt;</span></span>
<span id="cb11-161"><a href="#cb11-161" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb11-162"><a href="#cb11-162" aria-hidden="true"></a>          ids&#39; <span class="ot">=</span> Map.insert (idName bndr) bndr&#39; ids</span>
<span id="cb11-163"><a href="#cb11-163" aria-hidden="true"></a>          rhs&#39; <span class="ot">=</span> go ids&#39; rhs</span>
<span id="cb11-164"><a href="#cb11-164" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; }</span>
<span id="cb11-165"><a href="#cb11-165" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb11-166"><a href="#cb11-166" aria-hidden="true"></a>          <span class="dt">Let</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; } rhs&#39; (go ids&#39; body)</span>
<span id="cb11-167"><a href="#cb11-167" aria-hidden="true"></a>      <span class="co">--------------------------------------------------------------------------</span></span>
<span id="cb11-168"><a href="#cb11-168" aria-hidden="true"></a></span>
<span id="cb11-169"><a href="#cb11-169" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb11-170"><a href="#cb11-170" aria-hidden="true"></a>        e</span>
<span id="cb11-171"><a href="#cb11-171" aria-hidden="true"></a></span>
<span id="cb11-172"><a href="#cb11-172" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb11-173"><a href="#cb11-173" aria-hidden="true"></a>        <span class="dt">Lam</span> arg (go ids body)</span>
<span id="cb11-174"><a href="#cb11-174" aria-hidden="true"></a></span>
<span id="cb11-175"><a href="#cb11-175" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb11-176"><a href="#cb11-176" aria-hidden="true"></a>        <span class="dt">App</span> (go ids e1) (go ids e2)</span>
<span id="cb11-177"><a href="#cb11-177" aria-hidden="true"></a></span>
<span id="cb11-178"><a href="#cb11-178" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span></span>
<span id="cb11-179"><a href="#cb11-179" aria-hidden="true"></a>        <span class="dt">IfE</span> (go ids e1) (go ids e2) (go ids e3)</span></code></pre></div>
</details>
<details>
<p><summary>Full code (symbol table)</summary></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">-- Tried with GHC 8.6.4</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a><span class="co">-- mtl-2.2</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a><span class="co">-- containers-0.6</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="co">-- megaparsec-7.0</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a><span class="co">-- pretty-show-1.10</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">String</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">IdInfo</span> <span class="ot">=</span> <span class="dt">IdInfo</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>  {<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a>  ,<span class="ot"> idType ::</span> <span class="dt">Maybe</span> <span class="dt">Type</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a>    <span class="co">-- ^ Type of the id.</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a>  }</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Type</span> <span class="ot">=</span> <span class="dt">Type</span> <span class="co">-- Assume a large type</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true"></a></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">IdInfo</span> <span class="kw">where</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">IdInfo</span> arity _ _) <span class="ot">=</span> <span class="st">&quot;(IdInfo &quot;</span> <span class="op">++</span> <span class="fu">show</span> arity <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true"></a></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SymTbl</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">IdInfo</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true"></a></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true"></a><span class="ot">getIdInfo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> (<span class="dt">Maybe</span> <span class="dt">IdInfo</span>)</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true"></a>getIdInfo <span class="fu">id</span> <span class="ot">=</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true"></a>    Map.lookup <span class="fu">id</span> <span class="op">&lt;$&gt;</span> get</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true"></a></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true"></a><span class="ot">setIdArity ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true"></a>setIdArity <span class="fu">id</span> arity <span class="ot">=</span> modify (Map.alter alter <span class="fu">id</span>)</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true"></a>    alter <span class="dt">Nothing</span> <span class="ot">=</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true"></a>      <span class="dt">Just</span> <span class="dt">IdInfo</span>{ idArity <span class="ot">=</span> arity, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span>, idType <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true"></a>    alter (<span class="dt">Just</span> id_info) <span class="ot">=</span></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true"></a>      <span class="dt">Just</span> id_info{ idArity <span class="ot">=</span> arity }</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true"></a></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true"></a><span class="ot">setIdUnfolding ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true"></a>setIdUnfolding <span class="fu">id</span> unfolding <span class="ot">=</span> modify (Map.alter alter <span class="fu">id</span>)</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true"></a>    alter <span class="dt">Nothing</span> <span class="ot">=</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true"></a>      <span class="dt">Just</span> <span class="dt">IdInfo</span>{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> unfolding, idArity <span class="ot">=</span> <span class="dv">0</span>, idType <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true"></a>    alter (<span class="dt">Just</span> id_info) <span class="ot">=</span></span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true"></a>      <span class="dt">Just</span> id_info{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> unfolding }</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true"></a><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true"></a>countLambdas (<span class="dt">Lam</span> _ rhs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> countLambdas rhs</span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true"></a>countLambdas _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true"></a></span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> <span class="dt">Expr</span></span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true"></a>    <span class="fu">fmap</span> <span class="fu">snd</span> <span class="op">.</span> go Set.empty</span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true"></a>    go free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true"></a></span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb12-85"><a href="#cb12-85" aria-hidden="true"></a>        <span class="fu">return</span> (Set.insert <span class="fu">id</span> free_vars, e0)</span>
<span id="cb12-86"><a href="#cb12-86" aria-hidden="true"></a></span>
<span id="cb12-87"><a href="#cb12-87" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-88"><a href="#cb12-88" aria-hidden="true"></a>        <span class="fu">return</span> (free_vars, e0)</span>
<span id="cb12-89"><a href="#cb12-89" aria-hidden="true"></a></span>
<span id="cb12-90"><a href="#cb12-90" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-91"><a href="#cb12-91" aria-hidden="true"></a>        (free_vars&#39;, body&#39;) <span class="ot">&lt;-</span> go free_vars body</span>
<span id="cb12-92"><a href="#cb12-92" aria-hidden="true"></a>        <span class="fu">return</span> (Set.delete arg free_vars&#39;, <span class="dt">Lam</span> arg body&#39;)</span>
<span id="cb12-93"><a href="#cb12-93" aria-hidden="true"></a></span>
<span id="cb12-94"><a href="#cb12-94" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-95"><a href="#cb12-95" aria-hidden="true"></a>        (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb12-96"><a href="#cb12-96" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb12-97"><a href="#cb12-97" aria-hidden="true"></a>        <span class="fu">return</span> (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</span>
<span id="cb12-98"><a href="#cb12-98" aria-hidden="true"></a></span>
<span id="cb12-99"><a href="#cb12-99" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-100"><a href="#cb12-100" aria-hidden="true"></a>        (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb12-101"><a href="#cb12-101" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb12-102"><a href="#cb12-102" aria-hidden="true"></a>        (free3, e3&#39;) <span class="ot">&lt;-</span> go free_vars e3</span>
<span id="cb12-103"><a href="#cb12-103" aria-hidden="true"></a>        <span class="fu">return</span> (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</span>
<span id="cb12-104"><a href="#cb12-104" aria-hidden="true"></a></span>
<span id="cb12-105"><a href="#cb12-105" aria-hidden="true"></a>      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-106"><a href="#cb12-106" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb12-107"><a href="#cb12-107" aria-hidden="true"></a>        <span class="kw">if</span> Set.member bndr free2 <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb12-108"><a href="#cb12-108" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb12-109"><a href="#cb12-109" aria-hidden="true"></a>          trace (ppShow e1&#39;) (<span class="fu">return</span> ())</span>
<span id="cb12-110"><a href="#cb12-110" aria-hidden="true"></a>          setIdArity bndr (countLambdas e1&#39;)</span>
<span id="cb12-111"><a href="#cb12-111" aria-hidden="true"></a>          <span class="fu">return</span> (Set.delete bndr (Set.union free1 free2), <span class="dt">Let</span> bndr e1&#39; e2&#39;)</span>
<span id="cb12-112"><a href="#cb12-112" aria-hidden="true"></a>        <span class="kw">else</span></span>
<span id="cb12-113"><a href="#cb12-113" aria-hidden="true"></a>          <span class="fu">return</span> (free2, e2&#39;)</span>
<span id="cb12-114"><a href="#cb12-114" aria-hidden="true"></a></span>
<span id="cb12-115"><a href="#cb12-115" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-116"><a href="#cb12-116" aria-hidden="true"></a>addUnfoldings e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb12-117"><a href="#cb12-117" aria-hidden="true"></a></span>
<span id="cb12-118"><a href="#cb12-118" aria-hidden="true"></a>    <span class="dt">IdE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-119"><a href="#cb12-119" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb12-120"><a href="#cb12-120" aria-hidden="true"></a></span>
<span id="cb12-121"><a href="#cb12-121" aria-hidden="true"></a>    <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-122"><a href="#cb12-122" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb12-123"><a href="#cb12-123" aria-hidden="true"></a></span>
<span id="cb12-124"><a href="#cb12-124" aria-hidden="true"></a>    <span class="dt">Lam</span> _ body <span class="ot">-&gt;</span></span>
<span id="cb12-125"><a href="#cb12-125" aria-hidden="true"></a>      addUnfoldings body</span>
<span id="cb12-126"><a href="#cb12-126" aria-hidden="true"></a></span>
<span id="cb12-127"><a href="#cb12-127" aria-hidden="true"></a>    <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-128"><a href="#cb12-128" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb12-129"><a href="#cb12-129" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb12-130"><a href="#cb12-130" aria-hidden="true"></a></span>
<span id="cb12-131"><a href="#cb12-131" aria-hidden="true"></a>    <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-132"><a href="#cb12-132" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb12-133"><a href="#cb12-133" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb12-134"><a href="#cb12-134" aria-hidden="true"></a>      addUnfoldings e3</span>
<span id="cb12-135"><a href="#cb12-135" aria-hidden="true"></a></span>
<span id="cb12-136"><a href="#cb12-136" aria-hidden="true"></a>    <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-137"><a href="#cb12-137" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb12-138"><a href="#cb12-138" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb12-139"><a href="#cb12-139" aria-hidden="true"></a>      setIdUnfolding bndr e1</span>
<span id="cb12-140"><a href="#cb12-140" aria-hidden="true"></a></span>
<span id="cb12-141"><a href="#cb12-141" aria-hidden="true"></a><span class="ot">dropTypes ::</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-142"><a href="#cb12-142" aria-hidden="true"></a>dropTypes <span class="ot">=</span> modify (Map.map (\id_info <span class="ot">-&gt;</span> id_info{ idType <span class="ot">=</span> <span class="dt">Nothing</span> }))</span>
<span id="cb12-143"><a href="#cb12-143" aria-hidden="true"></a></span>
<span id="cb12-144"><a href="#cb12-144" aria-hidden="true"></a><span class="ot">pgm ::</span> <span class="dt">Expr</span></span>
<span id="cb12-145"><a href="#cb12-145" aria-hidden="true"></a>pgm <span class="ot">=</span> <span class="dt">Let</span> <span class="st">&quot;fac&quot;</span> rhs body</span>
<span id="cb12-146"><a href="#cb12-146" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-147"><a href="#cb12-147" aria-hidden="true"></a>    rhs <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">IfE</span> (<span class="dt">IdE</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;*&quot;</span>) (<span class="dt">IdE</span> <span class="st">&quot;x&quot;</span>))</span>
<span id="cb12-148"><a href="#cb12-148" aria-hidden="true"></a>                                      (<span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;fac&quot;</span>)</span>
<span id="cb12-149"><a href="#cb12-149" aria-hidden="true"></a>                                           (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;-&quot;</span>) (<span class="dt">IdE</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb12-150"><a href="#cb12-150" aria-hidden="true"></a>                                 (<span class="dt">IntE</span> <span class="dv">1</span>))</span>
<span id="cb12-151"><a href="#cb12-151" aria-hidden="true"></a>    body <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;fac&quot;</span>) (<span class="dt">IntE</span> <span class="dv">5</span>)</span>
<span id="cb12-152"><a href="#cb12-152" aria-hidden="true"></a></span>
<span id="cb12-153"><a href="#cb12-153" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb12-154"><a href="#cb12-154" aria-hidden="true"></a><span class="co">-- Initializing unfolding fields in parse time, the boring way</span></span>
<span id="cb12-155"><a href="#cb12-155" aria-hidden="true"></a></span>
<span id="cb12-156"><a href="#cb12-156" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">String</span> <span class="dt">String</span> (<span class="dt">State</span> <span class="dt">SymTbl</span>)</span>
<span id="cb12-157"><a href="#cb12-157" aria-hidden="true"></a></span>
<span id="cb12-158"><a href="#cb12-158" aria-hidden="true"></a><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb12-159"><a href="#cb12-159" aria-hidden="true"></a>parseExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-160"><a href="#cb12-160" aria-hidden="true"></a>    exprs <span class="ot">&lt;-</span> some <span class="op">$</span></span>
<span id="cb12-161"><a href="#cb12-161" aria-hidden="true"></a>      choice <span class="op">$</span></span>
<span id="cb12-162"><a href="#cb12-162" aria-hidden="true"></a>      <span class="fu">map</span> (\p <span class="ot">-&gt;</span> p <span class="op">&lt;*</span> space)</span>
<span id="cb12-163"><a href="#cb12-163" aria-hidden="true"></a>        [ parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb12-164"><a href="#cb12-164" aria-hidden="true"></a>          parseLet, try parseId ]</span>
<span id="cb12-165"><a href="#cb12-165" aria-hidden="true"></a>    <span class="fu">return</span> (foldl1&#39; <span class="dt">App</span> exprs)</span>
<span id="cb12-166"><a href="#cb12-166" aria-hidden="true"></a></span>
<span id="cb12-167"><a href="#cb12-167" aria-hidden="true"></a>parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb12-168"><a href="#cb12-168" aria-hidden="true"></a>  parseLet,<span class="ot"> parseId ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb12-169"><a href="#cb12-169" aria-hidden="true"></a></span>
<span id="cb12-170"><a href="#cb12-170" aria-hidden="true"></a>parseParens <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-171"><a href="#cb12-171" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;(&#39;</span></span>
<span id="cb12-172"><a href="#cb12-172" aria-hidden="true"></a>    space</span>
<span id="cb12-173"><a href="#cb12-173" aria-hidden="true"></a>    expr <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-174"><a href="#cb12-174" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb12-175"><a href="#cb12-175" aria-hidden="true"></a>    <span class="fu">return</span> expr</span>
<span id="cb12-176"><a href="#cb12-176" aria-hidden="true"></a></span>
<span id="cb12-177"><a href="#cb12-177" aria-hidden="true"></a>parseIf <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-178"><a href="#cb12-178" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;if&quot;</span></span>
<span id="cb12-179"><a href="#cb12-179" aria-hidden="true"></a>    space</span>
<span id="cb12-180"><a href="#cb12-180" aria-hidden="true"></a>    condE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-181"><a href="#cb12-181" aria-hidden="true"></a></span>
<span id="cb12-182"><a href="#cb12-182" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;then&quot;</span></span>
<span id="cb12-183"><a href="#cb12-183" aria-hidden="true"></a>    space</span>
<span id="cb12-184"><a href="#cb12-184" aria-hidden="true"></a>    thenE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-185"><a href="#cb12-185" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;else&quot;</span></span>
<span id="cb12-186"><a href="#cb12-186" aria-hidden="true"></a>    space</span>
<span id="cb12-187"><a href="#cb12-187" aria-hidden="true"></a>    elseE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-188"><a href="#cb12-188" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IfE</span> condE thenE elseE)</span>
<span id="cb12-189"><a href="#cb12-189" aria-hidden="true"></a></span>
<span id="cb12-190"><a href="#cb12-190" aria-hidden="true"></a>parseLam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-191"><a href="#cb12-191" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;\\&#39;</span></span>
<span id="cb12-192"><a href="#cb12-192" aria-hidden="true"></a>    space</span>
<span id="cb12-193"><a href="#cb12-193" aria-hidden="true"></a>    <span class="fu">id</span> <span class="ot">&lt;-</span> parseId&#39;</span>
<span id="cb12-194"><a href="#cb12-194" aria-hidden="true"></a>    space</span>
<span id="cb12-195"><a href="#cb12-195" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;.&#39;</span></span>
<span id="cb12-196"><a href="#cb12-196" aria-hidden="true"></a>    space</span>
<span id="cb12-197"><a href="#cb12-197" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-198"><a href="#cb12-198" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Lam</span> <span class="fu">id</span> body)</span>
<span id="cb12-199"><a href="#cb12-199" aria-hidden="true"></a></span>
<span id="cb12-200"><a href="#cb12-200" aria-hidden="true"></a>parseInt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-201"><a href="#cb12-201" aria-hidden="true"></a>    chars <span class="ot">&lt;-</span> some digitChar</span>
<span id="cb12-202"><a href="#cb12-202" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IntE</span> (<span class="fu">read</span> chars))</span>
<span id="cb12-203"><a href="#cb12-203" aria-hidden="true"></a></span>
<span id="cb12-204"><a href="#cb12-204" aria-hidden="true"></a>parseLet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-205"><a href="#cb12-205" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;let&quot;</span></span>
<span id="cb12-206"><a href="#cb12-206" aria-hidden="true"></a>    space</span>
<span id="cb12-207"><a href="#cb12-207" aria-hidden="true"></a>    <span class="fu">id</span> <span class="ot">&lt;-</span> parseId&#39;</span>
<span id="cb12-208"><a href="#cb12-208" aria-hidden="true"></a>    space</span>
<span id="cb12-209"><a href="#cb12-209" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;=&#39;</span></span>
<span id="cb12-210"><a href="#cb12-210" aria-hidden="true"></a>    space</span>
<span id="cb12-211"><a href="#cb12-211" aria-hidden="true"></a>    rhs <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-212"><a href="#cb12-212" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;in&quot;</span></span>
<span id="cb12-213"><a href="#cb12-213" aria-hidden="true"></a>    space</span>
<span id="cb12-214"><a href="#cb12-214" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-215"><a href="#cb12-215" aria-hidden="true"></a>    lift (setIdUnfolding <span class="fu">id</span> rhs)</span>
<span id="cb12-216"><a href="#cb12-216" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Let</span> <span class="fu">id</span> rhs body)</span>
<span id="cb12-217"><a href="#cb12-217" aria-hidden="true"></a></span>
<span id="cb12-218"><a href="#cb12-218" aria-hidden="true"></a>parseId <span class="ot">=</span> <span class="dt">IdE</span> <span class="op">&lt;$&gt;</span> parseId&#39;</span>
<span id="cb12-219"><a href="#cb12-219" aria-hidden="true"></a></span>
<span id="cb12-220"><a href="#cb12-220" aria-hidden="true"></a><span class="ot">kws ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span></span>
<span id="cb12-221"><a href="#cb12-221" aria-hidden="true"></a>kws <span class="ot">=</span> Set.fromList [<span class="st">&quot;if&quot;</span>, <span class="st">&quot;then&quot;</span>, <span class="st">&quot;else&quot;</span>, <span class="st">&quot;let&quot;</span>, <span class="st">&quot;in&quot;</span>]</span>
<span id="cb12-222"><a href="#cb12-222" aria-hidden="true"></a></span>
<span id="cb12-223"><a href="#cb12-223" aria-hidden="true"></a><span class="ot">parseId&#39; ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb12-224"><a href="#cb12-224" aria-hidden="true"></a>parseId&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-225"><a href="#cb12-225" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> some letterChar</span>
<span id="cb12-226"><a href="#cb12-226" aria-hidden="true"></a>    guard (<span class="fu">not</span> (Set.member name kws))</span>
<span id="cb12-227"><a href="#cb12-227" aria-hidden="true"></a>    <span class="fu">return</span> name</span>
<span id="cb12-228"><a href="#cb12-228" aria-hidden="true"></a></span>
<span id="cb12-229"><a href="#cb12-229" aria-hidden="true"></a><span class="ot">testPgm ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb12-230"><a href="#cb12-230" aria-hidden="true"></a>testPgm pgm <span class="ot">=</span></span>
<span id="cb12-231"><a href="#cb12-231" aria-hidden="true"></a>    <span class="kw">case</span> evalState (runParserT parseExpr <span class="st">&quot;&quot;</span> pgm) Map.empty <span class="kw">of</span></span>
<span id="cb12-232"><a href="#cb12-232" aria-hidden="true"></a>      <span class="dt">Left</span> (<span class="ot">err_bundle ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span></span>
<span id="cb12-233"><a href="#cb12-233" aria-hidden="true"></a>        <span class="fu">error</span> (errorBundlePretty err_bundle)</span>
<span id="cb12-234"><a href="#cb12-234" aria-hidden="true"></a>      <span class="dt">Right</span> expr <span class="ot">-&gt;</span></span>
<span id="cb12-235"><a href="#cb12-235" aria-hidden="true"></a>        expr</span>
<span id="cb12-236"><a href="#cb12-236" aria-hidden="true"></a></span>
<span id="cb12-237"><a href="#cb12-237" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> [<span class="dt">Char</span>] <span class="kw">where</span></span>
<span id="cb12-238"><a href="#cb12-238" aria-hidden="true"></a>    showErrorComponent x <span class="ot">=</span> x</span></code></pre></div>
</details>]]></summary>
</entry>
<entry>
    <title>Knot-tying: why and how (and my opinions on it)</title>
    <link href="http://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html" />
    <id>http://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html</id>
    <published>2020-02-21T00:00:00Z</published>
    <updated>2020-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Suppose I have this simple language:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>When generating code, for an identifier that stands for a lambda, I want to know the arity of the lambda, so that I can generate more efficient code. While in this language a lambda takes only one argument, if I have something like</p>
<pre><code>let f = \x . \y . \z . ...
 in ...</code></pre>
<p>I consider <code>f</code> as having arity 3.</p>
<p>One way to implement this is having this information attached to every <code>Id</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  }</span></code></pre></div>
<p>This way of associating information to <code>Id</code>s makes some things very simple. For example, if I’m generating code for this application:</p>
<pre><code>f 1 2</code></pre>
<p>In AST:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="ot">=</span> <span class="dv">3</span> })) (<span class="dt">IntE</span> <span class="dv">1</span>)) (<span class="dt">IntE</span> <span class="dv">2</span>)</span></code></pre></div>
<p>I can simply use the <code>idArity</code> field to see the arity of the function being applied. It doesn’t get any simpler than this.</p>
<h1 id="problem-1-redundant-allocations">Problem 1: redundant allocations</h1>
<p>In a program we usually have many references to a single Id, whether it’s for a top-level function or an argument. If we allocate an Id for every occurrence that’s a lot of redundant allocations that make the AST representation larger, and affects compiler performance.</p>
<p>For example, if I have this expression:</p>
<pre><code>f x + f y</code></pre>
<p>A naive representation of this would be</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">App</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }))</span></code></pre></div>
<p>Here for every occurrence of <code>f</code> we have a new <code>Id</code>, and these <code>Id</code>s all have the same arity. This is two <code>Id</code> heap objects used for the same identifier.</p>
<p>A more efficient representation would be</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">let</span> f <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="kw">in</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="dt">App</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> f)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>     (<span class="dt">IdE</span> f)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }))</span></code></pre></div>
<p>Here we only have one heap object for <code>f</code>, and all uses refer to that one object.</p>
<p>This is actually not hard to fix: we maintain a map from <code>Id</code> names to the actual <code>Id</code>s. When we see a <code>let</code> we add the LHS to the map. When we see an identifier we lookup. Easy.</p>
<h1 id="problem-2-invalidating-the-information-during-transformations">Problem 2: invalidating the information during transformations</h1>
<p>Suppose I want to implement a pass that drops unused bindings. For example:</p>
<pre><code>let f = let a = e1
         in \x . e2
 in f z + f t</code></pre>
<p>Here if <code>e2</code> doesn’t use <code>a</code> I want to drop the binding:</p>
<pre><code>let f = \x . e2
 in f z + f t</code></pre>
<p>The AST for the original program is:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  (<span class="dt">Let</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>     <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;a&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>     <span class="op">&lt;</span>e1<span class="op">&gt;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>     (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="op">&lt;</span>e2<span class="op">&gt;</span>))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span></code></pre></div>
<p>Here’s a naive implementation of this pass:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> go Set.empty</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    go free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>        (Set.insert (idName <span class="fu">id</span>) free_vars, e0)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>        (free_vars, e0)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>        bimap (Set.delete (idName arg)) (<span class="dt">Lam</span> arg)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>              (go free_vars body)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go free_vars e1</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go free_vars e2</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>          (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go free_vars e1</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go free_vars e2</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a>          (free3, e3&#39;) <span class="ot">=</span> go free_vars e3</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>          (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> first (Set.delete (idName bndr)) (go free_vars e1)</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go free_vars e2</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a>          <span class="kw">if</span> Set.member (idName bndr) free2</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a>            <span class="kw">then</span> (Set.delete (idName bndr) (Set.union free1 free2),</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>                  <span class="dt">Let</span> (updateIdArity bndr e1&#39;) e1&#39; e2&#39;)</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>            <span class="kw">else</span> (free2, e2&#39;)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a>updateIdArity <span class="fu">id</span> rhs <span class="ot">=</span> <span class="fu">id</span>{ idArity <span class="ot">=</span> countLambdas rhs }</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a>countLambdas (<span class="dt">Lam</span> _ rhs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> countLambdas rhs</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a>countLambdas _ <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>The problem with this pass is that it changes arity of binders, but doesn’t update the <code>idArity</code>s of occurrences. Here’s what I get if I run this over the original AST:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">1</span> }</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="op">&lt;</span>e2<span class="op">&gt;</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span></code></pre></div>
<p>Note how <code>f</code>, which was not a lambda binder previously, became a lambda binder with arity 1. The pass correctly updated <code>f</code>’s <code>idArity</code> in the binder position, but it did not update it in the occurrences! Indeed, in this representation it’s not easy to do this efficiently.</p>
<p>Even if we solved the first problem and had only one closure for <code>f</code>, the <code>updateIdArity</code> step in this pass allocates a new <code>Id</code> and loses sharing. So we would end up with something like:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">let</span> f <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="kw">in</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">1</span> }</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="op">&lt;</span>e2<span class="op">&gt;</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>           (<span class="dt">IdE</span> f)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>        (<span class="dt">IdE</span> f)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span></code></pre></div>
<p>The arity of <code>f</code> in the use sites are still wrong, and we lost sharing.</p>
<h1 id="knot-tying">Knot-tying</h1>
<p>Knot-tying is a way of solving both of these in one step. I find it quite hard to explain in words so I’ll show the code (only the interesting bits):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="fu">snd</span> <span class="op">.</span> go Map.empty Set.empty</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    go binders free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>        (Set.insert (idName <span class="fu">id</span>) free_vars, <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (Map.lookup (idName <span class="fu">id</span>) binders)))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>      <span class="dt">Let</span> bndr<span class="op">@</span><span class="dt">Id</span>{ idName <span class="ot">=</span> bndr_name } e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> updateIdArity bndr e1&#39;</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>          binders&#39; <span class="ot">=</span> Map.insert bndr_name bndr&#39; binders</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> first (Set.delete bndr_name) (go binders&#39; free_vars e1)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders&#39; free_vars e2</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>          <span class="kw">if</span> Set.member bndr_name free2</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>            <span class="kw">then</span> (Set.delete bndr_name (Set.union free1 free2),</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>                  <span class="dt">Let</span> bndr&#39; e1&#39; e2&#39;)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>            <span class="kw">else</span> (free2, e2&#39;)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>      <span class="op">...</span></span></code></pre></div>
<p>The differences from the original version:</p>
<ul>
<li><p>We now pass around a “binders” map that maps identifier names to actual <code>Id</code>s. This is used to common-up uses of identifiers with one shared heap object with correct arity info.</p></li>
<li><p>In <code>IdE</code> case we now do lookup on this map, and replace the <code>Id</code> with the shared <code>Id</code> with correct arity info from the map.</p></li>
<li><p>The tricky bit is the <code>Let</code> case where we have a cyclic group of let bindings. <code>binders'</code> is the binder map with <code>bndr</code> with correct arity information. However to be able to generate that map we first need to process <code>e1</code>, and while processing <code>e1</code> we want to replace any occurrences of <code>bndr</code> with correct <code>Id</code> too! This gives us the cyclic bindings:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>bndr&#39; <span class="ot">=</span> updateIdArity bndr e1&#39;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>binders&#39; <span class="ot">=</span> Map.insert bndr_name bndr&#39; binders</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>(<span class="op">...</span>, e1&#39;) <span class="ot">=</span> <span class="op">...</span> (go binders&#39; free_vars e1)</span></code></pre></div></li>
</ul>
<p>This technique relies heavily on lazy evaluation. In the original example the AST is not recursive, but suppose we also want to record RHSs of let binders in <code>Id</code>s, to be used for inlining:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  { <span class="op">...</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a let binding, used for inlining</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  }</span></code></pre></div>
<p>Now once we implement sharing (solving problem 1) ASTs with recursive definitions will become cyclic. A simple example:</p>
<pre><code>let fac = \x . if x then x * fac (x - 1) else 1 in fac 5</code></pre>
<p>This will be represented as something like</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>pgm <span class="ot">=</span> <span class="dt">Let</span> fac_id rhs body</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    fac_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;fac&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    rhs <span class="ot">=</span> <span class="dt">Lam</span> x_id (<span class="dt">IfE</span> (<span class="dt">IdE</span> x_id)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>                        (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> star_id) (<span class="dt">IdE</span> x_id))</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>                             (<span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> minus_id) (<span class="dt">IdE</span> x_id))</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>                                                    (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>                                  (<span class="dt">IntE</span> <span class="dv">1</span>))</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    body <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">IntE</span> <span class="dv">5</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    x_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>    star_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;*&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>    minus_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;-&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span></code></pre></div>
<p>Here <code>fac_id</code> refers to <code>rhs</code>, which refers to <code>fac_id</code>, forming a cycle.</p>
<p>The knot-tying implementation of <code>dropUnusedBindings</code> works even in cases like this. We just need to update <code>updateIdArity</code> to update the unfolding, when it’s available:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>updateIdArity <span class="fu">id</span> rhs <span class="ot">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="fu">id</span>{ idArity <span class="ot">=</span> countLambdas rhs</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>      , idUnfolding <span class="ot">=</span> idUnfolding <span class="fu">id</span> <span class="op">$&gt;</span> rhs }</span></code></pre></div>
<p>This is a bit hard to try, but if I implement a <code>Show</code> instance for <code>Id</code> that doesn’t print the unfolding (to avoid looping), make <code>fac_id</code>’s arity <code>0</code>, and call <code>dropUnusedBindings</code> this is the AST I get:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  (<span class="dt">Lam</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>     (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>     (<span class="dt">IfE</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>))</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>           (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;*&quot;</span> <span class="dv">2</span>)) (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>)))</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>           (<span class="dt">App</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>              (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>))</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>              (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;-&quot;</span> <span class="dv">2</span>)) (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>))) (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>        (<span class="dt">IntE</span> <span class="dv">1</span>)))</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>  (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>)) (<span class="dt">IntE</span> <span class="dv">5</span>))</span></code></pre></div>
<p>All uses of <code>fac</code> have correct arity! Similarly I can do something hacky like this in GHCi to check that the unfolding has correct arity for uses of <code>fac</code> too:</p>
<pre><code>ghci&gt; let Let lhs _ _ = dropUnusedBindings pgm
ghci&gt; putStrLn (ppShow (idUnfolding lhs))
Just
  (Lam
     (Id &quot;x&quot; 0)
     (IfE
        (IdE (Id &quot;x&quot; 0))
        (App
           (App (IdE (Id &quot;*&quot; 2)) (IdE (Id &quot;x&quot; 0)))
           (App
              (IdE (Id &quot;fac&quot; 1))
              (App (App (IdE (Id &quot;-&quot; 2)) (IdE (Id &quot;x&quot; 0))) (IntE 1))))
        (IntE 1)))</code></pre>
<p>Nice!</p>
<h1 id="or-is-it">… or is it?</h1>
<p>The main problem with this technique is that it’s very difficult to understand. Even after working on different knot-tying code in GHC and implementing my own knot-tying passes, the recursive let bindings in the <code>Let</code> case above is still mind-boggling to me.</p>
<p>Secondly, it’s really hard to reason about the evaluation order of things in knot-tying code. You might think that this shouldn’t be an issue in a purely functional implementation, but in my experience any non-trivial compiler pass, even when implemented in a purely functional style, still needs debugging. Even if it’s not buggy, you may want to trace the evaluation and print a few things to understand how the code works.</p>
<p>Knot-tying code makes this, which should be absolutely trivial in any reasonable code base, very difficult. If you end up evaluating just the right places with your print statements you end looping. For example, here’s our AST with a few bang patterns:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="op">!</span><span class="dt">Id</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="op">!</span><span class="dt">Expr</span> <span class="op">!</span><span class="dt">Expr</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="op">!</span><span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>  }</span></code></pre></div>
<p>If you run the same program above using this AST definition you’ll see that the pass now loops. Note that I’ve removed the <code>idUnfolding</code> field just to demonstrate that this doesn’t happen because we have a loop in the AST.</p>
<p>It’s even more frustrating when what you’re debugging is a loop. You add a few prints, and scratch your head thinking why none of your prints are working even though the algorithm is clearly looping. What’s really happening is that the code is indeed looping, but for a different reason…</p>
<p>Finally, because making things more strict potentially breaks things, knot-tying makes fixing some memory leaks very hard. For example, we may have many passes on our AST, one of them being our knot-tying pass. Some of these passes may be very leaky, and instead of adding strict applications or bang patterns to dozens of places, we may want to add bangs to only a few places in the AST. But that, as demonstrated above, causes our knot-tying pass to loop.</p>
<h1 id="opinions">Opinions</h1>
<p>GHC makes use of knot-tying extensively, which has always been one of the pain points for me since my first days contributing to GHC. I vaguely remember, I was a graduate student at Indiana University at the time, making my first contributions to GHC. I remember finding it refreshing to be able to simply do <code>idType</code> and get type of an identifier in GHC, as opposed to using a symbol table, which I’d been doing in some of the other compilers I worked on in the past.</p>
<p>At the same time, I was constantly confused that my simple print statements added in some front-end pass makes the compiler loop. I had no idea what could be the reason. I had no idea that the thing I found so refreshing is also the reason why debugging and tracing were so much harder.</p>
<p>Suffice it to say, I don’t like knot-tying. If I had to use knot-tying in my project I’d probably reconsider how I represent my data instead. For example, if we simply used an unique number for our identifiers and maintained a symbol table to map the unique numbers to actual <code>Id</code>s then we wouldn’t have cycles for recursive functions in the AST and wouldn’t need knot-tying. Updating something about an <code>Id</code> would be a simple update in the symbol table.</p>
<details>
<p><summary>Full code</summary></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">-- Tried with GHC 8.6.4</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Functor</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span class="co">-- containers-0.6</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a><span class="co">-- pretty-show-1.10</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a><span class="co">data Expr</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a><span class="co">  = IdE !Id</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a><span class="co">  | IntE Int</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a><span class="co">  | Lam Id Expr</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a><span class="co">  | App !Expr !Expr</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a><span class="co">  | IfE Expr !Expr Expr</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a><span class="co">  | Let Id Expr Expr</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true"></a><span class="co">  | Placeholder String</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true"></a><span class="co">  deriving (Show)</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true"></a></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true"></a><span class="co">data Id = Id</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true"></a><span class="co">  { idName :: String</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true"></a><span class="co">    -- ^ Unique name of the identifier</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true"></a><span class="co">  , idArity :: !Int</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true"></a><span class="co">    -- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true"></a><span class="co">  }</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true"></a></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Placeholder</span> <span class="dt">String</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true"></a></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true"></a>  }</span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true"></a></span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">Id</span> name arity _) <span class="ot">=</span> <span class="st">&quot;(Id &quot;</span> <span class="op">++</span> <span class="fu">show</span> name <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="fu">show</span> arity <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true"></a></span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true"></a><span class="co">f_id = Id { idName = &quot;f&quot;, idArity = 0 }</span></span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true"></a><span class="co">a_id = Id { idName = &quot;a&quot;, idArity = 0 }</span></span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true"></a><span class="co">x_id = Id { idName = &quot;x&quot;, idArity = 0 }</span></span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true"></a><span class="co">z_id = Id { idName = &quot;z&quot;, idArity = 0 }</span></span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true"></a><span class="co">t_id = Id { idName = &quot;t&quot;, idArity = 0 }</span></span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true"></a><span class="co">plus_id = Id { idName = &quot;+&quot;, idArity = 2 }</span></span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true"></a></span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true"></a></span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true"></a><span class="co">f_x_plus_f_y = (App (App (IdE plus_id) (App (IdE f_id) (IdE z_id)))</span></span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true"></a><span class="co">                     (App (IdE f_id) (IdE t_id)))</span></span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true"></a></span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true"></a><span class="co">ast1 = Let f_id (Let a_id (Placeholder &quot;e1&quot;) (Lam x_id (Placeholder &quot;e2&quot;))) f_x_plus_f_y</span></span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true"></a></span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true"></a><span class="co">ast2 = Let a_id (Placeholder &quot;e1&quot;)</span></span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true"></a><span class="co">           (Let f_id (Lam x_id (Placeholder &quot;e2&quot;))</span></span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true"></a><span class="co">                     f_x_plus_f_y)</span></span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb24-78"><a href="#cb24-78" aria-hidden="true"></a></span>
<span id="cb24-79"><a href="#cb24-79" aria-hidden="true"></a><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></span>
<span id="cb24-80"><a href="#cb24-80" aria-hidden="true"></a>updateIdArity <span class="fu">id</span> rhs <span class="ot">=</span></span>
<span id="cb24-81"><a href="#cb24-81" aria-hidden="true"></a>  <span class="fu">id</span>{ idArity <span class="ot">=</span> countLambdas rhs,</span>
<span id="cb24-82"><a href="#cb24-82" aria-hidden="true"></a>      idUnfolding <span class="ot">=</span> idUnfolding <span class="fu">id</span> <span class="op">$&gt;</span> rhs }</span>
<span id="cb24-83"><a href="#cb24-83" aria-hidden="true"></a></span>
<span id="cb24-84"><a href="#cb24-84" aria-hidden="true"></a><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-85"><a href="#cb24-85" aria-hidden="true"></a>countLambdas (<span class="dt">Lam</span> _ rhs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> countLambdas rhs</span>
<span id="cb24-86"><a href="#cb24-86" aria-hidden="true"></a>countLambdas _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb24-87"><a href="#cb24-87" aria-hidden="true"></a></span>
<span id="cb24-88"><a href="#cb24-88" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb24-89"><a href="#cb24-89" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb24-90"><a href="#cb24-90" aria-hidden="true"></a>    <span class="fu">snd</span> <span class="op">.</span> go Map.empty Set.empty</span>
<span id="cb24-91"><a href="#cb24-91" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb24-92"><a href="#cb24-92" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb24-93"><a href="#cb24-93" aria-hidden="true"></a>    go binders free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb24-94"><a href="#cb24-94" aria-hidden="true"></a></span>
<span id="cb24-95"><a href="#cb24-95" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb24-96"><a href="#cb24-96" aria-hidden="true"></a>        (Set.insert (idName <span class="fu">id</span>) free_vars, <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (Map.lookup (idName <span class="fu">id</span>) binders)))</span>
<span id="cb24-97"><a href="#cb24-97" aria-hidden="true"></a></span>
<span id="cb24-98"><a href="#cb24-98" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb24-99"><a href="#cb24-99" aria-hidden="true"></a>        (free_vars, e0)</span>
<span id="cb24-100"><a href="#cb24-100" aria-hidden="true"></a></span>
<span id="cb24-101"><a href="#cb24-101" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb24-102"><a href="#cb24-102" aria-hidden="true"></a>        bimap (Set.delete (idName arg)) (<span class="dt">Lam</span> arg)</span>
<span id="cb24-103"><a href="#cb24-103" aria-hidden="true"></a>              (go binders free_vars body)</span>
<span id="cb24-104"><a href="#cb24-104" aria-hidden="true"></a></span>
<span id="cb24-105"><a href="#cb24-105" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb24-106"><a href="#cb24-106" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb24-107"><a href="#cb24-107" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go binders free_vars e1</span>
<span id="cb24-108"><a href="#cb24-108" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders free_vars e2</span>
<span id="cb24-109"><a href="#cb24-109" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb24-110"><a href="#cb24-110" aria-hidden="true"></a>          (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</span>
<span id="cb24-111"><a href="#cb24-111" aria-hidden="true"></a></span>
<span id="cb24-112"><a href="#cb24-112" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span></span>
<span id="cb24-113"><a href="#cb24-113" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb24-114"><a href="#cb24-114" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go binders free_vars e1</span>
<span id="cb24-115"><a href="#cb24-115" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders free_vars e2</span>
<span id="cb24-116"><a href="#cb24-116" aria-hidden="true"></a>          (free3, e3&#39;) <span class="ot">=</span> go binders free_vars e3</span>
<span id="cb24-117"><a href="#cb24-117" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb24-118"><a href="#cb24-118" aria-hidden="true"></a>          (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</span>
<span id="cb24-119"><a href="#cb24-119" aria-hidden="true"></a></span>
<span id="cb24-120"><a href="#cb24-120" aria-hidden="true"></a>      <span class="dt">Let</span> bndr<span class="op">@</span><span class="dt">Id</span>{ idName <span class="ot">=</span> bndr_name } e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb24-121"><a href="#cb24-121" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb24-122"><a href="#cb24-122" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> updateIdArity bndr e1&#39;</span>
<span id="cb24-123"><a href="#cb24-123" aria-hidden="true"></a>          binders&#39; <span class="ot">=</span> Map.insert bndr_name bndr&#39; binders</span>
<span id="cb24-124"><a href="#cb24-124" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> first (Set.delete bndr_name) (go binders&#39; free_vars e1)</span>
<span id="cb24-125"><a href="#cb24-125" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders&#39; free_vars e2</span>
<span id="cb24-126"><a href="#cb24-126" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb24-127"><a href="#cb24-127" aria-hidden="true"></a>          <span class="kw">if</span> Set.member bndr_name free2</span>
<span id="cb24-128"><a href="#cb24-128" aria-hidden="true"></a>            <span class="kw">then</span> (Set.delete bndr_name (Set.union free1 free2),</span>
<span id="cb24-129"><a href="#cb24-129" aria-hidden="true"></a>                  <span class="dt">Let</span> bndr&#39; e1&#39; e2&#39;)</span>
<span id="cb24-130"><a href="#cb24-130" aria-hidden="true"></a>            <span class="kw">else</span> (free2, e2&#39;)</span>
<span id="cb24-131"><a href="#cb24-131" aria-hidden="true"></a></span>
<span id="cb24-132"><a href="#cb24-132" aria-hidden="true"></a>      <span class="dt">Placeholder</span>{} <span class="ot">-&gt;</span></span>
<span id="cb24-133"><a href="#cb24-133" aria-hidden="true"></a>        (free_vars, e0)</span>
<span id="cb24-134"><a href="#cb24-134" aria-hidden="true"></a></span>
<span id="cb24-135"><a href="#cb24-135" aria-hidden="true"></a><span class="ot">pgm ::</span> <span class="dt">Expr</span></span>
<span id="cb24-136"><a href="#cb24-136" aria-hidden="true"></a>pgm <span class="ot">=</span> <span class="dt">Let</span> fac_id rhs body</span>
<span id="cb24-137"><a href="#cb24-137" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb24-138"><a href="#cb24-138" aria-hidden="true"></a>    fac_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;fac&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }</span>
<span id="cb24-139"><a href="#cb24-139" aria-hidden="true"></a>    rhs <span class="ot">=</span> <span class="dt">Lam</span> x_id (<span class="dt">IfE</span> (<span class="dt">IdE</span> x_id) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> star_id) (<span class="dt">IdE</span> x_id))</span>
<span id="cb24-140"><a href="#cb24-140" aria-hidden="true"></a>                                        (<span class="dt">App</span> (<span class="dt">IdE</span> fac_id)</span>
<span id="cb24-141"><a href="#cb24-141" aria-hidden="true"></a>                                             (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> minus_id) (<span class="dt">IdE</span> x_id)) (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb24-142"><a href="#cb24-142" aria-hidden="true"></a>                                   (<span class="dt">IntE</span> <span class="dv">1</span>))</span>
<span id="cb24-143"><a href="#cb24-143" aria-hidden="true"></a>    body <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">IntE</span> <span class="dv">5</span>)</span>
<span id="cb24-144"><a href="#cb24-144" aria-hidden="true"></a></span>
<span id="cb24-145"><a href="#cb24-145" aria-hidden="true"></a>    x_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb24-146"><a href="#cb24-146" aria-hidden="true"></a>    star_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;*&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb24-147"><a href="#cb24-147" aria-hidden="true"></a>    minus_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;-&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb24-148"><a href="#cb24-148" aria-hidden="true"></a></span>
<span id="cb24-149"><a href="#cb24-149" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-150"><a href="#cb24-150" aria-hidden="true"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> (ppShow (dropUnusedBindings pgm))</span></code></pre></div>
</details>
<p>Thanks to Oleg Grenrus for reading a draft of this.</p>]]></summary>
</entry>
<entry>
    <title>Some arguments against small syntax extensions in GHC</title>
    <link href="http://osa1.net/posts/2020-01-22-no-small-syntax-extensions.html" />
    <id>http://osa1.net/posts/2020-01-22-no-small-syntax-extensions.html</id>
    <published>2020-01-22T00:00:00Z</published>
    <updated>2020-01-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently realized that I haven’t published a single post in 2019. I think that’s the longest break I ever took to blogging, and it kinda made me motivated to publish some of the draft posts that I’ve been keeping in private Github gists.</p>
<p>This post is originally written in 11 January 2019. Because it is more of an angry rant than a constructive piece, I wasn’t sure at the time that publishing it is a good idea. However reading it again now, I see that it’s not directed at a person, a group, or a specific proposal/patch, so I think it shouldn’t be offensive to anyone and I should be able to publish it on my personal blog.</p>
<p>(original post starts below)</p>
<hr />
<p>So I woke up at 5AM today and felt like writing about one of my frustrations. These are my personal opinions, and I don’t represent GHC HQ here.</p>
<hr />
<p>At this point adding new syntax to GHC/Haskell is a bad idea. Before moving on to examples, here are some facts:</p>
<ul>
<li><p>The language that GHC supports is incredibly complex. GHC 8.6.3 man page lists 115 language pragmas.</p></li>
<li><p>You just can’t have a good understanding of <em>all</em> of these features and know interactions of the proposed syntax with all combinations of these.</p></li>
<li><p>GHC is a complex and old compiler with parts that today no active contributor knows well. The compiler (ignoring all the libraries, the RTS, tools etc.) currently has 189,699 lines of code (ignoring comments and whitespace). That’s a lot of complexity to deal with.</p></li>
<li><p>When you propose a new syntax, what you’re actually proposing is:</p>
<ul>
<li>At least one more pragma</li>
<li>More user manual sections</li>
<li>MVP implementation of your syntax (which is usually not bug-free)</li>
<li>A few common-case tests (which are usually not enough)</li>
<li>More headache for tool developers</li>
<li>Scaring more potential new Haskell developers away</li>
<li>Adding to the frustration of existing Haskell developers</li>
<li>Adding maintenance burden to GHC devs</li>
</ul></li>
<li><p>Because you can’t predict all the interactions of your new syntax (conceptually, or in the implementation) your syntax will cause a ton of problems.</p></li>
<li><p>Those problems will sit there unfixed for months/years.</p></li>
<li><p>GHC maintainers barely have enough time and manpower to provide stable releases. 8.6.1 and 8.6.2 are completely broken (<a href="https://gitlab.haskell.org/ghc/ghc/issues/15544">#15544</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15696">#15696</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15892">#15892</a>), and 8.6.3 doesn’t <a href="https://gitlab.haskell.org/ghc/ghc/issues/16057">work well on Windows</a>.</p></li>
</ul>
<p>You might not accept some of these, however in my experience these are facts. If you disagree with any of these let me know and I can elaborate.</p>
<p>I’ll have only two examples for now, because I don’t normally work on front-end parts of the compiler I don’t notice most of the problems.</p>
<h1 id="example-1-tiny-addition-to-ghci-syntax">Example 1: Tiny addition to GHCi syntax</h1>
<p><a href="https://gitlab.haskell.org/ghc/ghc/issues/7253">#7253</a> proposed a tiny new syntax in GHCi. A few years later a new contributor picked it up and submitted a <a href="https://phabricator.haskell.org/D1299">patch</a>. This trivial new syntax later caused <a href="https://gitlab.haskell.org/ghc/ghc/issues/11606">#11606</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/12091">#12091</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15721">#15721</a>. That’s 3 too many tickets for a trivial syntax that buys us so little. It also generated at least one <a href="https://stackoverflow.com/questions/53898220/sprint-and-seq-together-missing-evaluation">SO question</a>, and invalidated an answer to <a href="https://stackoverflow.com/questions/14052093/ghci-let-what-does-it-do/14052220#14052220">another SO question</a> by making things more complicated.</p>
<p>The implementation is finally <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/97">fixed by a frustrated maintainer</a>, but the additional complexity (both in the implementation, and as the GHCi syntax to be explained to users) it added won’t be fixed.</p>
<h1 id="example-2--xblockarguments">Example 2: -XBlockArguments</h1>
<p>This was proposed as <a href="https://github.com/ghc-proposals/ghc-proposals/pull/90">a GHC proposal</a>. It’s a trivial syntax change that in the best case can save 3 characters (including spaces). So far it generated two tickets: <a href="https://gitlab.haskell.org/ghc/ghc/issues/16137">#16137</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/16097">#16097</a>. Even worse than the previous example is none of these tickets mention <code>-XBlockArguments</code>, they don’t even use it! Yet the error messages got significantly worse because of it.</p>
<hr />
<h1 id="just-to-be-clear">Just to be clear</h1>
<p>I think some of the extensions are quite useful. However I also think that at this point new syntax extensions are doing more harm than good. Problems from a maintainer’s point of view are as listed above (arguably maintainers’ problems are also users’ problems because they lead to poor product, but let’s ignore this aspect for now). Now I want to add one more problem, this time from a software developer/engineer’s point of view:</p>
<ul>
<li>Adding a different way of doing things, especially when the difference is so small, does more harm than good.</li>
</ul>
<p>Here’s why. Now that we have two ways of using <code>do</code> syntax:</p>
<pre><code>-- (1)
atomically $ do
  ...

-- (2) with -XBlockArguments
atomically do
  ...</code></pre>
<p>with my team I have to do one of these</p>
<ol type="1">
<li>Decide which one to use, and somehow manually make sure to use it consistently (this can’t be done automatically as we lack the tooling)</li>
<li>Let everyone use whatever they want.</li>
</ol>
<p>(1) means wasting the team’s time and energy on endless bikeshedding. (2) means being inconsistent in the source code. Either way we lose.</p>
<p>You might argue that with good tooling (1) is not a problem, and I’d agree. However as we add new syntax the tooling story will only get worse. GHC Haskell syntax is already so complex we don’t even have a good formatter. We should first stop making it even more complex if we want the tooling story to get better.</p>
<h1 id="what-we-need">What we need</h1>
<p>In my opinion what we need is principles to guide the language and the compiler. Currently <a href="https://github.com/ghc-proposals/ghc-proposals/pull/190#issuecomment-450440245">we don’t have this</a> (last paragraph), and the result is 100+ pragmas, a buggy compiler, and frustrated users and maintainers.</p>
<h1 id="my-advice-to-users">My advice to users</h1>
<p>If you’re proposing a new syntax; don’t! If you know someone who will, point them to this blog post.</p>]]></summary>
</entry>
<entry>
    <title>A project we've been working on presented at MuniHac 2018</title>
    <link href="http://osa1.net/posts/2018-10-22-gc-work-presented.html" />
    <id>http://osa1.net/posts/2018-10-22-gc-work-presented.html</id>
    <published>2018-10-22T00:00:00Z</published>
    <updated>2018-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new low-latency garbage collector for GHC that <a href="http://bgamari.github.io/">Ben Gamari</a> and I have been working on for the last year or so has recently been presented at <a href="https://munihac.github.io/">MuniHac 2018</a>. I’d like to thank Ben for the great talk.</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7_ig6r2C-d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
<p>I’ve been answering some questions on the <a href="https://www.reddit.com/r/haskell/comments/9ygoy1/munihac_2018_keynote_a_lowlatency_garbage/">/r/haskell thread</a> (I’m /u/semanticistZombie on Reddit). If you have any questions please don’t hesitate to add a comment in the reddit thread (make sure to ping me so that I get a notification), or even better, add a comment below.</p>]]></summary>
</entry>
<entry>
    <title>New blog post published elsewhere</title>
    <link href="http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html" />
    <id>http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html</id>
    <published>2018-05-19T00:00:00Z</published>
    <updated>2018-05-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new blog post that I’ve authored has been published on <a href="http://www.well-typed.com/blog/2018/05/ghc-special-gc-objects/">Well-Typed’s blog</a>. If you’re interested in garbage collection or liked my <a href="/posts/2018-03-16-gc-optimizations.html">previous post</a> you should check it out.</p>]]></summary>
</entry>
<entry>
    <title>Debugging #15038</title>
    <link href="http://osa1.net/posts/2018-04-28-debugging-15038.html" />
    <id>http://osa1.net/posts/2018-04-28-debugging-15038.html</id>
    <published>2018-04-28T00:00:00Z</published>
    <updated>2018-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently spent some time debugging GHC bug <a href="https://ghc.haskell.org/trac/ghc/ticket/15038">#15038</a> and to help with context switching between debugging and other tasks I took notes during debugging. After successfully debugging it and reading my notes from the beginning I thought it may be an interesting read, so I’m publishing it. It may not make much sense to anyone other than me, and it’s very lightly edited, so keep your expectations low :)</p>
<hr />
<p>Crashes at this point:</p>
<pre><code>&gt;&gt;&gt; bt
#11 0x00000000008d6650 in
    barf (s=0x94fe90 &quot;evacuate(static): strange closure type %d&quot;) at rts/RtsMessages.c:47
#12 0x00000000008e7e83 in
    evacuate (p=0x981640) at rts/sm/Evac.c:574
#13 0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#14 0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#15 0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#16 0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#17 0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#18 0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#19 0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#20 0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#21 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#22 0x000000000040d7da in
    main ()</code></pre>
<p>While evacuating object at location</p>
<pre><code>p = (StgClosure **) 0x981640</code></pre>
<p>Info table of the object:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl(q)
$5 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>Untagged object:</p>
<pre><code>q = (StgClosure *) 0x981618</code></pre>
<p>Tagged:</p>
<pre><code>*p = (StgClosure *) 0x981619</code></pre>
<p>Where does this object appear? Tagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981619
(nothing)</code></pre>
<p>Untagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981618
(nothing)</code></pre>
<p>Not in the heap!</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981618
rctv_closure in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>According to STG output references should be</p>
<pre><code>lvl4_rctv referenced by
lvl5_rctw referenced by
lvl6_rctx referenced by
$wbyteParserBadOnce</code></pre>
<p>Looking at each closure:</p>
<pre><code>rctv :: ([Char], Packed.Bytes.Parser.Parser Word)

&gt;&gt;&gt; print (StgClosure)rctv_closure (0x981618)
{
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctv_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 0,
  code = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt; &quot;H\377\303\377e&quot;
}


rctw :: [([Char], Packed.Bytes.Parser.Parser Word)]

&gt;&gt;&gt; print (StgClosure)rctw_closure (0x981638)
{
  header = {
    info = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctw_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 1,
  code = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt; &quot;H\203\303\002\377e&quot;
}


rctx :: Packed.Bytes.Parser.Parser Word

&gt;&gt;&gt; print (StgClosure)rctx_closure (0x981658)
{
  header = {
    info = 0x40ca10 &lt;rctx_info&gt;
        -- Packed.Bytes.Parser.Parser GHC.Types.Word
  },
  payload = []
}
&gt;&gt;&gt; print *get_itbl(&amp;rctx_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 21, -- THUNK_STATIC
  srt_bitmap = 3,
  code = 0x40ca10 &lt;rctx_info&gt; &quot;H\215E\350L9\370r@H\203\354\bL\211\350H\211\336H\211\307\061\300\350S\314M&quot;
}

$wbyteParserBadOnce :: Int -&gt; Int#

&gt;&gt;&gt; print (StgClosure)Parser_zdwbyteParserBadOnce_closure (0x981680)
{
  header = {
    info = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;Parser_zdwbyteParserBadOnce_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 113,
  code = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt; &quot;H\215E\320L9\370\017\202\342\001&quot;
}</code></pre>
<p>Back to the backtrace. Adding watchpoints makes it run too slow, so first figure out when this happens:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 2 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 2 10000000
Will ignore next 10000000 crossings of breakpoint 2.
&gt;&gt;&gt; c
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 6 times
        ignore next 9999994 hits</code></pre>
<p>So 6th time we run GC we see this error. Let’s see if 0x981640 is a valid closure by the beginning of 6th GC:</p>
<pre><code>&gt;&gt;&gt; call LOOKS_LIKE_CLOSURE_PTR(0x981640)
$5 = true</code></pre>
<p>However at this point it already has wrong type:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl((StgClosure*)0x981640)
$4 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>In fact, this object has this type since the beginning.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981640
rctw_closure + 8 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>This object is in <code>payload[0]</code> of <code>rctw</code>?</p>
<pre><code>lvl5_rctw
  :: [(GHC.Base.String, Packed.Bytes.Parser.Parser GHC.Types.Word)]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [lvl4_rctv GHC.Types.[]];</code></pre>
<p>So it should be <code>rctv</code>. Something is wrong with first payload of <code>rctw</code>. We should focus on evacuation/scavenging of <code>rctw</code>.</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981638
&gt;&gt;&gt; c
** hits breakpoint **
&gt;&gt;&gt; call printClosure(q)
ghc-prim:GHC.Types.:(0x981619, 0xace111)
&gt;&gt;&gt; info symbol 0x981619
rctv_closure + 1 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>So indeed we have <code>rctv_closure</code> in first payload (but tagged).</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)
&gt;&gt;&gt; call printClosure(0xace111)
ghc-prim:GHC.Types.[](0x8c3450#)</code></pre>
<p>It looks OK. Let’s see if it breaks after this GC.</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981638)
ghc-prim:GHC.Types.:(0x981619, 0xace111)</code></pre>
<p>Nope. Continue until first payload of 0x981638 (<code>rctw</code>) changes.</p>
<p>It turns out the payload doesn’t change. So <code>rctv</code> itself changes!</p>
<p>On 4th <code>GarbageCollect()</code> this fails:</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
*** printClosure: unknown type 16585 ****
Main: internal error: printClosure 16585
    (GHC version 8.5.20180425 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
<p>So break at 3rd:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 1 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 1 2
Will ignore next 2 crossings of breakpoint 1.
&gt;&gt;&gt; c
&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)</code></pre>
<p>(Remember that 0x981619 is tagged 0x981618 which is <code>rctv</code>)</p>
<p>Now watch the closure:</p>
<pre><code>&gt;&gt;&gt; watch (StgClosure)rctv_closure
Watchpoint 2: (StgClosure)rctv_closure
&gt;&gt;&gt; disable breakpoint 1
&gt;&gt;&gt; c</code></pre>
<p>This takes forever, gdb starts leaking memory, fills 16G and swaps.</p>
<p>Let’s take a look at static objects again. <code>rctv</code>’s info table pointer somehow gets overwritten. What could cause this? Perhaps an object before <code>rctv</code> has an overlapping field.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981617
rctu_closure + 7 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>It seems like we have <code>rctu</code> before <code>rctv</code>.</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)

&gt;&gt;&gt; print (StgClosure)rctu_closure
{
  header = {
    info = 0x40c908 &lt;rctu_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;rctu_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 1,
  code = 0x40c908 &lt;rctu_info&gt; &quot;H\215E\370L9\370\017\202\277&quot;
}</code></pre>
<p>So locations of <code>rctu</code> and <code>rctv</code></p>
<pre><code>rctu: 0x981610
rctv: 0x981618</code></pre>
<p>There’s only 8 bytes in between. This doesn’t look right. Because <code>rctu</code> is a static object with no payload, so it needs at least two words: info table pointer and static link field. Static link field is missing in the layout, so info table pointer of <code>rctv</code> is used as static link.</p>
<p>At this point I remember different types of objects have link fields in different places so let’s check:</p>
<pre><code>#define FUN_STATIC_LINK(p)   (&amp;(p)-&gt;payload[0])</code></pre>
<p>Because I can’t add watchpoint to this location so I do this:</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981610</code></pre>
<p>Just to count which GC we’re at</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
&gt;&gt;&gt; ignore 2 10000</code></pre>
<p>First hit</p>
<pre><code>&gt;&gt;&gt; print (StgClosure)rctv_closure
$1 = {
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000008e7a73 in evacuate_static_object at rts/sm/Evac.c:340
        stop only if q == 0x981610 (target evals)
        breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 3 times
        ignore next 9997 hits</code></pre>
<p>Let’s see if this breaks it:</p>
<pre><code>&gt;&gt;&gt; fin
&gt;&gt;&gt; print (StgClosure)rctv_closure
$2 = {
  header = {
    info = 0x981561
  },
  payload = 0x8
}</code></pre>
<p>Yep! So this function call breaks rctv:</p>
<pre><code>&gt;&gt;&gt; bt
#0  evacuate_static_object (link_field=0x981618, q=0x981610 (rctu)) at rts/sm/Evac.c:340
#1  0x00000000008e7e20 in
    evacuate (p=0x981628) at rts/sm/Evac.c:546
#2  0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#3  0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#4  0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#5  0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#6  0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#7  0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#8  0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#9  0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#10 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#11 0x000000000040d7da in
    main ()</code></pre>
<p>I’m convinced that layout of <code>rctu</code> is wrong. I’ll add some debug prints to GHC to see why the layout is generated this way, but before that I’m saving all the binaries and dump files of this session.</p>
<p>The bug should be in <code>cgTopRhsClosure</code>, the Cmm code generator for top-level closures.</p>
<p>Good thing GHC is deterministic enough these days so I get the same symbols when I recompile (later I realized that top-level symbols are deterministic enough but local ids usually change).</p>
<pre><code>gen_code
  closure_label: lvl3_rctu_closure
  descr: &lt;Parser.lvl3_rctu&gt;
  info_tbl: label: lvl3_rctu_info
            rep:HeapRep static {
                  Fun {arity: 6 fun_type: ArgGen [True, False, False, True, True]} }
  fv_details: []</code></pre>
<p>This looks fine. Let’s check <code>mkStaticClosureFields</code>:</p>
<pre><code>mkStaticClosureFields
  caf_refs: NoCafRefs
  info_lbl: lvl3_rctu_info
  is_caf: False
  padding: []
  static_link_field: []
  saved_info_field: []
  static_link_value: 3</code></pre>
<p>So this object doesn’t get a static link field. This is because the condition</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>staticClosureNeedsLink (mayHaveCafRefs caf_refs) info_tbl</span></code></pre></div>
<p>doesn’t hold.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="ot">staticClosureNeedsLink ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">CmmInfoTable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="co">-- A static closure needs a link field to aid the GC when traversing</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="co">-- the static closure graph.  But it only needs such a field if either</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="co">--        a) it has an SRT</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span class="co">--        b) it&#39;s a constructor with one or more pointer fields</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a><span class="co">-- In case (b), the constructor&#39;s fields themselves play the role</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a><span class="co">-- of the SRT.</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>staticClosureNeedsLink has_srt <span class="dt">CmmInfoTable</span>{ cit_rep <span class="ot">=</span> smrep }</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>  <span class="op">|</span> isConRep smrep         <span class="ot">=</span> <span class="fu">not</span> (isStaticNoCafCon smrep)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>              <span class="ot">=</span> has_srt <span class="co">-- needsSRT (cit_srt info_tbl)</span></span></code></pre></div>
<p>So <code>has_srt</code> is <code>False</code> for this object and <code>idCafInfo</code> of this closure says it’s not caffy.</p>
<p>Just to make sure this is the problem, I modify the code to treat all top-level closures as caffy. Indeed that fixes the bug.</p>
<p>CAFness of bindings are decided in <code>hasCafRefs</code> in <code>TidyPgm</code>. Two conditions for CAFness are</p>
<ul>
<li>Top level and no arguments</li>
<li>Mentions CAFs</li>
</ul>
<p>First one obviously doesn’t hold becasue <code>rctu</code> is a function. I don’t know why the second condition doesn’t hold yet.</p>
<p><code>TidyPgm</code> operates on Core so let’s look at Core of <code>rctu</code>:</p>
<pre><code>-- RHS size: {terms: 80, types: 1,207, coercions: 0, joins: 0/0}
lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s, Packed.Bytes.Parser.Result# s Word #)
[GblId, Arity=2, Caf=NoCafRefs, Str=&lt;S,1*U&gt;&lt;S,U&gt;, Unf=OtherCon []]
lvl3_rctu
  = \ (@ s_a6Ca)
      (leftovers0_a691
         :: Packed.Bytes.Parser.Maybe#
              (Packed.Bytes.Parser.Leftovers# s_a6Ca))
      (s0_a692 :: GHC.Prim.State# s_a6Ca) -&gt;
      case leftovers0_a691 of {
        (#_|#) ds_d6Km -&gt;
          (# s0_a692,
             (# GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ (&#39;GHC.Types.TupleRep
                       &#39;[&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                         &#39;GHC.Types.LiftedRep])
                  @ (# #)
                  @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                  GHC.Prim.(##),
                GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ &#39;GHC.Types.LiftedRep
                  @ (# #)
                  @ Word
                  GHC.Prim.(##) #) #);
        (#|_#) ds_d6Kn -&gt;
          case ds_d6Kn of { (# bytes0_scqD, stream0_scqE #) -&gt;
          case bytes0_scqD of { (# arr0_scqH, off0_scqI, len0_scqJ #) -&gt;
          case GHC.Prim.&gt;# len0_scqJ 0# of {
            __DEFAULT -&gt;
              case Packed.Bytes.Parser.nextNonEmpty @ s_a6Ca stream0_scqE s0_a692
              of
              { (# ipv_s6NZ, ipv1_s6O0 #) -&gt;
              case ipv1_s6O0 of {
                (#_|#) ds3_d6JW -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          GHC.Prim.(##),
                        GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          GHC.Prim.(##) #) #);
                (#|_#) ds3_d6JX -&gt;
                  case ds3_d6JX of { (# bytes1_scqM, stream1_scqN #) -&gt;
                  case bytes1_scqM of { (# arr1_scqQ, off1_scqR, ds4_scqS #) -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          (# (# arr1_scqQ, GHC.Prim.+# off1_scqR 1#,
                                GHC.Prim.-# ds4_scqS 1# #),
                             stream1_scqN #),
                        GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          a1_rcbR #) #)
                  }
                  }
              }
              };
            1# -&gt;
              (# s0_a692,
                 (# GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ (&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                             &#39;GHC.Types.LiftedRep])
                      @ (# #)
                      @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                      (# (# arr0_scqH, GHC.Prim.+# off0_scqI 1#,
                            GHC.Prim.-# len0_scqJ 1# #),
                         stream0_scqE #),
                    GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ &#39;GHC.Types.LiftedRep
                      @ (# #)
                      @ Word
                      a1_rcbR #) #)
          }
          }
          }
      }</code></pre>
<p>This is huge and I’m not going to check this by hand. However at this point I realize that the condition for evacuating a <code>FUN_STATIC</code> is</p>
<pre><code>case FUN_STATIC:
    if (info-&gt;srt_bitmap != 0) {
        evacuate_static_object(FUN_STATIC_LINK((StgClosure *)q), q);
    }
    return;</code></pre>
<p>So this is not marked as CAF, but its SRT bitmap is not empty. Perhaps the bug is in the SRT bitmap.</p>
<p>I also try this in gdb:</p>
<pre><code>&gt;&gt;&gt; set get_itbl(&amp;rctu_closure)-&gt;srt_bitmap = 0</code></pre>
<p>This also fixes it. Now let’s figure out why SRT bitmap of <code>rctu</code> (which is supposed to be a non-CAF) is 1.</p>
<p>I look again at the definition of <code>rctu</code> and it seems like <code>a1_rcbR</code> is a free variable.</p>
<pre><code>a1_rcbR :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [5##];</code></pre>
<p>However because this is not a CAF it shouldn’t make <code>rctu</code> CAF.</p>
<p>I stare at the code aimlessly for a while until I realize something interesting. This is the STG for <code>rctu</code> after unarisation:</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=&lt;S,1*U&gt;&lt;S,U&gt;,
 Unf=OtherCon []] =
    [] \r [us_gcwc us_gcwd us_gcwe us_gcwf us_gcwg void_0E]
        case us_gcwc of tag_gcwh {
          __DEFAULT -&gt;
              (#,,,,,,#) [1#
                          Control.Exception.Base.absentError
                          Control.Exception.Base.absentError
                          0##
                          0##
                          1#
                          Control.Exception.Base.absentError];
          2# -&gt;
              case &gt;# [us_gcwg 0#] of {
                __DEFAULT -&gt;
                    case Packed.Bytes.Parser.nextNonEmpty us_gcwe GHC.Prim.void# of {
                      (#,,,,#) us_gcwi us_gcwj us_gcwk us_gcwl us_gcwm -&gt;
                          case us_gcwi of tag_gcwn {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [1#
                                            Control.Exception.Base.absentError
                                            Control.Exception.Base.absentError
                                            0##
                                            0##
                                            1#
                                            Control.Exception.Base.absentError];
                            2# -&gt;
                                case -# [us_gcwm 1#] of sat_scuk {
                                  __DEFAULT -&gt;
                                      case +# [us_gcwl 1#] of sat_scuj {
                                        __DEFAULT -&gt;
                                            (#,,,,,,#) [2#
                                                        us_gcwj
                                                        us_gcwk
                                                        sat_scuj
                                                        sat_scuk
                                                        2#
                                                        a1_rcbR];
                                      };
                                };
                          };
                    };
                1# -&gt;
                    case -# [us_gcwg 1#] of sat_scur {
                      __DEFAULT -&gt;
                          case +# [us_gcwf 1#] of sat_scuq {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [2# us_gcwd us_gcwe sat_scuq sat_scur 2# a1_rcbR];
                          };
                    };
              };
        };</code></pre>
<p>This has two free variables: <code>a1_rcbR</code> and <code>Control.Exception.Base.absentError</code>. <code>a1_rcbR</code> is clearly not a CAF, but maybe <code>absentError</code> is? Because <code>absentError</code> references are generated in unarise, which happens much later than <code>TidyPgm</code> (right before generating Cmm), <code>TidyPgm</code> can’t take those into account.</p>
<p><code>Id</code> for <code>absentError</code> is generated using <code>vanillaIdInfo</code> which sets the CAF-ness field as <code>MayHaveCafRefs</code>. So clearly <code>absentError</code> is a CAFFY.</p>
<p>So in summary, we introduce references to CAFs in <code>UnariseStg</code> which happens later than <code>TidyPgm</code>. The code generator is somehow handles this correctly by generating a SRT for this function and setting the info table bitmap correctly. However object layout generator (in <code>cgTopRhsClosure</code>) only uses the information generated in <code>TidyPgm</code>, so we get this mismatch of SRT information of this function.</p>
<p>Some ways to fix this:</p>
<ul>
<li>Update binder ids in unarise if we introduced an <code>absentError</code></li>
<li>Conservatively treat unboxed sums as CAFFY in <code>TidyPgm</code></li>
<li>Mark <code>absentError</code> as non-CAF (I don’t know if it has to be a CAF, I think error ids are conservatively marked as CAFs)</li>
</ul>
<p>The whole thing took 4:47 hours.</p>]]></summary>
</entry>
<entry>
    <title>On malloc and brk/sbrk</title>
    <link href="http://osa1.net/posts/2018-04-08-malloc-brk-sbrk.html" />
    <id>http://osa1.net/posts/2018-04-08-malloc-brk-sbrk.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Read about <code>malloc()</code> on Linux in lecture notes and even non-ancient books like The Linux Programming Interface (published on 2010) and you’ll see a lot of mentions to <code>brk()</code> and <code>sbrk()</code> system calls. They then move on to talk about <code>mmap()</code>, and at that point you probably start wondering how they interact.</p>
<p>The problem is, because <code>mmap()</code> lets you map stuff in your program’s address space, it seems like you can easily break <code>brk</code>/<code>sbrk</code> by mapping stuff right after the current program break. Here’s a program that does exactly that:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// mmap() something right after program break, then increase it by malloc-ing stuff</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>{</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    <span class="dt">long</span> page_size = sysconf(_SC_PAGESIZE);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    printf(<span class="st">&quot;Page size:             %ld</span><span class="sc">\n</span><span class="st">&quot;</span>, page_size);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>    <span class="dt">void</span>* brk = sbrk(<span class="dv">0</span>);</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    printf(<span class="st">&quot;Current program break: %p</span><span class="sc">\n</span><span class="st">&quot;</span>, brk);</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>    <span class="co">// mmap() right after program break</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>    <span class="dt">void</span>* mmap_ret = mmap(</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>            brk, page_size, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>    printf(<span class="st">&quot;mmap() returned:       %p</span><span class="sc">\n</span><span class="st">&quot;</span>, mmap_ret);</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>    assert(mmap_ret == brk);</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    <span class="co">// Allocate until brk changes</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    <span class="dt">void</span>* new_brk = sbrk(<span class="dv">0</span>);</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    <span class="dt">void</span>* ret = malloc(page_size);</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>    <span class="cf">for</span> (;;)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>    {</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>        <span class="cf">if</span> (!ret)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>        {</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>            printf(<span class="st">&quot;malloc() failed</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>        }</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>        <span class="cf">if</span> (new_brk != brk)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>        {</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>            printf(<span class="st">&quot;brk changed</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>        }</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>        <span class="cf">if</span> (ret &gt; brk)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>        {</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>            printf(<span class="st">&quot;ret &gt; brk</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>        }</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>        ret = malloc(page_size);</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>        new_brk = sbrk(<span class="dv">0</span>);</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>    }</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a>    printf(<span class="st">&quot;New brk:               %p</span><span class="sc">\n</span><span class="st">&quot;</span>, new_brk);</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a>    printf(<span class="st">&quot;ret:                   %p</span><span class="sc">\n</span><span class="st">&quot;</span>, ret);</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a>}</span></code></pre></div>
<p>So we read the program break, <code>mmap()</code> stuff right after it, then <code>malloc()</code> page-sized space until the program break changes. The idea is if we actually increment the program break, we’ll end up re-using <code>mmap()</code>d area.</p>
<p>Of course this does not happen. If you run this, you’ll see something like:</p>
<pre><code>Page size:             4096
Current program break: 0x1efb000
mmap() returned:       0x1efb000
ret &gt; brk
New brk:               0x1efb000
ret:                   0x7fdb72d8f010</code></pre>
<p>So the <code>malloc()</code> implementation doesn’t care about program break at all, instead it uses <code>mmap()</code>, probably with <code>NULL</code> as the <code>addr</code> parameter, to get a fresh location in the address space.</p>
<p>Of course this is all obvious if you’re already familiar with this stuff. <code>sbrk()</code> just can’t work with <code>mmap()</code>. Try adding these lines to the program above, right before the return statement:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>    <span class="co">// Try to increment program break manually</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="dt">void</span>* sbrk_ret = sbrk(page_size);</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    printf(<span class="st">&quot;sbrk_ret:              %p</span><span class="sc">\n</span><span class="st">&quot;</span>, sbrk_ret);</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    printf(<span class="st">&quot;New brk:               %p</span><span class="sc">\n</span><span class="st">&quot;</span>, sbrk(<span class="dv">0</span>));</span></code></pre></div>
<p>You’ll see that <code>sbrk()</code> returns something like <code>0xffffffffffffffff</code> ( <code>(void*)-1</code> ) and the program break does not change.</p>
<p>Really what confused me is all these over-simplified lecture notes and book chapters.</p>]]></summary>
</entry>

</feed>
