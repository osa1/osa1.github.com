<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged ocaml</title>
    <link href="http://osa1.net/tags/ocaml.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/ocaml.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2023-04-24T00:00:00Z</updated>
    <entry>
    <title>My thoughts on OCaml</title>
    <link href="http://osa1.net/posts/2023-04-24-ocaml-thoughts.html" />
    <id>http://osa1.net/posts/2023-04-24-ocaml-thoughts.html</id>
    <published>2023-04-24T00:00:00Z</published>
    <updated>2023-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Since 2013 I’ve had the chance to use OCaml a few times in different jobs, and I got frustrated and disappointed every time I had to use it. I just don’t enjoy writing OCaml.</p>
<p>In this post I want to summarize some of the reasons why I don’t like OCaml and why I wouldn’t choose it for a new project today.</p>
<h1 id="no-standard-and-easy-way-of-implementing-interfaces">No standard and easy way of implementing interfaces</h1>
<p>To me it’s absolutely essential that the language should have some way of defining interfaces, implementing those interfaces for the types, and programming against those interfaces.</p>
<p>In Haskell, this is done with typeclasses. Rust has a similar mechanism called traits. In languages with classes this is often done with abstract classes and “implementing” those classes in new classes (e.g. <code>implements</code> in Dart).</p>
<p>In OCaml there’s no way to do this. I have to explicitly pass functions along with my values, maybe in a product type, or with a functor, or as an argument.</p>
<p>Regardless of how I work around this limitation, it’s extremely inconvenient. Things that must be trivial in any code base, such as converting a value to a string for debugging purposes, become a chore, and sometimes even impossible.</p>
<p>As far as I know, there was at least one attempt at ameliorating this with modular implicits (implicit parameter passing), but I don’t know what happened to it since 2017. It looks like it’s still not a part of the language and the standard library is not using it.</p>
<h1 id="bad-standard-library">Bad standard library</h1>
<p>OCaml’s standard library is just bizarre. It has lots of small issues, and a few larger ones. It’s really just extremely painful to use.</p>
<p>Some examples of the issues:</p>
<ul>
<li><p>Zoo of printing/debugging and conversion functions such as <code>string_of_int</code>, <code>string_of_float</code>, <code>print_char</code>, <code>Int64.of_int</code>, <code>string_of_int</code>, …</p></li>
<li><p>Overly polymorphic operators with type <code>'a -&gt; 'a -&gt; bool</code> such as <code>=</code> (called “structural equality”, throws an exception if you pass a function) and <code>&gt;</code>. Code that uses these operators will probably not work on user-defined types as expected.</p></li>
<li><p>Standard types are sometimes persistent, sometimes mutable. <code>List</code>, <code>Map</code>, and <code>Set</code> are persistent. <code>Stack</code> and <code>Hashtbl</code> are mutable.</p></li>
<li><p>Inconsistent naming:</p>
<ul>
<li>Length function for <code>Map</code> is <code>cardinal</code>, length function for <code>Hashtbl</code> is <code>length</code>.</li>
<li>The “bytes” type is <code>Bytes.t</code>, the big int type is <code>Big_int.big_int</code> (instead of <code>Big_int.t</code>). The functions in these modules are also inconsistently named. <code>Big_int</code> functions are suffixed with <code>_big_int</code>, <code>Bytes</code> module functions are not prefixed or suffixed.</li>
</ul></li>
<li><p>The regex module uses global state: <code>string_match</code> runs a regex and sets some global state. <code>matched_string</code> returns the last matched string using the global state.</p></li>
<li><p>Lack of widely used operations such as <code>popcount</code> for integer types, unicode character operations.</p></li>
<li><p><code>Int.abs</code> can return a negative number.</p></li>
<li><p>It doesn’t have proper string and character types: <code>String</code> is a byte array, <code>char</code> is a byte.</p></li>
</ul>
<p>The bad state of OCaml’s standard library also causes fragmentation in the ecosystem with two competing alternatives: <a href="https://opensource.janestreet.com/core/">Core</a> and <a href="https://github.com/ocaml-batteries-team/batteries-included">Batteries</a>.</p>
<h1 id="syntax-problems">Syntax problems</h1>
<p>OCaml doesn’t have a single-line comment syntax.</p>
<p><a href="https://v2.ocaml.org/api/Stdlib.html#VALstring_of_int">The expression syntax</a> has just too many issues. It’s inconsistent in how it uses delimiters. <code>for</code> and <code>while</code> end with <code>end</code>, but <code>let</code>, <code>if</code>, <code>match</code>, and <code>try</code> don’t, even though the right-most non-terminal is the same in all of these productions:</p>
<pre><code>expr ::= ...
      | while &lt;expr&gt; do &lt;expr&gt; done
      | for &lt;value-name&gt; = &lt;expr&gt; ( to | downto ) &lt;expr&gt; do &lt;expr&gt; done
      | let &lt;let-binding&gt; in &lt;expr&gt;
      | if &lt;expr&gt; then &lt;expr&gt; [ else &lt;expr&gt; ]
      | match &lt;expr&gt; with (| &lt;pattern&gt; [ when &lt;expr&gt; ] -&gt; &lt;expr&gt;)+
      | try &lt;expr&gt; with (| &lt;pattern&gt; [ when &lt;expr&gt; ] -&gt; &lt;expr&gt;)+
      ...</code></pre>
<p>It has <code>for</code> and <code>while</code>, but no <code>break</code> and <code>continue</code>. So you use exceptions with a <code>try</code> inside the loop for <code>continue</code>, and outside for <code>break</code>.</p>
<p>It also has lots of ambiguities, and some of these ambiguities are resolved in an unintuitive way. In addition to making OCaml <a href="https://github.com/ocaml/ocaml/blob/063894d3fa8f63fedf6959744510e1635dccb3ca/parsing/parser.mly#L798-L837">difficult to parse correctly</a>, this can actually cause incorrect reading of the code.</p>
<p>Most common example is probably nesting <code>match</code> and <code>try</code> expressions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">match</span> e0 <span class="kw">with</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>| p1 -&gt; <span class="kw">try</span> e1 <span class="kw">with</span> p2 -&gt; e2</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>| p3 -&gt; e3</span></code></pre></div>
<p>Here <code>p3 -&gt; e3</code> is a part of the <code>try</code> expression.</p>
<p>Another example is the sequencing syntax <code>&lt;expr&gt; ; &lt;expr&gt;</code> and productions with <code>&lt;expr&gt;</code> as the right-most symbol:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">let</span> test1 b =</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="kw">if</span> b <span class="kw">then</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="dt">print_string</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  <span class="kw">else</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="dt">print_string</span> <span class="st">&quot;2&quot;</span>; <span class="dt">print_string</span> <span class="st">&quot;3&quot;</span></span></code></pre></div>
<p>Here <code>print_string "3"</code> is not a part of the <code>if</code> expression, so this function always prints “3”.</p>
<p>However, even though <code>match</code> also has <code>&lt;expr&gt;</code> as the right-most symbol, it has different precedence in comparison to semicolon:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">let</span> test2 b =</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  | <span class="kw">true</span> -&gt; <span class="dt">print_string</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  | <span class="kw">false</span> -&gt; <span class="dt">print_string</span> <span class="st">&quot;2&quot;</span>; <span class="dt">print_string</span> <span class="st">&quot;3&quot;</span></span></code></pre></div>
<p>Here <code>print_string "3"</code> is a part of the <code>false -&gt; ...</code> branch.</p>
<p>Try to guess how these functions are parsed:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">(* Is the last print part of `else` or not? *)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">let</span> test3 b =</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="kw">if</span> b <span class="kw">then</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="dt">print_string</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  <span class="kw">else</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="kw">let</span> x = <span class="st">&quot;2&quot;</span> <span class="kw">in</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="dt">print_string</span> x;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="dt">print_string</span> <span class="st">&quot;3&quot;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">(* Is this well-typed? *)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="kw">let</span> test4 b =</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>  <span class="kw">if</span> b <span class="kw">then</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>  <span class="kw">else</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>    <span class="dv">3</span>, <span class="dv">4</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a><span class="co">(* Is the type of this `(int * int) array -&gt; unit` or `int array -&gt; unit * int`? *)</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a><span class="kw">let</span> test5 a = a.(<span class="dv">0</span>) &lt;- <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a><span class="co">(* What if I replace `,` with `;`? Does this set the element 1 or 2? *)</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a><span class="kw">let</span> test6 a = a.(<span class="dv">0</span>) &lt;- <span class="dv">1</span>; <span class="dv">2</span></span></code></pre></div>
<p>When writing OCaml you have to keep these rules in mind.</p>
<p>It also has <a href="https://en.wikipedia.org/wiki/Dangling_else">the “dangling else” problem</a>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">(* Is `else` part of the inner `if` or the outer? *)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">if</span> e1 <span class="kw">then</span> <span class="kw">if</span> e2 <span class="kw">then</span> e3 <span class="kw">else</span> e4</span></code></pre></div>
<p>Finally, and I think this is probably the most strange thing about OCaml’s syntax and I’m not even sure what’s exactly happening here (I can’t find anything relevant in the language documentation), comments in OCaml are somehow tokenized and those tokens need to be terminated. They can be terminated inside another comment, or even outside. This is a bit difficult to explain but here’s a simple example:</p>
<pre><code>(* &quot; *)
print_string &quot;hi&quot;</code></pre>
<p>OCaml 5.0.0 rejects this program with this error:</p>
<pre><code>File &quot;./test.ml&quot;, line 2, characters 16-17:
2 | print_string &quot;hi&quot;
                    ^
  String literal begins here</code></pre>
<p>From the error message it seems like the <code>"</code> in the comment line actually starts a string literal, which is terminated in the first quote of <code>"hi"</code>. The closing double quote of <code>"hi"</code> thus starts another string literal, which is not terminated.</p>
<p>However that doesn’t explain why this works:</p>
<pre><code>(* &quot; *)
print_string &quot;hi&quot;
(* &quot; *)
print_string &quot;bye&quot;</code></pre>
<p>If my explanation of the previous version were correct this would fail with an unbound <code>hi</code> variable, but it works and prints “bye”!</p>
<h1 id="rest-of-the-package-is-also-not-that-good">Rest of the package is also not that good</h1>
<p>I’m not following developments in OCaml ecosystem too closely, but just two years ago it was common to use Makefiles to build OCaml projects. The language server barely worked on a project with less than 50 kloc. There was no standard way of doing compile-time metaprogramming and some projects even used the C preprocessor (cpp).</p>
<p>Some of these things probably improved in the meantime, but the overall package is still not good enough compared to the alternatives.</p>
<h1 id="but-at-least-its-a-functional-language">But at least it’s a functional language?</h1>
<p>Almost all modern statically typed languages have closures, higher-order functions/methods, lazy streams, and combinators that run efficiently. Persistent/immutable data structures can be implemented even in C.</p>
<p>Also, OCaml has no tracking of side-effects (like in Haskell), and the language and the standard library have lots of features and functions with mutation, such as the array update syntax, mutable record fields, <code>Hashtbl</code>, and the regex module.</p>
<p>The only thing that makes OCaml more “functional” than e.g. Dart, Java, or Rust is that it supports tail calls. While having tail calls is important for functional programming, I would happily give up on tail calls if that means not having the problems listed above.</p>
<p>Also keep in mind that when you mix imperative and functional styles tail calls become less important. For example, I don’t have to implement a stream <code>map</code> function in Dart with a tail call to map the rest of the stream, I can just use a <code>while</code> or <code>for</code> loop.</p>
<h1 id="when-should-i-use-it">When should I use it?</h1>
<p>In my opinion there is no reason to use OCaml in a new project in 2023. If you have a reason to think that OCaml is the best choice for a new project please let me know your use case, I’m genuinely curious.</p>]]></summary>
</entry>
<entry>
    <title>Compilation through interpretation, a small experiment</title>
    <link href="http://osa1.net/posts/2015-05-13-comp-through-interp.html" />
    <id>http://osa1.net/posts/2015-05-13-comp-through-interp.html</id>
    <published>2015-05-13T00:00:00Z</published>
    <updated>2015-05-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been studying different program transformation techniques recently, and to me <a href="http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html">Futamura projections</a> are one of the most interesting applications of program transformations. Couple of days ago I finished a small project in which I implemented first Futamura projection(aka. interpreter specialization) using <a href="http://www.madore.org/~david/programs/unlambda/">Unlambda</a> as object language. You can see the project <a href="https://github.com/osa1/int-proj">here</a>. I tried to write some comments to the source when I get stuck because of a problem or realized something interesting, so I suggest reading the source if you’re interested.</p>
<p>I did two implementations and used a different meta language for each one. There are multiple ways to achieve first Futamura projections: We can use a partial evaluator, a supercompiler(which may actually subsume partial evaluation, depending on how sophisticated it is), or just a “sufficiently smart” compiler. The problem though, we don’t have a lot of(read: any) usable implementations of partial evaluators or supercompilers, so I had to use the only language with a partial evaluator that I could find: <a href="https://github.com/idris-lang/Idris-dev">Idris</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>There’s one another technique that we can use. The techniques I listed above are all completely automated. If things don’t go as expected we’re on our own to figure out why is that and hack around to make the tool transform the program the way we want. Indeed this is happened even in this project, which is deliberately kept simple and small<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>At the other end of the spectrum is multi-stage programming. In multi-stage programming the programmer specifies, using some annotations<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, what code to generate and how to generate it. It clearly separates code that runs in code generation time and generated code. When generated code is printed to be compiled later, multi-stage programming feels like a compiler or a partial evaluator that the programmer can guide to generate the code he/she wants.</p>
<p>My second meta language is <a href="http://okmij.org/ftp/ML/MetaOCaml.html">MetaOCaml</a>, which is basically OCaml with multi-stage programming constructs. Using these two languages as representatives of two different program generation techniques, I implemented first Futamura projections for Unlambda.</p>
<p>There’s a report file in the repository, and I refer interesting readers to that document. README file contains compilation directives and some interesting executions. One interesting thing is that I later added a simple partial evaluator to MetaOCaml implementation, and in the <code>programs/</code> directory there’s an Unlambda interpreter, written in Unlambda. Using these two programs, you can do things like partially applying(specializing) Unlambda interpreter to other programs or even itself. Before every experiment, I suggest thinking about what is the generated code you’re expecting(what does it do). What would a “sufficiently smart” partial evaluator generate? What would a simple partial evaluator generate? Similarly, try these while generating first projections.</p>
<p>Finally, if you’re interested in program transformations, stay tuned for more blog posts.</p>
<p><a href="https://github.com/osa1/int-proj">Link to the project.</a></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>There is actually an <a href="https://github.com/annenkov/unmix">implementation of well-known partial evaluator unmix</a>. I knew about the project, but didn’t remember by the time I started this project. Still, I think I’d choose Idris even if I remembered.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Although some of those problems were implementation related, e.g. Idris was buggy. See the source code for comments and Github issues.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>In MetaOCaml case those annotations are term-level, but there are other cases where annotations happen in type level only. See <a href="http://scala-lms.github.io/">LMS</a> as an example. (I think it’s the only example for now)<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: My first academic work is now open source</title>
    <link href="http://osa1.net/posts/2013-07-22-sqml-open-sourced.html" />
    <id>http://osa1.net/posts/2013-07-22-sqml-open-sourced.html</id>
    <published>2013-07-22T00:00:00Z</published>
    <updated>2013-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Our work at Ozyegin University with Prof. Baris Aktemur is now open source.</p>
<ul>
<li>Home page: <a href="http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/">http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/</a></li>
<li>Github repository: <a href="https://github.com/ozusrl/SubtypedQuotedML">https://github.com/ozusrl/SubtypedQuotedML</a></li>
</ul>
<p>If you have trouble compiling/running it, please file an issue at Github page.</p>]]></summary>
</entry>
<entry>
    <title>Non-local returns in functional programs</title>
    <link href="http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html" />
    <id>http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html</id>
    <published>2013-07-21T00:00:00Z</published>
    <updated>2013-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s say we want to get nth visited element in depth-first traversal of a tree. Doing this is almost too easy in a language with statements(all imperative languages, some functional ones): Just run the depth-first traversal algorithm with explicit stack, and use <code>return</code> when you visit nth node.</p>
<p>In an expression language(Haskell, some Lisp languages) this is somewhat tricky.</p>
<p>Since I almost always prefer simplest possible solution of a problem, this would be my first attempt in a real-world situation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="ot">=</span> <span class="dt">Branch</span> [<span class="dt">Tree</span> a]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Leaf</span> a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>toList (<span class="dt">Branch</span> bs) <span class="ot">=</span> <span class="fu">concatMap</span> toList bs</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>toList (<span class="dt">Leaf</span> a)    <span class="ot">=</span> [a]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="ot">dfsNth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>dfsNth tree n <span class="ot">=</span> listToMaybe <span class="op">.</span> <span class="fu">drop</span> n <span class="op">$</span> toList tree</span></code></pre></div>
<p>One concern about this function may be that the complexity of list generation. It’s hard to predict complexity of this function, but traversing the whole tree just to get first element of it would be costly anyway.</p>
<p>But thanks to lazy evaluation, this function still not very bad. Because only required parts of the intermediate list will be generated. To see why you can do two things: 1) Just place some <code>Debug.Trace.trace</code> calls in <code>toList</code> function and see how many times a leaf node is visited and 2) evaluate this function by hand and observe unevaluated thunks.</p>
<p>Let’s just do the first one, since it’s easier:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>toList (<span class="dt">Branch</span> bs) <span class="ot">=</span> <span class="fu">concatMap</span> toList bs</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>toList (<span class="dt">Leaf</span> a)    <span class="ot">=</span> trace <span class="st">&quot;leaf node visited&quot;</span> [a]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="op">...</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>testTree <span class="ot">=</span> <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">1</span>, <span class="dt">Leaf</span> <span class="dv">2</span> ], <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">3</span> ], <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">4</span> ] ] ] ]</span></code></pre></div>
<pre><code>ghci&gt; dfsNth testTree 0
leaf node visited
Just 1

ghci&gt; dfsNth testTree 1
leaf node visited
leaf node visited
Just 2

ghci&gt; dfsNth testTree 10
leaf node visited
leaf node visited
leaf node visited
leaf node visited
Nothing</code></pre>
<hr />
<p>Other solutions are still worth exploring. When I think of “returning in the middle of a function” in Haskell, I always think <code>Either</code>. It’s monad definition is a great fit for this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Either</span> e) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="fu">return</span>        <span class="ot">=</span> <span class="dt">Right</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="dt">Left</span>  l <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Left</span> l</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="dt">Right</span> r <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> k r</span></code></pre></div>
<p>So when <code>Left data</code> used in monadic bind(<code>&gt;&gt;=</code>), second parameter just ignored and <code>Left data</code> is returned. Just like returning in the middle of a function in imperative setting, by ignoring rest of statements.</p>
<p>Using monad instance of Either, we can easily implement our function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">dfsNth&#39; ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>dfsNth&#39; tree n <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">case</span> iter tree n <span class="kw">of</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>      <span class="dt">Left</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>      <span class="dt">Right</span> i <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ot">    iter ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> a <span class="dt">Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    iter (<span class="dt">Branch</span> []) n     <span class="ot">=</span> <span class="fu">return</span> n</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    iter (<span class="dt">Branch</span> (b<span class="op">:</span>bs)) n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>      n&#39; <span class="ot">&lt;-</span> iter b n</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>      iter (<span class="dt">Branch</span> bs) n&#39;</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    iter (<span class="dt">Leaf</span> a) <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Left</span> a</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    iter <span class="dt">Leaf</span>{}   n <span class="ot">=</span> <span class="fu">return</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>It works exactly like our first implementation, but without generating an intermediate list.</p>
<h2 id="exceptions-and-either-monad">Exceptions and Either monad</h2>
<p>If I were using OCaml, I’d probably implement this function using an exception.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">exception</span> NonLocal <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">type</span> &#39;a tree =</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>  | Branch <span class="kw">of</span> (&#39;a tree) <span class="dt">list</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  | Leaf   <span class="kw">of</span> &#39;a</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="kw">let</span> dfs_nth tree n =</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  <span class="kw">let</span> <span class="kw">rec</span> iter tree n =</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    | Branch [] -&gt;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        n</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    | Branch (b :: bs) -&gt;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>        iter (Branch bs) (iter b n)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    | Leaf a -&gt;</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>        <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dt">raise</span> (NonLocal a) <span class="kw">else</span> n - <span class="dv">1</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>  <span class="kw">in</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>  <span class="kw">try</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    iter tree n;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>    <span class="dt">None</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>  <span class="kw">with</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    | NonLocal a -&gt; <span class="dt">Some</span> a</span></code></pre></div>
<p>An interesting thing to realize here is that this solution is very similar to our Haskell solution. In Haskell, Either is an instance of <code>MonadError</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Error</span> e <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    throwError             <span class="ot">=</span> <span class="dt">Left</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="dt">Left</span>  l <span class="ot">`catchError`</span> h <span class="ot">=</span> h l</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="dt">Right</span> r <span class="ot">`catchError`</span> _ <span class="ot">=</span> <span class="dt">Right</span> r</span></code></pre></div>
<p>This means if you replace <code>Left</code>s with <code>throwError</code> (just like <code>raise</code> in OCaml code), you have a similar solution with OCaml.</p>
<p>This doesn’t mean exceptions are same thing as Either types in functional programming. There are just too many differences that I won’t delve into in this post. With an exception, you can return from arbitrary deep contexts(ie. function calls), which is not easily possible with Either types. This is why exceptions sometimes referred as <em>non-local returns</em>.</p>
<p>We discussed this stuff over OCaml IRC channel, and smart people over there gave me some really good insights about non-local returns and exceptions. I’ll probably delve into details in another blog post. I’m especially interested in functional solutions that we can have in Haskell.</p>
<p>For the curious, for now I’ll just leave these two links here: (I haven’t read that links yet, but they’re probably related)</p>
<ul>
<li><a href="https://ocaml.janestreet.com/?q=node/91">https://ocaml.janestreet.com/?q=node/91</a></li>
<li><a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html</a></li>
</ul>
<p>Several other ideas also discussed at IRC channel, some of them were using delimited continuations, or passing a handler function as parameter and just calling it instead of raising an exception. I’ll continue investigating this stuff later.</p>
<p>I also came across this <a href="http://stackoverflow.com/questions/6915701/is-non-local-return-in-scala-new">StackOverflow post</a> that explains how Scala’s non-local returns implemented as exceptions internally. Interesting stuff.</p>]]></summary>
</entry>
<entry>
    <title>Epic OCamlYacc fail</title>
    <link href="http://osa1.net/posts/2013-03-01-ocamlyacc-fail.html" />
    <id>http://osa1.net/posts/2013-03-01-ocamlyacc-fail.html</id>
    <published>2013-03-01T00:00:00Z</published>
    <updated>2013-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been trying to compile <a href="http://gallium.inria.fr/~fpottier/wallace/">an OCaml library from 2000</a> recently and I came up against a strange OCamlYacc error; OCamlYacc doesn’t compile the parser file because parser function has a polymorphic type(with a type variable <code>'a</code>).</p>
<p>At first I tried to understand with which concrete type <code>'a</code> type variable is being equated, so that I could replace it with the concrete type and the program would be compiled.</p>
<p>After several hours wasted, I decided to follow some different path. I replaced type variables in <code>.mly</code> with some dummy type like <code>my_epic_dummy_type</code> and compiled it with OCamlYacc. Then I replaced <code>my_epic_dummy_type</code> types with the type variable <code>'a</code> in compiled <code>.ml</code> and <code>.mli</code> files.</p>
<p>And the library worked as expected.</p>
<p>Now the question naturally arises: Why does OCamlYacc refuse to compile parser function with polymorphic type ? I have no idea.</p>]]></summary>
</entry>
<entry>
    <title>Rowlar, kindlar ve tip çıkarımı hakkında öylesine bir yazı</title>
    <link href="http://osa1.net/posts/2013-02-15-rowlar-kindlar.html" />
    <id>http://osa1.net/posts/2013-02-15-rowlar-kindlar.html</id>
    <published>2013-02-15T00:00:00Z</published>
    <updated>2013-02-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı birkaç gün önce attığım bir mail aslında. Acele ile yazılmış bir yazı olmasına rağmen epey uzun oldu ve maili yazmaya başlamadan önce kafamda karmaşık bir şekilde duran bazı fikirleri toparlamamda yardımcı oldu. Pek kimsenin işine yarayacağını tahmin etmesem de, yine de buraya koyuyorum. Küçük bazı düzenlemeler yaptım. Eklemeler ise yazının en altına yazıldı. Kodlar OCaml dilinde yazıldı.</p>
<hr />
<p>Üzerinde çalıştığım dilin tip sistemi hakkında<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">type</span> ty =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  | ...</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  | TRow <span class="kw">of</span> tyrow</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  | ...</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="kw">type</span> fieldty =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  | Pre ty</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  | Btm <span class="co">(* Abs ismi lambda abstractionlarda kullanildi *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">type</span> tyrow =</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>  | EmptyRow</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>  | Row (id * ty * ..<span class="dv">1</span>..)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>  | ..<span class="dv">2</span>..</span></code></pre></div>
<p>1 ve 2 boşluklarını doldurmamız gerekiyor. Sorunlar şunlar:</p>
<p>1 kısmına yazdığımız tip, sadece yine kendi tipiyle(yani <code>TRow</code> ile) unify etmek zorunda(ilk bakışta <code>tyrow</code> yazmak mantıklı gibi geliyor ama bu yüzden değil).</p>
<p>2 kısmına yazdığımız constructor polymorphic row’u temsil edecek. Burada ben ilk başta aslında row değişkenlerini tamamen yok sayıp, recordlar extensible mı değil mi diye bir boolean flag tutayım demiştim. Fakat sorun, recordlar rowları paylaşabiliyorlar, örneğin şöyle bir fonksiyonda <code>\r -&gt; r.x = 10</code> tip <code>{r/x} -&gt; {x:int|r/x}</code> oluyor, başka bir yerde bu <code>r</code> kullanılabilir(parametre olarak verilen record başka yerlerde kullanıldığında fonksiyonun dönüş değeri olan recordın row değişkeni ile aynı row değişkenine sahip birden fazla record oluyor). Dolayısıyla bir değişken olmak zorunda.</p>
<p>Fakat bu <code>typevar</code> tipinde olamaz, çünkü <code>typevar</code> bir <code>ty</code> ile unify edilebiliyor. Rowlarda ise <code>tyrow</code> ile unify etmek istiyoruz. Ayrı bir tip gerekiyor yani.</p>
<p>Temel olarak row variable ile normal variable tamamen aynı olmalı, tek farkla, row değişkenler sadece row değişkenlerle/değerler ile unify edecek, variablelar da aynı şekilde.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h2 id="neden-tip-seviyesinde-kindlara-ihtiyaç-var">Neden tip seviyesinde kindlara ihtiyaç var ?</h2>
<p>Type schemeler row değişkenler de tutabilir. <code>let</code> ile bir fonksiyon tanımladım, fonksiyon tipindeki free type variableları generalize ederek(terimler teminoloji ile uyumlu olsun diye ingilizce kullanıldı) bu fonksiyon polymorphic hale getiriliyor ve tipi <code>TypeScheme</code> olarak tutuluyor, quantified değişkenler belirtiliyor.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Daha sonra bu fonksiyon kullanıldığında instantiate ediliyor. Burada instantiate edilen quantified değişkenler yerine ancak kendi kindlarında tiplerin konulması bir şekilde sağlanmalı.</p>
<p>Yani şunu demeye çalışıyorum, elimde bir row variable varsa, bu ancak bir row tipi ile yer değiştirebilir(yerine ancak row tipi yazılabilir). Bunu implementasyon sırasında tip sistemi ile garanti etmek gerçekten zor. İnsanlar bu yüzden kind sistemi kullanıyorlar sanırım.</p>
<p>Kind kullanırsam şöyle oluyor, her tipe bir kind veriyorum. Özet geçmek gerekirse, mesela TVar bir type değişkeni tutuyordu, şimdi bir de kind tutacak. Kindlar ise dilimde kaç tip -birbirlerinden farklı- type varsa, o kadar olacak. Örneğin <code>Star</code> int, bool gibi tipler için kullanılırken, <code>Row</code> row tipleri için kullanılır. Bu sayede bir değişkenim Row kindında ise, quantified edilse de instantiate edilse de bu bilgi taşınır ve en son yerine yazılacağında kind kontrol edilir. Tüm yerine yazmalar <code>kind-preserving</code> olmalıdır.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Bu sayede farklı kindlarda type variablelar için aynı fonksiyonları kullanabilirim, sürekli kind bilgisini de taşırım. En son substitution veya unification yaparken, kindların korunup korunmadığını kontrol ederim ve normal type değişkeni yerine row type yazılmamasını sağlarım veya unification sırasında hata alırım.</p>
<p>–</p>
<p>Kindlarla beraber tipleri şu şekilde tanımlayabiliyoruz(yaklaşık olarak, henüz programı yazmadım)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">type</span> kind =</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  | KStar                 <span class="co">(* kind of term types *)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  | KRow                  <span class="co">(* kind of row types *)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  | KArr <span class="kw">of</span> (kind * kind) <span class="co">(* kind of type constructors *)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">type</span> ty =</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  | TCon <span class="kw">of</span> tycon     <span class="co">(* constant *)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  | TVar <span class="kw">of</span> tyvar     <span class="co">(* type variable *)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  | TApp <span class="kw">of</span> (ty * ty)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>      <span class="co">(* type application, to be well-typed</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="co">         kind of first ty should be KArr (k2, k)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="co">         and second ty should be k2 *)</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="kw">and</span> tyvar = (tyvarlink <span class="dt">ref</span> * kind)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="kw">and</span> tyvarlink =</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>  | NoLink <span class="kw">of</span> id <span class="co">(* just a type variable *)</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  | LinkTo <span class="kw">of</span> ty <span class="co">(* equated to a ty *)</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="kw">and</span> tycon = (id * kind) <span class="co">(* kind should be always KStar *)</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a><span class="kw">let</span> t_int        = TCon (<span class="st">&quot;int&quot;</span>,  KStar)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="kw">let</span> t_bool       = TCon (<span class="st">&quot;bool&quot;</span>, KStar)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span class="kw">let</span> t_unit       = TCon (<span class="st">&quot;unit&quot;</span>, KStar)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a><span class="kw">let</span> t_list       = TCon (<span class="st">&quot;[]&quot;</span>,   KArr (KStar, KStar))</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a><span class="kw">let</span> t_ref        = TCon (<span class="st">&quot;ref&quot;</span>,  KArr (KStar, KStar))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a><span class="kw">let</span> t_arr        = TCon (<span class="st">&quot;-&gt;&quot;</span>,   KArr (KStar, KArr (KStar, KStar)))</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a><span class="kw">let</span> t_empty_row  = TCon (<span class="st">&quot;&lt;|&gt;&quot;</span>,  KRow)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a><span class="kw">let</span> t_row_ext    = TCon (<span class="st">&quot;&lt;+&gt;&quot;</span>,  KArr (KStar, KArr (KRow, KRow)))</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a><span class="kw">let</span> t_rec_const  = TCon (<span class="st">&quot;{_}&quot;</span>,  KArr (KRow, KStar))</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a><span class="co">(* type of {r1} *)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a><span class="kw">let</span> rp1 = TApp (t_rec_const, TVar (<span class="dt">ref</span> (NoLink <span class="st">&quot;r1&quot;</span>), KRow))</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a><span class="co">(* type of {r1} -&gt; {_:int|r1} *)</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a><span class="kw">let</span> f   = TApp (TApp (t_arr, rp1), TApp (TApp (t_row_ext, t_int), rp1))</span></code></pre></div>
<p>En sonraki iki tanım örnek olsun diyeydi.</p>
<p>Karmaşık olduğunun farkındayım ama 1) bu tip sistemi implementasyonları için standard yol gibi geldi bana(çok fazla makalede kind sistemlerinden bahsediliyor) 2) diğer türlü de daha az karmaşık değil gibi.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>Burda mesela <code>TApp</code> oluşturan bir yardımcı fonksiyon oluştururuz ve kindları kontrol eder, uyumlu mu diye, bir miktar daha kolaylaşır. Yardımcı fonksiyonlarla işi kolaylaştırabiliriz diye düşünüyorum yani.</p>
<p>Bu örnekde <code>rp1</code> yerine mesela <code>{a:bool}</code> (yani <code>TApp (TApp (t_rec_ext, bool_ty), t_empty_row)</code>) yazarsak:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>TApp (TApp (t_arr, rp1), TApp (TApp (t_row_ext, t_int), TApp (TApp (t_rec_ext, bool_ty), t_empty_row)))</span></code></pre></div>
<p>Bana gayet temiz bir şekilde <code>{x:int, a:bool}</code> elde ettik gibi geliyor ve tek yaptığımız yerine yazmak oldu. ( bu sunumda labelların atlandığının farkındayım, tam olarak labelları nasıl bu sisteme entegre ederim düşünmedim )</p>
<p>Diğer türlü yapılamaz mı, tabii ki yapılabilir ve ben zaten çok yaklaşmıştım. Fakat çirkin olmayan bir yolu yok. Kod içerisinde şöyle kısımlar olmak <em>zorunda</em> gibi: “implementasyonum doğru olduğuna göre bu type variable record ile unify edilmiş olacak, exhaustive olmayan pattern matching yap”. Mesela tüm row değişkenler bir record’a unify edilimş olacak, ben pattern matching ile fieldları alacağım kendi recordıma ekleyeceğim vs.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>Ama kindler ile yaptığımda bu gibi durumlar olmayacak, ben <code>TApp</code>’lar ile typelar oluşturacağım, kind preserving substitutionlar, generalizationlar, instantiationlar yapılacağından, her zaman row tiplerim well-formed olmuş olacak ben hiçbir kontrol yapmadan <code>TApp</code>’ler oluşturmaya başlayacağım.</p>
<p>Ben bugün akşam birkaç makale daha inceleyeceğim: Type Inference for Records in a Natural Extension of ML (Didier Rémy) ve A Polymorphic Type System for Extensible Records and Variants (Mark P. Jones, Benedict R. Gaster). Bir de Typing Haskell in Haskell (Mark P. Jones)’a baktım, Haskell’da burada konuştuğumuz anlamda recordlar yok, ama kind sisteminden bahsederken “row kindlar da kolayca eklenebilir” diyerek sanırım yukarıda yaptığım şeyi kastetmekte.</p>
<p>Bu nasıl olabiliyor anlayabilmiş değilim ama gerçekten internette hiç örnek implementasyon yok. Bu yüzden ben bir tane yazacağım blog yazısı olarak. Polymorphic recordlara sahip bir dil inceleyeyim dedim, bir tanesi <a href="http://elm-lang.org/">Elm</a> adlı bir dil, kaynağı Haskell ile yazılmış temel olarak “Scoped Labels” makalesini kullanmış, ama kod berbat bir durumda. Çok çok karmaşık, kod stili berbat(type annotationlarını atlamış, Haskell’da bunu hiçbir zaman yapmayız, derleyici uyarı verir, annotationlar OCaml’daki gibi kodun içine yazılmaz, ayrı bir satıra yazılır ve anlaşılabilmeye çok katkı sağlarlar) vs. Yine de okunacak olursa en mantıklısı bu.</p>
<p>İkincisi <a href="http://www.pllab.riec.tohoku.ac.jp/smlsharp/">SML#</a>. Bu da ne yazık ki SML üzerine implement edilmiş ve kaynak kodu devasa. Tüm SML kodunu incelemek gerekecek yani(aradım bulamadım alakalı kısımları).<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Özetle, row polymorphism’e sahip, multi-staged bir dil. Buradaki veri yapısı dilin tip sistemini ifade ediyor. Row tiplerine dikkat. Row polymorphism’de fieldlar üzerinde bazı kısıtlar tanımlamanın birkaç yolu var. Bir yol, benim burada yaptığım ve <a href="http://gallium.inria.fr/~remy/publications.html">D. Rémy</a>’nin “Type inference for records in a natural extension of ML” ve başka makalelerinde gösterdiği gibi, field tiplerinde bir çeşit “flag” tutmak. Makalelerde Abs/Pre diye geçer, benim kodumda Pre/Btm. Bu yolun bu işi yapmak en bariz yol olduğunu söyleyebiliriz belki. Fakat kesinlikle en kolay/güzel yötem değil. Alternatif olarak kısıtlar constraint seviyesinde, kind seviyesinde veya başka bazı seviyelerde tanımlanabiliyor.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Burada anlatmaya çalıştığım problem bana çok vakit kaybettirdi ve aslında pek çok kişiye tanıdık gelebilir. Kısaca yapmaya çalıştığım şey, bazı şeyleri statik olarak garanti etmek için tip sistemini kullanmaya çalışmak. Örneğin bir programlama dilinde syntax ağacını well-formed olmayan programları ifade edebilmesini engelleyecek şekilde oluşturmak gibi. Bu gibi durumlarda eğer yeterince güçlü tip sisteminiz yoksa(örnek: GADTler yardımcı olabiliyor) işiniz çok zorlaşabiliyor. Daha kolay bir yöntemi runtime’da bunu garantilemek. Hemen sonrasında anlattığım şey tam olarak bu aslında. Statik garantiler verebilmek süper birşey aslında. Hiçbir şart altında programınızın yanlış çalışmayacağını garanti altına alıyorsunuz. Ama bazı durumlarda bu mümkün ama çok zor olabiliyor. Diğer yandan, zor da olsa bir kere implement ettikten sonra kesin olarak doğru çalışacağından emin olabiliyorsunuz. Veya test etmesi çok kolay oluyor vs.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Anlattığım şey Damas-Hindley-Milner tip sisteminin temellerinden aslında.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Kindları kendi kendime keşfettiğim an. Aslında Haskell programcısı olduğumdan kind konspetine aşinaydım, ama bu şekilde kullanımı bir bakıma kendi kendime keşfettim diyebilirim. Kind adını da ben vermedim tabii, daha sonra hakkında okudukça farkettim.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>“diğer türlü daha az karmaşık değil gibi” derken kastettiğim, Rémy usulü, field tiplerine bir flag koyarak Abs/Pre özelliğini belirtmekti.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Burda aslında biraz programımın implementasyonu ile alakalı detaylardan bahsediyorum. Belki bir ara biraz daha açarım.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Daha sonradan farkettim ki bir alternatif daha varmış: “Extensible records with scoped labels” makalesinde bahsedilenlerin implement edildiği <a href="http://www.equational.org/morrow/">Morrow</a> programlama dili. En iyi implementasyon şimdilik bu. Tek problemi, kurulmak için <a href="http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem">UUAG attribute grammar system</a>a ihtiyaç duyması. Bir de eğer sadece type inference yapmasın, bir de çalıştırsın derseniz, OCaml’a ihtiyaç duyuyor. Evet çok fantastik. Haskell ile statik analiz kısımları yapılıyor ve OCaml’a derleniyor. Tabii programın asıl olayı tip sistemi olduğundan, deneme için yazdığınız programları çalıştırmak istemeyebilirsiniz, o zaman OCaml’a gerek yok.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Quick Vim Tip for OCaml programmers: Fix OCamlYacc comment syntax</title>
    <link href="http://osa1.net/posts/2013-02-14-quick-vim-tip-for-ocaml.html" />
    <id>http://osa1.net/posts/2013-02-14-quick-vim-tip-for-ocaml.html</id>
    <published>2013-02-14T00:00:00Z</published>
    <updated>2013-02-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been editing OCaml with Vim for several months now, one problem that annoys me with Vim’s built-in OCaml syntax highlighter is it behaves OCamlYacc files like it’s a normal OCaml file.</p>
<p>It generally works fine but OCamlYacc’s comment syntax is different from OCaml’s. When working on big OCamlYacc files this quickly becomes annoying.</p>
<p>I’m not proficient in VimL but I could manage to write a simple solution. I replaced this line in Vim’s built-int OCaml syntax highlighter:</p>
<pre><code>&quot; Comments 
syn region   ocamlComment start=&quot;(\*&quot; end=&quot;\*)&quot; contains=ocamlComment,ocamlTodo</code></pre>
<p>with:</p>
<pre><code>&quot; Comments
if expand(&quot;%:e&quot;) == &quot;mly&quot;
  syn region   ocamlComment start=&quot;/\*&quot; end=&quot;\*/&quot; contains=ocamlComment,ocamlTodo
else
  syn region   ocamlComment start=&quot;(\*&quot; end=&quot;\*)&quot; contains=ocamlComment,ocamlTodo
end</code></pre>
<p>(You can find you Vim’s built-in files’ folders by runing <code>:echo $VIMRUNTIME</code> inside Vim. On my machine, <code>ocaml.vim</code>s path is <code>/usr/share/vim/vim73/syntax/ocaml.vim</code>)</p>
<p>Works great. It can be further simplified but requires a variable declaration and I don’t want to mess with Vim variables without understanding the consequences(scope rules etc.)</p>]]></summary>
</entry>

</feed>
