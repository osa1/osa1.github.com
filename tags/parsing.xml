<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged parsing</title>
    <link href="http://osa1.net/tags/parsing.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/parsing.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-03-07T00:00:00Z</updated>
    <entry>
    <title>An idea to handle left-recursion in Parsec</title>
    <link href="http://osa1.net/posts/2014-03-07-parsec-left-recursion.html" />
    <id>http://osa1.net/posts/2014-03-07-parsec-left-recursion.html</id>
    <published>2014-03-07T00:00:00Z</published>
    <updated>2014-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently realized that it may be possible to handle left-recursion in Parsec style parser combinator libraries. I quickly wrote a simple prototype implementation that demonstrates the idea.</p>
<p>The idea is to keep track of parser functions that are called without consuming any tokens from input stream. You should be able to run failure procedures when same parser function is encountered more than one time without consuming any tokens. When a token is consumed, state that is used to keep track of parser functions should be reset.</p>
<p>One assumption here is that I’m assuming parser functions do not alter any states. Otherwise when you come across a same parser, you can have different state and parser may behave differently.</p>
<p>Implementing the idea is easy even without having any extra support from Parsec. Here’s a demonstration on my favorite ambiguous grammar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Exp ::= Int</span>
<span class="co">--      |  Exp `+` Exp</span>

<span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre>
<p>Parsers for non-terminals are easy:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">plus <span class="fu">=</span> char <span class="ch">&#39;+&#39;</span> <span class="fu">&gt;&gt;</span> spaces
int  <span class="fu">=</span> fmap (<span class="dt">Int</span> <span class="fu">.</span> read) <span class="fu">$</span> many1 digit <span class="fu">&lt;*</span> spaces</code></pre>
<p>I’m using a set to keep track of already visited parsers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MarksSeen</span> <span class="fu">=</span> <span class="dt">S.Set</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">RecParser</span> s m a <span class="fu">=</span> <span class="dt">ParsecT</span> s <span class="dt">MarksSeen</span> m a</code></pre>
<p>Auxiliary functions to alter the state that keeps track of visited parsers:</p>
<pre><code>putMark i = do
    is &lt;- getState
    if S.member i is
      then fail &quot;recursion&quot;
      else putState $ S.insert i is

resetMarks = putState S.empty</code></pre>
<p>Now the interesting part, <code>add</code> parser marks itself as first thing to do, and calls <code>exp</code> parser. Since <code>exp</code> parser is entry point, this means an indirect recursive call. When same <code>putMark</code> call is made, Parsec runs failure actions instead of going into infinte loop:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="fu">=</span> <span class="kw">do</span>
    putMark <span class="dv">1</span>
    e1 <span class="ot">&lt;-</span> exp
    resetMarks
    plus
    e2 <span class="ot">&lt;-</span> exp
    spaces
    return <span class="fu">$</span> <span class="dt">Add</span> e1 e2

exp <span class="fu">=</span> choice [try add, int]</code></pre>
<p><code>resetMarks</code> call is also important, <code>exp</code> has to consume some tokens, so after parsing <code>e1</code>, I’m calling <code>resetMarks</code>.</p>
<p>Here’s an example call of this parser:</p>
<pre><code>ghci&gt; runParser exp S.empty &quot;&quot; &quot;1 + 2 + 3 + 4&quot;
Right (Add (Int 1) (Add (Int 2) (Add (Int 3) (Int 4))))</code></pre>
<p>You can observe that parser gets into an infinite loop when marks are removed. Here’s an example demonstrating the error message:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rec <span class="fu">=</span> putMark <span class="dv">0</span> <span class="fu">&gt;&gt;</span> rec <span class="fu">&gt;&gt;</span> resetMarks

ghci<span class="fu">&gt;</span> runParser rec S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>
<span class="dt">Left</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)<span class="fu">:</span>
recursion</code></pre>
<p>One problem with this approach is that it requires more typing, and you should be careful too. Marks can be placed using TemplateHaskell to ensure unique numbers are given to each <code>putMark</code> call. As a second improvement, I think with some modifications on Parsec we can make Parsec to reset marks when a token is consumed(using <em>consumed-ok</em> continuation of <code>ParsecT</code>).</p>
<p>You can see the complete program <a href="https://gist.github.com/osa1/9414577">here</a>.</p>
<hr />
<p>Removing left-recursions in your grammar may not be a huge problem – except when you’re working on functional languages with ML-like syntax. Then you’re out of luck because being functional means you’re <code>Exp</code> non-terminal contains several dozen of productions and function applications is a part of that too, and it’s left-recursive:</p>
<pre><code>Exp ::= ...
     |  Exp Exp_1 ... Exp_N [left-associative]
     ... a hundred more productions ...</code></pre>
<p>Whenever I need to write a parser for a grammar like this, I’m thinking for an easier way to parse it. I still couldn’t come up with a solution. Idea I just explained does not solve it, because it parses right-associatively. There is one workaround, but I’m not sure if that results with a parser for same grammar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">app <span class="fu">=</span> <span class="kw">do</span>
    putMark <span class="dv">2</span>
    fn <span class="ot">&lt;-</span> exp
    resetMarks

    putMark <span class="dv">2</span>
    as <span class="ot">&lt;-</span> many1 exp
    resetMarks

    return <span class="fu">$</span> foldl <span class="dt">App</span> fn as


ghci<span class="fu">&gt;</span> runParser pgm S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;1 2 3 4 + 5 + 6 7&quot;</span>
<span class="dt">Right</span> (<span class="dt">Add</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">1</span>) (<span class="dt">Int</span> <span class="dv">2</span>)) (<span class="dt">Int</span> <span class="dv">3</span>)) (<span class="dt">Int</span> <span class="dv">4</span>)) (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">5</span>) (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">6</span>) (<span class="dt">Int</span> <span class="dv">7</span>))))

ghci<span class="fu">&gt;</span> runParser pgm S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;1 + 2 + 3 4&quot;</span>
<span class="dt">Right</span> (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">1</span>) (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">2</span>) (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">3</span>) (<span class="dt">Int</span> <span class="dv">4</span>))))</code></pre>]]></summary>
</entry>
<entry>
    <title>Memoized parsing in continuation-passing style</title>
    <link href="http://osa1.net/posts/2013-10-21-memoized-parsing-cps.html" />
    <id>http://osa1.net/posts/2013-10-21-memoized-parsing-cps.html</id>
    <published>2013-10-21T00:00:00Z</published>
    <updated>2013-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Continuations are truly magical things. They’re the “ultimate abstractions of control flow”. Even without using any fancy language features like <code>call/cc</code>, you can have seriously cool and mind-boggling programs.</p>
<p>In <a href="http://arxiv.org/pdf/cmp-lg/9504016">“Memoization in Top-Down Parsing”</a> paper, Mark Johnson builds up from memoizing top-down parsers and describes a way to handle left recursion in top-down parsers by combining memoization techniques with continuations.</p>
<p>I ported the code to Lua to experiment, you can see it <a href="https://gist.github.com/osa1/7089333">here</a>. Most interesting part is the memoized CPS parser generator from a normal CPS parser function:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> memo<span class="ot">(</span>parser<span class="ot">)</span>
    <span class="co">-- WARNING: this function is badly implemented in the sense that</span>
    <span class="co">-- if you parser generated by this function on two different streams</span>
    <span class="co">-- it will generate wrong results</span>
    <span class="kw">local</span> tbl <span class="ot">=</span> <span class="ot">{}</span>
    <span class="kw">return</span> <span class="kw">function</span> <span class="ot">(</span>stream<span class="ot">,</span> idx<span class="ot">,</span> cont<span class="ot">)</span>
        <span class="kw">if</span> tbl<span class="ot">[</span>idx<span class="ot">]</span> <span class="ot">==</span> <span class="kw">nil</span> <span class="kw">then</span>
            tbl<span class="ot">[</span>idx<span class="ot">]</span> <span class="ot">=</span> <span class="ot">{</span> results <span class="ot">=</span> <span class="ot">{},</span> conts <span class="ot">=</span> <span class="ot">{}</span> <span class="ot">}</span>
            <span class="fu">table.insert</span><span class="ot">(</span>tbl<span class="ot">[</span>idx<span class="ot">].</span>conts<span class="ot">,</span> cont<span class="ot">)</span>
            parser<span class="ot">(</span>stream<span class="ot">,</span> idx<span class="ot">,</span> <span class="kw">function</span> <span class="ot">(</span>parse_result<span class="ot">)</span>
                <span class="co">-- check if same parse_result is already in the table</span>
                <span class="kw">local</span> exists <span class="ot">=</span> <span class="kw">false</span>
                <span class="kw">for</span> _<span class="ot">,</span> result <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span>tbl<span class="ot">[</span>idx<span class="ot">].</span>results<span class="ot">)</span> <span class="kw">do</span>
                    <span class="kw">if</span> result <span class="ot">==</span> parse_result <span class="kw">then</span> <span class="co">-- TODO: this equality is probably wrong</span>
                        exists <span class="ot">=</span> <span class="kw">true</span>
                        <span class="kw">break</span>
                    <span class="kw">end</span>
                <span class="kw">end</span>
 
                <span class="kw">if</span> <span class="kw">not</span> exists <span class="kw">then</span>
                    <span class="fu">table.insert</span><span class="ot">(</span>tbl<span class="ot">[</span>idx<span class="ot">].</span>results<span class="ot">,</span> parse_result<span class="ot">)</span>
                    <span class="kw">for</span> _<span class="ot">,</span> cont <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span>tbl<span class="ot">[</span>idx<span class="ot">].</span>conts<span class="ot">)</span> <span class="kw">do</span>
                        cont<span class="ot">(</span>parse_result<span class="ot">)</span>
                    <span class="kw">end</span>
                <span class="kw">end</span>
            <span class="kw">end</span><span class="ot">)</span>
        <span class="kw">else</span>
            <span class="fu">table.insert</span><span class="ot">(</span>tbl<span class="ot">[</span>idx<span class="ot">].</span>conts<span class="ot">,</span> cont<span class="ot">)</span>
            <span class="kw">for</span> _<span class="ot">,</span> result <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span>tbl<span class="ot">[</span>idx<span class="ot">].</span>results<span class="ot">)</span> <span class="kw">do</span>
                cont<span class="ot">(</span>result<span class="ot">)</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
        <span class="kw">return</span> tbl<span class="ot">[</span>idx<span class="ot">]</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>(btw, I found porting this code to a purely functional setting very hard thing to do. If you find a way to do this, please send me your code. Thanks.)</p>
<p>This piece of code didn’t make sense to me for a while. I think the key to understand this function is to find answer to this question:</p>
<p>How is this different from keeping a set of productions visited without consuming any input from input stream and when you come to the same production, just failing instead of trying to parse? Because trying to derive same production without consuming any input means you’ll end up with infinite loop.</p>
<p>This function different in that it accounts for parsing same production after following a different path of production. Think this CFG as an example:</p>
<pre><code>T ::= T + T
    | int</code></pre>
<p>In order to derive first production, it first needs to parse a <code>T</code>. But then it will be already noted that it was already trying to parse <code>T</code>, and add the continuation to the list of continuations to be called when a T at input position 1 is parsed.</p>
<p>While trying alternatives, it will parse an <code>int</code>, and derive <code>T -&gt; int</code> at input position 1. And since it had saved the continuations to call when it successfully parse a <code>T</code> at location 1, it will call this continuations and thus parsing will continue.</p>
<p>I hope this helps other people to understand the trick.</p>]]></summary>
</entry>

</feed>
