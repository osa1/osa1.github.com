<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged rust</title>
    <link href="http://osa1.net/tags/rust.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/rust.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2017-10-08T00:00:00Z</updated>
    <entry>
    <title>More Rust woes</title>
    <link href="http://osa1.net/posts/2017-10-08-more-rust-woes.html" />
    <id>http://osa1.net/posts/2017-10-08-more-rust-woes.html</id>
    <published>2017-10-08T00:00:00Z</published>
    <updated>2017-10-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the third part of the series (<a href="http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html">1</a>, <a href="http://osa1.net/posts/2016-09-11-more-rust-problems.html">2</a>) we’re going to look at two curious cases, first one related with “drop checker” and the second one with “borrow checker”.</p>
<p>(examples below are tested with <code>rustc 1.22.0-nightly (05f8ddc46 2017-10-07)</code>)</p>
<h1 id="redundant-semicolon-fixes-borrow-or-drop-checker">1. Redundant semicolon fixes borrow (or drop) checker</h1>
<p>It turns out if you’re getting a weird borrow checker error about something not living long enough to be dropped you can sometimes fix it by adding more semicolons.</p>
<p>The error message itself is weird because intuitively you’d think that for something to be dropped it should first become dead, but the error message says something like “<code>x</code> dropped here while still borrowed”. Because the variable is not dropped explicitly by the user, this error message is actually complaining about compiler’s behavior not being consistent in itself.</p>
<p>Here’s an example:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Arc;
<span class="kw">use</span> std::sync::Mutex;

<span class="kw">fn</span> main() {
    <span class="kw">let</span> s: Arc&lt;Mutex&lt;<span class="kw">i32</span>&gt;&gt; = Arc::new(Mutex::new(<span class="dv">0</span>));
    <span class="kw">match</span> s.lock().unwrap() {
        _ =&gt; {}
    }
}</code></pre>
<p>This fails to compile with:</p>
<pre><code>error[E0597]: `s` does not live long enough
 --&gt; src/main.rs:9:1
  |
6 |     match s.lock().unwrap() {
  |           - borrow occurs here
...
9 | }
  | ^ `s` dropped here while still borrowed
  |
  = note: values in a scope are dropped in the opposite order they are created</code></pre>
<p>Solution? Add more semicolons! In this example, just put a semicolon after the match expression and it compiles fine.</p>
<p>Here’s <a href="https://github.com/rust-lang/rust/issues/21114#issuecomment-312447832">one more example</a>. It turns out questions about this error message are regularly asked on the IRC channel.</p>
<p><a href="https://github.com/rust-lang/rust/issues/21114">#21114</a> reported this issue on Jan 14, 2015, but no progress has been made towards a solution so far. It’s not clear if non-lexical lifetimes will help solving this.</p>
<h1 id="match-expression-keeps-values-alive-longer-than-necessary">2. <code>match</code> expression keeps values alive longer than necessary</h1>
<p>This problem is kind of special. All other problems mentioned in this series were about borrow checker being too strict. This one is different: it causes runtime bugs.</p>
<p><code>match</code> expression keeps the value to be examined (sometimes called <code>scrutinee</code> in Haskell land) alive longer than necessary. Because alive values are not dropped, if you rely on dynamic borrow checks in the scrutinee and in the branches, your checks fail. Here’s an example:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Arc;
<span class="kw">use</span> std::sync::Mutex;

<span class="kw">struct</span> S(<span class="kw">i32</span>);

<span class="kw">impl</span> S {
    <span class="kw">pub</span> <span class="kw">fn</span> get_int(&amp;<span class="kw">self</span>) -&gt; <span class="kw">i32</span> {
        <span class="kw">self</span>.<span class="dv">0</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> set_int(&amp;<span class="kw">mut</span> <span class="kw">self</span>, i: <span class="kw">i32</span>) {
        <span class="kw">self</span>.<span class="dv">0</span> = i;
    }
}

<span class="kw">fn</span> main() {
    <span class="kw">let</span> s = Arc::new(Mutex::new(S(<span class="dv">0</span>)));
    <span class="kw">match</span> s.lock().unwrap().get_int() {
        i =&gt; {
            s.lock().unwrap().set_int(i);
        }
    };
}</code></pre>
<p>(notice how I use a redundant semicolon after the match expression, to fix #1)</p>
<p>Even though <code>get_int()</code> returns in <code>i32</code> as a value, not a reference, the <code>MutexGuard</code> returned by <code>Mutex::lock()</code> is kept alive in the branches of this <code>match</code> expression, so the second <code>Mutex::lock()</code> call causes a deadlock. Solution? Use a <code>let</code> expression:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = s.lock().unwrap().get_x();
<span class="kw">match</span> x { ... }</code></pre>
<p>This problem makes <code>match &lt;expr&gt; { ... }</code> less useful than <code>let x = &lt;expr&gt;; match x { ... }</code>.</p>
<p><a href="https://github.com/rust-lang/rust/issues/38355">#38355</a> reported this issue on Dec 14, 2016, but no progress towards a solution has been made so far.</p>]]></summary>
</entry>
<entry>
    <title>More Rust problems (and a sketch of a solution)</title>
    <link href="http://osa1.net/posts/2016-09-11-more-rust-problems.html" />
    <id>http://osa1.net/posts/2016-09-11-more-rust-problems.html</id>
    <published>2016-09-11T00:00:00Z</published>
    <updated>2016-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s a nice coincidence that after a good productive weekend of Rust hacking I saw <a href="https://hackernoon.com/why-im-dropping-rust-fd1c32986c88">this blog post</a> about why the author is dropping Rust. I’ve been doing a lot of Rust programming lately (I have at least 3 programs –not libraries– that I’m hoping to publish in the near future), and I’m surprised to see that no one mentioned in the discussion threads about this blog post what IMHO is one of the most annoying problems with Rust.</p>
<p>Borrow checker rejects some programs that are perfectly valid in other languages, and by itself this isn’t a problem. Similar things happen in all languages <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. One of the first problems I encountered after started to write Rust was the OP’s second problem, namely, cyclic data structures (or graphs, but more specifically, widgets with parent/child relations). However, there is at least one pretty good solution for this, and all you need is to think harder and experiment with alternative designs. I’m actually very happy with my solution to this (which is also discovered independently by many people, for an example, see <a href="https://crates.io/crates/petgraph">petgraph</a>).</p>
<p>However, there are problems that basically can’t be solved in Rust without paying some runtime costs or using bad practices. See my <a href="">previous blog post</a> for some examples. In this post I’m going to show another, and more annoying, problem.</p>
<h1 id="self-borrows-all-of-its-fields"><code>self</code> borrows all of its fields</h1>
<p>This is a problem that happened in pretty much every single Rust program I’ve ever written. In a method, you can’t borrow some fields, and call another <code>&amp;mut self</code> method. This is because methods borrow the whole <code>self</code>, so you get an error saying that you can’t borrow <code>self</code> twice.</p>
<p>As an example, imagine writing a compiler. For some reason you want to collect all the variables defined in a scope, and then generate fresh variables for those. You may do something like this:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> FreshGen { <span class="co">/* abstract */</span> }

<span class="kw">struct</span> Var { <span class="co">/* abstract */</span> }

<span class="kw">impl</span> FreshGen {
    <span class="kw">fn</span> fresh(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; Var {
        <span class="ot">unimplemented!</span>()
    }
}

<span class="kw">struct</span> Compiler {
    fresh_gen: FreshGen,
    vars_in_scope: Vec&lt;Var&gt;,
}

<span class="kw">impl</span> Compiler {
    <span class="kw">fn</span> fresh(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; Var {
        <span class="kw">self</span>.fresh_gen.fresh()
    }

    <span class="kw">fn</span> gen_locals(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="kw">let</span> <span class="kw">mut</span> fresh_vars = <span class="ot">vec!</span>[];
        <span class="kw">for</span> var in <span class="kw">self</span>.vars_in_scope.iter() {
            fresh_vars.push(<span class="kw">self</span>.fresh());
        }
        <span class="co">// use fresh_vars</span>
    }
}</code></pre>
<p>Can you see any problems here? When I compile this with nightly 11/9/2016, I get this annoying error message:</p>
<pre><code>error[E0502]: cannot borrow `*self` as mutable because `self.vars_in_scope` is also borrowed as immutable
  --&gt; &lt;anon&gt;:24:29
   |
23 |         for var in self.vars_in_scope.iter() {
   |                    ------------------ immutable borrow occurs here
24 |             fresh_vars.push(self.fresh());
   |                             ^^^^ mutable borrow occurs here
25 |         }
   |         - immutable borrow ends here</code></pre>
<p>So basically, <code>self.vars_in_scope</code> is borrowed from <code>self</code>, and then <code>self.fresh()</code> is called while <code>vars_in_scope</code> is still borrowed. Even though <code>self.fresh()</code> doesn’t have anything to do with <code>self.vars_in_scope</code>, this is not allowed because the compiler simply doesn’t care about what pieces of <code>self</code> methods actually borrow. For me this is probably the #1 most annoying problem with Rust.</p>
<p>Now, I believe this problem is solvable. I imagine an algorithm like this:</p>
<p>It works in two steps.</p>
<ol style="list-style-type: decimal">
<li><p>We generate, for every method, borrow sets. A borrow set is a set of fields that are, at some point in the method, borrowed from <code>self</code>.</p></li>
<li><p>For every method call statement in every method, we look at intersections of currently borrowed fields and the borrow set of callee (i.e. (1) for the method being called).</p></li>
</ol>
<p>(1) works like this:</p>
<pre><code>workset = set of all methods
caller-graph = graph of all methods, with edges from callees to callers

# initially none of methods borrow any fields
for method in methods:
    method.borrows = empty set

while workset is not empty:
    work = workset.pop()
    for statement in work.statements:
        for field in self.borrowed_at(statement):
            if not work.borrows.contains(field):
                work.borrows.insert(field)
                for caller in caller-graph[work]:
                    workset.insert(caller)</code></pre>
<p>For a statement that has a method call, <code>borrowed_at()</code> returns the borrow set of the method being called. So when we update borrow set of a method, we add its callers to the workset and <code>borrowed_at()</code> will return more variables next time, propagating the information in the graph from callees to callers.</p>
<p>Now, for the second step, we first need to generate “live ranges” of borrowed fields. Assume that they’re generated.</p>
<pre><code>for method in methods:
    for borrowed_field in method.borrows():
        for field_live_range in borrowed_field.live_ranges():
            # for methods called in the range
            for method in method_calls(field_live_range):
                if method.borrows().contains(borrowed_field):
                    error(&quot;can&#39;t borrow twice&quot;)</code></pre>
<p>I sketched this in 30 minutes so I don’t expect this to work perfectly. Also, 4-level nested for loops look scary! But this is just to give an idea of how this might be solved.</p>
<p>In the example I showed above, borrow set of <code>fresh</code> would be <code>{fresh_gen}</code>, and borrow set of <code>gen_locals</code> would be <code>{vars_in_scope, fresh_gen}</code>. Now we look at live ranges of variables borrowed from <code>self</code> in <code>gen_locals</code>.</p>
<ul>
<li><code>vars_in_scope</code> lives between lines 2-4 in the method.</li>
<li><code>fresh_gen</code> lives in line 3 in the method.</li>
</ul>
<p>Since each variable has only one live range here, clearly there won’t be any intersections. So this would pass the borrow checker.</p>
<p>If <code>fresh</code> was also borrowing <code>vars_in_scope</code>, we’d get an error because <code>vars_in_scope</code> would now have two “live ranges”: between lines 2-4 as before, and in line 3. Since those intersect, we get an error.</p>
<p>(Again, this is a very quick sketch, so let me know if I’m missing something.)</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’m hoping to write more about this later. For now, think Haskell’s type system that separates pure functions from effectful ones as an example.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>How I solved the Synacor Challenge</title>
    <link href="http://osa1.net/posts/2016-06-19-solving-synacor-challenge.html" />
    <id>http://osa1.net/posts/2016-06-19-solving-synacor-challenge.html</id>
    <published>2016-06-19T00:00:00Z</published>
    <updated>2016-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It took 4 attempts at various coffee shops in Cambridge/UK (where I’m spending this summer – more on this later) but I finally solved the <a href="https://challenge.synacor.com/">Synacor Challenge</a>. Here’s how I did it.</p>
<p>WARNING: This post spoils everything! Do not read further if you’re interested in solving it yourself. It’s a lot of fun, so I highly recommend that.</p>
<h1 id="first-attempt">First attempt</h1>
<p>Initial VM implementation took about an hour. It worked well until I was eaten by a grue. At that point I realized that I need a save/load system.</p>
<p>The game looks like a classic text-based adventure where you interact by typing commands. So I thought saving the commands should be enough for “save game”. To load, VM would just load the input from the save file to its input buffer (which is used when <code>in</code> instruction is executed). Indeed it works nicely.</p>
<p>The game is very easy until you make it to the “office”. IIRC, you collect 6 out of 8 codes until that point. At the office you learn about the teleporter, which is the first real challenge in the game…</p>
<h1 id="second-attempt">Second attempt</h1>
<p>At this point I implemented about 20 debugger commands, for things like stepping, breaking at an instruction, breaking at an address, breaking on a specific register read, setting the instruction pointer etc. Just by using these commands I was able to teleport to the right place. However, the code I found there did not really work. It turns out the code is generated dynamically, based on the value in R8. Which is kind of expected, otherwise we could find all the codes just by looking at strings in the binary.</p>
<p>So at this point I realize I need a disassembler…</p>
<h1 id="third-attempt">Third attempt</h1>
<p>The disassembler was trivial to implement. I implement it as a part of VM because 1) in theory the program can generate code in runtime (although I don’t think this is the case in practice) 2) code and data is in the same address space and instruction boundaries are not clearly known. I guess I could do something like: Start with address 0, at each jump disassemble the jump target etc. but I’m not sure if that works as some jump targets are generated dynamically.</p>
<p>Anyway, the debugger has a disassembler now, and I start disassembling functions.</p>
<p>When I step instruction by instruction after using the teleporter, I see that it’s checking R8, if it’s not 0, then calling a function which is the “confimation process” that’s supposed to take 1 billion years. The function has very complex control flow so I try to avoid actually debugging it.</p>
<p>I look at the code that this function returns to. It’s checking if R1 (which has the return value) is 6. So I think, why not just set R1 6 and return from the function? Indeed, it works, but not really how I expected. I already knew that the code I’m searching is generated dynamically, but it’s actually generated using R8, and only when R1 is 6. So as it turns out, I need to guess a value of R8 that makes the validation function return 6. Just making the function return 6 doesn’t really work.</p>
<p>However, I said “it kinda worked”. Because the teleporter actually teleports me to the right place. It’s just that the generated code is not valid.</p>
<h1 id="fourth-attempt">Fourth attempt</h1>
<p>Before disassembling the verification function, I decide to solve the rest of the challenge. I realize that we’re now in a maze, 4x4. Each tile in the maze has either a number, or an operation (<code>+</code>, <code>-</code>, <code>*</code>). There’s an orb in the south-west corner, and there’s a door in the north-east corner. “30” is written on the door, and “22” is printed on the Orb. It’s easy to see what’s going on. Two things to realize are that every time we return to the first tile things get reset, and the goal tile can be visited only once (the orb disappears on visit).</p>
<p>I implement a program that does breadth-first search on this state space, see <code>maze.rs</code>. It then prints directions. When we follow those directions we find the final code and the challenge is completed.</p>
<p>However, since I by-passed the previous challenge, I need to solve that now.</p>
<p>This is the most fun part, it involves lots of debugging, and some programming. Here’s the disassembly of the verification function:</p>
<pre><code>                                         -- fn(reg0 = 4, reg1 = 1, reg7 = our value) {
[6027] Jt [Reg(0), Num(6035)]            --   if reg0 == 0 {
[6030] Add [Reg(0), Reg(1), Num(1)]      --     reg0 = reg1 + 1;
[6034] Ret []                            --     return; }
[6035] Jt [Reg(1), Num(6048)]            --   if reg1 == 0 {
[6038] Add [Reg(0), Reg(0), Num(32767)]  --     reg0 -= 1;
[6042] Set [Reg(1), Reg(7)]              --     reg1 = reg7;
[6045] Call [Num(6027)] ------ loop      --     fn();
[6047] Ret []                            --     return; }
[6048] Push [Reg(0)]                     --   push(reg0);
[6050] Add [Reg(1), Reg(1), Num(32767)]  --   reg1 -= 1;
[6054] Call [Num(6027)] ------ loop      --   fn();
[6056] Set [Reg(1), Reg(0)]              --   reg1 = reg0;
[6059] Pop [Reg(0)]                      --   reg0 = pop();
[6061] Add [Reg(0), Reg(0), Num(32767)]  --   reg0 -= 1;
[6065] Call [Num(6027)] ------ loop      --   fn();
[6067] Ret [] -- end of function at 6027 --   return;
                                         -- }</code></pre>
<p>I added next to each instruction how they would look like in a C-like language. It’s hard to understand what’s going on. So to experiment with it I implement it in Rust. Since registers are shared in each call, I use shared state in my initial implementation:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>inline<span class="ot">]</span>
<span class="kw">fn</span> add(i1 : <span class="kw">u16</span>, i2 : <span class="kw">u16</span>) -&gt; <span class="kw">u16</span> {
    (i1 + i2) % <span class="dv">32768</span>
}

<span class="ot">#[</span>derive<span class="ot">(</span>Debug<span class="ot">)]</span>
<span class="kw">struct</span> FnState {
    reg0  : <span class="kw">u16</span>,
    reg1  : <span class="kw">u16</span>,
    reg7  : <span class="kw">u16</span>,
    stack : Vec&lt;<span class="kw">u16</span>&gt;,
}

<span class="kw">impl</span> FnState {
    <span class="kw">fn</span> init(reg0 : <span class="kw">u16</span>, reg1 : <span class="kw">u16</span>, reg7 : <span class="kw">u16</span>) -&gt; FnState {
        FnState {
            reg0: reg0,
            reg1: reg1,
            reg7: reg7,
            stack: Vec::new(),
        }
    }

    <span class="kw">fn</span> f(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="kw">if</span> <span class="kw">self</span>.reg0 == <span class="dv">0</span> {
            <span class="kw">self</span>.reg0 = add(<span class="kw">self</span>.reg1, <span class="dv">1</span>);
            <span class="kw">return</span>;
        }
        <span class="kw">if</span> <span class="kw">self</span>.reg1 == <span class="dv">0</span> {
            <span class="co">// self.reg0 = add(self.reg0, 32767);</span>
            <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;
            <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg7;
            <span class="kw">self</span>.f();
            <span class="kw">return</span>;
        }
        <span class="kw">self</span>.stack.push(<span class="kw">self</span>.reg0);
        <span class="co">// self.reg1 = add(self.reg1, 32767);</span>
        <span class="kw">self</span>.reg1 -= <span class="dv">1</span>;
        <span class="kw">self</span>.f();
        <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg0;
        <span class="kw">self</span>.reg0 = <span class="kw">self</span>.stack.pop().unwrap();
        <span class="co">// self.reg0 = add(self.reg0, 32767);</span>
        <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;
        <span class="kw">self</span>.f();
        <span class="kw">return</span>;
    }
}</code></pre>
<p>Now, this function grows really fast. Even for very small inputs it takes minutes to compute. I try to think some well-known functions that grow very fast. Ackermann comes to my mind and I check the Wiki page. Indeed, this looks quite similar, but the third argument makes it different than Ackermann. In any case, it doesn’t really matter for the solution.</p>
<p>So the problem is coming up with a <code>reg7</code> in this code so that <code>f(4, 1, reg7)</code> returns <code>6</code>. For that I need to implement a search but this is basically impossible with this slow function. I start simplifying the function a little bit. My first attempt:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> FnState {
    <span class="kw">fn</span> f(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="co">// When reg0 hits zero, restart it from reg1 + 1</span>
        <span class="kw">if</span> <span class="kw">self</span>.reg0 == <span class="dv">0</span> {
            <span class="kw">self</span>.reg0 = add(<span class="kw">self</span>.reg1, <span class="dv">1</span>);
            <span class="kw">return</span>;
        }

        <span class="co">// When reg1 hits zero, decrement reg0, restart reg1 from reg7</span>
        <span class="kw">if</span> <span class="kw">self</span>.reg1 == <span class="dv">0</span> {
            <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;
            <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg7;
            <span class="kw">self</span>.f();
            <span class="kw">return</span>;
        }

        <span class="kw">let</span> save_reg0 = <span class="kw">self</span>.reg0;

        <span class="kw">self</span>.reg1 -= <span class="dv">1</span>;
        <span class="kw">self</span>.f();
        <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg0;

        <span class="kw">self</span>.reg0 = save_reg0;
        <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;

        <span class="kw">self</span>.f();
        <span class="kw">return</span>;
    }
}</code></pre>
<p>This version doesn’t use an explicit stack, instead uses a temporary in the call frame. This works because in the original version each push corresponds to a pop done in the same call frame.</p>
<p>It’s still too complicated. I keep simplifying.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> f(<span class="kw">mut</span> reg0 : <span class="kw">u16</span>, <span class="kw">mut</span> reg1 : <span class="kw">u16</span>, <span class="kw">mut</span> reg7 : <span class="kw">u16</span>) -&gt; (<span class="kw">u16</span>, <span class="kw">u16</span>) {
    <span class="kw">if</span> reg0 == <span class="dv">0</span> {
        reg0 = add(reg1, <span class="dv">1</span>);
        <span class="kw">return</span> (reg0, reg1);
    }

    <span class="kw">if</span> reg1 == <span class="dv">0</span> {
        reg0 -= <span class="dv">1</span>;
        reg1 = reg7;
        <span class="kw">return</span> f(reg0, reg1, reg7);
    }

    <span class="kw">let</span> save_reg0 = reg0;
    reg1 -= <span class="dv">1</span>;

    <span class="kw">let</span> (reg0_, reg1_) = f(reg0, reg1, reg7);
    reg0 = reg0_;
    reg1 = reg1_;

    reg1 = reg0;

    reg0 = save_reg0;
    reg0 -= <span class="dv">1</span>;

    <span class="kw">return</span> f(reg0, reg1, reg7);
}</code></pre>
<p>This version doesn’t have any shared mutable state. At this point I realize that it may be possible to remove internal mutable state too:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> f(reg0 : <span class="kw">u16</span>, reg1 : <span class="kw">u16</span>, reg7 : <span class="kw">u16</span>) -&gt; (<span class="kw">u16</span>, <span class="kw">u16</span>) {
    <span class="kw">if</span> reg0 == <span class="dv">0</span> {
        <span class="kw">return</span> (add(reg1, <span class="dv">1</span>), reg1);
    }

    <span class="kw">if</span> reg1 == <span class="dv">0</span> {
        <span class="kw">return</span> f(reg0 - <span class="dv">1</span>, reg7, reg7);
    }

    <span class="kw">let</span> (reg1, _) = f(reg0, reg1 - <span class="dv">1</span>, reg7);

    <span class="kw">return</span> f(reg0 - <span class="dv">1</span>, reg1, reg7);
}</code></pre>
<p>Now, this is a function I can read and understand. One advantage of this version is that this could be easily memoized:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> f_memo(reg0 : <span class="kw">u16</span>, reg1 : <span class="kw">u16</span>, reg7 : <span class="kw">u16</span>, memo : &amp;<span class="kw">mut</span> HashMap&lt;(<span class="kw">u16</span>, <span class="kw">u16</span>), (<span class="kw">u16</span>, <span class="kw">u16</span>)&gt;) -&gt; (<span class="kw">u16</span>, <span class="kw">u16</span>) {
    <span class="kw">if</span> <span class="kw">let</span> <span class="kw">Some</span>(ret) = memo.get(&amp;(reg0, reg1)) {
        <span class="kw">return</span> *ret;
    }

    <span class="kw">if</span> reg0 == <span class="dv">0</span> {
        <span class="kw">let</span> ret = (add(reg1, <span class="dv">1</span>), reg1);
        memo.insert((reg0, reg1), ret);
        <span class="kw">return</span> ret;
    }

    <span class="kw">if</span> reg1 == <span class="dv">0</span> {
        <span class="kw">let</span> ret = f_memo(reg0 - <span class="dv">1</span>, reg7, reg7, memo);
        memo.insert((reg0, reg1), ret);
        <span class="kw">return</span> ret;
    }

    <span class="co">// careful there</span>
    <span class="kw">let</span> (reg1_new, _) = f_memo(reg0, reg1 - <span class="dv">1</span>, reg7, memo);

    <span class="kw">let</span> ret = f_memo(reg0 - <span class="dv">1</span>, reg1_new, reg7, memo);
    memo.insert((reg0, reg1), ret);
    <span class="kw">return</span> ret;
}</code></pre>
<p>This version is super fast when compared to the original version. I feel like I can just search the whole space in a few hours. I start the search and as it searches through the search space I start wondering about how to further improve it. I think, why not split search space into pieces and search in parallel?</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> search(start_range : <span class="kw">u16</span>, end_range : <span class="kw">u16</span>) -&gt; <span class="kw">Option</span>&lt;<span class="kw">u16</span>&gt; {
    <span class="kw">for</span> i in start_range .. end_range {
        <span class="co">// println!(&quot;i = {}&quot;, i);</span>
        <span class="kw">let</span> <span class="kw">mut</span> tbl = HashMap::new();
        <span class="kw">let</span> ret = f_memo(<span class="dv">4</span>, <span class="dv">1</span>, i, &amp;<span class="kw">mut</span> tbl);
        <span class="kw">if</span> ret.<span class="dv">0</span> == <span class="dv">6</span> {
            <span class="ot">println!</span>(<span class="st">&quot;Found an answer: {:?} {}&quot;</span>, ret, i);
            <span class="kw">return</span> <span class="kw">Some</span>(i);
        }
    }

    <span class="kw">None</span>
}

<span class="kw">fn</span> search_in_parallel(n : <span class="kw">i32</span>) {
    <span class="kw">let</span> increment = <span class="kw">u16</span>::MAX / (n <span class="kw">as</span> <span class="kw">u16</span>);
    <span class="kw">let</span> <span class="kw">mut</span> threads = Vec::with_capacity(n <span class="kw">as</span> usize);

    <span class="kw">for</span> i in <span class="dv">0</span> .. n {
        <span class="kw">let</span> range_start = increment * (i <span class="kw">as</span> <span class="kw">u16</span>);
        <span class="kw">let</span> range_end   = increment * ((i <span class="kw">as</span> <span class="kw">u16</span>) + <span class="dv">1</span>) + <span class="dv">1</span>;
        threads.push(thread::Builder::new().stack_size(<span class="dv">1000000000</span>).spawn(move || {
            search(range_start, range_end)
        }).unwrap());
    }

    <span class="kw">for</span> thread in threads {
        thread.join();
    }
}

<span class="kw">fn</span> main() {
    search_in_parallel(<span class="dv">8</span>);
}</code></pre>
<p>This parallel search takes a couple of seconds until it prints:</p>
<pre><code>Found an answer: (6, 5) 25734</code></pre>
<p>So <code>25734</code> returns 6! This is the R8 value we were looking for.</p>
<p>I modify my VM to return when this function is called (I know it lives in address <code>6027</code> so I just check instruction pointer in the main loop) and drop to debugger prompt. In the debugger, I set R1 (return value register) 6, and set R8 25734, and continue running the program.</p>
<p>It works perfectly, with a working code printed to the screen!</p>
<h1 id="code-and-conclusion">Code and conclusion</h1>
<p>Overall I enjoyed this a lot. My favorite part was definitely debugging the verification function. I don’t really enjoy text adventures but that’s really a very small part of the challenge, so it wasn’t a big deal.</p>
<p><a href="https://github.com/osa1/synacor-challenge">My code is on Github</a>. I didn’t organize the code at all, so you can see my inline notes, logs, and commented out code with their improved/changed versions, and have a feeling of how I developed my solutions. In the repo you’ll also see the original binary and challenge spec. I pushed those in case the original challenge page disappears in the future.</p>
<p>The Rust compiler I used was <code>rustc 1.11.0-nightly (0554abac6 2016-06-10)</code>.</p>
<p>If you know similar challenges let me know in the comment section below. One challenge that looks similar is ICFP’06 programming contest <a href="http://www.boundvariable.org/">“The Cult of the Bound Variable”</a>, which I always wanted to solve but never really got a chance. Maybe I should try it next.</p>]]></summary>
</entry>
<entry>
    <title>Rust borrow checker woes</title>
    <link href="http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html" />
    <id>http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html</id>
    <published>2016-03-28T00:00:00Z</published>
    <updated>2016-03-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been doing some Rust hacking in my free time, and unfortunately while it’s way, way better than how it was when I first tried it (around 0.4 or 0.6 IIRC), it still has some problems that encourage redundant runtime operations or bad programming practices. In this post I’ll give three examples that are all caused by dumb borrow checker. As you’ll see, in all cases the cost is either bad programming practices or runtime costs (which is really ironic, given that one of the design goals of Rust is performance).</p>
<h1 id="no-local-reasoning-about-borrowing-rules-of-constructors">1. No local reasoning about borrowing rules of constructors</h1>
<p>It’s types that borrow, not values, and that makes sense. If you have an <code>Option&lt;&amp;'a T&gt;</code> where <code>'a</code> is coming from some other variable <code>x</code>, 1) <code>x</code> needs to live longer than this <code>Option</code> value 2) you can’t borrow <code>x</code> mutably while keeping the <code>Option</code> in scope (or the other way around, you can’t borrow <code>Option</code> mutably while keeping <code>x</code> in scope).</p>
<p>This makes sense because in compile time, given an <code>Option&lt;&amp;'a T&gt;</code>, you can’t make any assumptions on <code>Option</code>’s actual value. Since <code>Some</code> constructor of the <code>Option</code> type will borrow the <code>T</code> here, you just have to assume that values of this type always borrow <code>T</code> (and that’s why we have <code>&amp;'a</code> in the type).</p>
<p>The problem is that it’s sometimes possible to do some local reasoning, and not doing that is too restrictive. Suppose you have this:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> ListOfThings {
    list : Vec&lt;Thing&gt;,
}

<span class="kw">struct</span> Thing {
    name : String,
    <span class="co">// other fields here -- this is expensive to copy!</span>
}

<span class="kw">impl</span> Thing {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {}
}

<span class="kw">impl</span> ListOfThings {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>, name : &amp;<span class="kw">str</span>) {
        <span class="kw">match</span> <span class="kw">self</span>.find_thing_mut(name) {
            <span class="kw">None</span> =&gt; {
                <span class="kw">self</span>.init_thing(name.to_owned());
                <span class="kw">self</span>.do_something(name)
            },
            <span class="kw">Some</span>(t) =&gt; {
                t.do_something()
            },
        }
    }

    <span class="kw">fn</span> find_thing_mut&lt;<span class="ot">&#39;a</span>&gt;(&amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span>, name : &amp;<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> Thing&gt; {
        <span class="kw">self</span>.list.iter_mut().find(|t| t.name.as_str() == name)
    }

    <span class="kw">fn</span> init_thing(&amp;<span class="kw">mut</span> <span class="kw">self</span>, name : String) {
        <span class="kw">self</span>.list.push(Thing { name: name })
    }
}</code></pre>
<p>The important part is this expression:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> <span class="kw">self</span>.find_thing_mut(name) {
    <span class="kw">None</span> =&gt; {
        <span class="kw">self</span>.init_thing(name.to_owned());
        <span class="kw">self</span>.do_something(name)
    },
    <span class="kw">Some</span>(t) =&gt; {
        t.do_something()
    },
}</code></pre>
<p>The error we get is:</p>
<pre><code>&lt;anon&gt;:18:17: 18:21 error: cannot borrow `*self` as mutable more than once at a time [E0499]
&lt;anon&gt;:18                 self.init_thing(name.to_owned());
                          ^~~~
&lt;anon&gt;:18:17: 18:21 help: see the detailed explanation for E0499
&lt;anon&gt;:16:15: 16:19 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:16         match self.find_thing_mut(name) {
                        ^~~~
&lt;anon&gt;:24:10: 24:10 note: previous borrow ends here
&lt;anon&gt;:16         match self.find_thing_mut(name) {
...
&lt;anon&gt;:24         }
                  ^
&lt;anon&gt;:19:17: 19:21 error: cannot borrow `*self` as mutable more than once at a time [E0499]
&lt;anon&gt;:19                 self.do_something(name)
                          ^~~~
&lt;anon&gt;:19:17: 19:21 help: see the detailed explanation for E0499
&lt;anon&gt;:16:15: 16:19 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:16         match self.find_thing_mut(name) {
                        ^~~~
&lt;anon&gt;:24:10: 24:10 note: previous borrow ends here
&lt;anon&gt;:16         match self.find_thing_mut(name) {
...
&lt;anon&gt;:24         }
                  ^</code></pre>
<p><code>find_thing_mut()</code> really needs to return a ref, because <code>Thing</code> is expensive to copy. The problem is since <code>None</code> has type <code>Option&lt;&amp;'a mut Thing&gt;</code> where <code>a</code> is the lifetime of <code>self</code>, we can’t call a <code>&amp;mut self</code> when that <code>None</code> is in scope. This is annoying and could be improved by doing some local reasoning. In our case, since we know that <code>None</code> can’t borrow anything (it doesn’t have any references), we could refine our information about currently borrwed values, and let this compile.</p>
<p>There are a couple of solutions. One half-solution is to use something like standard <a href="http://doc.rust-lang.org/nightly/std/collections/struct.HashMap.html#method.entry"><code>HashMap</code>’s <code>entry()</code></a>. Imagine doing something like:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::collections::hash_map::HashMap;

<span class="kw">struct</span> ListOfThings {
    list : HashMap&lt;String, Thing&gt;,
}

<span class="kw">struct</span> Thing {
    field1 : <span class="kw">i32</span>,
    <span class="co">// other fields here -- this is expensive to copy!</span>
}

<span class="kw">impl</span> Thing {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {}
}

<span class="kw">impl</span> ListOfThings {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>, name : &amp;<span class="kw">str</span>) {
        <span class="kw">match</span> <span class="kw">self</span>.list.get_mut(name) {
            <span class="kw">None</span> =&gt; {
                <span class="kw">self</span>.list.insert(name.to_owned(), Thing { field1: <span class="dv">123</span> });
            },
            <span class="kw">Some</span>(t) =&gt; {
                t.do_something();
            }
        }
    }
}</code></pre>
<p>The error we get:</p>
<pre><code>&lt;anon&gt;:20:17: 20:26 error: cannot borrow `self.list` as mutable more than once at a time [E0499]
&lt;anon&gt;:20                 self.list.insert(name.to_owned(), Thing { field1: 123 });
                          ^~~~~~~~~
&lt;anon&gt;:20:17: 20:26 help: see the detailed explanation for E0499
&lt;anon&gt;:18:15: 18:24 note: previous borrow of `self.list` occurs here; the
                          mutable borrow prevents subsequent moves, borrows, or
                          modification of `self.list` until the borrow ends
&lt;anon&gt;:18         match self.list.get_mut(name) {
                        ^~~~~~~~~
&lt;anon&gt;:25:10: 25:10 note: previous borrow ends here
&lt;anon&gt;:18         match self.list.get_mut(name) {
...
&lt;anon&gt;:25         }
                  ^</code></pre>
<p>This is exactly the same error we got before. The solution is to use <a href="http://doc.rust-lang.org/nightly/std/collections/struct.HashMap.html#method.entry">the <code>Entry</code> API</a>:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::collections::hash_map::{HashMap, Entry};

<span class="kw">struct</span> ListOfThings {
    list : HashMap&lt;String, Thing&gt;,
}

<span class="kw">struct</span> Thing {
    field1 : <span class="kw">i32</span>,
    <span class="co">// other fields here -- this is expensive to copy!</span>
}

<span class="kw">impl</span> Thing {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {}
}

<span class="kw">impl</span> ListOfThings {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>, name : &amp;<span class="kw">str</span>) {
        <span class="kw">match</span> <span class="kw">self</span>.list.entry(name.to_owned()) {
            Entry::Vacant(ve) =&gt; {
                ve.insert(Thing { field1: <span class="dv">123</span> });
            },
            Entry::Occupied(<span class="kw">mut</span> oe) =&gt; {
                oe.get_mut().do_something();
            }
        }
    }
}</code></pre>
<p>Some things to note here:</p>
<ol style="list-style-type: decimal">
<li><p>We had to give ownership of the key to the lookup function (<code>HashMap::entry()</code>). This potentially means copying a value just to lookup. Ideally we’d only need to do this when inserting to the map. <code>HashMap::get()</code> doesn’t have this problem.</p></li>
<li><p>I said “half-solution” because this doesn’t really make the original code working. See how I removed a line in the first case in my <code>HashMap</code>-based implementation. If I change the first case to this:</p>
<pre class="sourceCode rust"><code class="sourceCode rust">        <span class="kw">match</span> <span class="kw">self</span>.list.entry(name.to_owned()) {
            Entry::Vacant(ve) =&gt; {
                ve.insert(Thing { field1: <span class="dv">123</span> });
                <span class="kw">self</span>.do_something(name)
            },</code></pre>
<p>It’d still fail as <code>Entry</code> keeps a reference to <code>self</code>. Of course you could always do things like:</p>
<pre class="sourceCode rust"><code class="sourceCode rust">        <span class="kw">match</span> <span class="kw">self</span>.list.entry(name.to_owned()) {
            Entry::Vacant(ve) =&gt; {
                <span class="kw">let</span> <span class="kw">mut</span> thing = Thing { field1 : <span class="dv">123</span> };
                thing.do_something();
                ve.insert(thing);
            },</code></pre>
<p>Which works, but that’s quite different from our original program. Note that if we still had a method like <code>init_thing()</code> and has to pass <code>Entry</code> to that, it’d still fail with same error message. So yeah, not quite a solution.</p></li>
</ol>
<p>The solution I use is this:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> ListOfThings {
    <span class="kw">fn</span> do_something(&amp;<span class="kw">mut</span> <span class="kw">self</span>, name : &amp;<span class="kw">str</span>) {
        <span class="kw">let</span> thing : <span class="kw">Option</span>&lt;*<span class="kw">mut</span> Thing&gt; = <span class="kw">self</span>.find_thing_mut(name).map(|t| (t <span class="kw">as</span> *<span class="kw">mut</span> _));
        <span class="kw">match</span> thing {
            <span class="kw">None</span> =&gt; {
                <span class="kw">self</span>.init_thing(name.to_owned());
                <span class="kw">self</span>.do_something(name)
            },
            <span class="kw">Some</span>(t) =&gt; {
                <span class="kw">unsafe</span> { (*t).do_something() }
            },
        }
    }
}</code></pre>
<p>(missing parts are the same as the original code),</p>
<p>I basically work around the borrow checker by using a raw pointer and an <code>unsafe</code> block, and hope that my <code>.map()</code> will be compiled as a no-op.</p>
<h1 id="references-to-self-in-method-values">2. References to self in method values</h1>
<p>A code like this fails if the method is mutable in self: <code>self.f(self.x)</code>. As a running example:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Widget {
    pos_x : <span class="kw">i32</span>,
    pos_y : <span class="kw">i32</span>,
}

<span class="kw">impl</span> Widget {
    <span class="kw">pub</span> <span class="kw">fn</span> draw(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="kw">self</span>.draw_at(<span class="kw">self</span>.pos_x, <span class="kw">self</span>.pos_y);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> draw_at(&amp;<span class="kw">mut</span> <span class="kw">self</span>, pos_x : <span class="kw">i32</span>, pos_y : <span class="kw">i32</span>) {}
}</code></pre>
<p>These are the errors:</p>
<pre><code>&lt;anon&gt;:8:22: 8:32 error: cannot use `self.pos_x` because it was mutably borrowed [E0503]
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                              ^~~~~~~~~~
&lt;anon&gt;:8:9: 8:13 note: borrow of `*self` occurs here
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                 ^~~~
&lt;anon&gt;:8:34: 8:44 error: cannot use `self.pos_y` because it was mutably borrowed [E0503]
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                                          ^~~~~~~~~~
&lt;anon&gt;:8:9: 8:13 note: borrow of `*self` occurs here
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                 ^~~~</code></pre>
<p>Basically the method itself (<code>self.draw_at</code>) borrows <code>self</code> mutably, and since arguments are evaluated <em>after</em> the function in a function application, we get this borrow checker error. The solution is simple in this case:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> pos_x = <span class="kw">self</span>.pos_x;
<span class="kw">let</span> pos_y = <span class="kw">self</span>.pos_y;
<span class="kw">self</span>.draw_at(pos_x, pos_y);</code></pre>
<h1 id="variables-that-live-across-loops">3. Variables that live across loops</h1>
<p>Suppose you have a loop that internally calls some <code>&amp;mut self</code> methods, and when it returns, it returns something with a reference to <code>&amp;self</code>. Something like:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> TUI {
    field1: <span class="kw">i32</span>,
}

<span class="kw">pub</span> <span class="kw">enum</span> TUIRet&lt;<span class="ot">&#39;a</span>&gt; {
    Abort,
    KeyHandled,
    Input(&amp;<span class="ot">&#39;a</span> <span class="kw">str</span>),
}

<span class="kw">impl</span> TUI {
    <span class="kw">pub</span> <span class="kw">fn</span> idle_loop&lt;<span class="ot">&#39;a</span>&gt;(&amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span>) -&gt; TUIRet&lt;<span class="ot">&#39;a</span>&gt; {
        <span class="kw">loop</span> {
            <span class="kw">self</span>.draw();

            <span class="kw">match</span> <span class="kw">self</span>.keypressed() {
                ret @ TUIRet::Abort =&gt; { <span class="kw">return</span> ret; },
                ret @ TUIRet::Input(_) =&gt; { <span class="kw">return</span> ret; },
                _ =&gt; {},
            }
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> keypressed(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; TUIRet {
        <span class="ot">panic!</span>()
    }

    <span class="kw">pub</span> <span class="kw">fn</span> draw(&amp;<span class="kw">self</span>) {}
}</code></pre>
<p>Can you see what could go wrong here? Here’s the error:</p>
<pre><code>&lt;anon&gt;:18:13: 18:17 error: cannot borrow `*self` as immutable because it is also borrowed as mutable [E0502]
&lt;anon&gt;:18             self.draw();
                      ^~~~
&lt;anon&gt;:20:19: 20:23 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:20             match self.keypressed() {
                            ^~~~
&lt;anon&gt;:26:6: 26:6 note: previous borrow ends here
&lt;anon&gt;:16     pub fn idle_loop&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; TUIRet&lt;&#39;a&gt; {
...
&lt;anon&gt;:26     }
              ^
&lt;anon&gt;:20:19: 20:23 error: cannot borrow `*self` as mutable more than once at a time [E0499]
&lt;anon&gt;:20             match self.keypressed() {
                            ^~~~
&lt;anon&gt;:20:19: 20:23 help: see the detailed explanation for E0499
&lt;anon&gt;:20:19: 20:23 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:20             match self.keypressed() {
                            ^~~~
&lt;anon&gt;:26:6: 26:6 note: previous borrow ends here
&lt;anon&gt;:16     pub fn idle_loop&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; TUIRet&lt;&#39;a&gt; {
...
&lt;anon&gt;:26     }
              ^</code></pre>
<p>This is probably the worst of all. The weird part is that this works:</p>
<pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">pub</span> <span class="kw">fn</span> idle_loop&lt;<span class="ot">&#39;a</span>&gt;(&amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span>) -&gt; TUIRet&lt;<span class="ot">&#39;a</span>&gt; {
        <span class="kw">loop</span> {
            <span class="kw">self</span>.draw();
            <span class="kw">return</span> <span class="kw">self</span>.keypressed();
        }
    }</code></pre>
<p>Only solution I could find here was to remove the references to <code>self</code>, by just copying the value to <code>Input</code>. This unfortunately means more redundant copying.</p>]]></summary>
</entry>

</feed>
