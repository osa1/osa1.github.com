<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged rust</title>
    <link href="http://osa1.net/tags/rust.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/rust.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragacan@gmail.com</email>
    </author>
    <updated>2024-11-29T00:00:00Z</updated>
    <entry>
    <title>Exploring parsing APIs: the cost of recursion</title>
    <link href="http://osa1.net/posts/2024-11-29-how-to-parse-3.html" />
    <id>http://osa1.net/posts/2024-11-29-how-to-parse-3.html</id>
    <published>2024-11-29T00:00:00Z</published>
    <updated>2024-11-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="https://osa1.net/posts/2024-11-22-how-to-parse-1.html">first post</a> of this series we looked at a few different ways of parsing a simple JSON-like language. In the <a href="https://osa1.net/posts/2024-11-28-how-to-parse-2.html">second post</a> we implemented a few lexers, and looked at the performance when the parsers from the first post are combined with the lexers in the second post.</p>
<p>One of the surprising results in these posts is that our recursive descent parser, which parses the input directly to an AST, and in some sense is the simplest possible implementation when we need an AST, actually performs the worst.</p>
<p>(The implementations that collect tokens in a vector before parsing perform worse than recursive descent parsing, but those implementations have other issues as well, and can’t be used in many cases. Maybe I should’ve omitted them entirely.)</p>
<p>To keep things simple, let’s consider these three benchmarks, from the last post:</p>
<ul>
<li>Recursive descent: 127 Mb/s</li>
<li>tokenize_iter + events_iter to AST: 138 Mb/s</li>
<li>tokenize_push + events_push to AST: 151 Mb/s</li>
</ul>
<p>To recap, the “iter” variants are <code>Iterator</code>s that return one parse (or lexing) event at a time. The “push” variants take a “listener” argument with callbacks for events. See the first post for details.</p>
<p>In the “iter” benchmark, the code that generates the AST iterates an event parser:</p>
<pre><code>fn event_to_tree&lt;I: Iterator&lt;Item = Result&lt;ParseEvent, ParseError&gt;&gt;&gt;(
    parser: &amp;mut I,
    input: &amp;str,
) -&gt; Result&lt;Json, ParseError&gt; {
  ...
}</code></pre>
<p>And the event parser iterates a lexer:</p>
<pre><code>fn parse_events_iter_using_lexer_iter&lt;I: Iterator&lt;Item = Result&lt;(usize, Token), usize&gt;&gt;&gt;(
    lexer: I,
    input_size: usize,
) -&gt; EventParser&lt;I&gt; {
    ...
}</code></pre>
<p>When the AST generator asks for the next parse event, the parse event generator asks for the next token (maybe multiple times) and returns an event. AST generator consumes all of the events and builds the AST.</p>
<p>In the “push” benchmark, we have a “listener” that handles parse events and builds up an AST:</p>
<pre><code>struct AstBuilderListener&lt;&#39;a&gt; {
    input: &amp;&#39;a str,
    container_stack: Vec&lt;Container&gt;,
    current_container: Option&lt;Container&gt;,
    parsed_object: Option&lt;Json&gt;,
    error: Option&lt;ParseError&gt;,
}

impl&lt;&#39;a&gt; EventListener for AstBuilderListener&lt;&#39;a&gt; {
    ...
}</code></pre>
<p>And another listener that handles tokens:</p>
<pre><code>struct LexerEventListenerImpl&lt;&#39;a, L: EventListener&gt; {
    listener: &amp;&#39;a mut L,
    container_stack: Vec&lt;Container&gt;,
    state: ParserState,
}

impl&lt;&#39;a, L: EventListener&gt; LexerEventListener for LexerEventListenerImpl&lt;&#39;a, L&gt; {
  ...
}</code></pre>
<p>This implementation is driven by the lexer which “pushes” the tokens to the event parser, which (possibly after handling multiple tokens) “pushes” parse events to the AST builder.</p>
<p>Both of these setups are considerably more complicated than recursive descent, yet they perform better. How?</p>
<p>When we consider what the recursive descent parser does that these don’t, it’s kind of obvious. It’s even in the name: recursion.</p>
<p>Our lexers and event parsers all optimize really well: there is no heap allocation anywhere, the code that “pushes” events are all monomorphised based on the handler type, so the handler calls are direct calls and can be (and probably) inlined. There’s also no recursion anywhere.</p>
<p>The recursive descent parser is basically one function that recursively calls itself for nested objects. It turns out this recursion has a cost. When I eliminate the recursion with some more state:</p>
<pre><code>enum ParserState {
    /// Parse any kind of object, update state based on the current container.
    TopLevel,

    /// Parsing a container, parse another element on &#39;,&#39;, or finish the
    /// container on &#39;]&#39; or &#39;}&#39;.
    ExpectComma,

    /// Parsing an object, parse a key.
    ObjectExpectKeyValue,

    /// Parsing an object, parse a key, or terminate the object.
    ObjectExpectKeyValueTerminate,

    /// Parsing an object and we&#39;ve just parsed a key, expect &#39;:&#39;.
    ObjectExpectColon,
}

fn parse_single(iter: &amp;mut Peekable&lt;CharIndices&gt;, input: &amp;str) -&gt; Result&lt;Json, ParseError&gt; {
    let mut container_stack: Vec&lt;Container&gt; = vec![];
    let mut state = ParserState::TopLevel;

    loop {
      ...
    }
}</code></pre>
<p>It performs better than the recursive descent parser and the iterator based parser, and on par with the “push” based parser: (numbers are slightly different than above as I rerun them together)</p>
<ul>
<li>Recursive descent: 127 Mb/s</li>
<li>tokenize_iter + events_iter to AST: 136 Mb/s</li>
<li>tokenize_push + events_push to AST: 158 Mb/s</li>
<li>Direct parser without recursion: 156 Mb/s</li>
</ul>
<p>I’m not quite sure what about recursion that makes the recursive descent parser perform so much worse, but my guess is that it makes the control flow more complicated to analyze, and in runtime, you have to move things around (in registers and stack locations) based on calling conventions. When moving between registers and stack locations you do memory reads and writes. My guess is that when combined, these cost something.</p>
<h1 id="other-considerations-with-recursion">Other considerations with recursion</h1>
<p>If you checkout the git repo and run the tests with <code>cargo test</code>, you will see that a test fails with a stack overflow.</p>
<p>This is something else to keep in mind when parsing recursively. Stack overflows are a real issue with recursive parsing, and I know some libraries that are <a href="https://github.com/google/protobuf.dart/blob/ccf104dbc36929c0f8708285d5f3a8fae206343e/protobuf/lib/src/protobuf/coded_buffer_reader.dart#L29">explicit about it</a>.</p>
<p>In practice though, I’m not sure if this can be the main reason to avoid recursive parsing. Recursion can happen in other places as well, and in a server application you would probably monitor runtime, memory consumption, and maybe even other resources of a handler, and have some kind of error handler that handles everything else.</p>
<p>In higher level languages like <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/GHC-IO-Exception.html#t:AsyncException">Haskell</a> and <a href="https://api.dart.dev/dart-core/StackOverflowError-class.html">Dart</a> that make stack overflows exceptions/errors that can be caught and handled, so they can be handled as a part of “unexpected” crashes easily. In Rust, they stack overflows can be handled at thread boundaries.</p>
<p>If the application is command line tool or a compiler, where the input is provided by the user and handled on the user’s computer, it’s less of a problem and you can probably just let the application crash.</p>
<p>So I don’t think we can say that recursion should be avoided at all costs when parsing.</p>
<h1 id="references">References</h1>
<p>As usual, the code is available: <a href="https://github.com/osa1/how-to-parse-3">github.com/osa1/how-to-parse-3</a>.</p>
<p>To work around the stack overflow when testing, test in release mode: <code>cargo test --release</code>.</p>
<p>If you want to profile the code and understand more about why one version is faster than the other, I added 4 executables to the package, one for each benchmark listed above. You can generate a 100M input and run the parsers individually with:</p>
<pre><code>$ cargo build --release
...

$ ./target/release/test_gen 100000000 &gt; input

$ time ./target/release/parse_non_recursive input
./target/release/parse_non_recursive input  0.64s user 0.22s system 99% cpu 0.854 total</code></pre>]]></summary>
</entry>
<entry>
    <title>Exploring parsing APIs: adding a lexer</title>
    <link href="http://osa1.net/posts/2024-11-28-how-to-parse-2.html" />
    <id>http://osa1.net/posts/2024-11-28-how-to-parse-2.html</id>
    <published>2024-11-28T00:00:00Z</published>
    <updated>2024-11-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="https://osa1.net/posts/2024-11-22-how-to-parse-1.html">previous post</a> we looked at three different parsing APIs, and compared them for runtime and the use cases they support.</p>
<p>In this post we’ll add a lexer (or “tokenizer”), with two APIs, and for each lexer see how the parsers from the previous post perform when combined with the lexer.</p>
<p><strong>What is a lexer?</strong> A lexer is very similar to the event parsers we saw in the previous post, but it doesn’t try to maintain any structure. It generates “tokens”, which are parts of the program that cannot be split into smaller parts. A lexer doesn’t care about parentheses or other delimiters being balanced, or that values in an array are separated by commas, or anything else. It simply splits the input into tokens.</p>
<p><strong>Why is a lexer useful?</strong> If you already have an event parser, adding a lexer may not allow a lot of new use cases. The main use cases that I’m aware of are:</p>
<ul>
<li><p>Syntax highlighting: when higlighting syntax we don’t care about the tree structure, we care about keywords, punctuation (list separators, dots in paths etc.), delimiters (commas, bracets, brackets), and literals. A lexer gives us exactly these and nothing else.</p></li>
<li><p>Supporting incremental parsing: one way of incrementally update an AST is by starting re-lexing a few (often just one) tokens before the edited token, re-lexing until after the edit location, until generating a token identical to an existing token again. AST nodes of modified tokens are then marked as “modified” and re-parsed.</p>
<p>The details are complicated, I recommend chapter 2 of <a href="https://diekmann.uk/diekmann_phd.pdf">this PhD thesis</a> for an introduction to incremental parsing.</p>
<p>If you need to re-parse code as it gets edited, even if you don’t need or want incremental parsing, incremental lexing is easy, it makes sense to re-lex incrementally and then parse from scratch using the incrementally updated token list, because incremental lexing is so simple.</p></li>
<li><p>For separating complex parsing code into smaller parts: modern languages can have complicated literal syntax, with multiple string literals with varying delimiters (like <code>r#"..."#</code> syntax in Rust, or <code>[=[...]=]</code> in Lua), multiple variants of comments (single line and multi-line, documentation and normal), multiple number syntaxes (with different suffixes like <code>123u32</code> in Rust, underscores to separate digits for readability) and so on.</p>
<p>A lexer separates handling of these from the part of the parser that deals with the program structure.</p></li>
</ul>
<h1 id="the-apis">The APIs</h1>
<p>Similar to the previous post, we will look at three different APIs for lexing:</p>
<ul>
<li>A lexer that generates a list of tokens directly: <code>tokenize_list</code>.</li>
<li>An iterator that generates one token at a time: <code>tokenize_iter</code>.</li>
<li>A “push” API that calls “listener” methods for the tokens: <code>tokenize_push</code>.</li>
</ul>
<p>For our simplified (and enhanced, with comments) JSON, our token type is:</p>
<pre><code>pub enum Token {
    Int(u64),
    Str { size_in_bytes: usize },
    True,
    False,
    Null,
    LBracket,
    RBracket,
    LBrace,
    RBrace,
    Colon,
    Comma,
    Comment { size_in_bytes: usize },
}</code></pre>
<p>Similar to our event type from the previous post, this type needs to be cheap to generate (ideally stack allocated).</p>
<p>The tokens are generated along with byte offsets in the input, also similar to events.</p>
<p>For the push API, the listener interface also directly follows the token type:</p>
<pre><code>pub trait LexerEventListener {
    fn handle_int(&amp;mut self, byte_offset: usize, i: u64);

    fn handle_str(&amp;mut self, byte_offset: usize, size_in_bytes: usize);

    // Similar for other token types.
    ...

    fn handle_error(&amp;mut self, byte_offset: usize);
}</code></pre>
<p>To keep things simple, the event handlers don’t return a <code>bool</code> to stop parsing. It can be added in a few lines of code and it doesn’t affect performance.</p>
<p>Unlike the different types of event parsers from the previous post, implementations of these lexer APIs are almost identical. This is because the lexer has only one state, which is the current position in the input. A <code>next</code> call in the iterator implementation simply continues from the current location in the input, and updates the current location as it reads characters from the input.</p>
<p>The entry points are:</p>
<pre><code>pub fn tokenize_iter&lt;&#39;a&gt;(input: &amp;&#39;a str) -&gt; Lexer&lt;&#39;a&gt; { ... }
  // Lexer implements `Iterator`

pub fn tokenize_push&lt;L: LexerEventListener&gt;(input: &amp;str, listener: &amp;mut L) { ... }

pub fn tokenize_list(input: &amp;str) -&gt; Result&lt;Vec&lt;(usize, Token)&gt; usize&gt; { ... }</code></pre>
<h1 id="combining-with-the-event-parsers">Combining with the event parsers</h1>
<p>We have 3 lexers and 2 event parsers, so 6 combinations in total:</p>
<ol type="1">
<li>tokenize_list + parse_events_iter</li>
<li>tokenize_list + parse_events_push</li>
<li>tokenize_iter + parse_events_iter</li>
<li>tokenize_iter + parse_events_push</li>
<li>tokenize_push + parse_events_iter</li>
<li>tokenize_push + parse_events_push</li>
</ol>
<p>However (5) is not easily possible in Rust. The problem is that a push implementation cannot be converted into an iterator, as it will scan the entire input without ever returning and keep calling the listener methods. To convert a push API into an iterator, we need a language feature that allows us to stop the current thread (or maybe a “fiber”, green thread etc.) and resume it later. In Rust, this is possible with <code>async</code> or threads. Threads are expensive, and <code>async</code> requires a lot of refactoring, and all the call sites to be made <code>async</code> as well.</p>
<p>So in this post we won’t consider this combination.</p>
<h1 id="notes-on-implementations">Notes on implementations</h1>
<p>Implementing these combinations is mostly straightforward. Full code is linked below as usual. The takeaways are:</p>
<ul>
<li>The push API cannot be converted into an iterator API, without language features.</li>
<li>The push API requires state management in the consumer: the consumer will have to save the state that needs to be maintained between the calls to the listener methods.</li>
<li>The iterator API is more flexible as it can be converted into a push API.</li>
<li>The iterator API is also easier to use: the consumer can iterate through the elements in nested loops, and needs less state management. The state can also be function locals, instead of fields of a struct (or class etc.).</li>
<li>The list API (generates an entire vector of tokens) only makes sense when you need to collect all of the tokens in memory. The only use case for this that I’m aware of is incremental parsing.</li>
</ul>
<h1 id="references-and-benchmarks">References and benchmarks</h1>
<p>The code (including benchmarks) is here: <a href="https://github.com/osa1/how-to-parse-2">github.com/osa1/how-to-parse-2</a>.</p>
<p><strong>Token generation benchmarks:</strong> Collect all of the tokens in a <code>Vec</code>.</p>
<ul>
<li>tokenize_list: 305 MB/s</li>
<li>tokenize_push: 303 MB/s</li>
<li>tokenize_iter: 329 MB/s</li>
</ul>
<p>In the event generation benchmarks in the last post, the push implementation is about 10% faster than the iterator. But in the lexer, the iterator is faster when collecting the tokens in a vector. It looks like when the state that the parser manages between the <code>next</code> calls gets simpler, the compiler is able to optimize the code better, and iterator implementation beats the push implementation.</p>
<p>The vector generator and push implementation adding the elements to a vector via the listener perform the same, which shows that when monomorphised, the push implementation optimizes quite well for simple cases (but also in complex cases, as we will see below). In languages without monomorphisation, the push API should be slower.</p>
<p><strong>Tokens to events:</strong> Convert tokens to events.</p>
<ul>
<li>events_iter: 282 MB/s</li>
<li>events_push: 315 MB/s</li>
<li>tokenize_list + events_iter: 181 MB/s</li>
<li>tokenize_list + events_push: 187 MB/s</li>
<li>tokenize_iter + events_iter: 269 MB/s</li>
<li>tokenize_iter + events_push: 275 MB/s</li>
<li>tokenize_push + events_push: 351 MB/s</li>
</ul>
<p>The first two benchmarks are the ones from the previous post that don’t use a lexer, generate events directly. The numbers are slightly different than the numbers from the previous post as I rerun them again.</p>
<p>If you need some kind of incremental implementation, scanning the entire input and collecting the events or tokens in a vector performs bad. There’s no point in combining the list API with push or iterator APIs.</p>
<p>What’s surprising is that the push lexer implementation combined with the push event generator implementation performs better than the event generator implementation that parses the input directly without a lexer. I don’t have an explanation to why, yet.</p>
<p>Lexer iterator implementations combined with any of the event generation implementations perform slower than the event push implementation that parses the input directly, but about as fast as the event iterator implementation that parses the input directly.</p>
<p><strong>Tokens to AST:</strong> Converts tokens to events, builds AST from the events.</p>
<ul>
<li>Recursive descent: 127 MB/s</li>
<li>events_iter to AST: 140 MB/s</li>
<li>events_push to AST: 145 MB/s</li>
<li>tokenize_list + events_iter to AST: 108 MB/s</li>
<li>tokenize_list + events_push to AST: 108 MB/s</li>
<li>tokenize_iter + events_iter to AST: 138 MB/s</li>
<li>tokenize_iter + events_push to AST: 139 MB/s</li>
<li>tokenize_push + events_push to AST: 151 MB/s</li>
</ul>
<p>The first three benchmarks below are from the last post. Rerun and included here for comparison.</p>
<p>When we add an AST building step, which is more complicated compared to the rest of steps, the performance difference between the most convenient implementation (tokenize_iter + events_iter to AST) and the most performant one (tokenize_push + events_push to AST) diminishes. In the event generation benchmark, the fast one is 30% faster, but when building an AST, it’s only 9% faster.</p>
<p>The push implementation is still faster than the recursive descent parser, even with the extra lexing step. I’m planning to investigate this further in a future post.</p>]]></summary>
</entry>
<entry>
    <title>Exploring parsing APIs: what to generate, and how</title>
    <link href="http://osa1.net/posts/2024-11-22-how-to-parse-1.html" />
    <id>http://osa1.net/posts/2024-11-22-how-to-parse-1.html</id>
    <published>2024-11-22T00:00:00Z</published>
    <updated>2024-11-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Consider a simplified and enhanced version of JSON, with these changes:</p>
<ul>
<li>Numbers are 64-bit unsigned integers.</li>
<li>Strings cannot have control and escape characters.</li>
<li>Single-line comments are allowed, with the usual syntax: <code>// ...</code> .</li>
</ul>
<p>When parsing a language like this, a common first step if to define an “abstract syntax tree” (AST), with only the details we want from the parser output.</p>
<p>For example, if we’re implementing a tool like <a href="https://jqlang.github.io/jq/">jq</a>, the AST may look like:</p>
<pre><code>enum Json {
    Int(u64),
    Str(String),
    Bool(bool),
    Array(Vec&lt;Json&gt;),
    Object(Vec&lt;(String, Json)&gt;),
    Null,
}</code></pre>
<p>This type is called an “abstract” syntax tree because it abstracts the unnecessary details from the parse output. In our tool we don’t need locations of nodes and comments, so the AST doesn’t contain them.</p>
<p>It’s easy to implement a parser for this AST: we iterate the input, skip whitespace and comments, then based on the next character decide what type of node (integer, string, etc.) to parse. For nested <code>Json</code> nodes in arrays and objects, we recursively call the parser.</p>
<p>This kind of parser is called a “recursive descent parser”. For our AST above, the parser looks like this:</p>
<pre><code>// The entry point: parses all of the input to JSON.
pub fn parse(input: &amp;str) -&gt; Result&lt;Json, JsonParseError&gt; {
    let mut iter = input.char_indices().peekable();
    let (_, json) = parse_single(&amp;mut iter, input)?;
    skip_trivia(&amp;mut iter)?;
    // Check that all of the input is consumed.
    ...
}

// Parse a single Json. After parsing, the input may have more characters to be parsed.
fn parse_single(
    iter: &amp;mut Peekable&lt;CharIndices&gt;,
    input: &amp;str,
) -&gt; Result&lt;(usize, Json), ParseError&gt; {
    // Skip whitespace and comments.
    skip_trivia(iter)?;

    // Get next character.
    let (byte_offset, char) = match iter.next() { ... }

    if char == &#39;[&#39; {
        // Parse an array. Call `parse_single` recursively for elements.
        ...
    }

    if char == &#39;{&#39; {
        // Parse an object. Call `parse_single` recursively for values.
        ...
    }

    if char == &#39;t&#39; {
        // Parse keyword &quot;true&quot;.
        ...
    }

    // Same for other keywords, integers, strings.
    ...
}</code></pre>
<p>While very common, this kind of parsers are inflexible, and slower than more flexible alternatives for many use cases.</p>
<p>Consider these use cases:</p>
<ul>
<li><p>A JSON formatter: a formatter needs to know about comments to be able to keep them in the formatted code. To support this use case, the AST needs to include comments too, which will make it larger, and parsing will be less efficient for the applications that don’t need comments.</p></li>
<li><p>A configuration file parser for a text editor: to be able to show error locations in configuration errors (such as an invalid value used for a setting), the AST will have to include source locations. Similar to above, this will make the AST larger and slower to parse for other applications that don’t need source locations.</p></li>
<li><p>An RPC server that looks at the command name in incoming JSON messages and relays the messages based on the command name: the server doesn’t even need a full parser, just a parser that can keep track of nesting level so that it can extract the request name field at the right level will suffice. Using a full AST parser will parse the whole message and be inefficient.</p></li>
<li><p>A log sorting tool that reads a file with one JSON log per line, sorts the lines based on top-level “timestamp” field values. Similar to the use case above, this tool only needs to read one field and parsing whole lines is wasteful.</p></li>
</ul>
<p>A well-known solution to these is to introduce a lower level parser that doesn’t generate a fully structured output like an AST, but a stream of “parse events”. These events should be general enough to allow different use cases like the ones we listed above, and should be cheap to allocate and pass around, ideally as stack allocated values, so that applications that don’t need them can skip them efficiently.</p>
<p>This type of parsing is often called “event driven parsing”. In our JSON variant, the events look like this:</p>
<pre><code>/// A parse event, with location of the event in the input.
pub struct ParseEvent {
    pub kind: ParseEventKind,
    pub byte_offset: usize,
}

/// Details of a parse event.
pub enum ParseEventKind {
    StartObject,
    EndObject,
    StartArray,
    EndArray,
    Int(u64),
    Str {
        /// Size of the string, not including the double quotes.
        size_in_bytes: usize,
    },
    Bool(bool),
    Null,
    Comment {
        /// Size of the comment, including the &quot;//&quot; a the beginning and newline at the end.
        size_in_bytes: usize,
    },
}</code></pre>
<p>Note that there’s no heap allocation required for these events. Contents of strings and comments can be obtained by slicing the input using the event location and <code>size_in_bytes</code> field.</p>
<p>When generating these event, it’s important that we don’t scan the whole input and collect all of the events in a list, as that would mean some of the users, like our RPC server and log sorted examples above, would have to do more work than necessary.</p>
<p>This means that the parser will have to be stateful: after returning an event, it needs to be able to continue from the last event location. This complicates the parser implementation quite a bit. Here’s how the parser looks like at a high level:</p>
<pre><code>// The entry point. Use via the `Iterator` interface.
pub fn parse_events(input: &amp;str) -&gt; EventParser {
    EventParser::new(input)
}

// The parser state.
pub struct EventParser&lt;&#39;a&gt; {
    input: &amp;&#39;a str,
    byte_offset: usize,
    container_stack: Vec&lt;Container&gt;,
    state: ParserState,
}

enum Container {
    Array,
    Object,
}

enum ParserState {
    /// Parse any kind of object, update state based on the current container.
    TopLevel,

    /// Finished parsing a top-level object, expect end-of-input.
    Done,

    /// Parsing an object, parse another element on &#39;,&#39;, or finish the array on &#39;}&#39;.
    ObjectExpectComma,

    /// Parsing an object, parse the first element, or finish the array on &#39;]&#39;.
    ObjectExpectKeyValue,

    /// Parsing an object and we&#39;ve just parsed a key, expect &#39;:&#39;.
    ObjectExpectColon,

    /// Parsing an array, parse another element on &#39;,&#39;, or finish the array on &#39;]&#39;.
    ArrayExpectComma,
}

impl&lt;&#39;a&gt; Iterator for EventParser&lt;&#39;a&gt; {
    type Item = Result&lt;ParseEvent, ParseError&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.state {
            ParserState::TopLevel =&gt; self.top_level(),
            ParserState::Done =&gt; self.done(),
            ParserState::ObjectExpectComma =&gt; self.object_expect_comma(),
            ParserState::ObjectExpectKeyValue =&gt; self.object_expect_key_value(),
            ParserState::ObjectExpectColon =&gt; self.object_expect_colon(),
            ParserState::ArrayExpectComma =&gt; self.array_expect_comma(),
        }
    }
}

...</code></pre>
<p>The main complexity of this parser comes from the fact that it cannot return an event and keep running, the caller needs to call the relevant method (<code>next</code> from the <code>Iterator</code> trait above) to keep parsing. To be able to continue from where it’s left, the parser needs to maintain some state outside of the parse functions.</p>
<p>This parser is general enough to allow implementing our original AST parser:</p>
<pre><code>pub fn event_to_tree&lt;I: Iterator&lt;Item = Result&lt;ParseEvent, ParseError&gt;&gt;&gt;(
    parser: &amp;mut I,
    input: &amp;str,
) -&gt; Result&lt;Json, ParseError&gt; {
    let mut container_stack: Vec&lt;Container&gt; = vec![];
    let mut current_container: Option&lt;Container&gt; = None;
    let mut parsed_object: Option&lt;Json&gt; = None;

    for event in parser.by_ref() {
        match event {
            ...
        }
    }

    Ok(parsed_object.unwrap())
}</code></pre>
<p>But it also allows parsing to an AST with comments (for our formatter), source locations (for our configuration parser), and our RPC server and log sorter. Here’s how the timestamp parser that stops after finding the field looks like:</p>
<pre><code>/// Parse the &quot;timestamp&quot; field at the top-level map of the JSON.
pub fn parse_timestamp(log_line: &amp;str) -&gt; Result&lt;Option&lt;u64&gt;, ParseError&gt; {
    let mut container_depth: u32 = 0;
    let mut expect_timestamp = false;

    for event in parse_events(log_line) {
        let ParseEvent { kind, byte_offset } = match event {
            Ok(event) =&gt; event,
            Err(err) =&gt; return Err(err),
        };

        let expect_timestamp_ = expect_timestamp;
        expect_timestamp = false;

        match kind {
            ParseEventKind::StartObject =&gt; {
                container_depth += 1;
            }

            ParseEventKind::EndObject =&gt; {
                container_depth -= 1;
            }

            ParseEventKind::StartArray =&gt; {
                if container_depth == 0 {
                    // Array at the top level, the line does not contain the field.
                    return Ok(None);
                }
                container_depth += 1;
            }

            ParseEventKind::EndArray =&gt; {
                container_depth -= 1;
            }

            ParseEventKind::Str { size_in_bytes } =&gt; {
                if container_depth != 1 {
                    continue;
                }
                let str = &amp;log_line[byte_offset..byte_offset + size_in_bytes];
                expect_timestamp = str == &quot;timestamp&quot;;
            }

            ParseEventKind::Int(i) =&gt; {
                if expect_timestamp_ {
                    return Ok(Some(i));
                }
            }

            ParseEventKind::Bool(_)
            | ParseEventKind::Null
            | ParseEventKind::Comment { .. } =&gt; {}
        }
    }

    Ok(None)
}</code></pre>
<p>A nice property of this parser is that it does not allocate at all. It doesn’t build an AST (so no heap-allocated vectors), and parse events are 24-byte stack allocated values. The event parser is also stack allocated by this function.</p>
<p>An alternative design to this that is slightly less flexible and more difficult to use, but easier to implement and faster is what’s sometimes called a “push parser”.</p>
<p>The idea is that, instead of returning one event at a time, the parser takes a “listener” argument, and calls the listener callbacks for each event generated. The listener type directly follows our event type above:</p>
<pre><code>// Methods return a `bool` indicating whether to continue parsing after the event.
pub trait EventListener {
    fn handle_start_object(&amp;mut self, _byte_offset: usize) -&gt; bool {
        true
    }

    fn handle_end_object(&amp;mut self, _byte_offset: usize) -&gt; bool {
        true
    }

    fn handle_start_array(&amp;mut self, _byte_offset: usize) -&gt; bool {
        true
    }

    fn handle_end_array(&amp;mut self, _byte_offset: usize) -&gt; bool {
        true
    }

    fn handle_int(&amp;mut self, _byte_offset: usize, _i: u64) -&gt; bool {
        true
    }

    fn handle_str(&amp;mut self, _byte_offset: usize, _size_in_bytes: usize) -&gt; bool {
        true
    }

    fn handle_bool(&amp;mut self, _byte_offset: usize, _b: bool) -&gt; bool {
        true
    }

    fn handle_null(&amp;mut self, _byte_offset: usize) -&gt; bool {
        true
    }

    fn handle_comment(&amp;mut self, _byte_offset: usize, _size_in_bytes: usize) -&gt; bool {
        true
    }

    fn handle_error(&amp;mut self, _error: ParseError);
}</code></pre>
<p>The parser:</p>
<pre><code>// The entry point. Parse all of the input, call `listener` with the events.
pub fn parse&lt;L: EventListener&gt;(input: &amp;str, listener: &amp;mut L) {
    let mut iter = input.char_indices().peekable();
    let input_size = input.len();

    // Parse a single JSON.
    if !parse_single(&amp;mut iter, input_size, listener) {
        return;
    }

    // Check that all of the input is consumed.
    ...
}

// Returns whether an error was reported.
fn parse_single&lt;L: EventListener&gt;(
    iter: &amp;mut Peekable&lt;CharIndices&gt;,
    input_size: usize,
    listener: &amp;mut L,
) -&gt; bool {
    // Skip whitespace and comments, generate events for comments.
    skip_trivia!(iter, listener);

    // Get next character.
    let (byte_offset, char) = match iter.next() {
        Some(next) =&gt; next,
        None =&gt; {
            listener.handle_error(ParseError {
                byte_offset: input_size,
                reason: &quot;unexpected end of input&quot;,
            });
            return false;
        }
    };

    if char == &#39;[&#39; {
        // Parse an array. Call `parse_single` recursively for elements.
        ...
    }

    if char == &#39;{&#39; {
        // Parse an object. Call `parse_single` recursively for values.
        ...
    }

    if char == &#39;t&#39; {
        // Parse keyword &quot;true&quot;.
        ...
    }

    // Same for other keywords, integers, strings.
    ...
}</code></pre>
<p>Note that the parser functions are identical (in terms of names and what they do) to our simple recursive descent parser. This is because the parser no longer needs to maintain state to be able to return and continue from where it was left, as it does all of the work in one go. Instead of building an AST or a list of events, it takes an <code>EventListener</code> argument and calls the handle methods.</p>
<p>This is a bit less convenient to use, but it’s still flexible enough to build an AST. An <code>EventListener</code> implementation that builds up a <code>Json</code> AST looks like this:</p>
<pre><code>pub struct AstBuilderListener&lt;&#39;a&gt; {
    input: &amp;&#39;a str,
    container_stack: Vec&lt;Container&gt;,
    current_container: Option&lt;Container&gt;,
    parsed_object: Option&lt;Json&gt;,
    error: Option&lt;ParseError&gt;,
}

impl&lt;&#39;a&gt; EventListener for AstBuilderListener&lt;&#39;a&gt; {
    ...
}</code></pre>
<p>However, if you need to be able to stop parsing and continue later, this parser can’t do that.</p>
<p>The main advantage of this parser is that, with the right programming language and parser design, it can be faster than the alternatives, while still being flexible enough for most use cases. See below for benchmarks.</p>
<hr />
<h1 id="aside-event-parsing-vs.-lexing">Aside: event parsing vs. lexing</h1>
<p>Our <code>ParseEvent</code> type has no nested data and looks like what we could define as the “tokens” in a parser for a programming language.</p>
<p>So it shouldn’t be surprising that we can use a lexer generator to implement a parse event generator:</p>
<pre><code>// Same `parse_events` as above, but uses a generated lexer.
pub fn parse_events(input: &amp;str) -&gt; LexgenIteratorAdapter {
    LexgenIteratorAdapter {
        lexer: Lexer::new(input),
    }
}

// An adapter is necessary to convert lexgen values to `parse_events` items.
pub struct LexgenIteratorAdapter&lt;&#39;a&gt; {
    lexer: Lexer&lt;&#39;a, std::str::Chars&lt;&#39;a&gt;&gt;,
}

impl&lt;&#39;a&gt; Iterator for LexgenIteratorAdapter&lt;&#39;a&gt; {
    type Item = Result&lt;ParseEvent, ParseError&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        ...
    }
}

struct LexerState {
    container_stack: Vec&lt;Container&gt;,
}

lexgen::lexer! {
    Lexer(LexerState) -&gt; ParseEvent;

    type Error = &amp;&#39;static str;

    let comment = &quot;//&quot; (_ # &#39;\n&#39;)* &#39;\n&#39;;

    rule Init {
        $$ascii_whitespace,

        $comment =&gt; comment,

        &#39;[&#39; =&gt; ...,

        &#39;]&#39; =&gt; ...,

        &#39;{&#39; =&gt; ...,

        &quot;true&quot; =&gt; ...,

        &quot;false&quot; =&gt; ...,

        &quot;null&quot; =&gt; ...,

        [&#39;0&#39;-&#39;9&#39;]+ =&gt; ...,

        &#39;&quot;&#39; (_ # &#39;&quot;&#39;)* &#39;&quot;&#39; =&gt; ...
    }

    rule Done { ... }

    rule ArrayExpectComma { ... }

    rule ObjectExpectKeyValue { ... }

    rule ObjectExpectColon { ... }

    rule ObjectExpectComma { ... }
}</code></pre>
<p>This uses <a href="https://github.com/osa1/lexgen">lexgen</a>. lexgen generates slightly different values than what we want, so we have a <code>map</code> in the entry point to convert the lexgen values.</p>
<p>The main difference between an event parser and lexer is that an event parser maintains some of the structure of the parsed format. For example, we check that brackets are balanced, after a key in a map a colon follows, and so on.</p>
<p>A lexer generator can be used to implement an event parser, as demonstrated above.</p>
<hr />
<h1 id="references-and-benchmarks">References and benchmarks</h1>
<p>All of the code in this blog post, and more, is here: <a href="https://github.com/osa1/how-to-parse">github.com/osa1/how-to-parse</a>.</p>
<p>In the benchmark program (run with <code>cargo bench</code>), we generate a 10M large JSON, and parse it to either an AST or a vector of events.</p>
<p><strong>AST building benchmarks:</strong></p>
<ul>
<li><p>Recursive descent: the recursive descent parser that generates an AST.</p>
<p>Throughput: 128 Mb/s.</p></li>
<li><p>Event generator to AST: the iterator-style event generator, events processed by <code>event_to_tree</code> to build an AST.</p>
<p>Throughput: 138 Mb/s.</p></li>
<li><p>Lexgen event to AST: same as above, but the event parser is implemented with lexgen.</p>
<p>Throughput: 106 Mb/s.</p></li>
<li><p>Push event parser to AST: the “push” event parser, <code>AstBuilderListener</code> as the event listener.</p>
<p>Throughput: 147 Mb/s.</p></li>
</ul>
<p><strong>Event generation benchmarks:</strong> (collect events in a <code>Vec</code>)</p>
<ul>
<li><p>Parse events: the iterator-style event generator.</p>
<p>Throughput: 274 Mb/s.</p></li>
<li><p>Parse events lexgen: the lexgen-generated event generator.</p>
<p>Throughput: 179 Mb/s.</p></li>
<li><p>Parse events via push: the push event parser, events added to a <code>Vec</code> via by the listener.</p>
<p>Throughput: 304 Mb/s.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li><p>lexgen-generated event parser is the slowest, but I think it should be possible to make it perform at least as good as the hand-written one. So far I’ve spent very little time to optimize lexgen’s code generator.</p></li>
<li><p>Push-based implementation is faster than the iterator-style implementation, both for generating events in a list, and also for building an AST.</p>
<p>The main advantage of the push-based implementation is that the control flow is as simple as the recursive descent parsing (contained within parse functions, as opposed to externally in a struct), as it does all of the parsing in one go. It looks like managing the parser state externally in a struct is not free.</p></li>
<li><p>I think the tradeoffs between the push-based and iterator implementations will be different in most high-level languages without control over allocations and monomorphisation.</p>
<ul>
<li><p>In the Rust implementation, events are stack allocated values, which will be heap-allocated objects in some of the other languages.</p></li>
<li><p>In the push-based implementation, the parser is monomorphised based on the listener type. Both the listener and parser are stack allocated. All event handler method calls are direct calls (as opposed to virtual, or via some other dynamic invocation method), which can be inlined. None of these will be the case in, e.g., Haskell and Dart.</p></li>
</ul>
<p>It would be interesting to implement the same in some other languages to see how they perform relative to each other.</p></li>
<li><p>I’m not sure why the recursive descent parser is not at least as fast as the push-based implementation, and not faster than the iterator-style one. If you have any insights into this, please let me know.</p></li>
</ul>
<h1 id="more-use-cases">More use cases</h1>
<p>The use cases described at the beginning of the post are all extracted from real-world use cases of various other formats.</p>
<p>Here are more use cases that require flexible and fast parser design:</p>
<ul>
<li><p>“Outline” views in text editors or online code browsing tools may want to process top-level definitions, and definitions nested in <code>class</code>, <code>impl</code>, and similar blocks. Parsing the whole file to an AST would be inefficient.</p></li>
<li><p>Syntax-aware code search tools like <a href="https://github.com/osa1/sg">sg</a> can implement searching only in identifiers, string literals, comments with an event-based parser. This could also be implemented with a lexer.</p></li>
<li><p>As mentioned in a <a href="https://osa1.net/posts/2024-11-04-resumable-exceptions.html">previous post</a>, ideally a formatter, language server, compiler, and refactoring tools, should reuse as much parsing code as possible. It’s difficult to do this with an AST parser, as the AST would have too much information for each of these tools. Event-based parsing makes this easier.</p></li>
</ul>
<h1 id="event-parsing-examples-from-programming-languages">Event parsing examples from programming languages</h1>
<p>I think event-driven parsing is common in some languages when parsing data formats like XML, but less common for parsing programming languages. Two examples that I’m aware of that applies the ideas to programming languages:</p>
<ul>
<li><p>rust-analyzer’s parser is <a href="https://github.com/rust-lang/rust-analyzer/blob/c0bbbb3e5d7d1d1d60308c8270bfd5b250032bb4/docs/dev/architecture.md#cratesparser">a hand written one that generates events</a>. The architecture documentation mentions that Kotlin uses a similar idea:</p>
<blockquote>
<p>It is a hand-written recursive descent parser, which produces a sequence of events like “start node X”, “finish node Y”. It works similarly to kotlin’s parser, which is a good source of inspiration for dealing with syntax errors and incomplete input</p>
</blockquote></li>
<li><p>Dart’s parser <a href="https://github.com/dart-lang/sdk/blob/19da943583e020e96026f797904dc5c6b993d4ac/pkg/_fe_analyzer_shared/lib/src/parser/listener.dart#L35-L46">uses the push-based API</a>. This parser is the only Dart language parser used by the SDK. It’s used by the analyzer, language server, compilers, and anything else that the SDK includes.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Conditional compilation based on crate type</title>
    <link href="http://osa1.net/posts/2020-12-24-crate-type-conditional.html" />
    <id>http://osa1.net/posts/2020-12-24-crate-type-conditional.html</id>
    <published>2020-12-24T00:00:00Z</published>
    <updated>2020-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Suppose you have a <code>no_std</code> crate that you want to use in two ways:</p>
<ol type="1">
<li>As a self-contained static library, to link with other (non-Rust) code</li>
<li>As a Rust library, to import from another crate to test it</li>
</ol>
<p>(1) is the main use case for this library. (2) is because you want to test this library and you want to be able to use Rust’s <code>std</code> and other Rust libraries for testing.</p>
<p>The Rust crate type for (1) is <code>staticlib</code>. For (2) you need <code>rlib</code>. (<a href="https://doc.rust-lang.org/reference/linkage.html">documentation on crate types</a>)</p>
<p>Here’s the problem. To be able to generate <code>staticlib</code> you need to implement a <a href="https://doc.rust-lang.org/nomicon/panic-handler.html">panic handler</a> as otherwise the code won’t know how to panic<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. However, if you define a panic handler, you won’t be able to use your crate in other crates anymore as your panic handler will clash with the <code>std</code> panic handler.</p>
<p>4 files needed to demonstrate this:</p>
<pre><code>-- Cargo.toml for the library
[package]
name = &quot;nostd_lib&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[lib]
crate-type = [&quot;staticlib&quot;, &quot;rlib&quot;]

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;

-- lib.rs
#![no_std]

#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}

-- Cargo.toml for the importing crate
[package]
name = &quot;nostd_bin&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[dependencies]
nostd_lib = { path = &quot;../nostd_lib&quot; }

-- main.rs
extern crate nostd_lib;

fn main() {}</code></pre>
<p>The library builds fine, but if you try to build <code>nostd_bin</code> you’ll get this error:</p>
<pre><code>error: duplicate lang item in crate `nostd_lib` (which `nostd_bin` depends on): `panic_impl`.
  |
  = note: the lang item is first defined in crate `std` (which `nostd_bin` depends on)
  = note: first definition in `std` loaded from ...
  = note: second definition in `nostd_lib` loaded from ...</code></pre>
<p>Which says you now have two panic handlers: one in <code>std</code> and one in your library.</p>
<p>If you remove the panic handler in the library then you won’t be able to build the library anymore:</p>
<pre><code>error: `#[panic_handler]` function required, but not found</code></pre>
<p>So you need some kind of conditional compilation, to generate panic handler only when generating <code>staticlib</code>. Unfortunately conditional compilation based on crate type is <a href="https://github.com/rust-lang/rust/issues/20267">currently not possible</a>. It is also <a href="https://github.com/rust-lang/cargo/issues/6160">not possible to specify target crate type when invoking cargo</a>.</p>
<p>The least hacky way I could find to solve this (and without using anything other than just <code>cargo build</code> to build) is by having two <code>Cargo.toml</code> files.</p>
<p>Cargo really wants manifest files to be named <code>Cargo.toml</code>, so we put the files in different directories. In my case the top-level one is for <code>staticlib</code> and it looks like this:</p>
<pre><code>[package]
name = &quot;nostd_lib&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[features]
default = [&quot;panic_handler&quot;]
panic_handler = []

[lib]
crate-type = [&quot;staticlib&quot;]

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;</code></pre>
<p>I also update <code>lib.rs</code> to only define the panic handler when the feature is enabled:</p>
<pre><code>#[cfg(feature = &quot;panic_handler&quot;)]
#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    ...
}</code></pre>
<p>Now I can build the library at the library’s top-level with just <code>cargo build</code>. Because the <code>panic_handler</code> feature is enabled by default in this <code>Cargo.toml</code>, the panic handler will be defined by default with just <code>cargo build</code> and static library will build and work fine.</p>
<p>For the <code>rlib</code> I create a similar <code>Cargo.toml</code> in <code>rlib</code> directory:</p>
<pre><code>[package]
name = &quot;nostd_lib&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[lib]
crate-type = [&quot;rlib&quot;]
path = &quot;../src/lib.rs&quot;

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;</code></pre>
<p>The differences are: this one only generates <code>rlib</code>, doesn’t define the <code>panic_handler</code> feature, and specifies the library source path explicitly (as it’s not in the default location relative to this <code>Cargo.toml</code>). It’s fine to refer to a feature that you never define in <code>Cargo.toml</code> in your code, so <code>lib.rs</code> is still fine, and the panic handler will never be built when you build the crate with this <code>Cargo.toml</code>.</p>
<p>Now in the importing crate I use this <code>Cargo.toml</code> instead of the top-level one:</p>
<pre><code>[dependencies]
nostd_lib = { path = &quot;../nostd_lib/rlib&quot; }</code></pre>
<p>And it works fine. The downside is I have two <code>Cargo.toml</code> files now, but in my case that’s not a big deal, as my <code>Cargo.toml</code> is quite small and have no dependencies other than <code>libc</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>I hope this is helpful. If you know any better way to do conditional compilation based on crate types, or to solve the problem of generating usable <code>staticlib</code> and <code>rlib</code>s from a single <code>no_std</code> crate, let me know!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>You need a <code>panic_handler</code> even if you never panic in your crate (assuming that’s possible). For example, you can’t compile <code>fn main() {}</code> with <code>no_std</code>, <code>panic=abort</code>, and without a <code>panic_handler</code>: the compiler complains about the missing panic handler.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>If you’re working on a <code>no_std</code> crate I think you won’t be able to find a lot of libraries that you can use anyway.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>More Rust woes</title>
    <link href="http://osa1.net/posts/2017-10-08-more-rust-woes.html" />
    <id>http://osa1.net/posts/2017-10-08-more-rust-woes.html</id>
    <published>2017-10-08T00:00:00Z</published>
    <updated>2017-10-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the third part of the series (<a href="http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html">1</a>, <a href="http://osa1.net/posts/2016-09-11-more-rust-problems.html">2</a>) we’re going to look at two curious cases, first one related with “drop checker” and the second one with “borrow checker”.</p>
<p>(examples below are tested with <code>rustc 1.22.0-nightly (05f8ddc46 2017-10-07)</code>)</p>
<h1 id="redundant-semicolon-fixes-borrow-or-drop-checker">1. Redundant semicolon fixes borrow (or drop) checker</h1>
<p>It turns out if you’re getting a weird borrow checker error about something not living long enough to be dropped you can sometimes fix it by adding more semicolons.</p>
<p>The error message itself is weird because intuitively you’d think that for something to be dropped it should first become dead, but the error message says something like “<code>x</code> dropped here while still borrowed”. Because the variable is not dropped explicitly by the user, this error message is actually complaining about compiler’s behavior not being consistent in itself.</p>
<p>Here’s an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Arc<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">let</span> s<span class="op">:</span> Arc<span class="op">&lt;</span>Mutex<span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">Mutex::</span>new(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">match</span> s<span class="op">.</span>lock()<span class="op">.</span>unwrap() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        _ <span class="op">=&gt;</span> <span class="op">{}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This fails to compile with:</p>
<pre><code>error[E0597]: `s` does not live long enough
 --&gt; src/main.rs:9:1
  |
6 |     match s.lock().unwrap() {
  |           - borrow occurs here
...
9 | }
  | ^ `s` dropped here while still borrowed
  |
  = note: values in a scope are dropped in the opposite order they are created</code></pre>
<p>Solution? Add more semicolons! In this example, just put a semicolon after the match expression and it compiles fine.</p>
<p>Here’s <a href="https://github.com/rust-lang/rust/issues/21114#issuecomment-312447832">one more example</a>. It turns out questions about this error message are regularly asked on the IRC channel.</p>
<p><a href="https://github.com/rust-lang/rust/issues/21114">#21114</a> reported this issue on Jan 14, 2015, but no progress has been made towards a solution so far. It’s not clear if non-lexical lifetimes will help solving this.</p>
<h1 id="match-expression-keeps-values-alive-longer-than-necessary">2. <code>match</code> expression keeps values alive longer than necessary</h1>
<p>This problem is kind of special. All other problems mentioned in this series were about borrow checker being too strict. This one is different: it causes runtime bugs.</p>
<p><code>match</code> expression keeps the value to be examined (sometimes called <code>scrutinee</code> in Haskell land) alive longer than necessary. Because alive values are not dropped, if you rely on dynamic borrow checks in the scrutinee and in the branches, your checks fail. Here’s an example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Arc<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="kw">struct</span> S(<span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="kw">impl</span> S <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> get_int(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span><span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> set_int(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> i<span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span><span class="dv">0</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">Mutex::</span>new(S(<span class="dv">0</span>)))<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>    <span class="kw">match</span> s<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">.</span>get_int() <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        i <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>            s<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">.</span>set_int(i)<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>(notice how I use a redundant semicolon after the match expression, to fix #1)</p>
<p>Even though <code>get_int()</code> returns in <code>i32</code> as a value, not a reference, the <code>MutexGuard</code> returned by <code>Mutex::lock()</code> is kept alive in the branches of this <code>match</code> expression, so the second <code>Mutex::lock()</code> call causes a deadlock. Solution? Use a <code>let</code> expression:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">let</span> x <span class="op">=</span> s<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">.</span>get_x()<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">match</span> x <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>This problem makes <code>match &lt;expr&gt; { ... }</code> less useful than <code>let x = &lt;expr&gt;; match x { ... }</code>.</p>
<p><a href="https://github.com/rust-lang/rust/issues/38355">#38355</a> reported this issue on Dec 14, 2016, but no progress towards a solution has been made so far.</p>]]></summary>
</entry>
<entry>
    <title>More Rust problems (and a sketch of a solution)</title>
    <link href="http://osa1.net/posts/2016-09-11-more-rust-problems.html" />
    <id>http://osa1.net/posts/2016-09-11-more-rust-problems.html</id>
    <published>2016-09-11T00:00:00Z</published>
    <updated>2016-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s a nice coincidence that after a good productive weekend of Rust hacking I saw <a href="https://hackernoon.com/why-im-dropping-rust-fd1c32986c88">this blog post</a> about why the author is dropping Rust. I’ve been doing a lot of Rust programming lately (I have at least 3 programs –not libraries– that I’m hoping to publish in the near future), and I’m surprised to see that no one mentioned in the discussion threads about this blog post what IMHO is one of the most annoying problems with Rust.</p>
<p>Borrow checker rejects some programs that are perfectly valid in other languages, and by itself this isn’t a problem. Similar things happen in all languages <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. One of the first problems I encountered after started to write Rust was the OP’s second problem, namely, cyclic data structures (or graphs, but more specifically, widgets with parent/child relations). However, there is at least one pretty good solution for this, and all you need is to think harder and experiment with alternative designs. I’m actually very happy with my solution to this (which is also discovered independently by many people, for an example, see <a href="https://crates.io/crates/petgraph">petgraph</a>).</p>
<p>However, there are problems that basically can’t be solved in Rust without paying some runtime costs or using bad practices. See my <a href="">previous blog post</a> for some examples. In this post I’m going to show another, and more annoying, problem.</p>
<h1 id="self-borrows-all-of-its-fields"><code>self</code> borrows all of its fields</h1>
<p>This is a problem that happened in pretty much every single Rust program I’ve ever written. In a method, you can’t borrow some fields, and call another <code>&amp;mut self</code> method. This is because methods borrow the whole <code>self</code>, so you get an error saying that you can’t borrow <code>self</code> twice.</p>
<p>As an example, imagine writing a compiler. For some reason you want to collect all the variables defined in a scope, and then generate fresh variables for those. You may do something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">struct</span> FreshGen <span class="op">{</span> <span class="co">/* abstract */</span> <span class="op">}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">struct</span> Var <span class="op">{</span> <span class="co">/* abstract */</span> <span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">impl</span> FreshGen <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">fn</span> fresh(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> Var <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="pp">unimplemented!</span>()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="kw">struct</span> Compiler <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    fresh_gen<span class="op">:</span> FreshGen<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    vars_in_scope<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Var<span class="op">&gt;,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="kw">impl</span> Compiler <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    <span class="kw">fn</span> fresh(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> Var <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>fresh_gen<span class="op">.</span>fresh()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>    <span class="kw">fn</span> gen_locals(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>        <span class="kw">let</span> <span class="kw">mut</span> fresh_vars <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        <span class="kw">for</span> var <span class="kw">in</span> <span class="kw">self</span><span class="op">.</span>vars_in_scope<span class="op">.</span>iter() <span class="op">{</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>            fresh_vars<span class="op">.</span>push(<span class="kw">self</span><span class="op">.</span>fresh())<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>        <span class="co">// use fresh_vars</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Can you see any problems here? When I compile this with nightly 11/9/2016, I get this annoying error message:</p>
<pre><code>error[E0502]: cannot borrow `*self` as mutable because `self.vars_in_scope` is also borrowed as immutable
  --&gt; &lt;anon&gt;:24:29
   |
23 |         for var in self.vars_in_scope.iter() {
   |                    ------------------ immutable borrow occurs here
24 |             fresh_vars.push(self.fresh());
   |                             ^^^^ mutable borrow occurs here
25 |         }
   |         - immutable borrow ends here</code></pre>
<p>So basically, <code>self.vars_in_scope</code> is borrowed from <code>self</code>, and then <code>self.fresh()</code> is called while <code>vars_in_scope</code> is still borrowed. Even though <code>self.fresh()</code> doesn’t have anything to do with <code>self.vars_in_scope</code>, this is not allowed because the compiler simply doesn’t care about what pieces of <code>self</code> methods actually borrow. For me this is probably the #1 most annoying problem with Rust.</p>
<p>Now, I believe this problem is solvable. I imagine an algorithm like this:</p>
<p>It works in two steps.</p>
<ol type="1">
<li><p>We generate, for every method, borrow sets. A borrow set is a set of fields that are, at some point in the method, borrowed from <code>self</code>.</p></li>
<li><p>For every method call statement in every method, we look at intersections of currently borrowed fields and the borrow set of callee (i.e. (1) for the method being called).</p></li>
</ol>
<p>(1) works like this:</p>
<pre><code>workset = set of all methods
caller-graph = graph of all methods, with edges from callees to callers

# initially none of methods borrow any fields
for method in methods:
    method.borrows = empty set

while workset is not empty:
    work = workset.pop()
    for statement in work.statements:
        for field in self.borrowed_at(statement):
            if not work.borrows.contains(field):
                work.borrows.insert(field)
                for caller in caller-graph[work]:
                    workset.insert(caller)</code></pre>
<p>For a statement that has a method call, <code>borrowed_at()</code> returns the borrow set of the method being called. So when we update borrow set of a method, we add its callers to the workset and <code>borrowed_at()</code> will return more variables next time, propagating the information in the graph from callees to callers.</p>
<p>Now, for the second step, we first need to generate “live ranges” of borrowed fields. Assume that they’re generated.</p>
<pre><code>for method in methods:
    for borrowed_field in method.borrows():
        for field_live_range in borrowed_field.live_ranges():
            # for methods called in the range
            for method in method_calls(field_live_range):
                if method.borrows().contains(borrowed_field):
                    error(&quot;can&#39;t borrow twice&quot;)</code></pre>
<p>I sketched this in 30 minutes so I don’t expect this to work perfectly. Also, 4-level nested for loops look scary! But this is just to give an idea of how this might be solved.</p>
<p>In the example I showed above, borrow set of <code>fresh</code> would be <code>{fresh_gen}</code>, and borrow set of <code>gen_locals</code> would be <code>{vars_in_scope, fresh_gen}</code>. Now we look at live ranges of variables borrowed from <code>self</code> in <code>gen_locals</code>.</p>
<ul>
<li><code>vars_in_scope</code> lives between lines 2-4 in the method.</li>
<li><code>fresh_gen</code> lives in line 3 in the method.</li>
</ul>
<p>Since each variable has only one live range here, clearly there won’t be any intersections. So this would pass the borrow checker.</p>
<p>If <code>fresh</code> was also borrowing <code>vars_in_scope</code>, we’d get an error because <code>vars_in_scope</code> would now have two “live ranges”: between lines 2-4 as before, and in line 3. Since those intersect, we get an error.</p>
<p>(Again, this is a very quick sketch, so let me know if I’m missing something.)</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I’m hoping to write more about this later. For now, think Haskell’s type system that separates pure functions from effectful ones as an example.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>How I solved the Synacor Challenge</title>
    <link href="http://osa1.net/posts/2016-06-19-solving-synacor-challenge.html" />
    <id>http://osa1.net/posts/2016-06-19-solving-synacor-challenge.html</id>
    <published>2016-06-19T00:00:00Z</published>
    <updated>2016-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It took 4 attempts at various coffee shops in Cambridge/UK (where I’m spending this summer – more on this later) but I finally solved the <a href="https://challenge.synacor.com/">Synacor Challenge</a>. Here’s how I did it.</p>
<p>WARNING: This post spoils everything! Do not read further if you’re interested in solving it yourself. It’s a lot of fun, so I highly recommend that.</p>
<h1 id="first-attempt">First attempt</h1>
<p>Initial VM implementation took about an hour. It worked well until I was eaten by a grue. At that point I realized that I need a save/load system.</p>
<p>The game looks like a classic text-based adventure where you interact by typing commands. So I thought saving the commands should be enough for “save game”. To load, VM would just load the input from the save file to its input buffer (which is used when <code>in</code> instruction is executed). Indeed it works nicely.</p>
<p>The game is very easy until you make it to the “office”. IIRC, you collect 6 out of 8 codes until that point. At the office you learn about the teleporter, which is the first real challenge in the game…</p>
<h1 id="second-attempt">Second attempt</h1>
<p>At this point I implemented about 20 debugger commands, for things like stepping, breaking at an instruction, breaking at an address, breaking on a specific register read, setting the instruction pointer etc. Just by using these commands I was able to teleport to the right place. However, the code I found there did not really work. It turns out the code is generated dynamically, based on the value in R8. Which is kind of expected, otherwise we could find all the codes just by looking at strings in the binary.</p>
<p>So at this point I realize I need a disassembler…</p>
<h1 id="third-attempt">Third attempt</h1>
<p>The disassembler was trivial to implement. I implement it as a part of VM because 1) in theory the program can generate code in runtime (although I don’t think this is the case in practice) 2) code and data is in the same address space and instruction boundaries are not clearly known. I guess I could do something like: Start with address 0, at each jump disassemble the jump target etc. but I’m not sure if that works as some jump targets are generated dynamically.</p>
<p>Anyway, the debugger has a disassembler now, and I start disassembling functions.</p>
<p>When I step instruction by instruction after using the teleporter, I see that it’s checking R8, if it’s not 0, then calling a function which is the “confimation process” that’s supposed to take 1 billion years. The function has very complex control flow so I try to avoid actually debugging it.</p>
<p>I look at the code that this function returns to. It’s checking if R1 (which has the return value) is 6. So I think, why not just set R1 6 and return from the function? Indeed, it works, but not really how I expected. I already knew that the code I’m searching is generated dynamically, but it’s actually generated using R8, and only when R1 is 6. So as it turns out, I need to guess a value of R8 that makes the validation function return 6. Just making the function return 6 doesn’t really work.</p>
<p>However, I said “it kinda worked”. Because the teleporter actually teleports me to the right place. It’s just that the generated code is not valid.</p>
<h1 id="fourth-attempt">Fourth attempt</h1>
<p>Before disassembling the verification function, I decide to solve the rest of the challenge. I realize that we’re now in a maze, 4x4. Each tile in the maze has either a number, or an operation (<code>+</code>, <code>-</code>, <code>*</code>). There’s an orb in the south-west corner, and there’s a door in the north-east corner. “30” is written on the door, and “22” is printed on the Orb. It’s easy to see what’s going on. Two things to realize are that every time we return to the first tile things get reset, and the goal tile can be visited only once (the orb disappears on visit).</p>
<p>I implement a program that does breadth-first search on this state space, see <code>maze.rs</code>. It then prints directions. When we follow those directions we find the final code and the challenge is completed.</p>
<p>However, since I by-passed the previous challenge, I need to solve that now.</p>
<p>This is the most fun part, it involves lots of debugging, and some programming. Here’s the disassembly of the verification function:</p>
<pre><code>                                         -- fn(reg0 = 4, reg1 = 1, reg7 = our value) {
[6027] Jt [Reg(0), Num(6035)]            --   if reg0 == 0 {
[6030] Add [Reg(0), Reg(1), Num(1)]      --     reg0 = reg1 + 1;
[6034] Ret []                            --     return; }
[6035] Jt [Reg(1), Num(6048)]            --   if reg1 == 0 {
[6038] Add [Reg(0), Reg(0), Num(32767)]  --     reg0 -= 1;
[6042] Set [Reg(1), Reg(7)]              --     reg1 = reg7;
[6045] Call [Num(6027)] ------ loop      --     fn();
[6047] Ret []                            --     return; }
[6048] Push [Reg(0)]                     --   push(reg0);
[6050] Add [Reg(1), Reg(1), Num(32767)]  --   reg1 -= 1;
[6054] Call [Num(6027)] ------ loop      --   fn();
[6056] Set [Reg(1), Reg(0)]              --   reg1 = reg0;
[6059] Pop [Reg(0)]                      --   reg0 = pop();
[6061] Add [Reg(0), Reg(0), Num(32767)]  --   reg0 -= 1;
[6065] Call [Num(6027)] ------ loop      --   fn();
[6067] Ret [] -- end of function at 6027 --   return;
                                         -- }</code></pre>
<p>I added next to each instruction how they would look like in a C-like language. It’s hard to understand what’s going on. So to experiment with it I implement it in Rust. Since registers are shared in each call, I use shared state in my initial implementation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">fn</span> add(i1 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> i2 <span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> <span class="dt">u16</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    (i1 <span class="op">+</span> i2) <span class="op">%</span> <span class="dv">32768</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="kw">struct</span> FnState <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>    reg0  <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    reg1  <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    reg7  <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    stack <span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u16</span><span class="op">&gt;,</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="kw">impl</span> FnState <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="kw">fn</span> init(reg0 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> reg1 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> reg7 <span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> FnState <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>        FnState <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>            reg0<span class="op">:</span> reg0<span class="op">,</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>            reg1<span class="op">:</span> reg1<span class="op">,</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>            reg7<span class="op">:</span> reg7<span class="op">,</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>            stack<span class="op">:</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">,</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>    <span class="kw">fn</span> f(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>        <span class="kw">if</span> <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">=</span> add(<span class="kw">self</span><span class="op">.</span>reg1<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>            <span class="kw">return</span><span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>        <span class="kw">if</span> <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a>            <span class="co">// self.reg0 = add(self.reg0, 32767);</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>reg7<span class="op">;</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>f()<span class="op">;</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a>            <span class="kw">return</span><span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>stack<span class="op">.</span>push(<span class="kw">self</span><span class="op">.</span>reg0)<span class="op">;</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a>        <span class="co">// self.reg1 = add(self.reg1, 32767);</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>f()<span class="op">;</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>reg0<span class="op">;</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>stack<span class="op">.</span>pop()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true"></a>        <span class="co">// self.reg0 = add(self.reg0, 32767);</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>f()<span class="op">;</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true"></a>        <span class="kw">return</span><span class="op">;</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Now, this function grows really fast. Even for very small inputs it takes minutes to compute. I try to think some well-known functions that grow very fast. Ackermann comes to my mind and I check the Wiki page. Indeed, this looks quite similar, but the third argument makes it different than Ackermann. In any case, it doesn’t really matter for the solution.</p>
<p>So the problem is coming up with a <code>reg7</code> in this code so that <code>f(4, 1, reg7)</code> returns <code>6</code>. For that I need to implement a search but this is basically impossible with this slow function. I start simplifying the function a little bit. My first attempt:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">impl</span> FnState <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="kw">fn</span> f(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>        <span class="co">// When reg0 hits zero, restart it from reg1 + 1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        <span class="kw">if</span> <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">=</span> add(<span class="kw">self</span><span class="op">.</span>reg1<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>            <span class="kw">return</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>        <span class="co">// When reg1 hits zero, decrement reg0, restart reg1 from reg7</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>        <span class="kw">if</span> <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>reg7<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>f()<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>            <span class="kw">return</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>        <span class="kw">let</span> save_reg0 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>reg0<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>f()<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg1 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>reg0<span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">=</span> save_reg0<span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>reg0 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>f()<span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>        <span class="kw">return</span><span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This version doesn’t use an explicit stack, instead uses a temporary in the call frame. This works because in the original version each push corresponds to a pop done in the same call frame.</p>
<p>It’s still too complicated. I keep simplifying.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">fn</span> f(<span class="kw">mut</span> reg0 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> <span class="kw">mut</span> reg1 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> <span class="kw">mut</span> reg7 <span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> (<span class="dt">u16</span><span class="op">,</span> <span class="dt">u16</span>) <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">if</span> reg0 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        reg0 <span class="op">=</span> add(reg1<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        <span class="kw">return</span> (reg0<span class="op">,</span> reg1)<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="kw">if</span> reg1 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        reg0 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>        reg1 <span class="op">=</span> reg7<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        <span class="kw">return</span> f(reg0<span class="op">,</span> reg1<span class="op">,</span> reg7)<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    <span class="kw">let</span> save_reg0 <span class="op">=</span> reg0<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    reg1 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    <span class="kw">let</span> (reg0_<span class="op">,</span> reg1_) <span class="op">=</span> f(reg0<span class="op">,</span> reg1<span class="op">,</span> reg7)<span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    reg0 <span class="op">=</span> reg0_<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    reg1 <span class="op">=</span> reg1_<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>    reg1 <span class="op">=</span> reg0<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    reg0 <span class="op">=</span> save_reg0<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>    reg0 <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>    <span class="kw">return</span> f(reg0<span class="op">,</span> reg1<span class="op">,</span> reg7)<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This version doesn’t have any shared mutable state. At this point I realize that it may be possible to remove internal mutable state too:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">fn</span> f(reg0 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> reg1 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> reg7 <span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> (<span class="dt">u16</span><span class="op">,</span> <span class="dt">u16</span>) <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="kw">if</span> reg0 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        <span class="kw">return</span> (add(reg1<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> reg1)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="kw">if</span> reg1 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="kw">return</span> f(reg0 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> reg7<span class="op">,</span> reg7)<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    <span class="kw">let</span> (reg1<span class="op">,</span> _) <span class="op">=</span> f(reg0<span class="op">,</span> reg1 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> reg7)<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="kw">return</span> f(reg0 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> reg1<span class="op">,</span> reg7)<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Now, this is a function I can read and understand. One advantage of this version is that this could be easily memoized:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">fn</span> f_memo(reg0 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> reg1 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> reg7 <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> memo <span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> HashMap<span class="op">&lt;</span>(<span class="dt">u16</span><span class="op">,</span> <span class="dt">u16</span>)<span class="op">,</span> (<span class="dt">u16</span><span class="op">,</span> <span class="dt">u16</span>)<span class="op">&gt;</span>) <span class="op">-&gt;</span> (<span class="dt">u16</span><span class="op">,</span> <span class="dt">u16</span>) <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(ret) <span class="op">=</span> memo<span class="op">.</span>get(<span class="op">&amp;</span>(reg0<span class="op">,</span> reg1)) <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>        <span class="kw">return</span> <span class="op">*</span>ret<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="kw">if</span> reg0 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>        <span class="kw">let</span> ret <span class="op">=</span> (add(reg1<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> reg1)<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>        memo<span class="op">.</span>insert((reg0<span class="op">,</span> reg1)<span class="op">,</span> ret)<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>        <span class="kw">return</span> ret<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    <span class="kw">if</span> reg1 <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>        <span class="kw">let</span> ret <span class="op">=</span> f_memo(reg0 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> reg7<span class="op">,</span> reg7<span class="op">,</span> memo)<span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>        memo<span class="op">.</span>insert((reg0<span class="op">,</span> reg1)<span class="op">,</span> ret)<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>        <span class="kw">return</span> ret<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    <span class="co">// careful there</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>    <span class="kw">let</span> (reg1_new<span class="op">,</span> _) <span class="op">=</span> f_memo(reg0<span class="op">,</span> reg1 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> reg7<span class="op">,</span> memo)<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    <span class="kw">let</span> ret <span class="op">=</span> f_memo(reg0 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> reg1_new<span class="op">,</span> reg7<span class="op">,</span> memo)<span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>    memo<span class="op">.</span>insert((reg0<span class="op">,</span> reg1)<span class="op">,</span> ret)<span class="op">;</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>    <span class="kw">return</span> ret<span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This version is super fast when compared to the original version. I feel like I can just search the whole space in a few hours. I start the search and as it searches through the search space I start wondering about how to further improve it. I think, why not split search space into pieces and search in parallel?</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">fn</span> search(start_range <span class="op">:</span> <span class="dt">u16</span><span class="op">,</span> end_range <span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u16</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="kw">for</span> i <span class="kw">in</span> start_range <span class="op">..</span> end_range <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>        <span class="co">// println!(&quot;i = {}&quot;, i);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        <span class="kw">let</span> <span class="kw">mut</span> tbl <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        <span class="kw">let</span> ret <span class="op">=</span> f_memo(<span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> i<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> tbl)<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        <span class="kw">if</span> ret<span class="op">.</span><span class="dv">0</span> <span class="op">==</span> <span class="dv">6</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>            <span class="pp">println!</span>(<span class="st">&quot;Found an answer: {:?} {}&quot;</span><span class="op">,</span> ret<span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>            <span class="kw">return</span> <span class="cn">Some</span>(i)<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>    <span class="cn">None</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="kw">fn</span> search_in_parallel(n <span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>    <span class="kw">let</span> increment <span class="op">=</span> <span class="dt">u16</span><span class="pp">::</span><span class="cn">MAX</span> <span class="op">/</span> (n <span class="kw">as</span> <span class="dt">u16</span>)<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>    <span class="kw">let</span> <span class="kw">mut</span> threads <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(n <span class="kw">as</span> <span class="dt">usize</span>)<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>    <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0</span> <span class="op">..</span> n <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>        <span class="kw">let</span> range_start <span class="op">=</span> increment <span class="op">*</span> (i <span class="kw">as</span> <span class="dt">u16</span>)<span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>        <span class="kw">let</span> range_end   <span class="op">=</span> increment <span class="op">*</span> ((i <span class="kw">as</span> <span class="dt">u16</span>) <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>        threads<span class="op">.</span>push(<span class="pp">thread::Builder::</span>new()<span class="op">.</span>stack_size(<span class="dv">1000000000</span>)<span class="op">.</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>            search(range_start<span class="op">,</span> range_end)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>        <span class="op">}</span>)<span class="op">.</span>unwrap())<span class="op">;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>    <span class="kw">for</span> thread <span class="kw">in</span> threads <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>        thread<span class="op">.</span>join()<span class="op">;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a>    search_in_parallel(<span class="dv">8</span>)<span class="op">;</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This parallel search takes a couple of seconds until it prints:</p>
<pre><code>Found an answer: (6, 5) 25734</code></pre>
<p>So <code>25734</code> returns 6! This is the R8 value we were looking for.</p>
<p>I modify my VM to return when this function is called (I know it lives in address <code>6027</code> so I just check instruction pointer in the main loop) and drop to debugger prompt. In the debugger, I set R1 (return value register) 6, and set R8 25734, and continue running the program.</p>
<p>It works perfectly, with a working code printed to the screen!</p>
<h1 id="code-and-conclusion">Code and conclusion</h1>
<p>Overall I enjoyed this a lot. My favorite part was definitely debugging the verification function. I don’t really enjoy text adventures but that’s really a very small part of the challenge, so it wasn’t a big deal.</p>
<p><a href="https://github.com/osa1/synacor-challenge">My code is on Github</a>. I didn’t organize the code at all, so you can see my inline notes, logs, and commented out code with their improved/changed versions, and have a feeling of how I developed my solutions. In the repo you’ll also see the original binary and challenge spec. I pushed those in case the original challenge page disappears in the future.</p>
<p>The Rust compiler I used was <code>rustc 1.11.0-nightly (0554abac6 2016-06-10)</code>.</p>
<p>If you know similar challenges let me know in the comment section below. One challenge that looks similar is ICFP’06 programming contest <a href="http://www.boundvariable.org/">“The Cult of the Bound Variable”</a>, which I always wanted to solve but never really got a chance. Maybe I should try it next.</p>]]></summary>
</entry>
<entry>
    <title>Rust borrow checker woes</title>
    <link href="http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html" />
    <id>http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html</id>
    <published>2016-03-28T00:00:00Z</published>
    <updated>2016-03-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been doing some Rust hacking in my free time, and unfortunately while it’s way, way better than how it was when I first tried it (around 0.4 or 0.6 IIRC), it still has some problems that encourage redundant runtime operations or bad programming practices. In this post I’ll give three examples that are all caused by dumb borrow checker. As you’ll see, in all cases the cost is either bad programming practices or runtime costs (which is really ironic, given that one of the design goals of Rust is performance).</p>
<h1 id="no-local-reasoning-about-borrowing-rules-of-constructors">1. No local reasoning about borrowing rules of constructors</h1>
<p>It’s types that borrow, not values, and that makes sense. If you have an <code>Option&lt;&amp;'a T&gt;</code> where <code>'a</code> is coming from some other variable <code>x</code>, 1) <code>x</code> needs to live longer than this <code>Option</code> value 2) you can’t borrow <code>x</code> mutably while keeping the <code>Option</code> in scope (or the other way around, you can’t borrow <code>Option</code> mutably while keeping <code>x</code> in scope).</p>
<p>This makes sense because in compile time, given an <code>Option&lt;&amp;'a T&gt;</code>, you can’t make any assumptions on <code>Option</code>’s actual value. Since <code>Some</code> constructor of the <code>Option</code> type will borrow the <code>T</code> here, you just have to assume that values of this type always borrow <code>T</code> (and that’s why we have <code>&amp;'a</code> in the type).</p>
<p>The problem is that it’s sometimes possible to do some local reasoning, and not doing that is too restrictive. Suppose you have this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">struct</span> ListOfThings <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    list <span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Thing<span class="op">&gt;,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">struct</span> Thing <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    name <span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="co">// other fields here -- this is expensive to copy!</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">impl</span> Thing <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="kw">impl</span> ListOfThings <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> name <span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>        <span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>find_thing_mut(name) <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>            <span class="cn">None</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>                <span class="kw">self</span><span class="op">.</span>init_thing(name<span class="op">.</span>to_owned())<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>                <span class="kw">self</span><span class="op">.</span>do_something(name)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>            <span class="op">},</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>            <span class="cn">Some</span>(t) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>                t<span class="op">.</span>do_something()</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>            <span class="op">},</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    <span class="kw">fn</span> find_thing_mut<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> name <span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> Thing<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>iter_mut()<span class="op">.</span>find(<span class="op">|</span>t<span class="op">|</span> t<span class="op">.</span>name<span class="op">.</span>as_str() <span class="op">==</span> name)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    <span class="kw">fn</span> init_thing(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> name <span class="op">:</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>push(Thing <span class="op">{</span> name<span class="op">:</span> name <span class="op">}</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The important part is this expression:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>find_thing_mut(name) <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="cn">None</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>init_thing(name<span class="op">.</span>to_owned())<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>do_something(name)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="op">},</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="cn">Some</span>(t) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        t<span class="op">.</span>do_something()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>    <span class="op">},</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The error we get is:</p>
<pre><code>&lt;anon&gt;:18:17: 18:21 error: cannot borrow `*self` as mutable more than once at a time [E0499]
&lt;anon&gt;:18                 self.init_thing(name.to_owned());
                          ^~~~
&lt;anon&gt;:18:17: 18:21 help: see the detailed explanation for E0499
&lt;anon&gt;:16:15: 16:19 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:16         match self.find_thing_mut(name) {
                        ^~~~
&lt;anon&gt;:24:10: 24:10 note: previous borrow ends here
&lt;anon&gt;:16         match self.find_thing_mut(name) {
...
&lt;anon&gt;:24         }
                  ^
&lt;anon&gt;:19:17: 19:21 error: cannot borrow `*self` as mutable more than once at a time [E0499]
&lt;anon&gt;:19                 self.do_something(name)
                          ^~~~
&lt;anon&gt;:19:17: 19:21 help: see the detailed explanation for E0499
&lt;anon&gt;:16:15: 16:19 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:16         match self.find_thing_mut(name) {
                        ^~~~
&lt;anon&gt;:24:10: 24:10 note: previous borrow ends here
&lt;anon&gt;:16         match self.find_thing_mut(name) {
...
&lt;anon&gt;:24         }
                  ^</code></pre>
<p><code>find_thing_mut()</code> really needs to return a ref, because <code>Thing</code> is expensive to copy. The problem is since <code>None</code> has type <code>Option&lt;&amp;'a mut Thing&gt;</code> where <code>a</code> is the lifetime of <code>self</code>, we can’t call a <code>&amp;mut self</code> when that <code>None</code> is in scope. This is annoying and could be improved by doing some local reasoning. In our case, since we know that <code>None</code> can’t borrow anything (it doesn’t have any references), we could refine our information about currently borrwed values, and let this compile.</p>
<p>There are a couple of solutions. One half-solution is to use something like standard <a href="http://doc.rust-lang.org/nightly/std/collections/struct.HashMap.html#method.entry"><code>HashMap</code>’s <code>entry()</code></a>. Imagine doing something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">std::collections::hash_map::</span>HashMap<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">struct</span> ListOfThings <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    list <span class="op">:</span> HashMap<span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> Thing<span class="op">&gt;,</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="kw">struct</span> Thing <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    field1 <span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="co">// other fields here -- this is expensive to copy!</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="kw">impl</span> Thing <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="kw">impl</span> ListOfThings <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> name <span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>        <span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>get_mut(name) <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>            <span class="cn">None</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>                <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>insert(name<span class="op">.</span>to_owned()<span class="op">,</span> Thing <span class="op">{</span> field1<span class="op">:</span> <span class="dv">123</span> <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>            <span class="op">},</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>            <span class="cn">Some</span>(t) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>                t<span class="op">.</span>do_something()<span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>            <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The error we get:</p>
<pre><code>&lt;anon&gt;:20:17: 20:26 error: cannot borrow `self.list` as mutable more than once at a time [E0499]
&lt;anon&gt;:20                 self.list.insert(name.to_owned(), Thing { field1: 123 });
                          ^~~~~~~~~
&lt;anon&gt;:20:17: 20:26 help: see the detailed explanation for E0499
&lt;anon&gt;:18:15: 18:24 note: previous borrow of `self.list` occurs here; the
                          mutable borrow prevents subsequent moves, borrows, or
                          modification of `self.list` until the borrow ends
&lt;anon&gt;:18         match self.list.get_mut(name) {
                        ^~~~~~~~~
&lt;anon&gt;:25:10: 25:10 note: previous borrow ends here
&lt;anon&gt;:18         match self.list.get_mut(name) {
...
&lt;anon&gt;:25         }
                  ^</code></pre>
<p>This is exactly the same error we got before. The solution is to use <a href="http://doc.rust-lang.org/nightly/std/collections/struct.HashMap.html#method.entry">the <code>Entry</code> API</a>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">std::collections::hash_map::</span><span class="op">{</span>HashMap<span class="op">,</span> Entry<span class="op">};</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">struct</span> ListOfThings <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    list <span class="op">:</span> HashMap<span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> Thing<span class="op">&gt;,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="kw">struct</span> Thing <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    field1 <span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="co">// other fields here -- this is expensive to copy!</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a><span class="kw">impl</span> Thing <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a><span class="kw">impl</span> ListOfThings <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> name <span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        <span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>entry(name<span class="op">.</span>to_owned()) <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>            <span class="pp">Entry::</span>Vacant(ve) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>                ve<span class="op">.</span>insert(Thing <span class="op">{</span> field1<span class="op">:</span> <span class="dv">123</span> <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>            <span class="op">},</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>            <span class="pp">Entry::</span>Occupied(<span class="kw">mut</span> oe) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>                oe<span class="op">.</span>get_mut()<span class="op">.</span>do_something()<span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>            <span class="op">}</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Some things to note here:</p>
<ol type="1">
<li><p>We had to give ownership of the key to the lookup function (<code>HashMap::entry()</code>). This potentially means copying a value just to lookup. Ideally we’d only need to do this when inserting to the map. <code>HashMap::get()</code> doesn’t have this problem.</p></li>
<li><p>I said “half-solution” because this doesn’t really make the original code working. See how I removed a line in the first case in my <code>HashMap</code>-based implementation. If I change the first case to this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>        <span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>entry(name<span class="op">.</span>to_owned()) <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>            <span class="pp">Entry::</span>Vacant(ve) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>                ve<span class="op">.</span>insert(Thing <span class="op">{</span> field1<span class="op">:</span> <span class="dv">123</span> <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>                <span class="kw">self</span><span class="op">.</span>do_something(name)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>            <span class="op">},</span></span></code></pre></div>
<p>It’d still fail as <code>Entry</code> keeps a reference to <code>self</code>. Of course you could always do things like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>        <span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>list<span class="op">.</span>entry(name<span class="op">.</span>to_owned()) <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>            <span class="pp">Entry::</span>Vacant(ve) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>                <span class="kw">let</span> <span class="kw">mut</span> thing <span class="op">=</span> Thing <span class="op">{</span> field1 <span class="op">:</span> <span class="dv">123</span> <span class="op">};</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>                thing<span class="op">.</span>do_something()<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>                ve<span class="op">.</span>insert(thing)<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>            <span class="op">},</span></span></code></pre></div>
<p>Which works, but that’s quite different from our original program. Note that if we still had a method like <code>init_thing()</code> and has to pass <code>Entry</code> to that, it’d still fail with same error message. So yeah, not quite a solution.</p></li>
</ol>
<p>The solution I use is this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">impl</span> ListOfThings <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> name <span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>        <span class="kw">let</span> thing <span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;*</span><span class="kw">mut</span> Thing<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>find_thing_mut(name)<span class="op">.</span>map(<span class="op">|</span>t<span class="op">|</span> (t <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> _))<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="kw">match</span> thing <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>            <span class="cn">None</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>                <span class="kw">self</span><span class="op">.</span>init_thing(name<span class="op">.</span>to_owned())<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>                <span class="kw">self</span><span class="op">.</span>do_something(name)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>            <span class="op">},</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>            <span class="cn">Some</span>(t) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>                <span class="kw">unsafe</span> <span class="op">{</span> (<span class="op">*</span>t)<span class="op">.</span>do_something() <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>            <span class="op">},</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>(missing parts are the same as the original code),</p>
<p>I basically work around the borrow checker by using a raw pointer and an <code>unsafe</code> block, and hope that my <code>.map()</code> will be compiled as a no-op.</p>
<h1 id="references-to-self-in-method-values">2. References to self in method values</h1>
<p>A code like this fails if the method is mutable in self: <code>self.f(self.x)</code>. As a running example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">struct</span> Widget <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    pos_x <span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    pos_y <span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">impl</span> Widget <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>        <span class="kw">self</span><span class="op">.</span>draw_at(<span class="kw">self</span><span class="op">.</span>pos_x<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>pos_y)<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> draw_at(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> pos_x <span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> pos_y <span class="op">:</span> <span class="dt">i32</span>) <span class="op">{}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>These are the errors:</p>
<pre><code>&lt;anon&gt;:8:22: 8:32 error: cannot use `self.pos_x` because it was mutably borrowed [E0503]
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                              ^~~~~~~~~~
&lt;anon&gt;:8:9: 8:13 note: borrow of `*self` occurs here
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                 ^~~~
&lt;anon&gt;:8:34: 8:44 error: cannot use `self.pos_y` because it was mutably borrowed [E0503]
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                                          ^~~~~~~~~~
&lt;anon&gt;:8:9: 8:13 note: borrow of `*self` occurs here
&lt;anon&gt;:8         self.draw_at(self.pos_x, self.pos_y);
                 ^~~~</code></pre>
<p>Basically the method itself (<code>self.draw_at</code>) borrows <code>self</code> mutably, and since arguments are evaluated <em>after</em> the function in a function application, we get this borrow checker error. The solution is simple in this case:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">let</span> pos_x <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>pos_x<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">let</span> pos_y <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>pos_y<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="kw">self</span><span class="op">.</span>draw_at(pos_x<span class="op">,</span> pos_y)<span class="op">;</span></span></code></pre></div>
<h1 id="variables-that-live-across-loops">3. Variables that live across loops</h1>
<p>Suppose you have a loop that internally calls some <code>&amp;mut self</code> methods, and when it returns, it returns something with a reference to <code>&amp;self</code>. Something like:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">pub</span> <span class="kw">struct</span> TUI <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    field1<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="kw">pub</span> <span class="kw">enum</span> TUIRet<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    Abort<span class="op">,</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    KeyHandled<span class="op">,</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    Input(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">,</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="kw">impl</span> TUI <span class="op">{</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> idle_loop<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> TUIRet<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>        <span class="kw">loop</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>draw()<span class="op">;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>            <span class="kw">match</span> <span class="kw">self</span><span class="op">.</span>keypressed() <span class="op">{</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>                ret <span class="op">@</span> <span class="pp">TUIRet::</span>Abort <span class="op">=&gt;</span> <span class="op">{</span> <span class="kw">return</span> ret<span class="op">;</span> <span class="op">},</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>                ret <span class="op">@</span> <span class="pp">TUIRet::</span>Input(_) <span class="op">=&gt;</span> <span class="op">{</span> <span class="kw">return</span> ret<span class="op">;</span> <span class="op">},</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>                _ <span class="op">=&gt;</span> <span class="op">{},</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>            <span class="op">}</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> keypressed(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> TUIRet <span class="op">{</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>        <span class="pp">panic!</span>()</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{}</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Can you see what could go wrong here? Here’s the error:</p>
<pre><code>&lt;anon&gt;:18:13: 18:17 error: cannot borrow `*self` as immutable because it is also borrowed as mutable [E0502]
&lt;anon&gt;:18             self.draw();
                      ^~~~
&lt;anon&gt;:20:19: 20:23 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:20             match self.keypressed() {
                            ^~~~
&lt;anon&gt;:26:6: 26:6 note: previous borrow ends here
&lt;anon&gt;:16     pub fn idle_loop&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; TUIRet&lt;&#39;a&gt; {
...
&lt;anon&gt;:26     }
              ^
&lt;anon&gt;:20:19: 20:23 error: cannot borrow `*self` as mutable more than once at a time [E0499]
&lt;anon&gt;:20             match self.keypressed() {
                            ^~~~
&lt;anon&gt;:20:19: 20:23 help: see the detailed explanation for E0499
&lt;anon&gt;:20:19: 20:23 note: previous borrow of `*self` occurs here; the mutable
                          borrow prevents subsequent moves, borrows, or
                          modification of `*self` until the borrow ends
&lt;anon&gt;:20             match self.keypressed() {
                            ^~~~
&lt;anon&gt;:26:6: 26:6 note: previous borrow ends here
&lt;anon&gt;:16     pub fn idle_loop&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; TUIRet&lt;&#39;a&gt; {
...
&lt;anon&gt;:26     }
              ^</code></pre>
<p>This is probably the worst of all. The weird part is that this works:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>    <span class="kw">pub</span> <span class="kw">fn</span> idle_loop<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> TUIRet<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>        <span class="kw">loop</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>            <span class="kw">self</span><span class="op">.</span>draw()<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>            <span class="kw">return</span> <span class="kw">self</span><span class="op">.</span>keypressed()<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    <span class="op">}</span></span></code></pre></div>
<p>Only solution I could find here was to remove the references to <code>self</code>, by just copying the value to <code>Input</code>. This unfortunately means more redundant copying.</p>]]></summary>
</entry>

</feed>
