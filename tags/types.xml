<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged types</title>
    <link href="http://osa1.net/tags/types.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/types.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-06-13T00:00:00Z</updated>
    <entry>
    <title>Type checking with Prolog</title>
    <link href="http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html" />
    <id>http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html</id>
    <published>2013-06-13T00:00:00Z</published>
    <updated>2013-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There is a deep relation between a type inference system and a logic programming system. I don’t fully understand this relation. <a href="http://stackoverflow.com/questions/13899586/haskells-type-system-and-logic-programming-how-to-port-prolog-programs-to-typ">This question</a> I asked at StackOverflow a few months ago gives some tips, but doesn’t explain much.</p>
<p>I could finally spare some time and play with a type checker implementation in Prolog. What I had in mind before starting writing this code was that having a unification mechanism at hand should make type checking easier.</p>
<p>Indeed that is the case, as you’ll see shortly. Type inference is harder, and I also explain the reason and how could it be done.</p>
<hr />
<p>I will not formally define the type system here, but I think it can be seen as a simple Damas-Hindley-Milner style type system.</p>
<p>This implementation basically embeds type definitions in Prolog. This is what makes this implementation simple. You can always implement a fully-featured type system in Prolog just like you can do it in any other language. What I’m trying to show here that it’s very simple to do when there is a way to implement types as rules in Prolog.</p>
<p>Here’s knowledge base of types:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">nat(o)<span class="kw">.</span>
nat(s(<span class="dt">N</span>)) <span class="kw">:-</span> nat(<span class="dt">N</span>)<span class="kw">.</span>

bool(<span class="kw">true</span>)<span class="kw">.</span>
bool(<span class="kw">false</span>)<span class="kw">.</span>

type(<span class="dt">A</span><span class="kw">,</span> nat) <span class="kw">:-</span> nat(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span>
type(<span class="dt">A</span><span class="kw">,</span> bool) <span class="kw">:-</span> bool(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span>
type(id<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)) <span class="kw">:-</span> <span class="kw">!.</span>
type(add<span class="kw">,</span> arrow(nat<span class="kw">,</span> arrow(nat<span class="kw">,</span> nat))) <span class="kw">:-</span> <span class="kw">!.</span>
type(not<span class="kw">,</span> arrow(bool<span class="kw">,</span> bool)) <span class="kw">:-</span> <span class="kw">!.</span>
type(const<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> arrow(<span class="dt">_</span><span class="kw">,</span> <span class="dt">A</span>)))<span class="kw">.</span></code></pre>
<p>Implementing type definitions as rules in a Prolog system is what makes this implementation simple. Here <code>id</code> is a function with type <code>forall a. a -&gt; a</code>, <code>add</code> is <code>nat -&gt; nat</code>, <code>not</code> is <code>bool -&gt; bool</code>, and <code>const</code> is <code>forall a b. a -&gt; b -&gt; a</code>.</p>
<p>Type checking of function applications is also simple:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">R</span>))<span class="kw">,</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></code></pre>
<p>And we’re done. This much code is enough for type checking polymorphic functions. Here are some examples:</p>
<pre><code>?- type(app(id, false), T).
T = bool.

?- type(app(id, o), T).
T = nat.

?- type(app(add, o), T).
T = arrow(nat, nat).

?- type(app(app(add, o), s(o)), T).
T = nat.

?- type(app(app(add, o), false), T).
false.

?- type(app(app(const, false), o), T).
T = bool.

?- type(app(app(const, false), true), T).
T = bool.</code></pre>
<p>One major limitation of this implementation is that there is no way to implement monomorphic functions. To do this, we should somehow have two different kinds of Prolog variables, one for polymorphic variables and one for monomorphic ones.</p>
<p>Since there’s no way to directly express this in Prolog, I had to extend this code with a typing environment. In the implementation above, if parameter of a function is an atom and not a variable, then it’s looked in a global environment.</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">var</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% polymorphic parameter</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">,</span>
    <span class="dt">R</span> <span class="kw">=</span> <span class="dt">B</span><span class="kw">,</span>
    <span class="kw">!.</span>

type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span>
    get_type(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span>
    <span class="co">% type already exists in environment</span>
    <span class="kw">!,</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span>
    type_in_env(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span>
    <span class="kw">!.</span>

type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span>
    <span class="co">% type doesn&#39;t exist in environment</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span>
    add_type(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span>
    type_in_env(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span>
    <span class="kw">!.</span></code></pre>
<p>First rule is for polymorphic parameters, only difference from the first code is <code>var(A)</code>, which ensures the parameter type is a variable.</p>
<p>Second rule does a similar check, but this time to ensure the parameter is an atom and not a variable. After that, type of this parameter is looked from an environment and checked against it. The third rule is when a type is not found in the environment. In that case, a new type is added to the environment.</p>
<p>Note that first cut is required in second rule. Because otherwise, when a type checking fails, third rule would be executed and a new type would be added to the environment.</p>
<p>Here are environment operations:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">init_state(<span class="dt">Name</span>) <span class="kw">:-</span>
    empty_assoc(<span class="dt">A</span>)<span class="kw">,</span>
    nb_setval(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>

add_type(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span>
    nb_getval(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span>
    put_assoc(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">,</span>
    nb_setval(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">.</span>

get_type(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span>
    nb_getval(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span>
    get_assoc(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span>)<span class="kw">.</span></code></pre>
<p>Environment operations get a environment name to keep the state local. ie. you can be sure your state is local if name of the state is not used somewhere else :-)</p>
<p>This helper is used to get type of a term when term is an atom, and it’s type is available in environment. Otherwise it returns the term itself.</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type_in_env(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>) <span class="kw">:-</span> get_type(types<span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>)<span class="kw">.</span>
type_in_env(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span></code></pre>
<p>An example monomorphic function rule:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(mono_id<span class="kw">,</span> arrow(mono_id__a<span class="kw">,</span> mono_id__a)) <span class="kw">:-</span> <span class="kw">!.</span></code></pre>
<p>It should be guaranteed by the programmer that <code>mono_id__a</code> atom is only used for <code>mono_id</code> function.</p>
<p>Here are some examples for checking monomorphic functions(others work as before):</p>
<pre><code>?- init_state(types).
true.

?- type(app(mono_id, o), T).
T = nat.

?- type(app(mono_id, s(o)), T).
T = nat.

?- type(app(mono_id, false), T).
false.

?- init_state(types).
true.

?- type(app(mono_id, false), T).
T = bool.

?- type(app(mono_id, o), T).
false.</code></pre>
<p>This code should demonstrate how easy it’s to implement a type checker when there’s a way to express typing rules as Prolog rules. We had type checker for polymorphic and monomorphic functions in 57 lines of Prolog.</p>
<p>For type inference, we need to generate new rules in runtime. I’m looking for ways to do this. <code>assert/1</code> and <code>dynamic/1</code> predicates make this possible, but I still couldn’t find a way to generate fresh Prolog variables(like <code>gensym</code>, but for variables). I’ll update this post later.</p>]]></summary>
</entry>
<entry>
    <title>Implicit casts</title>
    <link href="http://osa1.net/posts/2013-05-25-implicit-casts.html" />
    <id>http://osa1.net/posts/2013-05-25-implicit-casts.html</id>
    <published>2013-05-25T00:00:00Z</published>
    <updated>2013-05-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote a C++ code like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> max_number_of_something = <span class="dv">-1</span>;
set&lt;some_type&gt; s;

...

<span class="kw">if</span> (s.size() &gt; max_number_of_something)
    max_number_of_something = s.size();</code></pre>
<p>The problem with this code is that this conditional will never be taken, and no errors will be raised either. This is because type of <code>s.size()</code> is unsigned and in the expression <code>s.size() &gt; max_number_of_something</code>, <code>max_number_of_something</code> will be casted to unsigned, implicitly. So <code>-1</code> is now <code>4294967295</code> and no other 32bit unsigned integer is bigger than that number.</p>
<p>Another reason to not to like weak typing and implicit type casts.</p>]]></summary>
</entry>
<entry>
    <title>On typing dynamic langs</title>
    <link href="http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html" />
    <id>http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html</id>
    <published>2013-04-19T00:00:00Z</published>
    <updated>2013-04-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://marijnhaverbeke.nl/blog/tern.html">This excellent post</a> on Tern’s internals reminded me of why I lost interest of my statically typed Lua project.</p>
<p>I lost my interest in a program exponentially with the amount of hacky solutions it involves.</p>
<p>I love Lua, it’s so simple but it is so powerful at the same time, without having any quirks most other dynamic languages have. But when it comes developing a type inference system for such a dynamic language, the result will have to contain a lot of hacks.</p>
<p>Here’s a quote from Tern post, which explains handling dynamically extending objects:</p>
<blockquote>
<p>And now we’re off into dodgy hack land. In order to meet this challenge, Tern uses a special treatment for for/in loops that appear to be copying properties. When it encounters them, it assumes that the properties from the source object will be copied to the target object. It ignores control flow (conditionals and such) and simply copies all properties.</p>
</blockquote>
<p>Similar situation is applied to Lua and this is where I dropped my project. Basically, there is no way to give a type to an object without actually running the program to the point where completion is needed. But even then you can’t have completely correct type information because for instance, you may have a different object in second iteration of loop but your type inference system would be only run it for one iteration. Still, I think running a program in an isolated environment to the point where enough type information is acquired is the best way to infer types in dynamic languages.</p>
<p>Accepting having a subset of Lua and forbidding object extensions in run-time is not a solution because then you can’t even use tables as, well, tables, rather than objects.</p>
<p>The obvious solution is creating a new syntax for defining objects. That syntax should be allowed only in top-level of a file, ie. you can’t use object definition syntax inside of a function.</p>
<p>But then a new language that is not Lua would be invented. I deliberately wanted to avoid this situation because in my opinion, it’s slightly missing the point of that kind of languages. I don’t like CoffeeScript’s additional compile step to my workflow. One nice property of dynamic languages is that we don’t have any visible intermediate steps between writing the source code and running it. All intermediate steps(parsing, compiling to some kind of byte-code, like Python does) are completely hidden to programmer.</p>
<p>Maybe the problem is that I’m looking for a perfect solution which does not exist in reality. I’m not sure how can I overcome this problem, I don’t want to work on programs full of hacks in my free time(well, I don’t want to work on this kind of programs in <em>any</em> time, but doing that as a hobby is more unbearable).</p>]]></summary>
</entry>
<entry>
    <title>Internship report - type inference, row polymorphism, and multi-stage programming</title>
    <link href="http://osa1.net/posts/2013-04-15-internship.report.html" />
    <id>http://osa1.net/posts/2013-04-15-internship.report.html</id>
    <published>2013-04-15T00:00:00Z</published>
    <updated>2013-04-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is the report of my 3.5-month internship fulfilled at <a href="http://ozyegin.edu.tr/">Ozyegin University</a> under <a href="http://faculty.ozyegin.edu.tr/aktemur/">Prof. Baris Aktemur</a>’s supervision.</p>
<p>I wrote this report as a short and informal introduction to the topics I worked on in my internship, and since I know nobody will ever read this internship report, I decided publishing it in my blog with hoping someone benefit from it.</p>
<p>A note before reading: Things went in an unexpected way shortly after I started writing the report: I got bored. So each chapter got shorter and shorter, leaving tons of interesting and important stuff unmentioned. Sorry for that.</p>
<h2 id="contents">Contents:</h2>
<ul>
<li>Introduction to type systems and polymorphism</li>
<li>Hindley-Damas-Milner type system and type inference</li>
<li>Row polymorphism</li>
<li>Multi-stage porgramming</li>
<li>Our work - extending multi-stage language with subtyping and Wallce: a module type inference system</li>
</ul>
<h1 id="introduction-to-type-systems-and-polymorphism">Introduction to type systems and polymorphism</h1>
<p>As far as software engineering concerned, a type system is a static analysis method that aims to prove a program ‘won’t go wrong’<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, meaning that the program will not crash at runtime. Static type checking can also be used for some compiler optimisations. Also, some languages have mechanisms for dispatching on types.</p>
<p>Type systems (in this text, this term is used as ‘static type systems’) do that by inspecting program terms and proving some properties and relations among them. This work is done before run-time, and most type information can be deleted so that it won’t cause any runtime costs.</p>
<p>For most type systems, process of type checking is ‘syntactic’. This means two things; first, the type checker only needs program text and it doesn’t need any information that can only be obtained at run-time. And second, type checking a program term only depends on type checking subterms of that program. These two properties also give us a somewhat simple way to express type checking on terms in a symbolic and formal way.</p>
<p>Type systems are ‘conservative’, meaning they will reject some ‘correct’ programs. A correct program means a program that won’t crash at runtime. For instance, this program(in OCaml syntax):</p>
<pre><code>if true then 1 else 42(5)</code></pre>
<p>is actually correct, and it can be given the type <code>int</code> (since we know it always evaluates to <code>1</code>, which has type <code>int</code>), but almost all type systems reject this program because of the ‘else’ branch expression <code>42(5)</code> that is ill-typed.</p>
<p>Research on type systems aims to have more “powerful” type systems. Being more powerful means accepting <em>more</em> correct programs and also being able to encode more <em>invariants</em> in the type system, so that more <em>incorrect</em> programs will be rejected.</p>
<p>Being wrong and being incorrect is used with different meanings in this text: a wrong program will crash at run-time, but incorrect program will result with a wrong answer. For instance, a wrong implemented algorithm may not be <em>wrong</em>, but it’s <em>incorrect</em>. So it will work fine, but return a wrong result.</p>
<p>As an instance of accepting more correct programs, this code is not typeable under simply-typed lambda calculus:</p>
<pre><code>let id a = a in
(id 1, id true)</code></pre>
<p>But it’s well-typed in polymorphic lambda calculus. As a second example, this is not typeable under polymorphic lambda calculus:</p>
<pre><code>add5 : float -&gt; float
...
add5 10</code></pre>
<p>Here <code>10</code> has type <code>int</code>, so we can’t apply it to a function that expects a float value. Type systems with subtyping overcome this problem by defining a common supertype of types. In our case, <code>float</code> is already a supertype of <code>int</code>, so this example is well-typed in the presence of subtyping.</p>
<p>As an example of being able to encode more <em>invariants</em> in the type system, let’s look to the type of a sort function from a dependently-typed programming language:<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<pre><code>sort : List Int -&gt; List Int</code></pre>
<p>This type can be inhabited with some wrong functions. For instance, a function that takes a list and returns an empty list will have this type, just like <em>reverse</em> and <em>shuffle</em> functions.</p>
<pre><code>sort : Vect Int n -&gt; Vect Int n</code></pre>
<p>This type has a invariant encoded in it: length of it’s input and output should be equal. This means our first function that takes a list and returns an empty list now can’t be inhabited by this type. We have a more precise type.</p>
<pre><code>sort : (xs : Vect Int n) -&gt;
       (ys : Vect Int n ** Permutation xs ys)</code></pre>
<p>This type is even more precise, a function that takes a list and returns a list with some random elements can’t get this type.</p>
<p>One problem with more expressive type systems is that there may be some types that can’t be inferred by type system, but the type can be given by programmer. In some cases the type system may not be able to prove that an expresion has the denoted type. In case of dependently typed languages, programmer is required to give some proofs to the type checker. But even in much simpler type systems programmer may have to give some types manually.</p>
<p>–</p>
<p>A word about the terms ‘polymorphism’ and ‘subtyping’: Polymorphic type systems can give multiple types to a single piece of code, thus providing reuse. This is done by giving the code a general type and then creating instances of type depending on the use. As an example, let us start with a simple OCaml function, <code>fst</code>.</p>
<p><code>fst</code> returns first element of any pair, it has the type <code>('a * 'b) -&gt; 'a</code> (the language of types is described in next section). This means for any pair with type of <code>('a * 'b)</code>, <code>fst</code> will return value with type of <code>'a'</code>. When applied on a value typed <code>(bool * int)</code> it will return <code>bool</code>, and when applied on a value typed <code>( (string * bool) * string )</code> it will return <code>(string * bool)</code> etc.</p>
<p>Subtyping defines a relationship that if a type <code>t1</code> is subtype of a type <code>t2</code>, this means that <code>t1</code> can be given to context where <code>t2</code> is expected. This usually means <code>t1</code> already has all properties of <code>t2</code>.</p>
<p>For instance, a record with fields <code>a: int, b: bool</code> can be passed to a function that expects a parameter typed <code>{a: int}</code>. The same effect can also be obtained by row polymorphism, which we’ll see in it’s own chapter.</p>
<p>Subtyping is generally divided into two branches; nominal and structural subtyping. Structural subtyping relation is syntactic, ie. type system can decide if one type is subtype of another type just by inspecting their forms (like in the example above). Nominal subtyping requires definition from the programmer or a pre-defined type lattice from the language designer, ie. there is no way for a type system to infer subtyping relation between int and float types if this relation is not built-in; similarly a Square is not a subtype of Shape unless the programmer manually defines this subtyping relation.</p>
<h1 id="hindley-damas-milner-type-system-and-type-inference">Hindley-Damas-Milner type system and type inference</h1>
<p>Manually giving types to program terms may be impractical, since programs can contain hundreds of definitions. Type inference is the process of deriving types for program terms. As an example of language with type inference, OCaml programs with no type annotations can be type-inferred and checked. This results in more concise programs. Type annotations can still be given for documentation or error reporting purposes.</p>
<p>Hindley-Damas-Milner(abbreviated as HM henceforth) type system is likely to be the most widely-used type system. It has a great property that if a term is typeable under HM type system, HM inference algorithm will result with a most general type (also called ‘principal type’).</p>
<p>HM is the system lies behind statically typed functional languages like the ML family of languages and Haskell.</p>
<p>In HM, a polymorphic type is specified as a ‘type scheme’. A type scheme is a type with universally quantified type variables. Type system’s job then is to give terms of a program type schemes so that for each instantiation of the scheme, the result is well-typed.</p>
<p>HM type system produces polymorphic types (type schemes) only for some expressions, in the case of ML family of languages, it’s the <code>let</code> expression. A <code>let</code> expression binds a name to an expression and introduces a scope that the name is bound to the expression. HM type system gives a most general type to that name, and so every use of this name in the scope is valid if a valid instantiation of the required type can be obtained from the type scheme it’s given.</p>
<pre><code>let id a = a in
(id 1, id true)</code></pre>
<p>Here the <code>id</code> function is given the type scheme of <code>forall a. a -&gt; a</code>. The variable <code>a</code> is called to be ‘universally quantified’. In <code>id 1</code>, <code>id</code>s type is instantiated from type scheme as <code>int -&gt; int</code> by substituting <code>a</code> with <code>int</code>. Same operation is done in <code>id true</code> and <code>id</code> is given the type <code>bool -&gt; bool</code>. So this term is well-typed under HM.</p>
<p>Inferring a type scheme is done by assigning fresh type variables to terms with unknown types and unifying this variables with concrete types while type checking rest of the term. At the end, types that are not unified with concrete types will remain polymorphic.</p>
<p>This is also called let-polymorphism because polymorphic type (type scheme) generation is only done in let expressions.</p>
<p>Note that not all names defined in a let expression can be generalized. As an example, see this classic example:</p>
<pre><code>let c = ref (fun x -&gt; x) in
c := (fun x -&gt; x+1);
!c true</code></pre>
<p>Giving <code>c</code> the type <code>forall a. ('a -&gt; 'a) ref</code> (in OCaml syntax) makes this example well-typed, which is wrong. Instead, type system should have given the type <code>( '_a -&gt; '_a) ref</code>, then during the type checking <code>c := (fun x -&gt; x + 1)</code>, <code>_a</code> should be unified with <code>int</code>. Note that since <code>('_a -&gt; '_a) ref</code> doesn’t quantify the variable <code>a</code>, after this point, type of <code>c</code> will be <code>(int -&gt; int_ ref</code>, so applying it a bool value will fail.</p>
<p>Let-polymorphism has some interesting properties. It’s simple, but it still accepts realistic programs. And even though its worst-case efficiency is exponential on the size of input program, most realistic programs don’t hit the worst case and have linear time complexity. For this reason, let-polymorphism is named as the ‘sweet-spot’ of type systems.</p>
<p>Another great property of HM type system is that it can be reduced to constraint generation and solving steps. These separate steps lead to a more modular algorithm, with changeable constraint generators and solvers. HM(X)<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> is a formalization of this observation.</p>
<h1 id="row-polymorphism">Row polymorphism</h1>
<p>Rows are a way to encode ‘labeled products’. A product type is a type that contains some other types; for example, a pair is a product type of two other types (<code>(int * bool)</code> is a product type with <code>int</code> and <code>bool</code> parts).</p>
<p>A ‘labeled sum’ is a product type, but with labels. For instance:</p>
<pre><code>type error = { code : int; reason : string }</code></pre>
<p>is just like an <code>(int * string)</code> type, but it has labels for subparts. There are severals ways to encode labeled products as rows. Here’s one way:</p>
<pre><code>type error = { code : abs int; reason : abs int; rho[code,int] }</code></pre>
<p>This syntax is similar to Rémy’s, which was also used in our project. Last <code>rho</code> is the polymorphic part, it means that an error type is a row type with <code>code</code> and <code>reason</code> fields with gives types, but with a polymorphic part that can be unified with any record except the fields labeled with <code>code</code> or <code>int</code> (some systems accept field repetition, like in Daan Leijen’s “Extensible records with scoped labels”).</p>
<p>Row polymorphism gives us a subtyping-like effect. For example, this function:</p>
<pre><code>fun x -&gt; x.a + 1</code></pre>
<p>Now has the type <code>{ a : int; rho[a] } -&gt; int</code> and we can apply it to the record <code>{ x : some_type; y : some_other_type; a : int; ... }</code>, like in structural subtyping.</p>
<p>The way row polymorphism and structural subtyping accept this term are completely different though. In row polymorphism, parameter type <code>{a : int; rho[a] }</code> is being unified with <code>{ x : some_type; y : some_other_type; a : int; ... }</code>, so parameter type of function is actually getting more specialized. On the other hand, in subtyping, extra fields of actual parameter is being forgotten, like casting a type to it’s super type.</p>
<p>More words will be said about row polymorphism in later sections.</p>
<h1 id="multi-stage-programming">Multi-stage programming</h1>
<p>Multi-stage programming languages makes distinguished evaluation stages in run-time. Some part of the program can be generated depending on some user input.</p>
<p>Evaluation is done at stage 0. A program generated in staged 0 has stage 1, program generated in stage 1 has stage 2 etc. This notion of separate stages has some semantic effects. Each stage has a scope, but most systems offer a mechanism to lift a value from a lower stage.</p>
<p>Being able to generate code in run-time gives us a way to specialize algorithms depending on user input. Let’s look at a classic example:</p>
<pre><code>let rec pow_body_gen n =
  if n = 0 then &lt;1&gt;
  else &lt;a * ~(pow_body_gen (n-1))&gt;;;</code></pre>
<p><code>pow_body_gen</code> takes an integer <code>n</code> and returns the code <code>a * a * a * ... * 1</code>, a to the power of n. With the help of this function, we can generate a specialized function <code>power_five</code> which raises an integer to the power 5, but without running a loop or recursively calling a function:</p>
<pre><code>let rec power_five a = &lt;let a = ~lift(a) in ~(pow_body_gen 5)&gt;;;</code></pre>
<p>For example, output of <code>power_five 12</code> in our interpreter is <code>&lt;let a = 12 in (a * (a * (a * (a * (a * 1)))))&gt;</code>. This is a code value. Notice the <code>a</code> value, which is multiplied by itself, 5 times.</p>
<p>To actually run this code, we can call <code>run</code>(stage primitives will be explained shortly):</p>
<pre><code>&gt; run(power_five 12);;
248832</code></pre>
<p>Our multi-stage language has three primitives for staging operations: angle brackets indicate a staged expression, contents of staged expression will be run in stage <code>n+1</code>, where n is the current stage level. Tilde (~) ‘unboxes’ a staged expression, expressions indicated with a unboxing operator will be run in stage <code>n-1</code>. Unboxing operator can only be used in stages n &gt; 0. Finally, <code>run</code> primitive is used to run a closed code value at stage 0.</p>
<p>Note that code values can be open, but only closed code values can be run. Our <code>pow_body_gen</code> function returns a code value with an unbound variable <code>a</code>, then in <code>power_five</code>, we define <code>a</code> in stage 1, and by unboxing <code>pow_body_gen 5</code>, we actually generate a bigger code value, with <code>a</code> defined. Now our code value is closed, so it can be run.</p>
<p>There is also a relation between multi-stage programming and partial evaluation, but this is out of this text’s scope.</p>
<h1 id="our-work">Our work</h1>
<p>Wallace is a type inference library, supporting subtyping. “Its goal is to serve as a plug-in component in the design of a constraint-based type-checker, regardless of the programming language being analyzed.”<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>We used Wallace to get subtyping in our language. Wallace comes with an example language, called ‘toy’, which has extensible records built-in. For simplicity, instead of generating constraints for Wallace, we first translated our multi-stage language to record calculus. Translation to record calculus preserves semantics, but eliminates staged computations<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. Our record calculus is then translated to ‘toy’. ‘toy’ infers types for us, by generating and passing constraints to Wallace.</p>
<p>We then compared our type system with<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. This expression:</p>
<pre><code>run((fun c -&gt; &lt;(let x = 1 in ~c, let y = 1 in ~c)&gt;) &lt;1&gt;);;</code></pre>
<p>is not typeable under polymorphic type system, but is well-typed in our system with subtyping. By mapping the calculated type back to our multi-stage language, we got subtyping in the multi-stage language for free.</p>
<p>Wallace is used as is, without any modifications. But we changed ‘toy’ language for our purposes. We first added some numerical types with subtyping relations. ‘toy’ had a problem that it was generalizing every let bindings, without value restriction. To overcome this problem, we added an extra lambda wrapper in the translator when value restriction is needed. Since our type system already had value restriction, it was trivial to apply the same test to check if an expression is expansive. Expansive expressions are those that may allocate new memory cells. Expansive expressions are not generalized.</p>
<p>Another problem with ‘toy’ language is that it doesn’t support toplevel declarations, and adding that wasn’t easy. To overcome this without any serious modifications in ‘toy’s source, we collected all well-typed toplevel expressions and declarations, and then generated a <code>let .. in ..</code> chain of toplevel declarations to give ’toy’ type checker. This means for every new toplevel phrase, ‘toy’ now type checks all old expressions too. This may not be efficient but works fine with our purposes, and it was easy to implement.</p>
<p>Implementing type inference: Implementing a type inference system is hard to do elegantly. One problem is already discussed in my blog (in Turkish)<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>. Every non-trivial type system requires types to be separated into kinds. After that, every type variable will also have kind information and it’s a type error to unify a type variable with wrong kinds. Type applications also checked with the help of kinds.</p>
<p>Kinds are generally checked at run-time. Type systems with kinds usually lead to a simpler type language. For instance, almost all types mentioned in this text can be represented by this simply type language (code taken from <a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>) :</p>
<pre><code>type kind =
  | KStar                 (* kind of term types *)
  | KRow                  (* kind of row types *)
  | KArr of (kind * kind) (* kind of type constructors *)

type ty =
  | TCon of tycon     (* constant *)
  | TVar of tyvar     (* type variable *)
  | TApp of (ty * ty)
      (* type application, to be well-typed
         kind of first ty should be KArr (k2, k)
         and second ty should be k2 *)
and tyvar = (tyvarlink ref * kind)
and tyvarlink =
  | NoLink of id (* just a type variable *)
  | LinkTo of ty (* equated to a ty *)
and tycon = (id * kind) (* kind should be always KStar *)</code></pre>
<p>We decided to take a different path, instead of keeping kind information for every type, we created new type constructors for every type and then separating differently kinded type variables with different types. This lead us to this type language:</p>
<pre><code>type ty =
 | TInt
 | TBool
 | TUnit

 | TPair of ty * ty

 | TList of ty
 | TRef  of ty

 | TFun of ty * ty
 | TRec of tyrec
 | TVar of typevar

 | TBox of tyrec * ty

...

and typevar = (tyvarlink * int) ref
and tyvarlink = ty link

and fieldvar = (fieldvarlink * int) ref
and fieldvarlink = field link

and recvar = (recvarlink * int * IdSet.t) ref
and recvarlink = tyrec link</code></pre>
<p>We also needed a sum type for handling differently kinded type variables:</p>
<pre><code>and linkvar =
 | TV of typevar
 | FV of fieldvar
 | RV of recvar</code></pre>
<p>This also made our algorithms more complex, since we had more cases to handle.</p>
<p>This representation is not without any advantages though. For instance, writing a pretty-printer was very easy, because we could easily print a pair and a function or a list and a ref differently, even though they share similar structure, with simple pattern matching.</p>
<p>A note on pretty-printing: OCaml has a great pretty-printer library in stdlib. It’s simple but powerful at the same time, allowing printing most complex structures easily. It interprets some characters in input strings as boxes/spaces indicators etc. and formats the text. For instance, this code:</p>
<pre><code>printf &quot;@[&lt;hov 2&gt;~(&quot;; print_exp exp; printf &quot;)@]&quot;</code></pre>
<p>Here <code>@[&lt;hov 2&gt;</code> part creates a new “horizontal or vertical” box. This box has a property that when a line is split to two lines, every other newline pointers will also be split into separate lines. So contents of this box is either displayed as a single line, or separated from every newline pointers. Later, <code>print_exp exp;</code> part prints the expression inside the box. And lastly, `printf “)@]” closes the paren, then closes the box, so that the text comes later will not be bound with this line split rule.</p>
<p>This gives an easy and concise way to print even most complex structures.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A Theory of Type Polymorphism in Programming – Robin Milner<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Code examples taken from <a href="http://vimeo.com/61576198">Dependently Typed Functional Programming with Idris</a> course slides.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.73.3971">Notes on HM(X)</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://gallium.inria.fr/~fpottier/wallace/">Wallace</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Choi, Aktemur, Yi, Tatsuta: Static Analysis of Multi-Staged Programs via Unstaging Translation<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Kim, Yi, Calcagno: A Polymorphic Modal Type System for List-Like Multi-Staged Languages<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>http://osa1.net/rowlar-kindlar/<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>http://osa1.net/rowlar-kindlar/<a href="#fnref8">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Rowlar, kindlar ve tip çıkarımı hakkında öylesine bir yazı</title>
    <link href="http://osa1.net/posts/2013-02-15-rowlar-kindlar.html" />
    <id>http://osa1.net/posts/2013-02-15-rowlar-kindlar.html</id>
    <published>2013-02-15T00:00:00Z</published>
    <updated>2013-02-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı birkaç gün önce attığım bir mail aslında. Acele ile yazılmış bir yazı olmasına rağmen epey uzun oldu ve maili yazmaya başlamadan önce kafamda karmaşık bir şekilde duran bazı fikirleri toparlamamda yardımcı oldu. Pek kimsenin işine yarayacağını tahmin etmesem de, yine de buraya koyuyorum. Küçük bazı düzenlemeler yaptım. Eklemeler ise yazının en altına yazıldı. Kodlar OCaml dilinde yazıldı.</p>
<hr />
<p>Üzerinde çalıştığım dilin tip sistemi hakkında<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ty =
  | ...
  | <span class="dt">TRow</span> <span class="kw">of</span> tyrow
  | ...

<span class="kw">type</span> fieldty =
  | <span class="dt">Pre</span> ty
  | <span class="dt">Btm</span> <span class="co">(* Abs ismi lambda abstractionlarda kullanildi *)</span>

<span class="kw">type</span> tyrow =
  | <span class="dt">EmptyRow</span>
  | <span class="dt">Row</span> (id * ty * ..<span class="fl">1.</span>.)
  | ..<span class="fl">2.</span>.</code></pre>
<p>1 ve 2 boşluklarını doldurmamız gerekiyor. Sorunlar şunlar:</p>
<p>1 kısmına yazdığımız tip, sadece yine kendi tipiyle(yani <code>TRow</code> ile) unify etmek zorunda(ilk bakışta <code>tyrow</code> yazmak mantıklı gibi geliyor ama bu yüzden değil).</p>
<p>2 kısmına yazdığımız constructor polymorphic row’u temsil edecek. Burada ben ilk başta aslında row değişkenlerini tamamen yok sayıp, recordlar extensible mı değil mi diye bir boolean flag tutayım demiştim. Fakat sorun, recordlar rowları paylaşabiliyorlar, örneğin şöyle bir fonksiyonda <code>\r -&gt; r.x = 10</code> tip <code>{r/x} -&gt; {x:int|r/x}</code> oluyor, başka bir yerde bu <code>r</code> kullanılabilir(parametre olarak verilen record başka yerlerde kullanıldığında fonksiyonun dönüş değeri olan recordın row değişkeni ile aynı row değişkenine sahip birden fazla record oluyor). Dolayısıyla bir değişken olmak zorunda.</p>
<p>Fakat bu <code>typevar</code> tipinde olamaz, çünkü <code>typevar</code> bir <code>ty</code> ile unify edilebiliyor. Rowlarda ise <code>tyrow</code> ile unify etmek istiyoruz. Ayrı bir tip gerekiyor yani.</p>
<p>Temel olarak row variable ile normal variable tamamen aynı olmalı, tek farkla, row değişkenler sadece row değişkenlerle/değerler ile unify edecek, variablelar da aynı şekilde.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<h2 id="neden-tip-seviyesinde-kindlara-ihtiyaç-var">Neden tip seviyesinde kindlara ihtiyaç var ?</h2>
<p>Type schemeler row değişkenler de tutabilir. <code>let</code> ile bir fonksiyon tanımladım, fonksiyon tipindeki free type variableları generalize ederek(terimler teminoloji ile uyumlu olsun diye ingilizce kullanıldı) bu fonksiyon polymorphic hale getiriliyor ve tipi <code>TypeScheme</code> olarak tutuluyor, quantified değişkenler belirtiliyor.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<p>Daha sonra bu fonksiyon kullanıldığında instantiate ediliyor. Burada instantiate edilen quantified değişkenler yerine ancak kendi kindlarında tiplerin konulması bir şekilde sağlanmalı.</p>
<p>Yani şunu demeye çalışıyorum, elimde bir row variable varsa, bu ancak bir row tipi ile yer değiştirebilir(yerine ancak row tipi yazılabilir). Bunu implementasyon sırasında tip sistemi ile garanti etmek gerçekten zor. İnsanlar bu yüzden kind sistemi kullanıyorlar sanırım.</p>
<p>Kind kullanırsam şöyle oluyor, her tipe bir kind veriyorum. Özet geçmek gerekirse, mesela TVar bir type değişkeni tutuyordu, şimdi bir de kind tutacak. Kindlar ise dilimde kaç tip -birbirlerinden farklı- type varsa, o kadar olacak. Örneğin <code>Star</code> int, bool gibi tipler için kullanılırken, <code>Row</code> row tipleri için kullanılır. Bu sayede bir değişkenim Row kindında ise, quantified edilse de instantiate edilse de bu bilgi taşınır ve en son yerine yazılacağında kind kontrol edilir. Tüm yerine yazmalar <code>kind-preserving</code> olmalıdır.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>Bu sayede farklı kindlarda type variablelar için aynı fonksiyonları kullanabilirim, sürekli kind bilgisini de taşırım. En son substitution veya unification yaparken, kindların korunup korunmadığını kontrol ederim ve normal type değişkeni yerine row type yazılmamasını sağlarım veya unification sırasında hata alırım.</p>
<p>–</p>
<p>Kindlarla beraber tipleri şu şekilde tanımlayabiliyoruz(yaklaşık olarak, henüz programı yazmadım)</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> kind =
  | <span class="dt">KStar</span>                 <span class="co">(* kind of term types *)</span>
  | <span class="dt">KRow</span>                  <span class="co">(* kind of row types *)</span>
  | <span class="dt">KArr</span> <span class="kw">of</span> (kind * kind) <span class="co">(* kind of type constructors *)</span>

<span class="kw">type</span> ty =
  | <span class="dt">TCon</span> <span class="kw">of</span> tycon     <span class="co">(* constant *)</span>
  | <span class="dt">TVar</span> <span class="kw">of</span> tyvar     <span class="co">(* type variable *)</span>
  | <span class="dt">TApp</span> <span class="kw">of</span> (ty * ty)
      <span class="co">(* type application, to be well-typed</span>
<span class="co">         kind of first ty should be KArr (k2, k)</span>
<span class="co">         and second ty should be k2 *)</span>
<span class="kw">and</span> tyvar = (tyvarlink <span class="dt">ref</span> * kind)
<span class="kw">and</span> tyvarlink =
  | <span class="dt">NoLink</span> <span class="kw">of</span> id <span class="co">(* just a type variable *)</span>
  | <span class="dt">LinkTo</span> <span class="kw">of</span> ty <span class="co">(* equated to a ty *)</span>
<span class="kw">and</span> tycon = (id * kind) <span class="co">(* kind should be always KStar *)</span>

<span class="kw">let</span> t_int        = <span class="dt">TCon</span> (<span class="st">&quot;int&quot;</span>,  <span class="dt">KStar</span>)
<span class="kw">let</span> t_bool       = <span class="dt">TCon</span> (<span class="st">&quot;bool&quot;</span>, <span class="dt">KStar</span>)
<span class="kw">let</span> t_unit       = <span class="dt">TCon</span> (<span class="st">&quot;unit&quot;</span>, <span class="dt">KStar</span>)
<span class="kw">let</span> t_list       = <span class="dt">TCon</span> (<span class="st">&quot;[]&quot;</span>,   <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>))
<span class="kw">let</span> t_ref        = <span class="dt">TCon</span> (<span class="st">&quot;ref&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>))
<span class="kw">let</span> t_arr        = <span class="dt">TCon</span> (<span class="st">&quot;-&gt;&quot;</span>,   <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>)))
<span class="kw">let</span> t_empty_row  = <span class="dt">TCon</span> (<span class="st">&quot;&lt;|&gt;&quot;</span>,  <span class="dt">KRow</span>)
<span class="kw">let</span> t_row_ext    = <span class="dt">TCon</span> (<span class="st">&quot;&lt;+&gt;&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KArr</span> (<span class="dt">KRow</span>, <span class="dt">KRow</span>)))
<span class="kw">let</span> t_rec_const  = <span class="dt">TCon</span> (<span class="st">&quot;{_}&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KRow</span>, <span class="dt">KStar</span>))

<span class="co">(* type of {r1} *)</span>
<span class="kw">let</span> rp1 = <span class="dt">TApp</span> (t_rec_const, <span class="dt">TVar</span> (<span class="dt">ref</span> (<span class="dt">NoLink</span> <span class="st">&quot;r1&quot;</span>), <span class="dt">KRow</span>))

<span class="co">(* type of {r1} -&gt; {_:int|r1} *)</span>
<span class="kw">let</span> f   = <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_arr, rp1), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_row_ext, t_int), rp1))</code></pre>
<p>En sonraki iki tanım örnek olsun diyeydi.</p>
<p>Karmaşık olduğunun farkındayım ama 1) bu tip sistemi implementasyonları için standard yol gibi geldi bana(çok fazla makalede kind sistemlerinden bahsediliyor) 2) diğer türlü de daha az karmaşık değil gibi.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<p>Burda mesela <code>TApp</code> oluşturan bir yardımcı fonksiyon oluştururuz ve kindları kontrol eder, uyumlu mu diye, bir miktar daha kolaylaşır. Yardımcı fonksiyonlarla işi kolaylaştırabiliriz diye düşünüyorum yani.</p>
<p>Bu örnekde <code>rp1</code> yerine mesela <code>{a:bool}</code> (yani <code>TApp (TApp (t_rec_ext, bool_ty), t_empty_row)</code>) yazarsak:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">TApp</span> (<span class="dt">TApp</span> (t_arr, rp1), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_row_ext, t_int), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_rec_ext, bool_ty), t_empty_row)))</code></pre>
<p>Bana gayet temiz bir şekilde <code>{x:int, a:bool}</code> elde ettik gibi geliyor ve tek yaptığımız yerine yazmak oldu. ( bu sunumda labelların atlandığının farkındayım, tam olarak labelları nasıl bu sisteme entegre ederim düşünmedim )</p>
<p>Diğer türlü yapılamaz mı, tabii ki yapılabilir ve ben zaten çok yaklaşmıştım. Fakat çirkin olmayan bir yolu yok. Kod içerisinde şöyle kısımlar olmak <em>zorunda</em> gibi: “implementasyonum doğru olduğuna göre bu type variable record ile unify edilmiş olacak, exhaustive olmayan pattern matching yap”. Mesela tüm row değişkenler bir record’a unify edilimş olacak, ben pattern matching ile fieldları alacağım kendi recordıma ekleyeceğim vs.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Ama kindler ile yaptığımda bu gibi durumlar olmayacak, ben <code>TApp</code>’lar ile typelar oluşturacağım, kind preserving substitutionlar, generalizationlar, instantiationlar yapılacağından, her zaman row tiplerim well-formed olmuş olacak ben hiçbir kontrol yapmadan <code>TApp</code>’ler oluşturmaya başlayacağım.</p>
<p>Ben bugün akşam birkaç makale daha inceleyeceğim: Type Inference for Records in a Natural Extension of ML (Didier Rémy) ve A Polymorphic Type System for Extensible Records and Variants (Mark P. Jones, Benedict R. Gaster). Bir de Typing Haskell in Haskell (Mark P. Jones)’a baktım, Haskell’da burada konuştuğumuz anlamda recordlar yok, ama kind sisteminden bahsederken “row kindlar da kolayca eklenebilir” diyerek sanırım yukarıda yaptığım şeyi kastetmekte.</p>
<p>Bu nasıl olabiliyor anlayabilmiş değilim ama gerçekten internette hiç örnek implementasyon yok. Bu yüzden ben bir tane yazacağım blog yazısı olarak. Polymorphic recordlara sahip bir dil inceleyeyim dedim, bir tanesi <a href="http://elm-lang.org/">Elm</a> adlı bir dil, kaynağı Haskell ile yazılmış temel olarak “Scoped Labels” makalesini kullanmış, ama kod berbat bir durumda. Çok çok karmaşık, kod stili berbat(type annotationlarını atlamış, Haskell’da bunu hiçbir zaman yapmayız, derleyici uyarı verir, annotationlar OCaml’daki gibi kodun içine yazılmaz, ayrı bir satıra yazılır ve anlaşılabilmeye çok katkı sağlarlar) vs. Yine de okunacak olursa en mantıklısı bu.</p>
<p>İkincisi <a href="http://www.pllab.riec.tohoku.ac.jp/smlsharp/">SML#</a>. Bu da ne yazık ki SML üzerine implement edilmiş ve kaynak kodu devasa. Tüm SML kodunu incelemek gerekecek yani(aradım bulamadım alakalı kısımları).<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Özetle, row polymorphism’e sahip, multi-staged bir dil. Buradaki veri yapısı dilin tip sistemini ifade ediyor. Row tiplerine dikkat. Row polymorphism’de fieldlar üzerinde bazı kısıtlar tanımlamanın birkaç yolu var. Bir yol, benim burada yaptığım ve <a href="http://gallium.inria.fr/~remy/publications.html">D. Rémy</a>’nin “Type inference for records in a natural extension of ML” ve başka makalelerinde gösterdiği gibi, field tiplerinde bir çeşit “flag” tutmak. Makalelerde Abs/Pre diye geçer, benim kodumda Pre/Btm. Bu yolun bu işi yapmak en bariz yol olduğunu söyleyebiliriz belki. Fakat kesinlikle en kolay/güzel yötem değil. Alternatif olarak kısıtlar constraint seviyesinde, kind seviyesinde veya başka bazı seviyelerde tanımlanabiliyor.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Burada anlatmaya çalıştığım problem bana çok vakit kaybettirdi ve aslında pek çok kişiye tanıdık gelebilir. Kısaca yapmaya çalıştığım şey, bazı şeyleri statik olarak garanti etmek için tip sistemini kullanmaya çalışmak. Örneğin bir programlama dilinde syntax ağacını well-formed olmayan programları ifade edebilmesini engelleyecek şekilde oluşturmak gibi. Bu gibi durumlarda eğer yeterince güçlü tip sisteminiz yoksa(örnek: GADTler yardımcı olabiliyor) işiniz çok zorlaşabiliyor. Daha kolay bir yöntemi runtime’da bunu garantilemek. Hemen sonrasında anlattığım şey tam olarak bu aslında. Statik garantiler verebilmek süper birşey aslında. Hiçbir şart altında programınızın yanlış çalışmayacağını garanti altına alıyorsunuz. Ama bazı durumlarda bu mümkün ama çok zor olabiliyor. Diğer yandan, zor da olsa bir kere implement ettikten sonra kesin olarak doğru çalışacağından emin olabiliyorsunuz. Veya test etmesi çok kolay oluyor vs.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Anlattığım şey Damas-Hindley-Milner tip sisteminin temellerinden aslında.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Kindları kendi kendime keşfettiğim an. Aslında Haskell programcısı olduğumdan kind konspetine aşinaydım, ama bu şekilde kullanımı bir bakıma kendi kendime keşfettim diyebilirim. Kind adını da ben vermedim tabii, daha sonra hakkında okudukça farkettim.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>“diğer türlü daha az karmaşık değil gibi” derken kastettiğim, Rémy usulü, field tiplerine bir flag koyarak Abs/Pre özelliğini belirtmekti.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Burda aslında biraz programımın implementasyonu ile alakalı detaylardan bahsediyorum. Belki bir ara biraz daha açarım.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Daha sonradan farkettim ki bir alternatif daha varmış: “Extensible records with scoped labels” makalesinde bahsedilenlerin implement edildiği <a href="http://www.equational.org/morrow/">Morrow</a> programlama dili. En iyi implementasyon şimdilik bu. Tek problemi, kurulmak için <a href="http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem">UUAG attribute grammar system</a>a ihtiyaç duyması. Bir de eğer sadece type inference yapmasın, bir de çalıştırsın derseniz, OCaml’a ihtiyaç duyuyor. Evet çok fantastik. Haskell ile statik analiz kısımları yapılıyor ve OCaml’a derleniyor. Tabii programın asıl olayı tip sistemi olduğundan, deneme için yazdığınız programları çalıştırmak istemeyebilirsiniz, o zaman OCaml’a gerek yok.<a href="#fnref7">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
