<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged haskell</title>
    <link href="http://osa1.net/tags/haskell.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/haskell.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2015-01-16T00:00:00Z</updated>
    <entry>
    <title>Loading dynamic Haskell libs in Lua</title>
    <link href="http://osa1.net/posts/2015-01-16-haskell-so-lua.html" />
    <id>http://osa1.net/posts/2015-01-16-haskell-so-lua.html</id>
    <published>2015-01-16T00:00:00Z</published>
    <updated>2015-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Last year I wrote <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">a blog post</a> in which I explained how to call Lua from Haskell and Haskell from Lua using <a href="http://hackage.haskell.org/package/hslua">hslua</a> library. At the end of that blog post I mentioned that it should be possible to compile Haskell code to shared library and load that in Lua.</p>
<p>Today a friend in our research group <a href="https://github.com/iu-parfunc">parfunc</a> asked a question about compiling Haskell to shared libraries and loading generated libraries in other programs and I thought while I’m at it I can just update my blog post as well. So in this post I’m going to explain how to compile Haskell functions to shared libraries and load them in Lua.</p>
<p>Before diving into the code, a few remarks:</p>
<ul>
<li>All the code in this blog post is tried on Linux, with Lua 5.1 and latest LuaJIT.</li>
<li>To be able to load our function in Lua and register it, our functions should have C linkage and <a href="http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><code>lua_CFunction</code></a> type. We can either write Haskell functions directly using this type, or write C wrapper functions around our Haskell functions to be able to use them in Lua. In this post I’m going to do first one.</li>
<li>We’ll need some intermediate C code to expose some Haskell RTS functions to Lua, like <code>hs_init</code> to start Haskell runtime and <code>hs_exit</code> to stop it.</li>
<li>To be able to <code>require</code> our shared library in Lua, we need to implement a <code>int luaopen_&lt;ourlibrary&gt;(lua_State *L)</code> function. While in theory it should be possible to implement that function in Haskell, I’ll implement it in C in this post, because I’m not sure how to write Lua wrappers for <code>hs_init</code> and <code>hs_exit</code> in Haskell.</li>
<li>To keep the code as simple as possible, our Haskell function will be a very dumb addition function.</li>
</ul>
<p>Let’s start.</p>
<h1 id="defining-lua-function-in-haskell">Defining Lua function in Haskell</h1>
<p>This is exactly the same as before: We just define a function with type: <code>LuaState -&gt; IO Int</code>. To keep the code simple, we don’t do error handling at all.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">LibArith</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Scripting.Lua</span> <span class="co">-- this one from hslua</span>

foreign export ccall
<span class="ot">  add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="ot">add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
add l <span class="fu">=</span> <span class="kw">do</span>
  i1 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">1</span>
  i2 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">2</span>
  pop l <span class="dv">2</span>
  push l (i1 <span class="fu">+</span><span class="ot"> i2 ::</span> <span class="dt">Int</span>)
  return <span class="dv">1</span></code></pre>
<h1 id="implementing-intermediate-c">Implementing intermediate C</h1>
<p>In our C glue code, we do two things:</p>
<ol style="list-style-type: decimal">
<li>Wrap <code>hs_init</code> and <code>hs_exit</code> Haskell runtime functions.</li>
<li>Implement Lua C module interface in which we register our functions to Lua. (see <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders">related docs</a> for details)</li>
</ol>
<p>Here’s the code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;LibArith_stub.h&quot;</span>
<span class="ot">#include &quot;lua.h&quot;</span>

<span class="dt">int</span> hs_init_lua(lua_State *L)
{
  hs_init(NULL, NULL);
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> hs_exit_lua(lua_State *L)
{
  hs_exit();
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> luaopen_lualibhelper(lua_State *L)
{
  lua_pushcfunction(L, add);
  lua_setglobal(L, <span class="st">&quot;add_in_haskell&quot;</span>);
  lua_pushcfunction(L, hs_init_lua);
  lua_setglobal(L, <span class="st">&quot;hs_init&quot;</span>);
  lua_pushcfunction(L, hs_exit_lua);
  lua_setglobal(L, <span class="st">&quot;hs_exit&quot;</span>);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Some things to note:</p>
<ul>
<li><code>LibArith_stub.h</code> is generated by GHC. I’ll explain how to compile and link next.</li>
<li>Our Haskell function actually has type <code>HsInt (*)(void *)</code>. While this is not what Lua API expected(it expects <code>int (*)(lua_State *L)</code>), in my x86_64 Linux machine this is working fine. In the worst case, you may need to wrap the Haskell function in C and convert the types using Haskell RTS C API and Lua C API.</li>
</ul>
<h1 id="compiling-and-linking">Compiling and linking</h1>
<p>This is the tricky part, I wasted a good 2 hours trying to figure how to compile to <code>.so</code> and link it with correct set of libraries.</p>
<p>First step is to compile <code>hslua</code> in a sandbox, or at least make it reachable by GHC(by installing globally, using nix environments etc.). I’ll be giving commands assuming that you’re in a sandbox that has <code>hslua</code> installed, if you’re not, then just replace <code>cabal exec ghc --</code> part with <code>ghc</code> and it should just work.</p>
<p>Step 1, compile and link the Haskell code to generate a shared library:</p>
<pre><code>$ cabal exec ghc -- LibArith.hs -shared -dynamic -fPIC -o libarith.so -lHSrts-ghc7.8.3</code></pre>
<p>Note that if you’re using a different version of GHC, you’ll need to modify the last argument to make it link it with corrent GHC RTS library.(alternatively, you can link with debug or profiling versions etc.)</p>
<p>Step 2, compile the Lua module written in C(the C code above) and link it with our shared Haskell library:</p>
<pre><code>$ cabal exec ghc -- libarithhelper.c -no-hs-main -optl -larith -o lualibhelper.so -shared -fPIC -dynamic</code></pre>
<p>Note that you may need to pass extra linker parameters if you have Lua library/headers in non-standard locations. If that’s the case, <code>-optl</code> argument of GHC is used to add linker arguments, just use standard linker arguments with that(<code>-L</code>, <code>-I</code> etc.).</p>
<p>This command should print a warning like this:</p>
<pre><code>/home/omer/opt/luajit_bin/include/luajit-2.0/lua.h:168:16:
     note: expected ‘lua_CFunction’ but argument is of type ‘HsInt (*)(void *)’
     LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);</code></pre>
<p>Like mentioned above, this doesn’t make any difference on my x86_64 Linux machine. If that’s being a problem on your system, just wrap your Haskell function in intermediate C code above using Haskell RTS API.</p>
<p>Now you should have two shared libraries, one for our Haskell code and one for the intermediate C code. One problem is that the shared library generated from C is now depending on the one generated from Haskell. So Haskell library should be in your <code>LD_LIBRARY_PATH</code>.</p>
<p>A good improvement here would be to compile Haskell code to static library, and generate one dynamic library only. (which has Haskell library statically linked to it)</p>
<h1 id="loading-the-code-in-lua">Loading the code in Lua</h1>
<p>Before loading it, make sure that the dynamic linker can really find the shared library generated from Haskell. Run this:</p>
<pre><code>$ ldd lualibhelper.so | grep &quot;not found&quot;</code></pre>
<p>Make sure it’s not printing anything.</p>
<p>Now just run Lua and enjoy the library:</p>
<pre><code>$ luajit-2.0.3
LuaJIT 2.0.3 -- Copyright (C) 2005-2014 Mike Pall. http://luajit.org/
JIT: ON CMOV SSE2 SSE3 SSE4.1 fold cse dce fwd dse narrow loop abc sink fuse
&gt; require &quot;lualibhelper&quot;
&gt; hs_init()
&gt; print(add_in_haskell(1, 2))
3
&gt; print(add_in_haskell(-10, 20))
10</code></pre>
<p>Just for the amusement, let’s crash it by running Haskell function <em>after</em> stopping the Haskell runtime:</p>
<pre><code>&gt; hs_exit()
&gt; add_in_haskell(1, 2)
newBoundTask: RTS is not initialised; call hs_init() first</code></pre>
<p>Fun :)</p>
<h1 id="conclusion">Conclusion</h1>
<p>It turns out that extending Lua using Haskell is almost as easy as the doing it using the technique I explained in my <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">previous blog post on this topic</a>.</p>
<p>This post also demonstrates one other thing, namely, compiling Haskell libraries to shared libraries and dynamically loading them in different programs. I’m hoping that this post helps fellow Haskellers to extend their programs written in different languages with Haskell.</p>]]></summary>
</entry>
<entry>
    <title>GHC + Cabal installation guide for starters</title>
    <link href="http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html" />
    <id>http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html</id>
    <published>2014-09-12T00:00:00Z</published>
    <updated>2014-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I see a lot of starters having problems with installing latest GHC and Cabal, and then keeping their package repository in a sane state(e.g. no thousands of broken packages because of one re-install, no installation problems because of conflicts). I came up with a simple method several years ago, and today when combined with sandboxes, that works really well. I suggest every new Haskeller to do the same. Here’s how I do my GHC/Cabal installation up-to-date and sane:</p>
<p>NEVER USE HASKELL PALTFORM. When I first started, it caused just too much pain. I don’t know how it is today, but I presume same problems should still apply. (globally installing packages)</p>
<p>Most important thing is to keep Cabal and cabal-install up-to-date. You can easily remove a GHC, or install other versions and keep them togerher once you have a working and relatively new(so that it supports sandboxes) Cabal. In fact, I currently have 3 versions of GHC installed, for different projects, and I have no problems at all. Starting from a system with no GHC/Cabal is installed, here’s the way to install latest Cabal and cabal-install:</p>
<ol style="list-style-type: decimal">
<li>Install whatever GHC and Cabal you have in your package manager.</li>
<li>If the GHC you installed from package manager is not latest one, install latest pre-compiled binary from <a href="http://www.haskell.org/ghc/">GHC webpage</a>. Set your <code>$PATH</code>(or move executables to <code>$PATH</code>) and remove the GHC you installed using the package manager.</li>
<li>Run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, then remove Cabal and cabal-install installed using the package manager, and add <code>~/.cabal/bin</code> to $PATH. After doing that, you’ll have latest GHC and Cabal installed. Also, Cabal will be installed locally, so you can update it very easily using <code>cabal udpate &amp;&amp; cabal install Cabal cabal-install</code> whenever you want. Updating for newer GHC is similarly easy, just installed pre-compiled binary from the link above and move it wherever you want. You can use multiple GHC installations at the same time without any problems, Cabal just keeps separate repositories for different GHC versions.</li>
</ol>
<p>The worst thing that can happen is that your package manager may not have Cabal at all. In that case you may need Haskell Platform temporarily, for booting GHC and Cabal. Once you have Haskell Platform(which includes Cabal) and run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, just remove Haskell Platform and download latest GHC as mentioned above and go from there.</p>
<p>Occasionally you may want to remove some directories in <code>~/.cabal/lib</code>. Here’s what I have right now:</p>
<pre><code>➜  lib  pwd
/home/omer/.cabal/lib
➜  lib  ls | xargs du -hs
107M    x86_64-linux-ghc-7.6.3
341M    x86_64-linux-ghc-7.8.3
170M    x86_64-linux-ghcjs-0.1.0_ghc-7.8.2
34M     x86_64-linux-ghcjs-0.1.0_ghc-7.8.3</code></pre>
<p>I have 170M of libraries installed in GHCJS compiled with GHC 7.8.2, but I updated my GHCJS installation and I won’t be using that version anymore, so it’s safe to remove that directory. Similarly you may want to remove versions you won’t be using anymore.</p>
<p>Once you have GHC and Cabal installed, you should be very careful with global installations. Basically all you need to do is to use sandboxes as much as possible. You may want or need to have some programs installed globally, like <code>alex</code> and <code>happy</code> and those are fine since they have almost no dependencies at all.</p>
<p>In all other cases, just create a <code>~/bin</code> directory and add it to your <code>$PATH</code>. Now whenever you need a Haskell program in your path, install it in a sandbox, and symlink it to <code>~/bin</code>.</p>
<p>Another very useful tip: You may still have some installation problems because of dependency conflicts. In that cases always try to install with <code>cabal install --allow-newer</code>. Most of the time this sandbox approach + <code>--allow-newer</code> should solve all your problems.</p>
<p>As a last thing, if you still have problems because you installed some libs globally for some reason, you may want to reset your whole Cabal state. In that case, just copy <code>~/.cabal/bin/cabal</code> to somewhere else and remove <code>~/.cabal</code>. Then using copied <code>cabal</code> executable, run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code> again. Now you have a fresh Cabal state and you can remove copied <code>cabal</code> executable and go with the one just installed at <code>~/.cabal/bin</code>.</p>
<p>I hope this helps.</p>]]></summary>
</entry>
<entry>
    <title>Stack traces in GHCJS</title>
    <link href="http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html" />
    <id>http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html</id>
    <published>2014-06-20T00:00:00Z</published>
    <updated>2014-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m about to finish the first part of my GSoC project and as a part of my project I have implemented stack traces for GHCJS. Currently <code>GHC.Stack</code> functions should work in GHCJS, except for some cases I explain below.</p>
<p>As a demo, I set up <a href="http://osa1.net/files/stacktrace.jsexe/index.html">this page</a>, it runs the Haskell program rendered on the page (some part of the code is copied from Simon Marlow’s <a href="http://www.youtube.com/watch?v=J0c4L-AURDQ">“Why can’t I get stack traces?” presentation</a>). Output is printed to the console. You should be seeing something like this:</p>
<div class="figure">
<img src="http://osa1.net/images/ghcjs-stacktrace.png" />
</div>
<p>My main goal is to implement profiling features of GHC (cost-centres, SCC annotations, reporting allocations/ticks etc.) for GHCJS. It turns out that cost-centre stacks and call stacks are same thing. <code>GHC.Stack.currentCallStack</code> returns the current cost-centre stack, and cost attribution is done to current call-stack(or current cost-centre stack, since they’re exactly the same thing). Similarly, <code>GHC.Stack.whoCreated</code> returns the cost centre stack that was active when the heap object was created.</p>
<p><a href="https://github.com/osa1/ghcjs/compare/ghcjs:master...work3">20 changed files with 810 additions and 527 deletions</a> later, I had <code>GHC.Stack</code> working. You won’t need to do anything different once it’s merged into GHCJS, but for now it requires some effort to install. It also still has some bugs and differences from GHC version. Rest of the post explains how to test it, bugs, and differences from GHC.</p>
<h1 id="how-to-use">How to use</h1>
<p>Because of a horrible bug(see bugs section), you need a 32bit system to use profiling features of GHCJS. You should clone my fork of <a href="https://github.com/osa1/ghcjs">GHCJS</a> and <a href="https://github.com/osa1/shims">shims</a>. For GHCJS, switch to <code>work3</code> branch(that 3 represents how many times I started from scratch :) and for shims switch to <code>work2</code> branch. You need to install <a href="https://github.com/ghcjs/Cabal">modified Cabal for GHCJS</a>. After installing Cabal, install GHCJS and run <code>ghcjs-boot --init -q --prof</code>. This takes about 20 minutes on my system and compiles <code>base</code> and some other libraries. <code>--prof</code> is used to generate profiled versions of libraries.</p>
<p>After GHCJS has been booted, replace ~/.ghcjs/&lt;your platform&gt;/shims folder with my fork of shims(make sure you switched to work2 branch). Now you should be able to compile and run programs with profiling options of GHC. For example, to compile and run the example program given above, run <code>ghcjs stacktrace.hs -prof -fprof-auto</code> and then run generated <code>stacktrace.jsexe/all.js</code> using nodejs. Enabling profiling gives you a debug executable, with more metadata (object names) and longer (non-renamed) variable names.</p>
<h1 id="differences">Differences</h1>
<p>Because GHCJS represents some objects as unboxed numbers and currently we don’t associate any cost-centres with this type of objects, <code>whoCreated</code> returns an empty list. If there’s demand, we can disable unboxing with a command line switch and <code>whoCreated</code> on these values would work. In the example program, second and third lines are printing empty lists because of this.</p>
<h1 id="bugs">Bugs</h1>
<p>Currently we discovered two bugs:</p>
<ol style="list-style-type: decimal">
<li><p>There’s a horrible bug happening outside of GHCJS code, see my <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">blog post</a> and <a href="http://www.haskell.org/pipermail/ghc-devs/2014-May/005059.html">ghc-devs mail</a>. Because of this bug, booting GHCJS with profiling enabled is resulting with a segfault on 64bit systems. I’m developing this project on a 32bit VM, running on a VPS :) I need to make some more progress before tracking this bug.</p></li>
<li><p>We’re having a bug that makes stack traces sometimes a bit different than the ones generated by GHC compiled programs. For example, the example program should have printed this stack trace:</p>
<pre><code>Main.errorM.\ (stacktrace.hs:13:22-54)
Main.errorM (stacktrace.hs:13:1-54)
Main.foo.\.\ (stacktrace.hs:27:23-30)
Main.foo.\ (stacktrace.hs:27:16-33)
Main.foo (stacktrace.hs:27:1-36)
Main.bar (stacktrace.hs:24:1-20)
Main.runM.(...) (stacktrace.hs:16:20-31)
Main.runM (stacktrace.hs:16:1-36)
Main.main (stacktrace.hs:(29,1)-(38,36))
Main.CAF (&lt;entire-module&gt;)</code></pre>
<p>.. but <code>runM</code> calls are missing in GHCJS output. I have no idea what could be the reason for this and I’m currently working to fix this. After fixing this, I think we’ll have exactly same stack traces as the ones produced by GHC compiled programs.</p></li>
</ol>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>I’d like to thank my mentor Luite Stegeman for answering my endless questions, helping me understanding GHC and GHCJS internals and reviewing this blog post.</p>]]></summary>
</entry>
<entry>
    <title>Dependency boundaries and orphan instances</title>
    <link href="http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html" />
    <id>http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>According to the <a href="http://www.haskell.org/haskellwiki/Package_versioning_policy">PVP</a>(Package Versioning Policy), adding a non-orphan instance is not a breaking change and a minor version number should be bumped(<code>C</code> in <code>A.B.C</code>) in case of a non-orphan instance implementation.</p>
<p>This means that if you’re implementing an orphan instance, you should specify minor upper bound of the package that defines the typeclass. Otherwise if the package implements the typeclass for the type in the future, you’re package will be broken.</p>
<p>I want to add <code>StackValue a =&gt; StackValue [a]</code> instance in hslua, but that breaks Pandoc because it implements that instance without using a newtype(an orphan instance) and hslua dependency upper bound is specified as <code>&lt; 0.4</code>.</p>
<p>Good news is that bergmark at Freenode #haskell told me that now it’s possible to change dependency ranges on Hackage without pushing a new version, so there’s an easy fix that’ll keep package working.</p>]]></summary>
</entry>
<entry>
    <title>GHC RTS notes</title>
    <link href="http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html" />
    <id>http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html</id>
    <published>2014-05-30T00:00:00Z</published>
    <updated>2014-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://news.ycombinator.com/item?id=7818768">Someone on HN</a> shared <a href="http://stanford.edu/~adebray/240h_notes.pdf">this class notes</a> of Stanford’s “Functional Systems in Haskell” class. Most of the stuff is very basic but sections 16 and 17 are very useful for me since they’re related with GHC internals which I’m currently studying.</p>
<p>You can see slides of Section 17 <a href="http://ezyang.tumblr.com/post/87048816817/cs240h-lecture-on-the-ghc-runtime-system">here</a>.</p>
<p>These are probably only up-to-date reading materials about GHC RTS you can find. (unless you count source code as a reading material ;_; )</p>
<p>Some other useful GHC Wiki pages that I find useful: (validness of these for current GHC is not guaranteed, but theoretic stuff should be still valid)</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps">PrimOps</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply">Function calls</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#ThreadStateObjects">The layout of heap objects</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Stack">Layout of the stack</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution">The Haskell Execution Model</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode">STG by example</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode">Debugging GHC-compiled code with gdb</a> (I hope you don’t really need this!)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/RuntimeSystem">Debugging the runtime system</a> (same as above)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">The Garbage Collector</a></li>
<li><a href="http://www.mono-project.com/Generational_GC">Generational GC page of Mono project</a> – not really Haskell, but I think it’s a good source to understand GC concepts that is related with GHC’s GC implementation.</li>
</ul>
<p>Now I can close my browser tabs in peace…</p>
<p>Bonus content: Here’s a <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">horror story</a> that is probably related with a GHC RTS bug and making progress in my work impossible.</p>
<p>EDIT: Someone on GHC IRC channel shared <a href="http://arashrouhani.com/papers/master-thesis.pdf">his masters thesis about GHC stack traces</a>, even if you’re not interested in stack traces I think it contains lots of useful information about GHC compilation pipeline.</p>]]></summary>
</entry>
<entry>
    <title>The GHC bug that ruined my day</title>
    <link href="http://osa1.net/posts/2014-05-27-worst-bug.html" />
    <id>http://osa1.net/posts/2014-05-27-worst-bug.html</id>
    <published>2014-05-27T00:00:00Z</published>
    <updated>2014-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just came across a very serious GHC bug that prevents me from making progress on my GHCJS project. It looks like it’s very hard to come up with a minimal program that reproduces the bug. Here’s a very long way to reproduce it:</p>
<ul>
<li><p>Install <a href="https://github.com/ghcjs/Cabal">patched Cabal for GHCJS</a>.</p></li>
<li><p>Clone <a href="https://github.com/osa1/ghcjs">my fork of GHCJS</a>, switch to <code>work</code> branch and install it.</p></li>
<li><p>Delete <code>~/.ghcjs</code> folder if you already have one.</p></li>
<li><p>Run <code>ghcjs-boot --init --prof -v</code> and wait for it to fail with segmentation fault while compiling profiling object files for <code>base</code> library. Segmentation fault is reported as <code>ExitFailure (-11)</code> by Cabal.</p></li>
<li><p>Since we run <code>ghcjs-boot</code> in verbose mode(using <code>-v</code> parameter), at this point it should have printed what command it was running when the error occured. It should be a very very long command, starting with something like <code>/home/omer/.cabal/bin/ghcjs --make -fbuilding-cabal-package -O -prof ...</code>. Copy that command because that’s how we reproduce the error.</p></li>
<li><p>Now to trace the bug, we need to compile GHCJS for debugging. Note that booting GHCJS with debugging build takes forever, so we first installed GHCJS and built some libraries using that fast build. To compile for debugging, first run <code>cabal clean</code> and then <code>cabal install --disable-executable-stripping --ghc-options=-debug</code>.</p></li>
<li><p>Move to <code>~/.ghcjs/&lt;your platform&gt;/ghcjs-boot/boot/base</code> and run the command you copied from <code>ghcjs-boot</code> verbose output when the error happened for first time. You should get the same error very fast.</p></li>
<li><p>At that point you can use gdb and friends. On my system gdb backtrace gives this:</p></li>
</ul>
<pre><code>[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
Detaching after fork from child process 3382.
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
Detaching after fork from child process 3383.
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
Detaching after fork from child process 3384.
[ 51 of 202] Compiling GHC.Fingerprint[boot] ( GHC/Fingerprint.hs-boot, dist/build/GHC/Fingerprint.js_p_o-boot )
Detaching after fork from child process 3385.
[ 55 of 202] Compiling GHC.IO.Exception[boot] ( GHC/IO/Exception.hs-boot, dist/build/GHC/IO/Exception.js_p_o-boot )
Detaching after fork from child process 3386.
[ 75 of 202] Compiling Foreign.C.Types  ( Foreign/C/Types.hs, dist/build/Foreign/C/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x000000000425f776 in scavenge_mutable_list1 (bd=0x7fffe5c02a00, gen=0x4d1fd48) at rts/sm/Scav.c:1400
#2  0x000000000425fa13 in scavenge_capability_mut_Lists1 (cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x0000000004256b66 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2,
    cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x00000000042454a3 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d32b60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x0000000004243de4 in schedule (initialCapability=0x4cfe5c0 &lt;MainCapability&gt;, task=0x4d32b60)
    at rts/Schedule.c:553
#6  0x0000000004246436 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x000000000423e9b4 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x477f850, ret=0x0) at rts/RtsAPI.c:500
#8  0x0000000004241666 in real_main () at rts/RtsMain.c:63
#9  0x0000000004241759 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x477f850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Thanks to Luite Stegeman for helping me with debugging. We could reproduce this error on 64bit Linux and 64bit OS X. I don’t know how to track down this bug but it just made making progress in my project impossible.</p>
<hr />
<p>EDIT: I just found a workaround: run GHCJS with <code>+RTS -G1</code>. I was reading code of functions in the backtrace and I realized some RTS parameters are used. By playing with them changing randomly, I found this. Some details about this parameter is explained in <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">GHC Trac GC section</a>(see “generational gc” parts). Unfortunately with this RTS parameter GHCJS runs at least 100x slower(at least in debug build) so even though I can boot GHCJS with my changes it’s not very usable since I sometimes boot it 10 times a day in this stage of the development.</p>
<hr />
<p>EDIT 2: My workaround did not work great – now compilation is failing in some other stage:</p>
<pre><code>Failed to install base-4.7.0.0
Last 10 lines of the build log ( /home/omer/.cabal/logs/base-4.7.0.0.log ):
[  4 of 202] Compiling Unsafe.Coerce    ( Unsafe/Coerce.hs, dist/build/Unsafe/Coerce.js_p_o )
[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
[  8 of 202] Compiling GHC.Err          ( GHC/Err.lhs, dist/build/GHC/Err.js_p_o )
[  9 of 202] Compiling GHC.Base         ( GHC/Base.lhs, dist/build/GHC/Base.js_p_o )
[ 10 of 202] Compiling Data.Maybe       ( Data/Maybe.hs, dist/build/Data/Maybe.js_p_o )
[ 11 of 202] Compiling GHC.List         ( GHC/List.lhs, dist/build/GHC/List.js_p_o )
[ 12 of 202] Compiling GHC.Num          ( GHC/Num.lhs, dist/build/GHC/Num.js_p_o )
[ 13 of 202] Compiling GHC.Show         ( GHC/Show.lhs, dist/build/GHC/Show.js_p_o )
cabal: Error: some packages failed to install:
base-4.7.0.0 failed during the building phase. The exception was:
ExitFailure (-11)</code></pre>
<p>However, when I tried to run the command that led to this segfault in gdb to see if it gives a different backtrace, it worked fine and no segfaults happened.</p>
<hr />
<p>EDIT 3: There has been some changes in GHCJS codegen and I wanted to try to reproduce this bug using that new codegen, hoping that it may be a workaround for the segfault(I rebased my patches for new version). It’s still happening, but now in different file:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x00000000042565e6 in scavenge_mutable_list1 (bd=0x7fffe5800c40, gen=0x4d17d48) at rts/sm/Scav.c:1400
#2  0x0000000004256883 in scavenge_capability_mut_Lists1 (cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x000000000424d9d6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x000000000423c313 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d2ab60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x000000000423ac54 in schedule (initialCapability=0x4cf6340 &lt;MainCapability&gt;, task=0x4d2ab60)
    at rts/Schedule.c:553
#6  0x000000000423d2a6 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x0000000004235824 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#8  0x00000000042384d6 in real_main () at rts/RtsMain.c:63
#9  0x00000000042385c9 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Backtrace is same. I think it’s interesting that this problem is happening while compiling <code>Types</code> modules in 2/3 of the cases(<code>Foreign.C.Types</code> and <code>System.Posix.Types</code>). As far as I can see this two modules are using <code>INTEGRAL_TYPE</code> extensively, which creates a newtype and implements <code>Read</code> and <code>Show</code> instances. Other problematic module, <code>GHC.Show</code> also implements same instances, but does that manually instead of calling <code>INTEGRAL_TYPE</code>. I wonder if it could be related with that.</p>
<hr />
<p>EDIT 4: When I run GHCJS using <code>--no-native</code>, it failed with an assertion error rather than a segfault:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )
ghcjs: internal error: ASSERTION FAILED: file rts/sm/Scav.c, line 1400

    (GHC version 7.8.2 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug

Program received signal SIGABRT, Aborted.
0x00007ffff687f849 in raise () from /lib64/libc.so.6
(gdb) bt
#0  0x00007ffff687f849 in raise () from /lib64/libc.so.6
#1  0x00007ffff6880cd8 in abort () from /lib64/libc.so.6
#2  0x0000000004238a27 in rtsFatalInternalErrorFn (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;, 
    ap=0x7fffffffbe58) at rts/RtsMessages.c:170
#3  0x000000000423865f in barf (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;) at rts/RtsMessages.c:42
#4  0x00000000042386c2 in _assertFail (filename=0x4559fbd &quot;rts/sm/Scav.c&quot;, linenum=1400) at rts/RtsMessages.c:57
#5  0x00000000042565e9 in scavenge_mutable_list1 (bd=0x7fffe7402dc0, gen=0x4d15d88) at rts/sm/Scav.c:1400
#6  0x0000000004256873 in scavenge_capability_mut_Lists1 (cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#7  0x000000000424d9c6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#8  0x000000000423c303 in scheduleDoGC (pcap=0x7fffffffc188, task=0x4d28ba0, force_major=rtsFalse)
    at rts/Schedule.c:1650
#9  0x000000000423ac44 in schedule (initialCapability=0x4cf49c0 &lt;MainCapability&gt;, task=0x4d28ba0)
    at rts/Schedule.c:553
#10 0x000000000423d296 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2b0) at rts/Schedule.c:2346
#11 0x0000000004235814 in rts_evalLazyIO (cap=0x7fffffffc2b0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#12 0x00000000042384c6 in real_main () at rts/RtsMain.c:63
#13 0x00000000042385b9 in hs_main (argc=238, argv=0x7fffffffc438, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#14 0x0000000000408ea7 in main ()</code></pre>
<p>Not passing <code>--not-native</code> is resulting with a segfault and same backtrace as before.</p>]]></summary>
</entry>
<entry>
    <title>Calling Haskell from Lua and Lua from Haskell</title>
    <link href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html" />
    <id>http://osa1.net/posts/2014-04-27-calling-haskell-lua.html</id>
    <published>2014-04-27T00:00:00Z</published>
    <updated>2014-04-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>TL;DR: It’s possible to call Haskell functions from Lua and Lua function from Haskell using <a href="https://github.com/osa1/hslua">hslua</a>. <a href="https://github.com/osa1/hslua/tree/master/examples/callbacks">“Callbacks” example</a> in hslua repository shows how to do this.</p>
<hr />
<p><a href="https://github.com/osa1/hslua"><code>hslua</code></a> provides Lua 5.1 C API to the programmer, and using it we can call Lua functions from Haskell and Haskell functions from Lua. In this post, I’m going to give two example Lua function implementations in Haskell. This functions will be mapped to a global name in Lua and one of them will be getting Lua functions as it’s arguments.</p>
<h1 id="two-ways-of-writing-lua-functions-in-haskell">Two ways of writing Lua functions in Haskell</h1>
<p>There are two ways of writing Lua functions in Haskell using hslua. First is the high-level method, where the Haskell function is just any function, provided that it’s type is an instance of <code>LuaImport</code>(we’ll come to this later). Second method is what I’d like to call the <em>raw</em> Haskell function method. <em>Raw</em> Haskell functions should have the type <code>LuaState -&gt; IO CInt</code>, where <code>LuaState</code> is Lua interpreter state provided by <code>hslua</code> and return type <code>CInt</code> represents the amount of return values(e.g. values that are left on the stack by this function). In <em>raw</em> functions, you need to do Lua stack manipulation using standard <a href="http://www.lua.org/manual/5.1/manual.html#3">Lua 5.1 API</a>.</p>
<p>While first method gives you a nice, abstracted way of writing Lua functions in Haskell, <em>raw</em> function method gives you the maximum amount of flexibility that Lua can provide. First method has lots of limitations when compared with <em>raw</em> method.</p>
<h1 id="higher-level-haskell-functions-in-lua">Higher-level Haskell functions in Lua</h1>
<p>In first method all you have to do is to write a Haskell function with it’s type is an instance of <code>LuaImport</code>. So let’s see what types are instances:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">StackValue</span> a) <span class="ot">=&gt;</span> <span class="dt">LuaImport</span> (<span class="dt">IO</span> a) <span class="kw">where</span>
<span class="kw">instance</span> (<span class="dt">StackValue</span> a, <span class="dt">LuaImport</span> b) <span class="ot">=&gt;</span> <span class="dt">LuaImport</span> (a <span class="ot">-&gt;</span> b)</code></pre>
<p>So basically every function type where it’s argument types are instances of <code>StackValue</code> and return type is <code>IO a</code> where <code>a</code> is also an instance of <code>StackValue</code> is an instance of <code>LuaImport</code> and thus can be used in this higher-level method of writing Lua functions in Haskell. Let’s see which types are <code>StackValue</code>s:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaInteger</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaNumber</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Int</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Double</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">String</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Bool</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> (<span class="dt">FunPtr</span> <span class="dt">LuaCFunction</span>)
<span class="kw">instance</span> <span class="dt">StackValue</span> (<span class="dt">Ptr</span> a)
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaState</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> ()</code></pre>
<p>We have basic Haskell types <code>Int</code>, <code>Double</code>, <code>String</code>, and <code>Bool</code> as instances. Other types are for more advanced use, for example, <code>Ptr a</code> is used for <code>userdata</code>(basically any binary data that you want to pass to Lua stack and later get back, see <a href="http://www.lua.org/manual/5.1/manual.html#2.2">reference manual</a> for more details).</p>
<p>This two functions are instances of <code>LuaImport</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">concat&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
concat&#39; s1 s2 <span class="fu">=</span> return <span class="fu">$</span> s1 <span class="fu">++</span> s2

<span class="ot">pow ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span>
pow d1 d2 <span class="fu">=</span> return <span class="fu">$</span> d1 <span class="fu">**</span> d2</code></pre>
<p>And we can push this functions to Lua stack using <code>pushhsfunction</code> or directly assign them to a global variable using <code>registerhsfunction</code>. In this post I’ll use register functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Scripting.Lua</span> <span class="kw">as</span> <span class="dt">Lua</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> newstate
    openlibs l
    registerhsfunction l <span class="st">&quot;concat&quot;</span> concat&#39;
    registerhsfunction l <span class="st">&quot;pow&quot;</span> pow
    loadfile l <span class="st">&quot;haskellfun.lua&quot;</span>
    call l <span class="dv">0</span> <span class="dv">0</span>
    close l</code></pre>
<p>With 11 lines of code, we can create a Lua state and map this Haskell functions to some names and call them from Lua. This program runs Lua file <code>haskellfun.lua</code>, which you can see in examples folder of <a href="https://github.com/osa1/hslua/tree/master/examples/haskellfun"><code>hslua</code> repository</a>.</p>
<p>Apart from the simplicity, another good thing about this method is that it handles type checking of Lua values automatically. Internally, this functions are wrapped with another function which gets <code>LuaState</code> as parameter and collects Lua values from stack, checks their types(and throws error in case of a type mismatch), and push return value of the function to the Lua stack again. Here’s an example call with wrong type of values:</p>
<pre><code>print(pow(&quot;wrong&quot;))
...
bad argument #1 to &#39;?&#39; (number expected, got string)</code></pre>
<p>Major limitation of this method is that you can only get basic Lua types from the Lua stack. For example, you can’t get a Lua table automatically like you get a Lua string. This because Lua needs to keep track of tables and some other values for garbage collection.</p>
<h1 id="working-on-more-complex-lua-types-and-the-registry">Working on more complex Lua types and the registry</h1>
<p>The Lua way of using Lua tables, Lua functions etc. in Lua API is to register that values to the Lua table called <em>registry</em>, and refer to that values using their index at <em>registry</em>. Using <em>registry</em>, Lua keeps tracks of references to Lua values that are available for garbage collection. See <a href="http://www.lua.org/manual/5.1/manual.html#3.5">reference manual section 3.5</a> for more details.</p>
<h1 id="raw-haskell-function-method">Raw Haskell function method</h1>
<p>We can do this writing <em>raw</em> Haskell functions. Raw functions have type <code>LuaState -&gt; IO CInt</code> and <code>LuaState</code> allows us to run any C API function. <em>raw</em> functions are pushed to Lua stack using <code>pushrawhsfunction</code> and registered as global variable using <code>registerrawhsfunction</code>.</p>
<p><a href="https://github.com/osa1/hslua/tree/master/examples/callbacks"><code>callbacks</code> example</a> in the <code>hslua</code> repository takes Lua callbacks in Haskell functions and later call them in FIFO order and return their return values as a Lua array(table with int keys). You can see the complete program in the repository and here I’ll give only the tricky parts.</p>
<p><em>Raw</em> Haskell functions should return number of values left on the Lua stack as return values. As an example, <code>addLuaCallbacks</code> function uses this for simple error reporting, it puts the error string to the Lua stack and return <code>1</code> in case of an error, and return <code>0</code> otherwise:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addLuaCallbacks l <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
    <span class="kw">case</span> as <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="co">-- arguments are functions, add them to callback queue and return</span>
        <span class="co">-- nothing</span>
        addCallbacks <span class="dv">1</span> args
        return <span class="dv">0</span>
      <span class="dt">Just</span> errArg <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="co">-- error: argument at `errArg` is not a function, return error</span>
        <span class="co">-- string</span>
        pushstring l <span class="fu">$</span> <span class="st">&quot;argument &quot;</span> <span class="fu">++</span> show errArg <span class="fu">++</span> <span class="st">&quot; is not a function&quot;</span>
        return <span class="dv">1</span></code></pre>
<p>This example program keeps track of passed Lua callbacks in an <code>IORef</code>. Here’s the part that handles getting Lua callbacks from Lua stack:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addCallbacks n max
  <span class="fu">|</span> n <span class="fu">&gt;</span> max <span class="fu">=</span> return ()
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span>
      <span class="co">-- move nth argument to top of the stack</span>
      pushvalue l n
      <span class="co">-- add function reference to registry</span>
      refId <span class="ot">&lt;-</span> ref l registryindex
      <span class="co">-- add registry index to IORef</span>
      modifyIORef cs (<span class="fu">++</span> [refId])
      <span class="co">-- continue adding other arguments</span>
      addCallbacks (n<span class="fu">+</span><span class="dv">1</span>) max</code></pre>
<p>Note how we’re adding the function to the <em>registry</em> and getting it’s index at the <em>registry</em> in Haskell. We can now refer to this functions(e.g. push this function to Lua stack) using this index. Here’s the relevant code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Call Lua callbacks collected with `addLuaCallbacks`.</span>
<span class="ot">callLuaCallbacks ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CInt</span>
callLuaCallbacks l <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
  <span class="kw">where</span>
    iter [] <span class="fu">=</span> return ()
    iter (c <span class="fu">:</span> rest) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">...</span>
      pushinteger l (fromIntegral c)
      gettable l registryindex
      <span class="co">-- call the callback</span>
      call l <span class="dv">0</span> <span class="dv">1</span>
      <span class="fu">...</span>
      iter rest</code></pre>
<p>We’re pushing the index to the Lua stack, and calling <code>gettable</code> to push actual function to the stack using the index. Complete program is longish, so I’m omitting it here, you can see it in <a href="https://github.com/osa1/hslua/tree/master/examples/callbacks"><code>hslua</code>s Github repository</a> with an example Lua program that uses defined Haskell functions to pass Lua callbacks to Haskell.</p>
<h1 id="a-note-about-safety">A note about safety</h1>
<p>Lua tolerates some incorrect stack operations and if you do that while writing <em>raw</em> Haskell functions, you can have hard times debugging your programs. Fortunately, Lua also provides a compile time flag to enable checking API usage for safety. If you install <code>hslua</code> using <code>-fapicheck</code> Cabal flag, it compiled Lua with API checking enabled and Lua gives you errors instead of silently doing something not intended. For example, if you refer to a Lua value at stack index <code>-4</code> while your stack has only <code>3</code> elements, you get something like:</p>
<pre><code>callbacks: src/lapi.c:57: index2adr: Assertion `idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base&#39; failed.</code></pre>
<p>This helps making sure that your API usage is correct.</p>
<h1 id="using-hslua-for-reading-configuration-files-written-in-lua">Using hslua for reading configuration files written in Lua</h1>
<p>hslua also provides a module for reading configuration files. As an example, using <code>Scripting.Lua.ConfigFile.getNestedAssocLists</code>, you can execute the Lua file given below and get resulting nested table as Haskell <code>[(String, [(String, String)])]</code>:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"> someVal <span class="ot">=</span> <span class="ot">{</span>
    something <span class="ot">=</span> <span class="ot">{</span>
       foo <span class="ot">=</span> <span class="st">&quot;aaa&quot;</span><span class="ot">,</span>
       bar <span class="ot">=</span> <span class="st">&quot;bbb&quot;</span><span class="ot">,</span>
       baz <span class="ot">=</span> <span class="st">&quot;ccc&quot;</span>
    <span class="ot">},</span>
    somethingElse <span class="ot">=</span> <span class="ot">{</span>
       <span class="ot">...</span>
    <span class="ot">}</span>
 <span class="ot">}</span></code></pre>
<h1 id="running-lua-programs-using-lua-interpreters">Running Lua programs using Lua interpreters</h1>
<p>In all hslua examples, we needed to create Lua state in Haskell, register Haskell functions inside Haskell and then run Lua files using Lua C API again in Haskell. I think in theory it is also possible to run Lua programs using standard Lua interpreter executables(instead of running the interpreter using Lua C API inside Haskell) and load Haskell functions compiled to <code>*.so</code> shared library files.</p>
<p>About one year ago, I did something similar using C instead of Haskell. You can see the code <a href="https://github.com/osa1/lcl">here</a>. The library compiled to a <code>.so</code> file and by using Lua’s <code>package.loadlib</code>, you can load functions defined in the <code>.so</code>.</p>
<p>Compiling raw Haskell <code>hslua</code> functions to a <code>.so</code> should not be tricky. <code>LuaState</code> type is just a wrapper around <code>Ptr ()</code>, and <code>CInt</code> is just a C integer, so it’s signature is already compatible. We probably need to use <code>foreign export ...</code> of GHC FFI and find GHC parameters to compile to <code>.so</code>. I’ll investigate this further and post updates.</p>]]></summary>
</entry>
<entry>
    <title>I'm accepted into GSoC and I'll be hacking on GHCJS this summer</title>
    <link href="http://osa1.net/posts/2014-04-24-accepted-to-gsoc.html" />
    <id>http://osa1.net/posts/2014-04-24-accepted-to-gsoc.html</id>
    <published>2014-04-24T00:00:00Z</published>
    <updated>2014-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m accepted into Google Summer of Code 2014 and I’ll be working on adding profiling support to GHCJS. This is very exciting for me, I’ll be hacking on JavaScript backend of my favorite compiler(GHC) all summer and get paid :)</p>
<p>I can’t wait to start hacking, but unfortunately I still have one last and very important exam before my graduation from undergraduate school on 26th April and I have to study hard for that. After that, I’ll be hacking on GHCJS all summer long.</p>
<p>Stay tuned for updates about my work and live demos that you can run from within your browser, thanks to GHCJS.</p>
<p>You can see all accepted proposals of Haskell organization <a href="http://www.google-melange.com/gsoc/org2/google/gsoc2014/haskell">here</a>.</p>]]></summary>
</entry>
<entry>
    <title>An idea to handle left-recursion in Parsec</title>
    <link href="http://osa1.net/posts/2014-03-07-parsec-left-recursion.html" />
    <id>http://osa1.net/posts/2014-03-07-parsec-left-recursion.html</id>
    <published>2014-03-07T00:00:00Z</published>
    <updated>2014-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently realized that it may be possible to handle left-recursion in Parsec style parser combinator libraries. I quickly wrote a simple prototype implementation that demonstrates the idea.</p>
<p>The idea is to keep track of parser functions that are called without consuming any tokens from input stream. You should be able to run failure procedures when same parser function is encountered more than one time without consuming any tokens. When a token is consumed, state that is used to keep track of parser functions should be reset.</p>
<p>One assumption here is that I’m assuming parser functions do not alter any states. Otherwise when you come across a same parser, you can have different state and parser may behave differently.</p>
<p>Implementing the idea is easy even without having any extra support from Parsec. Here’s a demonstration on my favorite ambiguous grammar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Exp ::= Int</span>
<span class="co">--      |  Exp `+` Exp</span>

<span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre>
<p>Parsers for non-terminals are easy:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">plus <span class="fu">=</span> char <span class="ch">&#39;+&#39;</span> <span class="fu">&gt;&gt;</span> spaces
int  <span class="fu">=</span> fmap (<span class="dt">Int</span> <span class="fu">.</span> read) <span class="fu">$</span> many1 digit <span class="fu">&lt;*</span> spaces</code></pre>
<p>I’m using a set to keep track of already visited parsers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MarksSeen</span> <span class="fu">=</span> <span class="dt">S.Set</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">RecParser</span> s m a <span class="fu">=</span> <span class="dt">ParsecT</span> s <span class="dt">MarksSeen</span> m a</code></pre>
<p>Auxiliary functions to alter the state that keeps track of visited parsers:</p>
<pre><code>putMark i = do
    is &lt;- getState
    if S.member i is
      then fail &quot;recursion&quot;
      else putState $ S.insert i is

resetMarks = putState S.empty</code></pre>
<p>Now the interesting part, <code>add</code> parser marks itself as first thing to do, and calls <code>exp</code> parser. Since <code>exp</code> parser is entry point, this means an indirect recursive call. When same <code>putMark</code> call is made, Parsec runs failure actions instead of going into infinte loop:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="fu">=</span> <span class="kw">do</span>
    putMark <span class="dv">1</span>
    e1 <span class="ot">&lt;-</span> exp
    resetMarks
    plus
    e2 <span class="ot">&lt;-</span> exp
    spaces
    return <span class="fu">$</span> <span class="dt">Add</span> e1 e2

exp <span class="fu">=</span> choice [try add, int]</code></pre>
<p><code>resetMarks</code> call is also important, <code>exp</code> has to consume some tokens, so after parsing <code>e1</code>, I’m calling <code>resetMarks</code>.</p>
<p>Here’s an example call of this parser:</p>
<pre><code>ghci&gt; runParser exp S.empty &quot;&quot; &quot;1 + 2 + 3 + 4&quot;
Right (Add (Int 1) (Add (Int 2) (Add (Int 3) (Int 4))))</code></pre>
<p>You can observe that parser gets into an infinite loop when marks are removed. Here’s an example demonstrating the error message:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rec <span class="fu">=</span> putMark <span class="dv">0</span> <span class="fu">&gt;&gt;</span> rec <span class="fu">&gt;&gt;</span> resetMarks

ghci<span class="fu">&gt;</span> runParser rec S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>
<span class="dt">Left</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)<span class="fu">:</span>
recursion</code></pre>
<p>One problem with this approach is that it requires more typing, and you should be careful too. Marks can be placed using TemplateHaskell to ensure unique numbers are given to each <code>putMark</code> call. As a second improvement, I think with some modifications on Parsec we can make Parsec to reset marks when a token is consumed(using <em>consumed-ok</em> continuation of <code>ParsecT</code>).</p>
<p>You can see the complete program <a href="https://gist.github.com/osa1/9414577">here</a>.</p>
<hr />
<p>Removing left-recursions in your grammar may not be a huge problem – except when you’re working on functional languages with ML-like syntax. Then you’re out of luck because being functional means you’re <code>Exp</code> non-terminal contains several dozen of productions and function applications is a part of that too, and it’s left-recursive:</p>
<pre><code>Exp ::= ...
     |  Exp Exp_1 ... Exp_N [left-associative]
     ... a hundred more productions ...</code></pre>
<p>Whenever I need to write a parser for a grammar like this, I’m thinking for an easier way to parse it. I still couldn’t come up with a solution. Idea I just explained does not solve it, because it parses right-associatively. There is one workaround, but I’m not sure if that results with a parser for same grammar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">app <span class="fu">=</span> <span class="kw">do</span>
    putMark <span class="dv">2</span>
    fn <span class="ot">&lt;-</span> exp
    resetMarks

    putMark <span class="dv">2</span>
    as <span class="ot">&lt;-</span> many1 exp
    resetMarks

    return <span class="fu">$</span> foldl <span class="dt">App</span> fn as


ghci<span class="fu">&gt;</span> runParser pgm S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;1 2 3 4 + 5 + 6 7&quot;</span>
<span class="dt">Right</span> (<span class="dt">Add</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">1</span>) (<span class="dt">Int</span> <span class="dv">2</span>)) (<span class="dt">Int</span> <span class="dv">3</span>)) (<span class="dt">Int</span> <span class="dv">4</span>)) (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">5</span>) (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">6</span>) (<span class="dt">Int</span> <span class="dv">7</span>))))

ghci<span class="fu">&gt;</span> runParser pgm S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;1 + 2 + 3 4&quot;</span>
<span class="dt">Right</span> (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">1</span>) (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">2</span>) (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">3</span>) (<span class="dt">Int</span> <span class="dv">4</span>))))</code></pre>]]></summary>
</entry>
<entry>
    <title>Combining digestive-functors and heist with Snap (continued from last tutorial)</title>
    <link href="http://osa1.net/posts/2014-01-04-combining-df-heist-snap-cont.html" />
    <id>http://osa1.net/posts/2014-01-04-combining-df-heist-snap-cont.html</id>
    <published>2014-01-04T00:00:00Z</published>
    <updated>2014-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s an high-level overview of last post:</p>
<ul>
<li>We used digestive-functors for handling form validation and digestive-functors-heist for rendering Heist templates with digestive-funtors forms.</li>
<li>A digestive-functor form has type <code>Form v m a</code> where <code>v</code> is type of error messages, <code>m</code> is the monad type that are used in validation functions, <code>a</code> is return type of a valid form. In our example, <code>a</code> was <code>User</code> since our form was to create a <code>User</code> object. In order to render HTML from a <code>Form</code>, we had to generate a <code>View v</code> object, using <code>getForm</code> or <code>postForm</code> functions from digestive-functors package(<code>Text.Digestive.View</code> module). Once we had a our <code>View</code>, we can use <code>digestiveSplices</code> function from digestive-functors-heist package to get Heist splices of our form. (note: for some type mismatch problem, we had to use <code>bindDigestiveSplices</code> to bind our splices to a Heist state directly, instead of getting splices using <code>digestiveSplices</code> and then binding using some Heist functions) The rest is related with Hesit template rendering.</li>
<li>In Heist site, we had to create a HeistState object which keeps track of compiled and interpreted splices, template paths and some other things.</li>
<li>We then rendered our forms using <code>renderTemplate</code>, binding our form splices to HeistState using <code>bindDigestiveSplices</code>.</li>
</ul>
<p>In this post, I’m going to add some functionalities from Snap to serve HTML pages from a server and handle routing and POST request processing. Our forms will be served at root and when we submit our form, we will be informed whether user creating was successful or what was the problem.</p>
<p>Recommended way fo starting a Snap applcation is by using <code>snap init</code> command. It creates a cabal project structure with <code>Application.hs</code>, <code>Site.hs</code> and <code>Main.hs</code>. According to Snap docs, we only rarely need to touch <code>Main.hs</code>. The other two files are used to create a new Snaplet, and only function we need to provide to <code>Main</code> module is <code>app :: SnapletInit App App</code> for some <code>App</code> type.</p>
<p>In this post I’m assuming you created a Snap project using <code>snap init</code> command and have <code>Main.hs</code> file. You don’t need <code>Application.hs</code> file and in this post we’ll be writing <code>Site.hs</code> file.</p>
<p>Required for some Snap features</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell     #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Tut2</span> (app) <span class="kw">where</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Control.Applicative</span>        (<span class="dt">Applicative</span> (..), (&lt;$&gt;))
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Maybe</span>                 (isJust)
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Text</span>                  <span class="kw">as</span> <span class="dt">T</span></code></pre>
<p>from `digestive-functors’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Text.Digestive</span></code></pre>
<p>from `digestive-functors-heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Text.Digestive.Heist</span>       (bindDigestiveSplices)</code></pre>
<p>from <code>lens</code> package, required for Snaplets</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Control.Lens</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Snap.Snaplet</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Snap.Snaplet.Heist</span></code></pre>
<p>from <code>bytestring</code> package, required for some Snap functions</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.ByteString</span>            <span class="kw">as</span> <span class="dt">B</span></code></pre>
<p>from <code>digestive-functors-snap</code> package, required for form rendering, we had handled that using <code>getForm</code> and <code>postForm</code> from <code>Text.Digestive.Heist</code> before.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Text.Digestive.Snap</span>        (runForm)</code></pre>
<p><code>snap init</code> creates a project with only this code in <code>Application.hs</code>:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span>
<span class="ot">&gt;</span>     { _<span class="ot">heist ::</span> <span class="dt">Snaplet</span> (<span class="dt">Heist</span> <span class="dt">App</span>)
<span class="ot">&gt;</span>     }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> makeLenses <span class="ch">&#39;&#39;</span><span class="dt">App</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">HasHeist</span> <span class="dt">App</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     heistLens <span class="fu">=</span> subSnaplet heist</code></pre>
<p>In this post I’m copying this code to <code>Site.hs</code> and removing <code>Application.hs</code> file. Here, I only changed the definition of <code>App</code>. Since our application is minimal, we only need Heist Snaplet nested in our App. When we need other functionalities in the future(like database access), we will extend this definition for new Snaplets.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; app ::</span> <span class="dt">SnapletInit</span> <span class="dt">App</span> <span class="dt">App</span></code></pre>
<p>First type parameter of SnapletInit is for type of parent Snaplet. In our case, we don’t have a parent Snaplet but I guess this is what you do in that case. Second type is currently initialized Snaplet’s type.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> app <span class="fu">=</span> makeSnaplet <span class="st">&quot;app&quot;</span> <span class="st">&quot;An snaplet example application&quot;</span> <span class="dt">Nothing</span> <span class="fu">$</span> <span class="kw">do</span></code></pre>
<p>Type of <code>makeSnaplet</code> is really helpful to understand what’s going on at the level of types:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">makeSnaplet
<span class="ot">  ::</span> <span class="dt">T.Text</span>                  <span class="co">-- ^ Default ID of the Snaplet, I have no idea where is this used.</span>
     <span class="ot">-&gt;</span> <span class="dt">T.Text</span>               <span class="co">-- ^ Description of the Snaplet, again, no idea where is this used.</span>
     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">IO</span> <span class="dt">FilePath</span>)  <span class="co">-- ^ Root folder for Snaplet&#39;s filesystem content. In case your Snaplet works on files.</span>
     <span class="ot">-&gt;</span> <span class="dt">Initializer</span> b v v    <span class="co">-- ^ Initializer for the Snaplet.</span>
     <span class="ot">-&gt;</span> <span class="dt">SnapletInit</span> b v      <span class="co">-- ^ SnapletInit is an opaque type for internal use. It&#39;s needed for embedding our snaplet to other snaplets.</span></code></pre>
<p>We’re nesting Heist snaplet provided by <code>Snap.Snaplet.Heist</code> from <code>snap</code> package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    h <span class="ot">&lt;-</span> nestSnaplet <span class="st">&quot;&quot;</span> heist <span class="fu">$</span> heistInit <span class="st">&quot;templates&quot;</span></code></pre>
<p>self explanatory, see definition below</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    addRoutes routes
<span class="ot">&gt;</span>    return <span class="fu">$</span> <span class="dt">App</span> h
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;    routes ::</span> [(<span class="dt">B.ByteString</span>, <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ())]</code></pre>
<p>routes are how we handle requests. <code>Handler</code> type takes 3 arguments, but I’m yet to figure out what do these arguments mean. I guess these are same as arguments in <code>SnapletInit</code> type, except the last one is for return values of Handler functions.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    routes <span class="fu">=</span> [ (<span class="st">&quot;/&quot;</span>, mainHandler) ]</code></pre>
<p><code>mainHandler</code> is our handler function. Thanks to <code>runForm</code> function provided by <code>Text.Digestive.Snap</code>, we don’t need to anything because it handles POST/GET requests and renders form templates depending on request data. <code>heistLocal</code> function is provided by <code>Snap.Snaplet.Heist</code> and runs a handler action(in our case, this is <code>render &quot;user_form&quot;</code>) on a modified Heist state. We’re modifying Heist state by binding our user form splices using <code>bindDigestiveSplices</code> as we did in previous post.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mainHandler ::</span> <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ()
<span class="ot">&gt;</span> mainHandler <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     (formView, maybeUser) <span class="ot">&lt;-</span> runForm <span class="st">&quot;userform&quot;</span> userForm
<span class="ot">&gt;</span>     heistLocal (bindDigestiveSplices formView) <span class="fu">$</span> render <span class="st">&quot;user_form&quot;</span></code></pre>
<p>This is some code from previous post.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     {<span class="ot"> uUsername ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uEmail    ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uKarma    ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     } <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; userForm ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">T.Text</span> m <span class="dt">User</span>
<span class="ot">&gt;</span> userForm <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;$&gt;</span> <span class="st">&quot;username&quot;</span>  <span class="fu">.:</span> text <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span>     <span class="fu">.:</span> check <span class="st">&quot;invalid email&quot;</span> validateEmail (text <span class="dt">Nothing</span>)
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> pure <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     validateEmail ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>     validateEmail <span class="fu">=</span> isJust <span class="fu">.</span> T.find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)</code></pre>
<p>As last thing, we need to copy our template file to <code>snaplets/heist/templates</code>. This is because of the way Snap handles Snaplets. I think what happens is for every Snaplet nested in a Snap application, Snap creates a folder in <code>snaplets/snaplet_name</code> and later when that Snaplet requires some filesystem operations, all paths are handled relative to this directory.</p>
<p>After that, if you compile and run the application, you can see our form at http://0.0.0.0:8000 and you can test error messages.</p>]]></summary>
</entry>

</feed>
