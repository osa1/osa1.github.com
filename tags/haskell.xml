<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged haskell</title>
    <link href="http://osa1.net/tags/haskell.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/haskell.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-07-07T00:00:00Z</updated>
    <entry>
    <title>fmap fix return</title>
    <link href="http://osa1.net/posts/2013-07-07-fmap-fix-return.html" />
    <id>http://osa1.net/posts/2013-07-07-fmap-fix-return.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While floating across the internets, I came across a blog with title <code>fmap fix return</code>. I immediately run ghci and queried it’s type:</p>
<pre class="ghci"><code>ghci&gt; :t fmap fix return
fmap fix return :: a -&gt; a</code></pre>
<p>We know that only value with type <code>forall a. a -&gt; a</code> (other than bottom) is identity function(<code>id</code> in Haskell). I found it very interesting, <code>fmap fix return</code> gives us identity function!</p>
<p>I got a pen and paper and started evaluating expressions to understand how does that give us the identity function.</p>
<p>First, let’s note our actors:</p>
<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- instance specific implementation

fix  :: (a -&gt; a) -&gt; a
fix f = let x = f x in x

return :: Monad m =&gt; a -&gt; m a
-- instance specific implementation</code></pre>
<p>A very important thing to realize at this point is which monad and functor instances are used for <code>return</code> and <code>fmap</code>. To realize this, observe that we get a function as return value of <code>fmap</code>. Which means <code>Functor f =&gt; f b</code> is <code>a -&gt; a</code>, or written in a different style to see it’s functor property: <code>((-&gt;) a) a</code>, so our functor here is <code>(-&gt;) a</code>.</p>
<p>After that, we need to look up functor and monad instances for <code>(-&gt;) a</code>. Since it’s 2:30 AM here, I wanted to derive that too.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
     <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>It’s very easy to derive just by looking specialized version of <code>fmap</code>s type for <code>((-&gt;) a)</code>: <code>fmap :: (a1 -&gt; b) -&gt; (a -&gt; a1) -&gt; (a -&gt; b)</code>.</p>
<p>We can easily prove that it satisfies functor laws:</p>
<pre><code>fmap id f
= id . f
= f

fmap (p . q) &lt;-&gt; (fmap p) . (fmap q)
(fmap p) . (fmap q) f
= fmap p . (q . f)
= p . q . f
= fmap (p . q) f</code></pre>
<p>Monad instance can also be derived from types of <code>return</code> and <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
    <span class="fu">return</span>   <span class="fu">=</span> <span class="fu">const</span>
    f <span class="fu">&gt;&gt;=</span> fn <span class="fu">=</span> \r <span class="ot">-&gt;</span> fn (f r) r</code></pre>
<p>(I found Monad instance of <code>((-&gt;) a)</code> very interesting, especially the <code>&gt;&gt;=</code> part. I couldn’t come up with a problem that makes use of this instance, I’ll investigate that after some sleep)</p>
<p>It satisfies monad laws:</p>
<pre><code>-- left identity
return a &gt;&gt;= f
= const a &gt;&gt;= f
= \r -&gt; f ((const a) r) r
= \r -&gt; f a r
= f a

-- right identity
m &gt;&gt;= return
= \r -&gt; return (m r) r
= \r -&gt; (const (m r) r)
= \r -&gt; m r
= m

-- associativity
(m &gt;&gt;= f) &gt;&gt;= g &lt;-&gt; m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

let&#39;s first write `p` for `m &gt;&gt;= f`

= p &gt;&gt;= g
= \r1 -&gt; g (p r1) r1

let&#39;s also evaluaute p

p = m &gt;&gt;= f
= \r2 -&gt; f (m r2) r2

substitute new p

= \r1 -&gt; g ((\r2 -&gt; f (m r2) r2) r1) r1
= \r1 -&gt; g (f (m r1) r1) r1
= \r -&gt; g (f (m r) r) r

now let&#39;s also evaluate right hand side of equation

m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
= m &gt;&gt;= (\x -&gt; (    f x &gt;&gt;= g    )) -- just added a paren for clarity
= m &gt;&gt;= (\x -&gt; (\r -&gt; g (f x r) r))

let write `p` for `\x -&gt; (\r -&gt; g (f x r) r)`

= m &gt;&gt;= p
= \r1 -&gt; p (m r1) r1

put p back

= \r1 -&gt; (\x -&gt; (\r -&gt; g (f x r) r)) (m r1) r1
= \r1 -&gt; (\r -&gt; g (f (m r1) r)) r1
= \r1 -&gt; g (f (m r1) r1)</code></pre>
<p>For those who have no idea what’s above, I’m basically proving some equalities by substituting expressions with their equivalents. This is a benefit for working on a purely functional language, which means referential transparency.</p>
<p>OK, now with these <code>return</code> and <code>fmap</code> implementations in mind, let’s evaluate <code>fmap fix return</code>:</p>
<pre><code>fmap fix return
= fix . return
= \r -&gt; fix (return r)
= \r -&gt; fix (const r)
= \r -&gt; (\f = let x = f x in x) (const r)
= \r -&gt; let x = (const r) x in x

since `const a _ = a`, we have x = r here

= \r -&gt; r</code></pre>
<p>.. which is the identity function.</p>
<p>Thus <code>fmap fix return</code> demystified.</p>]]></summary>
</entry>
<entry>
    <title>Shen.hs FFI</title>
    <link href="http://osa1.net/posts/2013-06-29-shenhs-ffi.html" />
    <id>http://osa1.net/posts/2013-06-29-shenhs-ffi.html</id>
    <published>2013-06-29T00:00:00Z</published>
    <updated>2013-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Shen.hs now has a simple way to call Haskell functions. As an example, I removed some non-standard KLambda functions from <a href="https://github.com/osa1/Shen.hs/blob/master/src/KLambda/Fun.hs"><code>Fun.hs</code></a>(standard primitive functions are defined there). Instead, they live in a <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs">separate module</a> now, and I load them in run-time when I’m debugging.</p>
<h2 id="how-it-works">How it works</h2>
<p>Shen.hs is now exports it’s modules as a library. This is required to allow writing Shen.hs functions in Haskell.</p>
<p><code>KLambda.Types</code> module export all required type information to start writing Shen.hs functions in Haskell. All your functions should have the type <code>KlFun1</code>. To make converting Haskell functions with higher arity(ie. <code>KlFun2</code>, <code>KlFun3</code>) to <code>KlFun1</code>, all <code>KlFun</code> instances now have a <code>mkFun1 :: a -&gt; KlFun1</code> method.</p>
<p>As an example, <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs"><code>Debug.hs</code></a> module functions with types <code>KlFun2</code>, <code>KlFun3</code> etc. To call them from within Shen.hs, they are all wrapped with <code>mkFun1</code> function.</p>
<p>After defining functions with type <code>KlFun1</code> and compiling it, you should call <code>dynload</code> primitive to load functions. Here’s an example session that demonstrates loading and using debugging functions:</p>
<pre><code>$ Shen.hs --shen &quot;/home/omer/Shen/hs_yeni/K Lambda&quot;
loading file: /home/omer/Shen/hs_yeni/K Lambda/toplevel.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/core.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sys.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sequent.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/yacc.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/reader.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/prolog.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/track.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/load.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/writer.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/macros.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/declarations.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/t-star.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/types.kl ...loaded.

Shen 2010, copyright (C) 2010 Mark Tarver
released under the Shen license
www.shenlanguage.org, version 12
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan


(0-) (cd &quot;/home/omer/Shen/hs_yeni/dynload_test&quot;)
&quot;/home/omer/Shen/hs_yeni/dynload_test/&quot;

(1-) (dynload &quot;Debug.o&quot; &quot;debug1F&quot;)
&lt;function&gt;

(2-) (debug1F &quot;calling haskell function -- &quot; 1 2)
calling haskell function -- 1 :: TyNum

2

(3-)</code></pre>
<p>Note that you need both <code>.hi</code> and <code>.o</code> files to be able to load the library dynamically.</p>
<h2 id="status-of-shen.hs">Status of Shen.hs</h2>
<p>Before this additional feature I had fixed a bug and now Shen.hs fails in 8 tests in Test Suite distributed with Shen source. All errors are related and probably there is only one bug. Unfortunately narrowing bug’s scope is very hard at this point. Pull requests are welcome.</p>
<p>If you encounter any bugs please open an issue in <a href="https://github.com/osa1/Shen.hs">Github repository</a>.</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: Shen.hs -- Haskell port of Shen</title>
    <link href="http://osa1.net/posts/2013-06-21-ann-shen-hs.html" />
    <id>http://osa1.net/posts/2013-06-21-ann-shen-hs.html</id>
    <published>2013-06-21T00:00:00Z</published>
    <updated>2013-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m copying <a href="https://groups.google.com/forum/?hl=en#!topic/qilang/GKVN4E_ntWw">my email</a> sent to Shen mailing list:</p>
<blockquote>
<p>Hi all,</p>
<p>I had started writing a port of Shen in Haskell some time ago. Unfortunately it never reached a stable state. And now I can’t spare enough time to fix bugs and improve performance. So I thought maybe it’s a good time to announce it and wait for contributions.</p>
<p>By ‘not stable’ I don’t mean it’s in a terrible state. For example, Shen test suite runs with following results:</p>
<pre><code>passed ... 94.0 
failed ...34.0 
pass rate ...73.4375% </code></pre>
<p>.. it’s not hopelessly bad. It probably has one or two deadly bugs and that causes dozens of tests to fail.</p>
<p>Anyway, that’s it for now. Github repository is here: <a href="https://github.com/osa1/Shen.hs">https://github.com/osa1/Shen.hs</a> .</p>
<p>If you try please tell me your thoughts!</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>A converter from Lua tables to JavaScript objects</title>
    <link href="http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html" />
    <id>http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html</id>
    <published>2013-05-06T00:00:00Z</published>
    <updated>2013-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote a simple Haskell program to convert some data encoded as Lua tables to JavaScript objects/arrays to be used in another project of mine:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span>           Language.Lua.Parser
<span class="kw">import</span>           Language.Lua.Types

<span class="kw">import</span> <span class="kw">qualified</span> Language.ECMAScript3.Syntax       <span class="kw">as</span> JS
<span class="kw">import</span>           Language.ECMAScript3.PrettyPrint  (renderExpression)

<span class="kw">import</span>           System.Environment                (getArgs)
<span class="kw">import</span>           Control.Monad
<span class="kw">import</span>           Prelude                           <span class="kw">hiding</span> (exp)

<span class="ot">unsupported ::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
unsupported <span class="fu">=</span> <span class="fu">error</span> <span class="fu">.</span> (<span class="st">&quot;unsupported exp: &quot;</span> <span class="fu">++</span>) <span class="fu">.</span> <span class="fu">show</span>

<span class="kw">class</span> <span class="dt">ToJsExp</span> a <span class="kw">where</span>
<span class="ot">    toJsExp ::</span> a <span class="ot">-&gt;</span> <span class="dt">JS.Expression</span> ()

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Exp</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Nil</span> _) <span class="fu">=</span> <span class="dt">JS.NullLit</span> ()
    toJsExp (<span class="dt">Bool</span> _ bool) <span class="fu">=</span> <span class="dt">JS.BoolLit</span> () bool
    toJsExp (<span class="dt">Number</span> _ num) <span class="fu">=</span> <span class="dt">JS.NumLit</span> () (<span class="fu">read</span> num)
    toJsExp (<span class="dt">String</span> _ str) <span class="fu">=</span> <span class="dt">JS.StringLit</span> () str
    toJsExp (<span class="dt">TableConst</span> _ table) <span class="fu">=</span> toJsExp table
    toJsExp unsupportedexp <span class="fu">=</span> unsupported (<span class="fu">fmap</span> (<span class="fu">const</span> ()) unsupportedexp)

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Table</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Table</span> _ fields)
      <span class="fu">|</span> <span class="fu">all</span> arrField fields <span class="fu">=</span>
          <span class="dt">JS.ArrayLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">Field</span> _ <span class="fu">exp</span>) <span class="ot">-&gt;</span> toJsExp <span class="fu">exp</span>) fields
      <span class="fu">|</span> <span class="fu">all</span> objField fields <span class="fu">=</span>
          <span class="dt">JS.ObjectLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">NamedField</span> _ (<span class="dt">Name</span> _ name) <span class="fu">exp</span>) <span class="ot">-&gt;</span> (<span class="dt">JS.PropId</span> () (<span class="dt">JS.Id</span> () name), toJsExp <span class="fu">exp</span>)) fields
      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> unsupported (<span class="fu">map</span> (<span class="fu">fmap</span> (<span class="fu">const</span> ())) fields)

      <span class="kw">where</span>
        arrField <span class="dt">Field</span>{} <span class="fu">=</span> <span class="kw">True</span>
        arrField _       <span class="fu">=</span> <span class="kw">False</span>

        objField <span class="dt">NamedField</span>{} <span class="fu">=</span> <span class="kw">True</span>
        objField _            <span class="fu">=</span> <span class="kw">False</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    contents <span class="ot">&lt;-</span> <span class="fu">readFile</span> (<span class="fu">head</span> args)
    <span class="kw">case</span> parseText <span class="fu">exp</span> contents <span class="kw">of</span>
      <span class="kw">Left</span> err <span class="ot">-&gt;</span> <span class="fu">print</span> err
      <span class="kw">Right</span> result <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> renderExpression <span class="fu">$</span> toJsExp result</code></pre>
<p>It uses <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>, a Lua parser and pretty-printer which I wrote to use in some other project of mine(a static analysis tool for Lua, I have big plans about it) and <a href="http://hackage.haskell.org/package/language-ecmascript">language-ecmascript</a>, JavaScript parser and pretty-printer.</p>]]></summary>
</entry>
<entry>
    <title>Weirdest bug</title>
    <link href="http://osa1.net/posts/2013-04-25-weirdest-bug.html" />
    <id>http://osa1.net/posts/2013-04-25-weirdest-bug.html</id>
    <published>2013-04-25T00:00:00Z</published>
    <updated>2013-04-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Haskell implementation of Shen is stuck because of some weird bugs. I think most of them are related with lazy io.</p>
<p>Weird bug #1: Print functions print not when they’re called, but at some later time. This causes Shen repl to take some input, and then print prompt line:</p>
<pre><code>(+ 1 2)
(0.0-) 3.0</code></pre>
<p>Shen REPL is defined in KLambda source, so we can know it’s implemented correctly. Also, KLambda REPL I wrote in Haskell doesn’t have this kind of problem(it prints the prompt, then gets user input).</p>
<p>Weird bug #2: <strong>REMOVED.</strong> When read this post second time after several hours, I realized his same as <em>Weird bug #3</em>. Writing really helps :-)</p>
<p>Weird bug #3: For some reason, <code>shen.read-file-as-bytelist-help</code> still doesn’t end even after printing the bytes. That’s because even if <code>read-byte</code>s return value is <code>-1</code>, <code>else</code> part of the conditional is taken. I have no idea why. Here’s a demonstration:</p>
<p>The file <code>empty.txt</code> is empty:</p>
<pre><code>➜  cat empty.txt
➜</code></pre>
<p>And reading it with <code>read-byte</code> Shen function returns correct value:</p>
<pre><code>➜ shenhs

Shen 2010, copyright (C) 2010 Mark Tarver
www.shenlanguage.org, version 9.2
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan

(= -1 (let stream (open file &quot;empty.txt&quot; in) (read-byte stream)))
(1.0-) true</code></pre>
<p>But reading file with <code>read-file</code> gets stuck in an infinite tail-call:</p>
<pre><code>(read-file &quot;empty.txt&quot;)
(2.0-) ^C</code></pre>
<p>For debugging purposes, I changed <code>shen.read-file-as-bytelist-help</code> and put some prints:</p>
<pre><code>(defun shen.read-file-as-bytelist-help (V2003 V2004 V2005)
  (cond ((= -1 V2004)
         (do
           (pr &quot;-1&lt;nop&gt;&quot; (value *stoutput*))
           V2005))
        (true
         (do
           (pr (str (= -1 V2004)) (value *stoutput*))
           (do
             (pr &quot;&lt;ok&gt;&quot; (value *stoutput*))
             (shen.read-file-as-bytelist-help V2003 (read-byte V2003) (cons V2004 V2005)))))))</code></pre>
<p>It prints <code>false&lt;ok&gt;</code> forever. Now this is strange because as I showed above, <code>read-byte</code> returns <code>-1</code> so <code>(= -1 V2004)</code> should have returned <code>true</code>. Here’s an even more interesting observation:</p>
<pre><code>(shen.read-file-as-bytelist-help -1 -1 -1)
(0.0-) false&lt;ok&gt;TypeError {foundTy = TyNum, expectedTy = TyStream}</code></pre>
<p>Passing <code>-1</code> as <code>V2004</code> still prints <code>false</code>. Now you can think that the problem is at conditionals, but it works fine hundreds of times until the program comes to this function call.</p>
<hr />
<p><strong>UPDATE:</strong> I solved the <code>read-file</code> bug. That was because the lexer was reading <code>-1</code> as a symbol, not a number. You can see the commit <a href="https://github.com/osa1/Shen.hs/commit/8092d2eef874dabc4a706a96f45ef6a3aab460a7">here</a>. (lexer may still have bugs though, it’s not well-tested, maybe I should take my time and read Shen specification in detail.</p>]]></summary>
</entry>
<entry>
    <title>An interesting case of closures: is closed-over variable reference or value?</title>
    <link href="http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html" />
    <id>http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html</id>
    <published>2013-04-24T00:00:00Z</published>
    <updated>2013-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I discovered an interesting behavior of JavaScript’s closures while writing a nodejs script.</p>
<p>This behavior is pretty easy to observe when writing a nodejs application, because of it’s callback-based asynchronous nature, you’ll be writing callbacks all the time. Let’s say I’ll create a callback function which uses a variable defined in outer-scope, then do some actions using that variable:</p>
<pre class="sourceCode JavaScript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>(<span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
    });
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>What I expect from this program is to print <code>foo\nbar\nbaz</code>, but it instead prints <code>baz\nbaz\nbaz</code>. It’s like <code>say</code> variable used inside the callback is a reference and not a value. But it’s still strange because the reference should be local to for-loop’s body, so each <code>var say = ...</code> assignment should create a separate reference.</p>
<p>I find this behavior very counterintuitive. Before moving to solutions to fix this, I tried same program with several other languages.</p>
<p>Python also has this problem<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback():
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>This prints same wrong output as with JavaScript.</p>
<p>Lua, my favorite dynamic language, does great:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">callbacks</span> <span class="ot">=</span> <span class="ot">{}</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">({</span> <span class="st">&quot;foo&quot;</span><span class="ot">,</span> <span class="st">&quot;bar&quot;</span><span class="ot">,</span> <span class="st">&quot;baz&quot;</span> <span class="ot">})</span> <span class="kw">do</span>
  <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">,</span> <span class="kw">function</span> <span class="ot">()</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;say &quot;</span> <span class="ot">..</span> <span class="kw">v</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="kw">end</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">)</span> <span class="kw">do</span>
  v<span class="ot">()</span>
<span class="kw">end</span></code></pre>
<p>It prints <code>foo\nbar\nbaz</code> as expected. Trying this in functional languages may be pointless, since variables are actually not <em>variables</em>(they’re immutable), but it may be still useful for demonstration purposes, here’s the Haskell code that works as expected:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

main <span class="fu">=</span> <span class="fu">sequence_</span> callbacks
  <span class="kw">where</span> callbacks <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">putStrLn</span> <span class="fu">.</span> (<span class="st">&quot;say &quot;</span> <span class="fu">++</span> )) [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]</code></pre>
<p>I’ll show how to get JavaScript’s behavior in languages that handle this right, and in Haskell it’s harder to get this behavior because we will need to use reference cells explicitly.</p>
<p>I think in Python it’s more understandable, because it doesn’t have any scope declarations. ie. we can’t reason about <code>say</code> variable’s scope by the look of it. In JavaScript, we have <code>var</code> keyword that indicates a new variable is created in the scope. But it still works wrong.</p>
<p>Indeed, in JavaScript, the worst language ever, <code>var</code> keyword is just like any other strange JavaScript feature and works in an unexpected way:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">for</span> (<span class="kw">var</span> v <span class="kw">in</span> [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ]) { <span class="ot">console</span>.<span class="fu">log</span>(v); }
<span class="dv">0</span>
<span class="dv">1</span>
<span class="dv">2</span>
&gt; v
<span class="st">&quot;2&quot;</span></code></pre>
<p>So one explanation of this behavior may be this: In Python, we don’t know the scope of variable and it looks like it’s global. So in closure, it works like a reference. And in JavaScript, <code>var</code> keyword is simply broken(and also variable inside closure works like reference).</p>
<h1 id="fixing-it">Fixing it</h1>
<p>Let’s fix that in JavaScript and Python.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>((<span class="kw">function</span> (say) {
      <span class="kw">return</span> <span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
      }
    })(say));
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>Here we’re creating a new scope with function(remember the JavaScript module pattern?), and then passing <code>say</code> variable to it. This guarantees that we have <code>say</code> variable local to the function. Then in callback returned by wrapper function, we have a reference just like before, but it’s not shared with any other functions.</p>
<p>In Python, there’s a cleaner way to do same thing:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback(say=say):
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>Here the parameter is passed implicitly. (to me it’s still very strange and it shouldn’t be working, but for now I’ll just keep this post short)</p>
<h1 id="breaking-it">Breaking it</h1>
<p>Let’s have JavaScript’s behavior in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Data.IORef

printFromRef r <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">=&lt;&lt;</span> readIORef r

mkCallbacks (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
    ref <span class="ot">&lt;-</span> newIORef w
    r   <span class="ot">&lt;-</span> iter ref ws
    <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> r
  <span class="kw">where</span> iter ref []     <span class="fu">=</span> <span class="fu">return</span> []
        iter ref (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
          writeIORef ref w
          cs <span class="ot">&lt;-</span> iter ref ws
          <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> cs

main <span class="fu">=</span> <span class="kw">do</span>
  callbacks <span class="ot">&lt;-</span> mkCallbacks [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]
  <span class="fu">sequence_</span> callbacks</code></pre>
<p>The reason this code is that long is because we need to create and pass references explicitly.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Calling this behavior <em>problem</em> may be a bit wrong, maybe it’s just a design decision. To me it’s a <em>problem</em> because this behavior is really counterintuitive.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Go channel examples ported to Haskell</title>
    <link href="http://osa1.net/posts/2013-04-08-go-ported-haskell.html" />
    <id>http://osa1.net/posts/2013-04-08-go-ported-haskell.html</id>
    <published>2013-04-08T00:00:00Z</published>
    <updated>2013-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been skimming over <a href="http://tour.golang.org/">gotour</a> recently. I think it’s great introduction to language; it’s short, but concise and it shows some of the interesting features of language.</p>
<p>Last part of the tour is about goroutines and channels. My concurrent programming experience is very limited, and since Haskell is my favorite language, I decided to port goroutine examples to Haskell as a learning exercise.</p>
<p>Any criticism would be appreciated.</p>
<h2 id="goroutines"><a href="http://tour.golang.org/#62">62 - Goroutines</a></h2>
<p>This is a very basic example of a program creating two threads and printing some strings.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent
<span class="kw">import</span> Control.Monad

<span class="ot">say ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
say s <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] <span class="fu">$</span> \ _ <span class="ot">-&gt;</span> <span class="kw">do</span>
  threadDelay <span class="dv">100000</span>
  <span class="fu">putStrLn</span> s

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  forkIO <span class="fu">$</span> say <span class="st">&quot;world&quot;</span>
  say <span class="st">&quot;hello&quot;</span></code></pre>
<h2 id="channels"><a href="http://tour.golang.org/#63">63 - Channels</a></h2>
<p>Simple channels example</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent

<span class="ot">sum&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Chan</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
sum&#39; ints chan <span class="fu">=</span> writeChan chan (<span class="fu">sum</span> ints)
<span class="co">-- alternative, `pointfree` style: </span>
<span class="co">-- sum&#39; = flip writeChan . sum</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> lst <span class="fu">=</span> [<span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="fu">-</span><span class="dv">9</span>, <span class="dv">4</span>, <span class="dv">0</span>]
  chan <span class="ot">&lt;-</span> newChan
  <span class="kw">let</span> (l1, l2) <span class="fu">=</span> <span class="fu">splitAt</span> (<span class="fu">floor</span> <span class="fu">$</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> lst) <span class="fu">/</span> <span class="dv">2</span>) lst
  forkIO <span class="fu">$</span> sum&#39; l1 chan
  forkIO <span class="fu">$</span> sum&#39; l2 chan
  x <span class="ot">&lt;-</span> readChan chan
  y <span class="ot">&lt;-</span> readChan chan
  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">unwords</span> [ <span class="fu">show</span> x, <span class="fu">show</span> y, <span class="fu">show</span> <span class="fu">$</span> x <span class="fu">+</span> y ]</code></pre>
<h2 id="buffered-channels"><a href="http://tour.golang.org/#64">64 - Buffered Channels</a></h2>
<p>This is where porting started getting tricky. Haskell channels are basically linked lists, and do not have length or size. In order to get a similar effect, I created a new channel type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent

<span class="co">-- Buffered chan</span>
<span class="kw">data</span> <span class="dt">BChan</span> a <span class="fu">=</span> <span class="dt">BChan</span> {<span class="ot"> chan ::</span> <span class="dt">Chan</span> a,<span class="ot"> size ::</span> <span class="dt">MVar</span> <span class="dt">Int</span>,<span class="ot"> limit ::</span> <span class="dt">Int</span> }

<span class="ot">newBChan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">BChan</span> a)
newBChan bufsize <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newChan
  bvar <span class="ot">&lt;-</span> newMVar <span class="dv">0</span>
  <span class="fu">return</span> <span class="dt">BChan</span>{chan<span class="fu">=</span>chan, size<span class="fu">=</span>bvar, limit<span class="fu">=</span>bufsize}

<span class="ot">readBChan ::</span> <span class="dt">BChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readBChan <span class="dt">BChan</span>{chan, size, limit} <span class="fu">=</span> <span class="kw">do</span>
  ret <span class="ot">&lt;-</span> readChan chan
  modifyMVar_ size <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="fu">return</span> (i<span class="fu">-</span><span class="dv">1</span>)
  <span class="fu">return</span> ret

<span class="ot">writeBChan ::</span> <span class="dt">BChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeBChan bchan<span class="fu">@</span><span class="dt">BChan</span>{chan, size, limit} val <span class="fu">=</span> <span class="kw">do</span>
  size&#39; <span class="ot">&lt;-</span> readMVar size
  <span class="kw">if</span> size&#39; <span class="fu">==</span> limit
    <span class="kw">then</span> <span class="kw">do</span>
      threadDelay <span class="dv">100000</span>
      writeBChan bchan val
    <span class="kw">else</span> <span class="kw">do</span>
      modifyMVar_ size <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="fu">return</span> (i<span class="fu">+</span><span class="dv">1</span>)
      writeChan chan val

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newBChan <span class="dv">2</span>
  writeBChan chan <span class="dv">1</span>
  writeBChan chan <span class="dv">2</span>

  v1 <span class="ot">&lt;-</span> readBChan chan
  <span class="fu">print</span> v1

  v2 <span class="ot">&lt;-</span> readBChan chan
  <span class="fu">print</span> v2</code></pre>
<p>Here one difference is that Haskell doesn’t fail with a “deadlock!!” error when an extra <code>writeBChan</code> operation is added(or one of them is removed), but just waits forever(like in a <em>real</em> deadlock :-P ). I wonder whether there is a way to get an exception like that, it’s awesome.</p>
<h2 id="range-and-close"><a href="http://tour.golang.org/#65">65 - Range and Close</a></h2>
<p>Same as above, Haskell channels are not working like Go channels. I had to simulate Go channels’ behavior.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns, MultiWayIf #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent
<span class="kw">import</span> Control.Monad (liftM)

<span class="co">-- Closable channel</span>
<span class="kw">data</span> <span class="dt">CChan</span> a <span class="fu">=</span> <span class="dt">CChan</span> (<span class="dt">MVar</span> ([a], <span class="dt">Int</span>, <span class="dt">Bool</span>))

<span class="ot">newCChan ::</span> <span class="dt">IO</span> (<span class="dt">CChan</span> a)
newCChan <span class="fu">=</span> liftM <span class="dt">CChan</span> (newMVar ([], <span class="dv">0</span>, <span class="kw">False</span>))

<span class="ot">readCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)
readCChan (<span class="dt">CChan</span> mvar) <span class="fu">=</span> <span class="kw">do</span>
  (contents, size, closed) <span class="ot">&lt;-</span> takeMVar mvar
  <span class="kw">if</span> <span class="fu">|</span> size <span class="fu">==</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> <span class="fu">not</span> closed <span class="ot">-&gt;</span> <span class="kw">do</span>
         putMVar mvar (contents, size, closed)
         readCChan (<span class="dt">CChan</span> mvar)
     <span class="fu">|</span> size <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
         putMVar mvar (contents, size, closed)
         <span class="fu">return</span> <span class="kw">Nothing</span>
     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
         <span class="kw">let</span> r <span class="fu">=</span> <span class="fu">head</span> contents
         putMVar mvar (<span class="fu">tail</span> contents, size<span class="fu">-</span><span class="dv">1</span>, closed)
         <span class="fu">return</span> <span class="fu">$</span> <span class="kw">Just</span> r

<span class="ot">writeCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeCChan (<span class="dt">CChan</span> mvar) val <span class="fu">=</span> <span class="kw">do</span>
  (contents, size, closed) <span class="ot">&lt;-</span> takeMVar mvar
  <span class="kw">if</span> closed
    <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;writing to a closed chan&quot;</span>
    <span class="kw">else</span> putMVar mvar (val <span class="fu">:</span> contents, size<span class="fu">+</span><span class="dv">1</span>, closed)

<span class="ot">forChan_ ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
forChan_ cchan f <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> readCChan cchan
  <span class="kw">case</span> v <span class="kw">of</span>
    <span class="kw">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()
    <span class="kw">Just</span> v&#39; <span class="ot">-&gt;</span> f v&#39; <span class="fu">&gt;&gt;</span> forChan_ cchan f

<span class="ot">closeCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
closeCChan (<span class="dt">CChan</span> mvar) <span class="fu">=</span>
    modifyMVar_ mvar <span class="fu">$</span> \(contents, size, closed) <span class="ot">-&gt;</span> <span class="fu">return</span> (contents, size, <span class="kw">True</span>)

<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CChan</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
fib i chan <span class="fu">=</span> <span class="kw">do</span>
    iter i <span class="dv">0</span> <span class="dv">1</span>
    closeCChan chan
  <span class="kw">where</span> iter <span class="dv">1</span> x y <span class="fu">=</span> writeCChan chan x
        iter n x y <span class="fu">=</span> <span class="kw">do</span>
          writeCChan chan x
          iter (n<span class="fu">-</span><span class="dv">1</span>) y (x<span class="fu">+</span>y)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newCChan
  forkIO <span class="fu">$</span> fib <span class="dv">10</span> chan
  forChan_ chan <span class="fu">print</span></code></pre>
<p>This example still doesn’t quite work like Go code. This is because I used a stack instead of a queue. It should be trivial to fix this code though.</p>
<h2 id="select-and-67---default-selection"><a href="http://tour.golang.org/#66">66 - Select</a> and <a href="http://tour.golang.org/#67">67 - Default Selection</a></h2>
<p>Now this is hard. In 66, example program listens multiple channels, and runs some code when any of the channels is ready. If multiple channels are ready at the same time, one of them is chosen randomly. 67 is similar, only difference is when none of the channels are ready, some default action is taken.</p>
<p>I’m actually not sure if it’s implementable with Haskell Chans, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Concurrent-Chan.html#v:isEmptyChan"><code>isEmptyChan :: Chan a -&gt; IO Bool</code></a> is deprecated, and users are directed to TChans(I think it’s mostly same as a Chan, but working on STM).</p>
<p>Anyway, that’s it for now. I’ll go learn(pun intended) some STM, why we need them and what’s different about them, and then maybe I can implement this last two examples.</p>]]></summary>
</entry>
<entry>
    <title>ADTler ve sınıflar: bir örnek</title>
    <link href="http://osa1.net/posts/2013-02-31-adtler-siniflar.html" />
    <id>http://osa1.net/posts/2013-02-31-adtler-siniflar.html</id>
    <published>2013-02-28T00:00:00Z</published>
    <updated>2013-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı, <a href="/rowlar-kindlar/">bir önceki yazım</a> gibi, yine bir mail için yazıldı. Birkaç düzenleme ve eklemeden sonra blog yazısı olarak yayınlıyorum.</p>
<hr />
<p>Bir programlama dili meraklısı olarak sık sık yorumlayıcılar ve nadiren derleyiciler yazıyorum. Derleyici/yorumlayıcı yazarken çok sık yapılan işlemlerden biri şudur:</p>
<p>Programda(derleyici/yorumlayıcıda) kod üzerinde çalışabilmek için son kullanıcı tarafından metin olarak girilmiş kodun üzerinde çalışılabilinecek bir veri yapısına dönüştürülmesi gerekir. Buna “parsing” işlemi diyoruz ve yaptığı iş kısaca metni alıp, abstract syntax tree(AST) dediğimiz bir çeşit ağaç yapısına dönüştürmektir.</p>
<p>Bu aşamadan sonra elimizde bir ağaç yapısı olmuş olur. Fakat burdaki ağaç yapısını veri yapıların dersinde gösterilen “binary tree” vs. yapılarla karıştırmamak lazım, burda çok çeşitli nodelar oluyor ve her bir node farklı özelliklere sahip, her birine ayrı muameleler yapılacak oluyor. (kod örnekleri vereceğim)</p>
<p>Bir yorumlayıcı/derleyicinin bu ağaç yapısı üzerinde defalarca gezinmesi gerekir ve genelde her bir gezinmede farklı işlemler yapılır. Bir tur sonrası ağaç üzerinde değişiklikleri yapılabilir ve bir sonraki turda bu yeni ağaç üzerinden devam edilir vs.</p>
<p>Örnek: Statically typed bir dil için yorumlayıcı yazdığımızda, ilk başta type checker ağaç üzerinde gezerek programın type-safe olduğundan emin olur. Program type-safe ise, ağacın biraz değiştirilmiş hali üzerinde(örneğin type annotationları silinmiş, veya ağacın tagless bir hali) yorumlayıcı çalışır.</p>
<p>Derleyicilerde ise ağaç çok daha fazla sayıda adımlanır. Her bir adımlamada ağaç yapısı değiştirilebilir.<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup></p>
<p>Yani kısaca problem şu: Elimde farklı tiplerde ağaçlar var(örnek: tip bilgilerini içeren, type checking/inference için oluşturulmuş bir ağaç ve tip bilgilerinin büyük oranda silindiği, yorumlama/derleme için kullanılan bir ağaç vs.), bu ağaçlar üzerinde turlar atacağım fakat tur atarken farklı işler yapacağım.</p>
<p>Katkı yaptığım bir derleyici kodundan birkaç örnek vereceğim: Fay, bir Haskell alt kümesinden JavaScript’e derleyici.</p>
<p><a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Compiler/Exp.hs#L21"><code>compileExp</code></a> fonksiyonu, <a href="http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html#g:8"><code>Exp</code></a> ağacı üzerinde gezinir çıktı olarak <a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Types.hs#L242"><code>JsExp</code></a> (yine başka bir ağaç) üretir. Bu bir ağaç üzerinde gezinip farklı işlemler yapıp farklı bir ağaçlar üreten fonksiyonlara bir örnek.</p>
<p><a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Compiler/Optimizer.hs"><code>Optimizer</code></a> modulü çeşitli ağaçlar üzerinde gezinip başka ağaçlar üreten 13 tane fonksiyondan oluşur ve bunların 5-6 tanesi <a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Types.hs#L227"><code>JsStmt</code></a> ağacını dolaşır. Bu da aynı ağaç üzerinde gezinip farklı işlemler yapan fonksiyonlara örnek.</p>
<p>Algebraic data typelara ve pattern matchinge sahip olan fonksiyonel dillerde(yani belki de tüm statically typed fonksiyonel dillerde) bunu yapmanın bir yolunu göstermek için hemen hiçbir işlevi olmayan çok basit bir aritmetik ifade dili oluşturalım:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span>
    <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Float</span></code></pre>
<p>Bu kadar işlevsiz bir dil olamaz. Şimdi bu ağaç üzerinde iki farklı işlem yapan iki fonksiyon:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
run (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> run e1 <span class="fu">+</span> run e2
run (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> run e1 <span class="fu">*</span> run e2
run (<span class="dt">Number</span> f)  <span class="fu">=</span> f</code></pre>
<p><code>run</code> programı çalıştırıp sonucu dönüyor.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringOfExp ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stringOfExp (<span class="dt">Add</span> e1 e2) <span class="fu">=</span>
    <span class="fu">concat</span> [ <span class="st">&quot;(&quot;</span>, stringOfExp e1, <span class="st">&quot; + &quot;</span>, stringOfExp e2, <span class="st">&quot;)&quot;</span> ]
stringOfExp (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span>
    <span class="fu">concat</span> [ <span class="st">&quot;(&quot;</span>, stringOfExp e1, <span class="st">&quot; * &quot;</span>, stringOfExp e2, <span class="st">&quot;)&quot;</span> ]
stringOfExp (<span class="dt">Number</span> f) <span class="fu">=</span> <span class="fu">show</span> f</code></pre>
<p><code>stringOfExp</code> ise programın string halini dönüyor. Örnek:</p>
<pre><code>ghci&gt; let prog1 = Add (Number 10) (Mul (Number 20) (Add (Number 30) (Number 40)))
ghci&gt; run prog1
1410.0
ghci&gt; stringOfExp prog1
&quot;(10.0 + (20.0 * (30.0 + 40.0)))&quot;</code></pre>
<p>Yarın ağaca yeni bir node eklediğimde ağaç üzerinde çalışan tüm fonksiyonları güncellemem gerekecek.</p>
<p>Herkes için son derece basittir sanıyorum. Şimdi aynısını ADT’lara sahip olmayan, OO bir dil ile yazalım.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Exp { <span class="co">// base class for expressions</span>
<span class="kw">public</span>:
  <span class="kw">virtual</span> ~Exp() {}
};

<span class="kw">class</span> AddExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  AddExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
};

<span class="kw">class</span> MulExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  MulExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
};

<span class="kw">class</span> Number : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> <span class="dt">float</span> f;
  Number(<span class="dt">const</span> <span class="dt">float</span> f) : f(f) {}
};</code></pre>
<p>Örnek programımız da şu şekilde yazılabilir:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Exp *prog1 = <span class="kw">new</span> AddExp(
    <span class="kw">new</span> Number(<span class="dv">10</span>), <span class="kw">new</span> MulExp(
      <span class="kw">new</span> Number(<span class="dv">20</span>), <span class="kw">new</span> AddExp(
        <span class="kw">new</span> Number(<span class="dv">30</span>), <span class="kw">new</span> Number(<span class="dv">40</span>))));</code></pre>
<p>Peki bu ağaç üzerinde gezinmek nasıl mümkün olabilir ? Bir kere, tüm nodelar alt node olarak <code>Exp</code> tipinde bir nesne tutuyor, kesin tip bilgisine sahip değiliz ve bu tip bilgisine sahip olmadan da yorumlamak mümkün değil mi, yorumladığımız node <code>Number</code> mı, <code>MulExp</code> mi vs. bilmemiz gerekir.</p>
<p>Bunu yapmanın çeşitli yolları var, ama güzel bir çözümü yok. Örneğin <code>Exp</code> sınıfında nodeların tipini tutan bir enum tutabiliriz ve <code>Exp *</code>leri gerekli tiplere cast ederiz. Veya Java gibi bir dilde <code>instanceof</code> kontrolü yapılıp cast edilebilir. Başka çözümler de bulunabilir.</p>
<p>Bu gibi durumlarda kabul edilen en yaygın çözüm visitor design patternı. Biraz aradığınızda onlarca tutorial bulabilirsiniz ki tutoriala ihtiyaç duyması bile aslında fonksiyonel dildeki çözümümüzden ne kadar kötü olduğunun bir göstergesi sayılabilir(8 satır son derece basit ve açık bir Haskell koduna denk bir iş yapmaya çalışıyoruz şu anda)</p>
<p>Bu probleme <em>double dispatch</em> problemi de deniyor. Sebebi yapacağımız işleme hem yorumlayıcıya, hem de ağaca göre karar vermek istiyoruz fakat bir yandan da ağaçlara ve yorumlayıcılara aynı muameleyi yapabilmeliyiz. C++ örneğinde her bir node’un bir ağaç oluşturduğuna dikkat.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> AddExp;
<span class="kw">class</span> MulExp;
<span class="kw">class</span> Number;

<span class="kw">class</span> ExpVisitor {
<span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) = <span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) = <span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) = <span class="dv">0</span>;

  <span class="kw">virtual</span> ~ExpVisitor() {};
};

<span class="kw">class</span> Exp { <span class="co">// base class for expressions</span>
<span class="kw">public</span>:
  <span class="kw">virtual</span> ~Exp() {}
  <span class="kw">virtual</span> <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> = <span class="dv">0</span>;
};

<span class="kw">class</span> AddExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  AddExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};

<span class="kw">class</span> MulExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  MulExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};

<span class="kw">class</span> Number : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> <span class="dt">float</span> f;
  Number(<span class="dt">const</span> <span class="dt">float</span> f) : f(f) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};</code></pre>
<p>Detaylara çok fazla girmek istemiyorum, kısaca, virtual methodların yardımıyla artık bir nesneyi <code>Exp</code> tipine cast etsek de doğru <code>visit</code> methodları çağırılacak. Buna göre ilk yorumlayıcımızı şu şekilde yazabiliyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Run : <span class="kw">public</span> ExpVisitor {
<span class="kw">public</span>:
  <span class="dt">float</span> result;
  Run() : result(<span class="dv">0</span>) {}

  <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) {
    Run v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    Run v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = v1.result + v2.result;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) {
    Run v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    Run v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = v1.result * v2.result;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) {
    result = exp-&gt;f;
  }
};</code></pre>
<p>Bu arada nesnesel çözümümüzün fonksiyonel çözümümüzden bir başka farkı da burda belli oluyor. Visitorlar arası değer dönmenin bir yolu yok ve bu yüzden buradaki <code>result</code> member değişkeni gibi bir mutable değişken kullanmak zorunda kalıyoruz.</p>
<p>İkinci yorumlayıcımız:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> StringOfExp : <span class="kw">public</span> ExpVisitor {
<span class="kw">public</span>:
  std::string result;
  StringOfExp() : result(<span class="kw">new</span> std::string()) {}

  <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) {
    StringOfExp v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    StringOfExp v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = <span class="st">&quot;(&quot;</span> + v1.result + <span class="st">&quot; + &quot;</span> +  v2.result + <span class="st">&quot;)&quot;</span>;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) {
    StringOfExp v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    StringOfExp v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = <span class="st">&quot;(&quot;</span> + v1.result + <span class="st">&quot; * &quot;</span> +  v2.result + <span class="st">&quot;)&quot;</span>;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) {
    std::ostringstream ss;
    ss &lt;&lt; exp-&gt;f;
    result = ss.str();
  }
};</code></pre>
<p><code>result</code> member değişkeninin tipinin farklı olduğuna dikkat. Buradaki farklılık Haskell fonksiyonlarındaki dönüş tiplerinin farklılığı ile aynı.</p>
<p>Son olarak programı şu şekilde çalıştırabiliyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Run r;
prog1-&gt;accept(&amp;r);
std::cout &lt;&lt; <span class="st">&quot;return value Run: &quot;</span> &lt;&lt; r.result &lt;&lt; std::endl;

StringOfExp s;
prog1-&gt;accept(&amp;s);
std::cout &lt;&lt; <span class="st">&quot;return value of StringOfExp: &quot;</span> &lt;&lt; s.result &lt;&lt; std::endl;</code></pre>
<p>Çıktı:</p>
<pre><code>➜  cpp  clang++ arith.cpp -g
➜  cpp  ./a.out
return value Run: 1410
return value of StringOfExp: (10 + (20 * (30 + 40)))</code></pre>
<p>Burda 14 satır Haskell kodu ile aynı işi yapan 125 satır C++ kodundan bahsediyoruz. Tabii kodun aynı özelliğe sahip olduğunu sadece aynı sonuca ulaşmasına bakarak karar vermiyoruz. Yapı olarak da oldukça benzerler.</p>
<p>Haskell programında ağaca yeni bir node eklemek için ilk başta <code>Exp</code> tipine yeni bir constructor eklememiz gerekecek ve daha sonra tüm yorumlayıcılarda match edilecek bir pattern daha eklenecek.</p>
<p>C++ programında, <code>Exp</code> sınıfından yeni bir sınıf türeteceğiz ve tamamen aynı <code>accept</code> methoduna sahip olacak. <code>ExpVisitor</code> sınıfına da bir <code>visit</code> methodu daha eklememiz gerek. Daha sonra yorumlayıcılara teker teker alakalı <code>visit</code> methodunun eklenmesi gerek.</p>
<p>Haskell fonksiyonlarının dönüş değerleri, Visitor sınıflarının <code>result</code> değişkeni ile eşleşiyor.</p>
<p>Aslında aynı şeylerden bahsediyoruz yani.</p>
<p>C++ kodunun çalışan bir haline <a href="https://gist.github.com/osa1/5005037">şuradan</a> ulaşabilirsiniz.</p>
<p>Alıştırma: Hem Haskell hem C++ programı için, ağaç üzerinde gezinerek “x + 0” ifadesini “x” haline, “x * 1” ifadesini “x” haline, “x * 0” ifadesini “0” haline getirecek yorumlayıcılar yazın. Anlamı koruyacak şekilde daha küçük bir ağaç elde etmiş olacağız. (bu optimizasyonlar gerçek derleyiciler tarafından yapılıyor)</p>
<h1 id="ifade-problemi">İfade problemi</h1>
<p>Yukarıda anlattıklarımın ifade problemi diye tercüme ettiğim <a href="http://en.wikipedia.org/wiki/Expression_problem">expression problem</a> ile de alakalı.</p>
<p>Problemimiz şu, program iki boyutta gelişebiliyor, 1.si veri yapısı boyutunda, yani ağaca yeni nodelar eklemek, 2.si operasyonlar boyutunda, yani yeni yorumlayıcılar eklemek.</p>
<p>Yukarıdaki çözümler aslında birbirlerine denk: İkisinde de veri yapısını değiştirdiğimizde kodu yeniden derlememiz gerekiyor(dolayısıyla kodun elimizde olması gerekiyor), fakat koda sahip olmadan ve yeniden derleme yapmadan yeni operasyon(yani yorumlayıcı ekleyebiliyoruz).</p>
<p>Bu yazının amacı ifade problemi değil, o yüzden en azından şimdilik bahsetmeyeceğim(yazının orjinalinde bu kısım hiç yoktu), fakat aslında oldukça ilginç bir konu ve Haskell’ın ve Lisp dillerinin getirdiği ilginç çözümler var. OO dillerin çözümleri hakkında pek bir bilgim yok.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Aslında tabii yorumlayıcı bir çeşit byte-code üzerinden değil de, AST üzerinden yorumlama yapıyorsa, program çalıştığı sürece AST’yi geziyor demektir ve bu durumda bir derleyiciden çok daha fazla sayıda tur atmış olur. Benim burada kastettiğim çalıştırılmadan önce ön işlem anlamında yapılan gezinmeler.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Haskell örneğinde yorumlayıcıların tipleri farklı olduğundan ikisine aynı muameleyi yapamıyoruz, farkındayım. Tamamen aynı tipte yorumlayıcılar için Fay için verdiğim linklere göz atabilirsiniz.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Separating lexing and parsing stages in Parsec</title>
    <link href="http://osa1.net/posts/2012-08-30-separating-lexing-and-parsing-in-parsec.html" />
    <id>http://osa1.net/posts/2012-08-30-separating-lexing-and-parsing-in-parsec.html</id>
    <published>2012-08-30T00:00:00Z</published>
    <updated>2012-08-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I really love Parsec. After using it several months now, I can’t think of parsing anything other than Parsec.</p>
<p>After I started working on more complex grammars, I thought maybe it could be good idea to separate lexing stage, since it may lead parser with simpler code. After some experimenting, a SO question, and reading some part of Parsec’s source, I finally managed to separate lexing and parsing. Now I’ll explain how to do that.</p>
<p>In lexing stage, other than writing ordinary token parsers, we also need to handle token positions. Each token moves the cursor, and saving this is needed for error reporing(and maybe some other reasons). In our case, simplest tokens are characters, and since we’re using Parsec’s built-in <code>Char</code> token, we don’t need to handle characters’ positions. But we need to save each token’s positions because we won’t be using Char tokens in parsing stage, we will be using our custom tokens.</p>
<p>You can see the full source <a href="https://gist.github.com/3507011">here</a>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">Ide</span> <span class="dt">String</span>
           <span class="fu">|</span> <span class="dt">LBrack</span>
           <span class="fu">|</span> <span class="dt">RBrack</span>
           <span class="fu">|</span> <span class="dt">LBrace</span>
           <span class="fu">|</span> <span class="dt">RBrace</span>
           <span class="fu">|</span> <span class="dt">Keyword</span> <span class="dt">String</span>
    <span class="kw">deriving</span> (<span class="kw">Show</span>, <span class="kw">Eq</span>)</code></pre>
<p>Token types should be instances of <code>Eq</code> to be able to test for equality while parsing, and <code>Show</code> to be able to print in error situations(actually you can use any function for testing for equality and printing, but I find this way easier).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TokenPos</span> <span class="fu">=</span> (<span class="dt">Token</span>, <span class="dt">SourcePos</span>)</code></pre>
<p>So we will be using <code>(Token, SourcePos)</code> pairs for tokens with positions of them in source. Now parsers are simple:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ide ::</span> <span class="dt">Parser</span> <span class="dt">TokenPos</span>
ide <span class="fu">=</span> <span class="kw">do</span>
    pos <span class="ot">&lt;-</span> getPosition
    fc  <span class="ot">&lt;-</span> oneOf firstChar
    r   <span class="ot">&lt;-</span> optionMaybe (many <span class="fu">$</span> oneOf rest)
    spaces
    <span class="fu">return</span> <span class="fu">$</span> <span class="fu">flip</span> (,) pos <span class="fu">$</span> <span class="kw">case</span> r <span class="kw">of</span>
                 <span class="kw">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Ide</span> [fc]
                 <span class="kw">Just</span> s  <span class="ot">-&gt;</span> <span class="dt">Ide</span> <span class="fu">$</span> [fc] <span class="fu">++</span> s
  <span class="kw">where</span> firstChar <span class="fu">=</span> [<span class="ch">&#39;A&#39;</span><span class="fu">..</span><span class="ch">&#39;Z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>] <span class="fu">++</span> <span class="st">&quot;_&quot;</span>
        rest      <span class="fu">=</span> firstChar <span class="fu">++</span> [<span class="ch">&#39;0&#39;</span><span class="fu">..</span><span class="ch">&#39;9&#39;</span>]</code></pre>
<p>This is a simple identifier parser(or lexer). Note the <code>pos &lt;- getPosition</code> part.</p>
<p>After more lexers like this, we need a <code>tokenize</code> function to generate token stream:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tokenize ::</span> <span class="dt">SourceName</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">TokenPos</span>]
tokenize <span class="fu">=</span> runParser tokens ()</code></pre>
<p>In parsing stage, we have several problems. One is that now we can’t use Parsec’s <code>parseTest</code> function, which I almost always use for testing purposes. Because now we need to pass the string to lexer, and then pass it’s output to parser. So I wrote this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Text.Parsec <span class="kw">as</span> P
<span class="fu">...</span>
<span class="ot">parseTest  ::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Parsec</span> [<span class="dt">TokenPos</span>] () a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
parseTest p s <span class="fu">=</span>
    <span class="kw">case</span> tokenize <span class="st">&quot;test&quot;</span> s <span class="kw">of</span>
        <span class="kw">Left</span> e    <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">show</span> e
        <span class="kw">Right</span> ts&#39; <span class="ot">-&gt;</span> P.parseTest p ts&#39;</code></pre>
<p><code>satisfy</code> gets a predicate on token, and return a token parser using Parsec’s <code>tokenPrim</code> function, which takes 3 functions as parameters, one for printing the token(to be used in error reporting), one for updating the current position, and one for returning the result after calling predicate. I adapted this function from Parsec’s string parsers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">advance ::</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> [<span class="dt">TokenPos</span>] <span class="ot">-&gt;</span> <span class="dt">SourcePos</span>
advance _ _ ((_, pos) <span class="fu">:</span> _) <span class="fu">=</span> pos
advance pos _ [] <span class="fu">=</span> pos
<span class="ot">satisfy ::</span> (<span class="dt">TokenPos</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Token</span>
satisfy f <span class="fu">=</span> tokenPrim <span class="fu">show</span>
                      advance
                      (\c <span class="ot">-&gt;</span> <span class="kw">if</span> f c <span class="kw">then</span> <span class="kw">Just</span> (<span class="fu">fst</span> c) <span class="kw">else</span> <span class="kw">Nothing</span>)</code></pre>
<p>Last function, <code>tok</code>, takes a token and returns a token parser:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tok ::</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Token</span>
tok t <span class="fu">=</span> (satisfy <span class="fu">$</span> (<span class="fu">==</span> t) <span class="fu">.</span> <span class="fu">fst</span>) <span class="fu">&lt;?&gt;</span> <span class="fu">show</span> t</code></pre>
<p><code>.. &lt;?&gt; show t</code> part is required for error reporting. See my <a href="http://stackoverflow.com/questions/12167329/haskell-parsec-error-messages-are-less-helpful-while-using-custom-tokens">SO question</a> for details.</p>
<p>Now, when using Parsec, generally there’s no need to separate lexing stage. Because as you can see above, it just makes code more complex, and adds no more flexibility. Instead of writing <code>tok $ Ide &quot;some-identifier&quot;</code>, you can always write <code>ide &quot;some-identifier&quot;</code> with a <code>ide</code> parser.</p>
<p>Still, I think understanding how to make this helps for at least two reasons. First, now you can work on any streams, not just character streams using Parsec’s <code>Char</code> token. And second, writing lexers can still help in some situations, like parsing indentation-based grammars. In that case, you can generate indent-dedent tokens in lexing stage, and make parser code more clean because it will be less <em>context-dependent</em> (I never tried that with Parsec, though) .</p>]]></summary>
</entry>
<entry>
    <title>Some GHC extensions I use</title>
    <link href="http://osa1.net/posts/2012-07-31-some-ghc-extensions.html" />
    <id>http://osa1.net/posts/2012-07-31-some-ghc-extensions.html</id>
    <published>2012-07-31T00:00:00Z</published>
    <updated>2012-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>GHC is a huge compiler. On GHC 7.4.1, I can see 85 optional language extensions<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Some of them are just adding some syntactic sugar(<code>NamedFieldPuns</code>, <code>RecordWildCards</code>), and some of them are extensions to type system(<code>GADTs</code>, <code>Rank2Types</code>). As a new Haskeller, I only know and use a small subset of this features, and in this post I’ll write about it.</p>
<h3 id="namedfieldpuns-and-recordwildcards">NamedFieldPuns and RecordWildCards</h3>
<p>This is some really simple syntactic sugar for pattern matching some names in records. Normally you’d do:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">someFun ::</span> <span class="dt">T</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
someFun <span class="dt">T</span>{n2<span class="fu">=</span>n2, n3<span class="fu">=</span>n3} <span class="fu">=</span> (n2, n3)</code></pre>
<p>But instead of assigning some names to members of a record with same names, with help of <code>NamedFieldPuns</code>, you could just write:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">someFun ::</span> <span class="dt">T</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
someFun <span class="dt">T</span>{n3, n2} <span class="fu">=</span> (n2, n3)</code></pre>
<p>It’s that simple. <code>RecordWildCards</code> doing something similar. Instead of writing <code>someFun T{n1,n2,n3}</code>, you just write <code>someFun T{..}</code>.</p>
<p>These are purely syntactic, so they can be used for any place that you can use pattern matching or destructuring(ie. <code>let .. in ..</code> or <code>where</code> clauses). Really helpful when working on data constructors that have 4+ members.</p>
<p>Most interesting use of <code>RecordWildCards</code> I’ve seen was <a href="http://hpaste.org/71626">this implementation</a> of localised module imports(I think this implementation can also be used for first-class modules).</p>
<h3 id="overloadedstrings">OverloadedStrings</h3>
<p>This really helps when working on <a href="http://hackage.haskell.org/package/text-0.11.2.2"><code>Text</code></a> data. When you are passing a function a <code>Text</code> data, instead of using <code>pack &quot;some string&quot;</code>, you can just use <code>&quot;some string&quot;</code> and compiler resolves the type of the string, adds required code etc.</p>
<p>Basically it provides a way to create instances of <code>class IsString a where fromString :: String -&gt; a</code> using string syntax. It’s mostly used with <code>Data.Text</code>, <code>ByteString.Text</code> etc.</p>
<h3 id="gadts">GADTs</h3>
<p>This is by far my favorite type system extension. This is mostly because I’m working on an interpreter, and GADTs are great for representing syntax trees.</p>
<p>To understand advantages of GADTs, first let’s think about how we can represent syntax tree for a simple language. Let some part of our sytax be(in a BNF-like format):</p>
<pre><code>&lt;var&gt;   = String
&lt;abst&gt;  = &quot;(&quot; &quot;λ&quot; &quot;(&quot; {&lt;var&gt; [&quot; &quot;]}* &quot;)&quot; &lt;term&gt; &quot;)&quot;
&lt;app&gt;   = &quot;(&quot; &lt;term&gt; {&lt;term&gt; [&quot; &quot;]}* &quot;)&quot;
&lt;term&gt;  = &lt;var&gt; | &lt;abst&gt; | &lt;app&gt;</code></pre>
<p>So, variables, lambda abstractions, and applications. Just like in untyped lambda calculus. Now let’s try to encode this format in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">String</span>
          <span class="fu">|</span> <span class="dt">Abst</span> [<span class="fu">??</span>] <span class="dt">Term</span>
          <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Term</span> <span class="dt">Term</span></code></pre>
<p>What should we write in place of <code>??</code> ? Writing <code>Term</code> is obviously wrong, since then we could be ill-formed data(for instance, think about a syntax like that: <code>(λ ((λ (a) ..)) ...)</code> we used lambda abstraction in place of lambda parameter names).</p>
<p>If the term <code>var</code> just consists of a String, then we can directly use String as a first member of <code>Abst</code> constructor, but think term <code>var</code> as a really complex constructor. I’m trying to make examples as clear and simple as possible.</p>
<p>One way to fix that is to use “smart constructors”. What this really means is that we can hide some data constructors in our module(ie. write exported names in module explicitly) and export some constructor function in place of them. With the help of a trick we can give users a more controlled way of creating data(in our case this means that we can prevent caller from creating ill-formed syntax tree).</p>
<p>First, let’s see the data type trick:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T1</span>
<span class="kw">data</span> <span class="dt">T2</span>
<span class="kw">data</span> <span class="dt">SomeData</span> a <span class="fu">=</span> <span class="dt">Data1</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Data2</span> <span class="dt">Int</span>
  <span class="kw">deriving</span> <span class="kw">Show</span></code></pre>
<p>This is interesting because data types T1 and T2 don’t have any constructors. So there is literally no way to create data in that types. Second interesting point in <code>SomeData a</code> is, the <code>a</code> variable is not used by data constructors(<code>Data1</code> and <code>Data2</code>). This code still works:</p>
<pre><code>ghci&gt; :t Data1 &quot;ok&quot;
Data1 &quot;ok&quot; :: SomeData a
ghci&gt; :t Data2 123
Data2 123 :: SomeData a
ghci&gt; Data1 &quot;ok&quot; :: SomeData Int
Data1 &quot;ok&quot;
ghci&gt; Data1 &quot;ok&quot; :: SomeData Char
Data1 &quot;ok&quot;</code></pre>
<p>If we could find a way to distinguish types of data created with <code>Data1</code> and <code>Data2</code>, we’re done. This is where smart constructors take place:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">data1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeData</span> <span class="dt">T1</span>
data1 <span class="fu">=</span> <span class="dt">Data1</span>
<span class="ot">data2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeData</span> <span class="dt">T2</span>
data2 <span class="fu">=</span> <span class="dt">Data2</span></code></pre>
<p>We’re telling to compiler that data created with <code>data1</code> constructor will be the type of <code>SomeData T1</code>. Now if we hide <code>Data1</code> and <code>Data2</code> data constructors and export <code>data1</code> and <code>data2</code> functions, there is no way for user create ill-formed data types like <code>Data1 &quot;ok&quot; :: SomeData SomeUnrelatedType</code> like we done in past example.</p>
<pre><code>ghci&gt; data1 &quot;ok&quot; :: SomeData Int

&lt;interactive&gt;:48:1:
    Couldn&#39;t match expected type `Int&#39; with actual type `T1&#39;
    Expected type: SomeData Int
      Actual type: SomeData T1
    In the return type of a call of `data1&#39;
    In the expression: data1 &quot;ok&quot; :: SomeData Int</code></pre>
<p>Now we can encode our syntax in Haskell like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Var</span>
<span class="kw">data</span> <span class="dt">Abst</span>
<span class="kw">data</span> <span class="dt">App</span>
<span class="kw">data</span> <span class="dt">AnyTerm</span>
<span class="kw">data</span> <span class="dt">Term</span> a <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">String</span>
            <span class="fu">|</span> <span class="dt">Abst</span> [<span class="dt">Term</span> <span class="dt">Var</span>] (<span class="dt">Term</span> <span class="dt">AnyTerm</span>)
            <span class="fu">|</span> <span class="dt">App</span> (<span class="dt">Term</span> <span class="dt">AnyTerm</span>) (<span class="dt">Term</span> <span class="dt">AnyTerm</span>)
<span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Var</span>
var <span class="fu">=</span> <span class="dt">Var</span>
<span class="ot">abst ::</span> [<span class="dt">Term</span> <span class="dt">Var</span>] <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Abst</span>
abst <span class="fu">=</span> <span class="dt">Abst</span>
<span class="ot">app ::</span> <span class="dt">Term</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">App</span>
app <span class="fu">=</span> <span class="dt">App</span>
anyTerm <span class="fu">=</span> <span class="fu">id</span></code></pre>
<p>Now I’m omitting some parts without explaining since this post is already long enough. But the point should be clear by now. Let’s see this in action:</p>
<pre><code>ghci&gt; abst [(abst [var &quot;p1&quot;] (anyTerm (var &quot;p1&quot;)))] (anyTerm (var &quot;somevar&quot;))

&lt;interactive&gt;:63:8:
    Couldn&#39;t match expected type `Var&#39; with actual type `Abst&#39;
    Expected type: Term Var
      Actual type: Term Abst
    In the return type of a call of `abst&#39;
    In the expression: (abst [var &quot;p1&quot;] (anyTerm (var &quot;p1&quot;)))</code></pre>
<p>Nice! Just like what we wanted. GADTs help for creating smart “data constructors” so that we don’t have to hide data constructors and export some smart constructor functions. Here’s the same code with GADTs:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Var</span>
<span class="kw">data</span> <span class="dt">Abst</span>
<span class="kw">data</span> <span class="dt">App</span>
<span class="kw">data</span> <span class="dt">Term</span> a <span class="kw">where</span>
    <span class="dt">Var</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Var</span>
    <span class="dt">Abst</span><span class="ot"> ::</span> [<span class="dt">Term</span> <span class="dt">Var</span>] <span class="ot">-&gt;</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Abst</span>
    <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">App</span>
<span class="kw">data</span> <span class="dt">AnyTerm</span> <span class="kw">where</span>
    <span class="dt">AnyTerm</span><span class="ot"> ::</span><span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">AnyTerm</span></code></pre>
<p>This code should be clear. All we do is to specify constructor’s return type.</p>
<p>This is really great improvement. Think of a more complex syntax tree, with a lot more constructors. The parser already checks for invalid syntax, so actually there’s no way to create ill-formed syntax tree since parser rejects the code.</p>
<p>If you don’t use GADTs or phantom types, you have to check for ill-formed syntax in your evaluator(or reducer or compiler or whatever) even if there’s no way for parser to generate ill-formed syntax tree. For instance, you’d have to check for <code>Var [(App ..)] ...</code> in your <code>eval :: Env -&gt; Term -&gt; Val</code> function.</p>
<p>The worst part of GADTs is that you can’t use <code>deriving</code> clause in data type declaration(can anyone explain why?). In my case, that means I have to write some big amounts of code just to be able to print out the data for debugging purposes. For instance, I had to write some repetitive code like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Show</span> (<span class="dt">Expr</span> a) <span class="kw">where</span>
    <span class="fu">...</span>
    <span class="fu">show</span> (<span class="dt">Lambda</span> params ret body) <span class="fu">=</span> <span class="st">&quot;(lambda (&quot;</span> <span class="fu">++</span> <span class="fu">unwords</span> (<span class="fu">map</span> <span class="fu">show</span> params) <span class="fu">++</span> <span class="st">&quot;) : &quot;</span> <span class="fu">++</span> <span class="fu">show</span> ret <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> <span class="fu">unwords</span> (<span class="fu">map</span> <span class="fu">show</span> body) <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    <span class="fu">show</span> (<span class="dt">If</span> ifE thenE elseE) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> intercalate <span class="st">&quot;,&quot;</span> [<span class="fu">show</span> ifE, <span class="fu">show</span> thenE, <span class="fu">show</span> elseE] <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    <span class="co">-- same repetitive code for each data constructor, it&#39;s really pain when the syntax grows bigger and when you frequently make some changes on it.</span></code></pre>
<p>I also had to write same amount of code just to be able to run tests on my parser(ie. I need to compare hand-written syntax tree with parser generated syntax tree).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Eq</span> (<span class="dt">Expr</span> a) <span class="kw">where</span>
    <span class="fu">...</span>
    <span class="dt">Lambda</span> p1 b1 <span class="fu">==</span> <span class="dt">Lambda</span> p2 b2 <span class="fu">=</span> p1 <span class="fu">==</span> p2 <span class="fu">&amp;&amp;</span> b1 <span class="fu">==</span> b2
    <span class="dt">If</span> i1 t1 e1 <span class="fu">==</span> <span class="dt">If</span> i2 t2 e2 <span class="fu">=</span> i1 <span class="fu">==</span> i2 <span class="fu">&amp;&amp;</span> t1 <span class="fu">==</span> t2 <span class="fu">&amp;&amp;</span> e1 <span class="fu">==</span> e2
    <span class="fu">...</span>
    _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="kw">False</span></code></pre>
<h3 id="further-reading">Further reading:</h3>
<ul>
<li><a href="http://www.haskell.org/haskellwiki/Phantom_type">Phantom type on Haskell wiki</a>. Phantom types are data types without constructors, like we’ve used in examples. I first met with this concept in <a href="http://vimeo.com/14313378">Yaron Minsky’s great talk on effective ML</a>. I highly recommend it.</li>
<li><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt">GHC user’s guide on GADTs</a>.</li>
<li><a href="http://www.haskell.org/haskellwiki/GADT">GADTs on Haskell wiki</a>.</li>
</ul>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>To list all extensions, I run GHCi, type <code>:set -X</code> and then run auto-complete, it says “Display all 167 possibilities?” on GHC 7.4.1, 82 of them are starting with <code>-XNo</code>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
