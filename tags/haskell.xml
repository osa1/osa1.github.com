<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged haskell</title>
    <link href="http://osa1.net/tags/haskell.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/haskell.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-01-03T00:00:00Z</updated>
    <entry>
    <title>Quick digestive-functors and heist tutorial</title>
    <link href="http://osa1.net/posts/2014-01-03-quick-digestive-f-heist-tut.html" />
    <id>http://osa1.net/posts/2014-01-03-quick-digestive-f-heist-tut.html</id>
    <published>2014-01-03T00:00:00Z</published>
    <updated>2014-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m currently learning some web programming related libraries for Haskell and I’m very, very confused because of the need for using more than 20 libraries for even the simplest CRUD webapp. In the end I’ll be using Snap, Heist, Digestive-functors, Persistent, Esqueleto and glue libraries to combine all of this together. After wasting several hours trying to learn all of them at once, I decided to move gradually from simplest parts. In this short tutorial, I’ll explain how to create forms using digestive-functors, render them in HTML and run some validation procedures.</p>
<p>This post is written in Literate Haskell, except for the last part, which contains a Heist template for rendering our forms in HTML.</p>
<p>In my opinition, there are two problems for starters of Haskell web programming in Snap. First, Snap lacks some important web development functionalities and for that you need to use separate libraries. This includes form generation and rendering, database operations and probably many others. (on the other hand, we have very high quality libraries so this part may not be a problem, depending on your point of view)</p>
<p>Second, while using other libraries you realize that most of the time documentation is not very good and some important details for starters are missing, when that happens you end up diving into the source code and open source examples.</p>
<p>Anyway, I hope this post serves as an example for using Digestive-functors and Heist together for handling user inputs.</p>
<p>A note before starting: I don’t understand how compiled splices of Heist works, I tried using them but for some reason I couldn’t make it working. So in this post I’ll be using interpreted splices only.</p>
<p>Let’s start with some langauge extensions. You’ll see why this extension is needed below</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></code></pre>
<p>This one is required for pattern matching against Text values</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings   #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></code></pre>
<p>Even though our program doesn’t do anything interesting, we still need to use about 10 libraries. I’m showing the package name when a non-standard(e.g. the ones distributed with Haskell Platform) module is imported.</p>
<p>from `blaze-builder’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Blaze.ByteString.Builder   (toByteString)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Applicative        (Applicative (..), (&lt;$&gt;), (&lt;*&gt;))
<span class="ot">&gt;</span> <span class="kw">import</span>           Control.Monad.IO.Class     (MonadIO)</code></pre>
<p>from `either’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Monad.Trans.Either (EitherT, runEitherT)</code></pre>
<p>from `bytestring’ package, needed for putStrLn function on bytestrings</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString.Char8      <span class="kw">as</span> BS (putStrLn)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Data.Maybe                 (isJust)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Text                  <span class="kw">as</span> T</code></pre>
<p>from `heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Heist
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Heist.Interpreted          <span class="kw">as</span> HI</code></pre>
<p>from `digestive-functors’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive</code></pre>
<p>from `digestive-functors-heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Heist       (bindDigestiveSplices)</code></pre>
<p>In this program, we’ll have one data type that represents a User in our app. I’m planning to extend this post later on to add CRUD database operations on same data type.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     {<span class="ot"> uUsername ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uEmail    ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uKarma    ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     } <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p><code>userForm</code> is a digestive-functors form for User type, which is used for creating new User and modifying existing User.</p>
<p>In the return type:</p>
<ul>
<li>First argument of Form(Text) is type of textual information printed to user. This is used for error messages and probably some other stuff</li>
<li>Second argument is the Monad type that validator of this form operates on.</li>
<li>Third argument is return type of this form. Form return types are used when combining forms using applicative instance. For example, a form that asks user for a text can be used to get a text value.</li>
</ul>
<p><code>.:</code> operator is used to assign a name to form fields. This names are later used in templates, POST request environments and probably in some other places.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; userForm ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">T.Text</span> m <span class="dt">User</span>
<span class="ot">&gt;</span> userForm <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;$&gt;</span> <span class="st">&quot;username&quot;</span>  <span class="fu">.:</span> text <span class="kw">Nothing</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span>     <span class="fu">.:</span> check <span class="st">&quot;invalid email&quot;</span> validateEmail (text <span class="kw">Nothing</span>)
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> pure <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     <span class="co">-- in our example, we don&#39;t need to use `m` monad for validation. if we</span>
<span class="ot">&gt;</span>     <span class="co">-- were to need that, we could use `checkM` instead of `check`, and</span>
<span class="ot">&gt;</span>     <span class="co">-- then use a validation function with type `T.Text -&gt; m Bool` for same m.</span>
<span class="ot">&gt;     validateEmail ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>     validateEmail <span class="fu">=</span> isJust <span class="fu">.</span> T.find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)</code></pre>
<p>For generating HTML using Heist, we need to maintain <code>HeistState</code> type, which keeps track of information that is needed for rendering templates.</p>
<p>In the code below, `m’ is called “runtime monad” and represents the monad type that rendering functions operate on. We will see an example use later.</p>
<p>I’m using <code>ScopedTypeVariables</code> extension to share type parameter <code>m</code> with type declarations in <code>where</code> part. This is only optional, since I could always use <code>let</code> or just inline the <code>heistConfig</code> definition.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; initHeistState ::</span> forall m<span class="fu">.</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> (<span class="dt">HeistState</span> m)
<span class="ot">&gt;</span> initHeistState <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     st <span class="ot">&lt;-</span> runEitherT <span class="fu">$</span> initHeist heistConfig
<span class="ot">&gt;</span>     <span class="kw">case</span> st <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Left</span> errors <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="fu">$</span> <span class="fu">unlines</span> errors
<span class="ot">&gt;</span>       <span class="kw">Right</span> state <span class="ot">-&gt;</span> <span class="fu">return</span> state
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     heistConfig ::</span> <span class="dt">HeistConfig</span> m
<span class="ot">&gt;</span>     <span class="co">-- In HeistConfig, we need to specify what load-time, compile-time and</span>
<span class="ot">&gt;</span>     <span class="co">-- run-time splices will be available. We also have options for</span>
<span class="ot">&gt;</span>     <span class="co">-- attibute splices(QUESTION: why we don&#39;t have time distinction in</span>
<span class="ot">&gt;</span>     <span class="co">-- attribute splices?) and locations of template files.</span>
<span class="ot">&gt;</span>     heistConfig <span class="fu">=</span> <span class="dt">HeistConfig</span>
<span class="ot">&gt;</span>       {
<span class="ot">&gt;</span>       <span class="co">-- default interpreted splices consists of</span>
<span class="ot">&gt;</span>       <span class="co">-- `apply`, `bind`, `ignore` and `markdown` splices</span>
<span class="ot">&gt;</span>         hcInterpretedSplices <span class="fu">=</span> defaultInterpretedSplices
<span class="ot">&gt;</span>       <span class="co">-- this is same as default interpreted splices</span>
<span class="ot">&gt;</span>       , hcLoadTimeSplices <span class="fu">=</span> defaultLoadTimeSplices
<span class="ot">&gt;</span>       <span class="co">-- I&#39;m not using compiled splices because of the reason explained</span>
<span class="ot">&gt;</span>       <span class="co">-- in first paragraphs</span>
<span class="ot">&gt;</span>       , hcCompiledSplices <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="co">-- .. also here.</span>
<span class="ot">&gt;</span>       , hcAttributeSplices <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="co">-- list of template locations. A template location is an</span>
<span class="ot">&gt;</span>       <span class="co">-- IO action that either returns a list of error strings,</span>
<span class="ot">&gt;</span>       <span class="co">-- or a map from template locations to template files.</span>
<span class="ot">&gt;</span>       <span class="co">-- We&#39;re using `loadTemplates` from Heist package for loading</span>
<span class="ot">&gt;</span>       <span class="co">-- templates from a folder. Subfolders are also traversed.</span>
<span class="ot">&gt;</span>       , hcTemplateLocations <span class="fu">=</span> [loadTemplates <span class="st">&quot;templates&quot;</span>]
<span class="ot">&gt;</span>       }</code></pre>
<p>This is our function to render form templates written in Heist template format using digestive-functors forms. Digestive-functors forms are not directly renderable, instead we need a <code>View</code> object generated from <code>Form</code> using <code>getForm</code> or <code>postForm</code> from <code>Text.Digestive.View</code> (<code>digestive-functors</code> package).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; renderForm ::</span> <span class="dt">HeistState</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">View</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> renderForm hs formView <span class="fu">=</span> <span class="kw">do</span></code></pre>
<p>Because of a problem, we can’t use <code>digestiveSplices form</code> to get splices and then bind them manually using <code>bindSplices</code>. I think this is because of a type mismatch caused by current versions of digestive-functors-heist and heist libraries. So we need to use <code>bindDigestiveSplices</code> from <code>Text.Digestive.Heist</code> (<code>digestive-functors-heist</code> package).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     maybeBuilder <span class="ot">&lt;-</span> HI.renderTemplate (bindDigestiveSplices formView hs) <span class="st">&quot;user_form&quot;</span>
<span class="ot">&gt;</span>     <span class="kw">case</span> maybeBuilder <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Nothing</span> <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>         <span class="co">-- This happens when wrong template name is given to `renderTemplate`.</span>
<span class="ot">&gt;</span>         <span class="fu">error</span> <span class="st">&quot;template is not rendered&quot;</span>
<span class="ot">&gt;</span>       <span class="kw">Just</span> (builder, mimeType) <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         <span class="co">-- here `builder` has type `Blaze.ByteString.Builder.Builder` from</span>
<span class="ot">&gt;</span>         <span class="co">-- `blaze-builder` package. It&#39;s used to efficiently build</span>
<span class="ot">&gt;</span>         <span class="co">-- ByteStrings.</span>
<span class="ot">&gt;</span>         BS.putStrLn (toByteString builder)
<span class="ot">&gt;</span>         <span class="fu">print</span> mimeType</code></pre>
<p>I’m just printing stuff, since this app is mostly for learning purposes.</p>
<p>In main function, I do three things:</p>
<ol style="list-style-type: decimal">
<li>Just render the form on empty POST request environment. This just renders the form without filling HTML fields with values.</li>
<li>Render form with invalid email address. This fills HTML fields with values form POST request environment, and renders an error message after email field saying that email is invalid. This validation part was handled in <code>validateEmail</code> function above, and error message was specified in <code>userForm</code> function.</li>
<li>Render the form with valid values.</li>
</ol>
<p>After rendering the HTML code, I’m just printing it. Also, form rendering function(<code>postForm</code>) returns an optional User object depending on the validness of information from POST request. I’m also printing that User object.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     hs <span class="ot">&lt;-</span> initHeistState
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- we need to dynamically bind splices related with form generation</span>
<span class="ot">&gt;</span>     <span class="co">-- while rendering `user_form` heist template. for that we need to use</span>
<span class="ot">&gt;</span>     <span class="co">-- `Heist.Interpreter` functions to modify interpereted splices of our</span>
<span class="ot">&gt;</span>     <span class="co">-- heist state.</span>
<span class="ot">&gt;</span>     <span class="fu">--</span>
<span class="ot">&gt;</span>     <span class="co">-- To get form splices, we need to pass some POST or GET request as</span>
<span class="ot">&gt;</span>     <span class="co">-- ByteString to `Text.Digestive.View.getForm` or `postForm`. Then we</span>
<span class="ot">&gt;</span>     <span class="co">-- can use `Text.Digestive.Heist.digestiveSplices` to get required</span>
<span class="ot">&gt;</span>     <span class="co">-- splices to render form.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Here the type T.Text comes from first argument of userForm&#39;s return</span>
<span class="ot">&gt;</span>     <span class="co">-- type</span>
<span class="ot">&gt;</span>     (formView, maybeUser) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm (<span class="fu">const</span> <span class="fu">$</span> <span class="fu">return</span> [])
<span class="ot">&gt;                                ::</span> <span class="dt">IO</span> (<span class="dt">View</span> <span class="dt">T.Text</span>, <span class="dt">Maybe</span> <span class="dt">User</span>)
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser
<span class="ot">&gt;</span>     renderForm hs formView
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Case 2, POST request with invalid email address</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> env path <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> path <span class="kw">of</span>
<span class="ot">&gt;</span>                               [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;username&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;testuser&quot;</span>]
<span class="ot">&gt;</span>                               [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;email&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;invalidemail&quot;</span>]
<span class="ot">&gt;</span>                               _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span>     (formView&#39;, maybeUser&#39;) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm env
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser&#39;
<span class="ot">&gt;</span>     renderForm hs formView&#39;
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Case 3, POST request with valid email address and username</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> env&#39; path <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> path <span class="kw">of</span>
<span class="ot">&gt;</span>                                [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;username&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;testuser&quot;</span>]
<span class="ot">&gt;</span>                                [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;email&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;valid@email.com&quot;</span>]
<span class="ot">&gt;</span>                                _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span>     (formView&#39;&#39;, maybeUser&#39;&#39;) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm env&#39;
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser&#39;&#39;
<span class="ot">&gt;</span>     renderForm hs formView&#39;&#39;</code></pre>
<p>Now our program is almost complete, only detail left is the Heist template file. We specified the template path in <code>initHeistState</code> as <code>templates</code> folder, and we’re rendering Heist template named <code>user_form</code> in <code>renderForm</code>. So the template file we need should be <code>templates/user_form.tpl</code>.</p>
<p>Here’s the template file:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;dfForm&gt;</span>
    <span class="kw">&lt;dfLabel</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/dfLabel&gt;</span>
    <span class="kw">&lt;dfInputText</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;dfErrorList</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span> <span class="kw">/&gt;</span>

    <span class="kw">&lt;dfLabel</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/dfLabel&gt;</span>
    <span class="kw">&lt;dfInputText</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;dfErrorList</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span> <span class="kw">/&gt;</span>

    <span class="kw">&lt;dfInputSubmit</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/dfForm&gt;</span></code></pre>
<p>One problem here is that there’s no way to know which tags to put in template file. I wrote this file mostly by looking to source code of <code>bindDigestiveSplices</code>, trial-and-error, and some open source examples.</p>
<p>Output should be something like: (after creating the template file, see below)</p>
<p>Case 1:</p>
<pre><code>Nothing</code></pre>
<p>because POST request environment is not valid, so it’s not possible to create a User object.</p>
<pre><code>&lt;form method=&#39;POST&#39; enctype=&#39;application/x-www-form-urlencoded&#39;&gt;
    &lt;label for=&#39;userform.username&#39;&gt;Username: &lt;/label&gt;
    &lt;input type=&#39;text&#39; id=&#39;userform.username&#39; name=&#39;userform.username&#39; value /&gt;


    &lt;label for=&#39;userform.email&#39;&gt;Email: &lt;/label&gt;
    &lt;input type=&#39;text&#39; id=&#39;userform.email&#39; name=&#39;userform.email&#39; value /&gt;
    &lt;ul&gt;&lt;li&gt;invalid email&lt;/li&gt;&lt;/ul&gt;

    &lt;input type=&#39;submit&#39; /&gt;
&lt;/form&gt;</code></pre>
<p>User form is generated without filling any values and no error messages.</p>
<p>Case 2:</p>
<pre><code>Nothing</code></pre>
<p>because email information in POST request environment is invalid.</p>
<pre><code>&lt;form method=&#39;POST&#39; enctype=&#39;application/x-www-form-urlencoded&#39;&gt;
    &lt;label for=&#39;userform.username&#39;&gt;Username: &lt;/label&gt;
    &lt;input type=&#39;text&#39; id=&#39;userform.username&#39; name=&#39;userform.username&#39; value=&#39;testuser&#39; /&gt;


    &lt;label for=&#39;userform.email&#39;&gt;Email: &lt;/label&gt;
    &lt;input type=&#39;text&#39; id=&#39;userform.email&#39; name=&#39;userform.email&#39; value=&#39;invalidemail&#39; /&gt;
    &lt;ul&gt;&lt;li&gt;invalid email&lt;/li&gt;&lt;/ul&gt;

    &lt;input type=&#39;submit&#39; /&gt;
&lt;/form&gt;</code></pre>
<p>User form is generated with fields filled and an error message is rendered.</p>
<p>Case 3:</p>
<pre><code>Just (User {uUsername = &quot;testuser&quot;, uEmail = &quot;valid@email.com&quot;, uKarma = 0})</code></pre>
<p>Since form data is valid, a User object is created.</p>
<pre><code>&lt;form method=&#39;POST&#39; enctype=&#39;application/x-www-form-urlencoded&#39;&gt;
    &lt;label for=&#39;userform.username&#39;&gt;Username: &lt;/label&gt;
    &lt;input type=&#39;text&#39; id=&#39;userform.username&#39; name=&#39;userform.username&#39; value=&#39;testuser&#39; /&gt;


    &lt;label for=&#39;userform.email&#39;&gt;Email: &lt;/label&gt;
    &lt;input type=&#39;text&#39; id=&#39;userform.email&#39; name=&#39;userform.email&#39; value=&#39;valid@email.com&#39; /&gt;


    &lt;input type=&#39;submit&#39; /&gt;
&lt;/form&gt;</code></pre>
<p>.. and for is created with values filled, no error messages is rendered.</p>
<p>Note the form and input ids and names. The name passed to <code>postForm</code> is used as prefix of generated HTML elements, and thus also used in POST request environments.</p>
<p>I hope this post helps starters with digestive-functors and heist.</p>]]></summary>
</entry>
<entry>
    <title>Testing assembly programs using Haskell, QuickCheck (and FFI)</title>
    <link href="http://osa1.net/posts/2013-11-14-testing-asm-using-haskell.html" />
    <id>http://osa1.net/posts/2013-11-14-testing-asm-using-haskell.html</id>
    <published>2013-11-14T00:00:00Z</published>
    <updated>2013-11-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been studying 64bit calling conventions for x64 family recently. To do this, I was writing some function in assembly and then calling my functions from a C program to be sure that parameter passing and returning values are working correctly.</p>
<p>It generally works fine, and linking C program with assembly programs are easy enough. Today I got the idea of using Haskell + QuickCheck to test my assembly programs, this way I could also be more confident that not only parameter passing/return values work correctly, but my implementation of algorithm in assembly is also correct.</p>
<p>Linking assembly programs with a Haskell program is surprisingly easy. In the rest of this post, I’ll explain how to compile and link power function written in assembly to test program written in Haskell.</p>
<p>Here’s a power function that works on 64bit unsigned numbers, implemented using x64 ABI conventions:</p>
<pre class="assembly"><code>section .text
global power
power:
	mov rbx, rdi        ; move first parameter to rbx
	mov rcx, rsi        ; move second parameter to rcx

	cmp rcx, 0          ; return 1 if power is 0
	je end_power_one

	mov rax, rbx        ; move result to rax for multiplication

power_loop_start:
	cmp rcx, 1
	je end_power

	mul rbx
	dec rcx
	jmp power_loop_start

end_power_one:
	mov rax, 1

end_power:
	ret</code></pre>
<p>This is written using <a href="http://www.nasm.us/">Netwide Assembler</a>(best assembly syntax, IMO). Since we’re working on 64bit system, we need to compile it to <code>elf64</code> format:</p>
<pre><code>nasm -f elf64 power_lib.s -o power_lib.o</code></pre>
<p>Once we have our compiled file for power function, we need to declare it in Haskell as a foreign function, using correct types. A short tour in <code>Foreign.C.Types</code> library showed that <code>CULong</code> type is actually a newtype wrapper around <code>Word64</code>, which is 64bit unsigned number type:</p>
<pre><code>ghci&gt; :m + Foreign.C.Types 
ghci&gt; :info CULong
newtype CULong = CULong GHC.Word.Word64
        -- Defined in `Foreign.C.Types&#39;</code></pre>
<p>(not that this part should be different on 32bit systems – eg. on 32bit system you should see <code>CULong GHC.Word.Word32</code> instead of <code>Word64</code>)</p>
<p>We also need a <code>Arbitrary</code> instance for <code>CULong</code> type to be able to use QuickCheck on this type. Since <code>CULong</code> is just a newtype wrapper over <code>Word64</code>, and <code>Word64</code> already has instance defined in QuickCheck library, we can have that for free. In the end, our test code is:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Foreign.C.Types
<span class="kw">import</span> Test.QuickCheck

foreign <span class="kw">import</span> ccall &quot;power&quot;
<span class="ot">    power ::</span> <span class="dt">CULong</span> <span class="ot">-&gt;</span> <span class="dt">CULong</span> <span class="ot">-&gt;</span> <span class="dt">CULong</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">CULong</span> <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="fu">fmap</span> <span class="dt">CULong</span> arbitrary
    shrink (<span class="dt">CULong</span> i) <span class="fu">=</span> <span class="fu">map</span> <span class="dt">CULong</span> <span class="fu">$</span> shrink i

test_prop b p <span class="fu">=</span> power b p <span class="fu">==</span> b <span class="fu">^</span> p

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> quickCheck test_prop</code></pre>
<p>and that’s it. Very simple, 16 lines of code. To compile this, I also wrote a Makefile:</p>
<pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">power:</span><span class="dt"> power_test.hs power_lib.o</span>
	ghc --make <span class="ch">$^</span>

<span class="dv">power_lib.o:</span><span class="dt"> power_lib.s</span>
	nasm -f elf64 <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">clean:</span>
	<span class="ch">-</span><span class="fu">rm power_lib.o</span>
	<span class="ch">-</span><span class="fu">rm power_test power_test.hi power_test.o</span></code></pre>
<p>(this may be helpful to see how compilation work)</p>
<p>I think this is also a good demonstration of how easy it is to interact with foreign functions in Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Observability of bottom values</title>
    <link href="http://osa1.net/posts/2013-11-03-observability-of-nulls.html" />
    <id>http://osa1.net/posts/2013-11-03-observability-of-nulls.html</id>
    <published>2013-11-03T00:00:00Z</published>
    <updated>2013-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While ranting about how much I hate about null values in Java(and other langauges) on Haskell IRC channel, someone in the channel reminded me that we have <code>undefined</code> in Haskell, which is actually similar to null values in some sense.</p>
<p>The difference between Haskell’s <code>undefined</code> and null values in other languages is that Haskell’s <code>undefined</code> is <em>unobservable</em>. This means you can’t test for a value being <code>undefined</code> or not in Haskell, but you can test for null values in Java and other languages.</p>
<p>This means you can’t rely on some values being <code>undefined</code> or not. This makes it only useful for 1) unreachable code and 2) filling some parts in the code for now just to make it compile and later complete that parts(and I’m using <code>undefined</code> for this purpose very often).</p>
<p>This is what makes Haskell’s <code>undefined</code> a useful feature, while null values is clearly <em>Considered Harmful</em>™.</p>]]></summary>
</entry>
<entry>
    <title>TIL - Haskell 98 doesn't have principal typing property</title>
    <link href="http://osa1.net/posts/2013-09-20-til-haskell-principal-typing.html" />
    <id>http://osa1.net/posts/2013-09-20-til-haskell-principal-typing.html</id>
    <published>2013-09-20T00:00:00Z</published>
    <updated>2013-09-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After hearing the term “polymorphic recursion” at <a href="http://fsl.cs.illinois.edu/index.php/Main_Page">FSL</a> meeting today, I just searched for it in Wikipedia(I never heard that term before). It’s explained with a Haskell code, with a note saying that:</p>
<blockquote>
<p>In Haskell, unlike for most other functions definitions, the type signature cannot be omitted.</p>
</blockquote>
<p>.. and that code is Haskell 98 compliant. For a long time I thought Haskell 98 has principal typing property – but apparently I was wrong. I wrote that in Haskell IRC channel and there were other people who were thinking same.</p>
<p>People at IRC channel also said that SML bans polymorphic recursion and have principal typing. Nice to know.</p>]]></summary>
</entry>
<entry>
    <title>MANTI - Prolog implementation in 515 lines of Haskell</title>
    <link href="http://osa1.net/posts/2013-07-31-announce-manti.html" />
    <id>http://osa1.net/posts/2013-07-31-announce-manti.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/osa1/MANTI">MANTI</a> is a pure Prolog implementation in 515 lines of Haskell. It’s only implements pure parts, meaning it doesn’t have cuts, IO predicates, non-pure arithmetic(<code>is</code> structures in modern Prolog implementation) or other structures that break logical reasoning of Prolog programs.</p>
<p>Here are some example Prolog programs that currently runs under MANTI: (you can find these in <code>tests/</code> folder in source repository)</p>
<ul>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/einstein.pl">Einstein’s riddle</a> – also called Zebra Puzzle. You can see problem definition in <a href="http://en.wikipedia.org/wiki/Zebra_Puzzle">Wikipedia - Zebra Puzzle</a>.</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/nqueens.pl">N-queens problem</a> (not that it takes some time to solve it for board bigger than 5x5, reasons for that slowness explained below)</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/zurg.pl">Escape from Zurg puzzle</a> - you can see a paper with definition of this problem <a href="http://web.engr.oregonstate.edu/~erwig/zurg/">here</a>.</li>
</ul>
<p>My aim while writing MANTI was to make it as simple as possible, yet a complete Prolog implementation that is capable to solve some real problems. For this reasons, it doesn’t have arithmetic, list structures and list operations built-in. Instead, arithmetic is implemented using <a href="http://en.wikipedia.org/wiki/Peano_axioms">Peano definitions</a>, you can see the implementation <a href="https://github.com/osa1/MANTI/blob/master/tests/peano.pl">here</a>. List operations are also implemented in MANTI itself, you can see definitions <a href="https://github.com/osa1/MANTI/blob/master/tests/list.pl">here</a>. List syntax is nothing special, it’s just a syntactic sugar that destructs to ordinary Prolog functors(you can see parser for list syntax <a href="https://github.com/osa1/MANTI/blob/master/src/Parser.hs#L80">here</a>).</p>
<p>For these reasons(and probably others, for instance, unification and <code>not</code> connective are implemented in most inefficient ways possible), it’s very slow. Also, there’s no way to disable occurs check without recompiling MANTI.</p>
<p>It’s mostly done and I don’t think I’ll work more on that. I hope you find MANTI useful(for learning purposes or others).</p>]]></summary>
</entry>
<entry>
    <title>Non-local returns in functional programs</title>
    <link href="http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html" />
    <id>http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html</id>
    <published>2013-07-21T00:00:00Z</published>
    <updated>2013-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s say we want to get nth visited element in depth-first traversal of a tree. Doing this is almost too easy in a language with statements(all imperative languages, some functional ones): Just run the depth-first traversal algorithm with explicit stack, and use <code>return</code> when you visit nth node.</p>
<p>In an expression language(Haskell, some Lisp languages) this is somewhat tricky.</p>
<p>Since I almost always prefer simplest possible solution of a problem, this would be my first attempt in a real-world situation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Branch</span> [<span class="dt">Tree</span> a]
    <span class="fu">|</span> <span class="dt">Leaf</span> a

<span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> [a]

<span class="ot">dfsNth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth tree n <span class="fu">=</span> listToMaybe <span class="fu">.</span> <span class="fu">drop</span> n <span class="fu">$</span> toList tree</code></pre>
<p>One concern about this function may be that the complexity of list generation. It’s hard to predict complexity of this function, but traversing the whole tree just to get first element of it would be costly anyway.</p>
<p>But thanks to lazy evaluation, this function still not very bad. Because only required parts of the intermediate list will be generated. To see why you can do two things: 1) Just place some <code>Debug.Trace.trace</code> calls in <code>toList</code> function and see how many times a leaf node is visited and 2) evaluate this function by hand and observe unevaluated thunks.</p>
<p>Let’s just do the first one, since it’s easier:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> trace <span class="st">&quot;leaf node visited&quot;</span> [a]

<span class="fu">...</span>

testTree <span class="fu">=</span> <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">1</span>, <span class="dt">Leaf</span> <span class="dv">2</span> ], <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">3</span> ], <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">4</span> ] ] ] ]</code></pre>
<pre><code>ghci&gt; dfsNth testTree 0
leaf node visited
Just 1

ghci&gt; dfsNth testTree 1
leaf node visited
leaf node visited
Just 2

ghci&gt; dfsNth testTree 10
leaf node visited
leaf node visited
leaf node visited
leaf node visited
Nothing</code></pre>
<hr />
<p>Other solutions are still worth exploring. When I think of “returning in the middle of a function” in Haskell, I always think <code>Either</code>. It’s monad definition is a great fit for this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">Either</span> e) <span class="kw">where</span>
    <span class="fu">return</span>        <span class="fu">=</span> <span class="kw">Right</span>
    <span class="kw">Left</span>  l <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Left</span> l
    <span class="kw">Right</span> r <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k r</code></pre>
<p>So when <code>Left data</code> used in monadic bind(<code>&gt;&gt;=</code>), second parameter just ignored and <code>Left data</code> is returned. Just like returning in the middle of a function in imperative setting, by ignoring rest of statements.</p>
<p>Using monad instance of Either, we can easily implement our function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dfsNth&#39; ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth&#39; tree n <span class="fu">=</span>
    <span class="kw">case</span> iter tree n <span class="kw">of</span>
      <span class="kw">Left</span> a  <span class="ot">-&gt;</span> <span class="kw">Just</span> a
      <span class="kw">Right</span> i <span class="ot">-&gt;</span> <span class="kw">Nothing</span>
  <span class="kw">where</span>
<span class="ot">    iter ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> a <span class="dt">Int</span>
    iter (<span class="dt">Branch</span> []) n     <span class="fu">=</span> <span class="fu">return</span> n
    iter (<span class="dt">Branch</span> (b<span class="fu">:</span>bs)) n <span class="fu">=</span> <span class="kw">do</span>
      n&#39; <span class="ot">&lt;-</span> iter b n
      iter (<span class="dt">Branch</span> bs) n&#39;
    iter (<span class="dt">Leaf</span> a) <span class="dv">0</span> <span class="fu">=</span> <span class="kw">Left</span> a
    iter <span class="dt">Leaf</span>{}   n <span class="fu">=</span> <span class="fu">return</span> (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<p>It works exactly like our first implementation, but without generating an intermediate list.</p>
<h2 id="exceptions-and-either-monad">Exceptions and Either monad</h2>
<p>If I were using OCaml, I’d probably implement this function using an exception.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">exception</span> <span class="dt">NonLocal</span> <span class="kw">of</span> <span class="dt">int</span>

<span class="kw">type</span> &#39;a tree =
  | <span class="dt">Branch</span> <span class="kw">of</span> (&#39;a tree) <span class="dt">list</span>
  | <span class="dt">Leaf</span>   <span class="kw">of</span> &#39;a

<span class="kw">let</span> dfs_nth tree n =
  <span class="kw">let</span> <span class="kw">rec</span> iter tree n =
    <span class="kw">match</span> tree <span class="kw">with</span>
    | <span class="dt">Branch</span> [] -&gt;
        n
    | <span class="dt">Branch</span> (b :: bs) -&gt;
        iter (<span class="dt">Branch</span> bs) (iter b n)
    | <span class="dt">Leaf</span> a -&gt;
        <span class="kw">if</span> n = 0 <span class="kw">then</span> raise (<span class="dt">NonLocal</span> a) <span class="kw">else</span> n - 1
  <span class="kw">in</span>
  <span class="kw">try</span>
    iter tree n;
    <span class="dt">None</span>
  <span class="kw">with</span>
    | <span class="dt">NonLocal</span> a -&gt; <span class="dt">Some</span> a</code></pre>
<p>An interesting thing to realize here is that this solution is very similar to our Haskell solution. In Haskell, Either is an instance of <code>MonadError</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Error</span> e <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span>
    throwError             <span class="fu">=</span> <span class="kw">Left</span>
    <span class="kw">Left</span>  l <span class="ot">`catchError`</span> h <span class="fu">=</span> h l
    <span class="kw">Right</span> r <span class="ot">`catchError`</span> _ <span class="fu">=</span> <span class="kw">Right</span> r</code></pre>
<p>This means if you replace <code>Left</code>s with <code>throwError</code> (just like <code>raise</code> in OCaml code), you have a similar solution with OCaml.</p>
<p>This doesn’t mean exceptions are same thing as Either types in functional programming. There are just too many differences that I won’t delve into in this post. With an exception, you can return from arbitrary deep contexts(ie. function calls), which is not easily possible with Either types. This is why exceptions sometimes referred as <em>non-local returns</em>.</p>
<p>We discussed this stuff over OCaml IRC channel, and smart people over there gave me some really good insights about non-local returns and exceptions. I’ll probably delve into details in another blog post. I’m especially interested in functional solutions that we can have in Haskell.</p>
<p>For the curious, for now I’ll just leave these two links here: (I haven’t read that links yet, but they’re probably related)</p>
<ul>
<li><a href="https://ocaml.janestreet.com/?q=node/91">https://ocaml.janestreet.com/?q=node/91</a></li>
<li><a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html</a></li>
</ul>
<p>Several other ideas also discussed at IRC channel, some of them were using delimited continuations, or passing a handler function as parameter and just calling it instead of raising an exception. I’ll continue investigating this stuff later.</p>
<p>I also came across this <a href="http://stackoverflow.com/questions/6915701/is-non-local-return-in-scala-new">StackOverflow post</a> that explains how Scala’s non-local returns implemented as exceptions internally. Interesting stuff.</p>]]></summary>
</entry>
<entry>
    <title>fmap fix return</title>
    <link href="http://osa1.net/posts/2013-07-07-fmap-fix-return.html" />
    <id>http://osa1.net/posts/2013-07-07-fmap-fix-return.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While floating across the internets, I came across a blog with title <code>fmap fix return</code>. I immediately run ghci and queried it’s type:</p>
<pre class="ghci"><code>ghci&gt; :t fmap fix return
fmap fix return :: a -&gt; a</code></pre>
<p>We know that only value with type <code>forall a. a -&gt; a</code> (other than bottom) is identity function(<code>id</code> in Haskell). I found it very interesting, <code>fmap fix return</code> gives us identity function!</p>
<p>I got a pen and paper and started evaluating expressions to understand how does that give us the identity function.</p>
<p>First, let’s note our actors:</p>
<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- instance specific implementation

fix  :: (a -&gt; a) -&gt; a
fix f = let x = f x in x

return :: Monad m =&gt; a -&gt; m a
-- instance specific implementation</code></pre>
<p>A very important thing to realize at this point is which monad and functor instances are used for <code>return</code> and <code>fmap</code>. To realize this, observe that we get a function as return value of <code>fmap</code>. Which means <code>Functor f =&gt; f b</code> is <code>a -&gt; a</code>, or written in a different style to see it’s functor property: <code>((-&gt;) a) a</code>, so our functor here is <code>(-&gt;) a</code>.</p>
<p>After that, we need to look up functor and monad instances for <code>(-&gt;) a</code>. Since it’s 2:30 AM here, I wanted to derive that too.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
     <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>It’s very easy to derive just by looking specialized version of <code>fmap</code>s type for <code>((-&gt;) a)</code>: <code>fmap :: (a1 -&gt; b) -&gt; (a -&gt; a1) -&gt; (a -&gt; b)</code>.</p>
<p>We can easily prove that it satisfies functor laws:</p>
<pre><code>fmap id f
= id . f
= f

fmap (p . q) &lt;-&gt; (fmap p) . (fmap q)
(fmap p) . (fmap q) f
= fmap p . (q . f)
= p . q . f
= fmap (p . q) f</code></pre>
<p>Monad instance can also be derived from types of <code>return</code> and <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
    <span class="fu">return</span>   <span class="fu">=</span> <span class="fu">const</span>
    f <span class="fu">&gt;&gt;=</span> fn <span class="fu">=</span> \r <span class="ot">-&gt;</span> fn (f r) r</code></pre>
<p>(I found Monad instance of <code>((-&gt;) a)</code> very interesting, especially the <code>&gt;&gt;=</code> part. I couldn’t come up with a problem that makes use of this instance, I’ll investigate that after some sleep)</p>
<p>It satisfies monad laws:</p>
<pre><code>-- left identity
return a &gt;&gt;= f
= const a &gt;&gt;= f
= \r -&gt; f ((const a) r) r
= \r -&gt; f a r
= f a

-- right identity
m &gt;&gt;= return
= \r -&gt; return (m r) r
= \r -&gt; (const (m r) r)
= \r -&gt; m r
= m

-- associativity
(m &gt;&gt;= f) &gt;&gt;= g &lt;-&gt; m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

let&#39;s first write `p` for `m &gt;&gt;= f`

= p &gt;&gt;= g
= \r1 -&gt; g (p r1) r1

let&#39;s also evaluaute p

p = m &gt;&gt;= f
= \r2 -&gt; f (m r2) r2

substitute new p

= \r1 -&gt; g ((\r2 -&gt; f (m r2) r2) r1) r1
= \r1 -&gt; g (f (m r1) r1) r1
= \r -&gt; g (f (m r) r) r

now let&#39;s also evaluate right hand side of equation

m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
= m &gt;&gt;= (\x -&gt; (    f x &gt;&gt;= g    )) -- just added a paren for clarity
= m &gt;&gt;= (\x -&gt; (\r -&gt; g (f x r) r))

let write `p` for `\x -&gt; (\r -&gt; g (f x r) r)`

= m &gt;&gt;= p
= \r1 -&gt; p (m r1) r1

put p back

= \r1 -&gt; (\x -&gt; (\r -&gt; g (f x r) r)) (m r1) r1
= \r1 -&gt; (\r -&gt; g (f (m r1) r)) r1
= \r1 -&gt; g (f (m r1) r1)</code></pre>
<p>For those who have no idea what’s above, I’m basically proving some equalities by substituting expressions with their equivalents. This is a benefit for working on a purely functional language, which means referential transparency.</p>
<p>OK, now with these <code>return</code> and <code>fmap</code> implementations in mind, let’s evaluate <code>fmap fix return</code>:</p>
<pre><code>fmap fix return
= fix . return
= \r -&gt; fix (return r)
= \r -&gt; fix (const r)
= \r -&gt; (\f = let x = f x in x) (const r)
= \r -&gt; let x = (const r) x in x

since `const a _ = a`, we have x = r here

= \r -&gt; r</code></pre>
<p>.. which is the identity function.</p>
<p>Thus <code>fmap fix return</code> demystified.</p>]]></summary>
</entry>
<entry>
    <title>Shen.hs FFI</title>
    <link href="http://osa1.net/posts/2013-06-29-shenhs-ffi.html" />
    <id>http://osa1.net/posts/2013-06-29-shenhs-ffi.html</id>
    <published>2013-06-29T00:00:00Z</published>
    <updated>2013-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Shen.hs now has a simple way to call Haskell functions. As an example, I removed some non-standard KLambda functions from <a href="https://github.com/osa1/Shen.hs/blob/master/src/KLambda/Fun.hs"><code>Fun.hs</code></a>(standard primitive functions are defined there). Instead, they live in a <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs">separate module</a> now, and I load them in run-time when I’m debugging.</p>
<h2 id="how-it-works">How it works</h2>
<p>Shen.hs is now exports it’s modules as a library. This is required to allow writing Shen.hs functions in Haskell.</p>
<p><code>KLambda.Types</code> module export all required type information to start writing Shen.hs functions in Haskell. All your functions should have the type <code>KlFun1</code>. To make converting Haskell functions with higher arity(ie. <code>KlFun2</code>, <code>KlFun3</code>) to <code>KlFun1</code>, all <code>KlFun</code> instances now have a <code>mkFun1 :: a -&gt; KlFun1</code> method.</p>
<p>As an example, <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs"><code>Debug.hs</code></a> module functions with types <code>KlFun2</code>, <code>KlFun3</code> etc. To call them from within Shen.hs, they are all wrapped with <code>mkFun1</code> function.</p>
<p>After defining functions with type <code>KlFun1</code> and compiling it, you should call <code>dynload</code> primitive to load functions. Here’s an example session that demonstrates loading and using debugging functions:</p>
<pre><code>$ Shen.hs --shen &quot;/home/omer/Shen/hs_yeni/K Lambda&quot;
loading file: /home/omer/Shen/hs_yeni/K Lambda/toplevel.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/core.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sys.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sequent.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/yacc.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/reader.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/prolog.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/track.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/load.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/writer.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/macros.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/declarations.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/t-star.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/types.kl ...loaded.

Shen 2010, copyright (C) 2010 Mark Tarver
released under the Shen license
www.shenlanguage.org, version 12
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan


(0-) (cd &quot;/home/omer/Shen/hs_yeni/dynload_test&quot;)
&quot;/home/omer/Shen/hs_yeni/dynload_test/&quot;

(1-) (dynload &quot;Debug.o&quot; &quot;debug1F&quot;)
&lt;function&gt;

(2-) (debug1F &quot;calling haskell function -- &quot; 1 2)
calling haskell function -- 1 :: TyNum

2

(3-)</code></pre>
<p>Note that you need both <code>.hi</code> and <code>.o</code> files to be able to load the library dynamically.</p>
<h2 id="status-of-shen.hs">Status of Shen.hs</h2>
<p>Before this additional feature I had fixed a bug and now Shen.hs fails in 8 tests in Test Suite distributed with Shen source. All errors are related and probably there is only one bug. Unfortunately narrowing bug’s scope is very hard at this point. Pull requests are welcome.</p>
<p>If you encounter any bugs please open an issue in <a href="https://github.com/osa1/Shen.hs">Github repository</a>.</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: Shen.hs -- Haskell port of Shen</title>
    <link href="http://osa1.net/posts/2013-06-21-ann-shen-hs.html" />
    <id>http://osa1.net/posts/2013-06-21-ann-shen-hs.html</id>
    <published>2013-06-21T00:00:00Z</published>
    <updated>2013-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m copying <a href="https://groups.google.com/forum/?hl=en#!topic/qilang/GKVN4E_ntWw">my email</a> sent to Shen mailing list:</p>
<blockquote>
<p>Hi all,</p>
<p>I had started writing a port of Shen in Haskell some time ago. Unfortunately it never reached a stable state. And now I can’t spare enough time to fix bugs and improve performance. So I thought maybe it’s a good time to announce it and wait for contributions.</p>
<p>By ‘not stable’ I don’t mean it’s in a terrible state. For example, Shen test suite runs with following results:</p>
<pre><code>passed ... 94.0 
failed ...34.0 
pass rate ...73.4375% </code></pre>
<p>.. it’s not hopelessly bad. It probably has one or two deadly bugs and that causes dozens of tests to fail.</p>
<p>Anyway, that’s it for now. Github repository is here: <a href="https://github.com/osa1/Shen.hs">https://github.com/osa1/Shen.hs</a> .</p>
<p>If you try please tell me your thoughts!</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>A converter from Lua tables to JavaScript objects</title>
    <link href="http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html" />
    <id>http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html</id>
    <published>2013-05-06T00:00:00Z</published>
    <updated>2013-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote a simple Haskell program to convert some data encoded as Lua tables to JavaScript objects/arrays to be used in another project of mine:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span>           Language.Lua.Parser
<span class="kw">import</span>           Language.Lua.Types

<span class="kw">import</span> <span class="kw">qualified</span> Language.ECMAScript3.Syntax       <span class="kw">as</span> JS
<span class="kw">import</span>           Language.ECMAScript3.PrettyPrint  (renderExpression)

<span class="kw">import</span>           System.Environment                (getArgs)
<span class="kw">import</span>           Control.Monad
<span class="kw">import</span>           Prelude                           <span class="kw">hiding</span> (exp)

<span class="ot">unsupported ::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
unsupported <span class="fu">=</span> <span class="fu">error</span> <span class="fu">.</span> (<span class="st">&quot;unsupported exp: &quot;</span> <span class="fu">++</span>) <span class="fu">.</span> <span class="fu">show</span>

<span class="kw">class</span> <span class="dt">ToJsExp</span> a <span class="kw">where</span>
<span class="ot">    toJsExp ::</span> a <span class="ot">-&gt;</span> <span class="dt">JS.Expression</span> ()

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Exp</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Nil</span> _) <span class="fu">=</span> <span class="dt">JS.NullLit</span> ()
    toJsExp (<span class="dt">Bool</span> _ bool) <span class="fu">=</span> <span class="dt">JS.BoolLit</span> () bool
    toJsExp (<span class="dt">Number</span> _ num) <span class="fu">=</span> <span class="dt">JS.NumLit</span> () (<span class="fu">read</span> num)
    toJsExp (<span class="dt">String</span> _ str) <span class="fu">=</span> <span class="dt">JS.StringLit</span> () str
    toJsExp (<span class="dt">TableConst</span> _ table) <span class="fu">=</span> toJsExp table
    toJsExp unsupportedexp <span class="fu">=</span> unsupported (<span class="fu">fmap</span> (<span class="fu">const</span> ()) unsupportedexp)

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Table</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Table</span> _ fields)
      <span class="fu">|</span> <span class="fu">all</span> arrField fields <span class="fu">=</span>
          <span class="dt">JS.ArrayLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">Field</span> _ <span class="fu">exp</span>) <span class="ot">-&gt;</span> toJsExp <span class="fu">exp</span>) fields
      <span class="fu">|</span> <span class="fu">all</span> objField fields <span class="fu">=</span>
          <span class="dt">JS.ObjectLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">NamedField</span> _ (<span class="dt">Name</span> _ name) <span class="fu">exp</span>) <span class="ot">-&gt;</span> (<span class="dt">JS.PropId</span> () (<span class="dt">JS.Id</span> () name), toJsExp <span class="fu">exp</span>)) fields
      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> unsupported (<span class="fu">map</span> (<span class="fu">fmap</span> (<span class="fu">const</span> ())) fields)

      <span class="kw">where</span>
        arrField <span class="dt">Field</span>{} <span class="fu">=</span> <span class="kw">True</span>
        arrField _       <span class="fu">=</span> <span class="kw">False</span>

        objField <span class="dt">NamedField</span>{} <span class="fu">=</span> <span class="kw">True</span>
        objField _            <span class="fu">=</span> <span class="kw">False</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    contents <span class="ot">&lt;-</span> <span class="fu">readFile</span> (<span class="fu">head</span> args)
    <span class="kw">case</span> parseText <span class="fu">exp</span> contents <span class="kw">of</span>
      <span class="kw">Left</span> err <span class="ot">-&gt;</span> <span class="fu">print</span> err
      <span class="kw">Right</span> result <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> renderExpression <span class="fu">$</span> toJsExp result</code></pre>
<p>It uses <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>, a Lua parser and pretty-printer which I wrote to use in some other project of mine(a static analysis tool for Lua, I have big plans about it) and <a href="http://hackage.haskell.org/package/language-ecmascript">language-ecmascript</a>, JavaScript parser and pretty-printer.</p>]]></summary>
</entry>

</feed>
