<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged haskell</title>
    <link href="http://osa1.net/tags/haskell.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/haskell.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2018-05-19T00:00:00Z</updated>
    <entry>
    <title>New blog post published elsewhere</title>
    <link href="http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html" />
    <id>http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html</id>
    <published>2018-05-19T00:00:00Z</published>
    <updated>2018-05-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new blog post that I’ve authored has been published on <a href="http://www.well-typed.com/blog/2018/05/ghc-special-gc-objects/">Well-Typed’s blog</a>. If you’re interested in garbage collection or liked my <a href="/posts/2018-03-16-gc-optimizations.html">previous post</a> you should check it out.</p>]]></summary>
</entry>
<entry>
    <title>Debugging #15038</title>
    <link href="http://osa1.net/posts/2018-04-28-debugging-15038.html" />
    <id>http://osa1.net/posts/2018-04-28-debugging-15038.html</id>
    <published>2018-04-28T00:00:00Z</published>
    <updated>2018-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently spent some time debugging GHC bug <a href="https://ghc.haskell.org/trac/ghc/ticket/15038">#15038</a> and to help with context switching between debugging and other tasks I took notes during debugging. After successfully debugging it and reading my notes from the beginning I thought it may be an interesting read, so I’m publishing it. It may not make much sense to anyone other than me, and it’s very lightly edited, so keep your expectations low :)</p>
<hr />
<p>Crashes at this point:</p>
<pre><code>&gt;&gt;&gt; bt
#11 0x00000000008d6650 in
    barf (s=0x94fe90 &quot;evacuate(static): strange closure type %d&quot;) at rts/RtsMessages.c:47
#12 0x00000000008e7e83 in
    evacuate (p=0x981640) at rts/sm/Evac.c:574
#13 0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#14 0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#15 0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#16 0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#17 0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#18 0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#19 0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#20 0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#21 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#22 0x000000000040d7da in
    main ()</code></pre>
<p>While evacuating object at location</p>
<pre><code>p = (StgClosure **) 0x981640</code></pre>
<p>Info table of the object:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl(q)
$5 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>Untagged object:</p>
<pre><code>q = (StgClosure *) 0x981618</code></pre>
<p>Tagged:</p>
<pre><code>*p = (StgClosure *) 0x981619</code></pre>
<p>Where does this object appear? Tagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981619
(nothing)</code></pre>
<p>Untagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981618
(nothing)</code></pre>
<p>Not in the heap!</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981618
rctv_closure in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>According to STG output references should be</p>
<pre><code>lvl4_rctv referenced by
lvl5_rctw referenced by
lvl6_rctx referenced by
$wbyteParserBadOnce</code></pre>
<p>Looking at each closure:</p>
<pre><code>rctv :: ([Char], Packed.Bytes.Parser.Parser Word)

&gt;&gt;&gt; print (StgClosure)rctv_closure (0x981618)
{
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctv_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 0,
  code = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt; &quot;H\377\303\377e&quot;
}


rctw :: [([Char], Packed.Bytes.Parser.Parser Word)]

&gt;&gt;&gt; print (StgClosure)rctw_closure (0x981638)
{
  header = {
    info = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctw_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 1,
  code = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt; &quot;H\203\303\002\377e&quot;
}


rctx :: Packed.Bytes.Parser.Parser Word

&gt;&gt;&gt; print (StgClosure)rctx_closure (0x981658)
{
  header = {
    info = 0x40ca10 &lt;rctx_info&gt;
        -- Packed.Bytes.Parser.Parser GHC.Types.Word
  },
  payload = []
}
&gt;&gt;&gt; print *get_itbl(&amp;rctx_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 21, -- THUNK_STATIC
  srt_bitmap = 3,
  code = 0x40ca10 &lt;rctx_info&gt; &quot;H\215E\350L9\370r@H\203\354\bL\211\350H\211\336H\211\307\061\300\350S\314M&quot;
}

$wbyteParserBadOnce :: Int -&gt; Int#

&gt;&gt;&gt; print (StgClosure)Parser_zdwbyteParserBadOnce_closure (0x981680)
{
  header = {
    info = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;Parser_zdwbyteParserBadOnce_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 113,
  code = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt; &quot;H\215E\320L9\370\017\202\342\001&quot;
}</code></pre>
<p>Back to the backtrace. Adding watchpoints makes it run too slow, so first figure out when this happens:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 2 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 2 10000000
Will ignore next 10000000 crossings of breakpoint 2.
&gt;&gt;&gt; c
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 6 times
        ignore next 9999994 hits</code></pre>
<p>So 6th time we run GC we see this error. Let’s see if 0x981640 is a valid closure by the beginning of 6th GC:</p>
<pre><code>&gt;&gt;&gt; call LOOKS_LIKE_CLOSURE_PTR(0x981640)
$5 = true</code></pre>
<p>However at this point it already has wrong type:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl((StgClosure*)0x981640)
$4 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>In fact, this object has this type since the beginning.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981640
rctw_closure + 8 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>This object is in <code>payload[0]</code> of <code>rctw</code>?</p>
<pre><code>lvl5_rctw
  :: [(GHC.Base.String, Packed.Bytes.Parser.Parser GHC.Types.Word)]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [lvl4_rctv GHC.Types.[]];</code></pre>
<p>So it should be <code>rctv</code>. Something is wrong with first payload of <code>rctw</code>. We should focus on evacuation/scavenging of <code>rctw</code>.</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981638
&gt;&gt;&gt; c
** hits breakpoint **
&gt;&gt;&gt; call printClosure(q)
ghc-prim:GHC.Types.:(0x981619, 0xace111)
&gt;&gt;&gt; info symbol 0x981619
rctv_closure + 1 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>So indeed we have <code>rctv_closure</code> in first payload (but tagged).</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)
&gt;&gt;&gt; call printClosure(0xace111)
ghc-prim:GHC.Types.[](0x8c3450#)</code></pre>
<p>It looks OK. Let’s see if it breaks after this GC.</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981638)
ghc-prim:GHC.Types.:(0x981619, 0xace111)</code></pre>
<p>Nope. Continue until first payload of 0x981638 (<code>rctw</code>) changes.</p>
<p>It turns out the payload doesn’t change. So <code>rctv</code> itself changes!</p>
<p>On 4th <code>GarbageCollect()</code> this fails:</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
*** printClosure: unknown type 16585 ****
Main: internal error: printClosure 16585
    (GHC version 8.5.20180425 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
<p>So break at 3rd:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 1 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 1 2
Will ignore next 2 crossings of breakpoint 1.
&gt;&gt;&gt; c
&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)</code></pre>
<p>(Remember that 0x981619 is tagged 0x981618 which is <code>rctv</code>)</p>
<p>Now watch the closure:</p>
<pre><code>&gt;&gt;&gt; watch (StgClosure)rctv_closure
Watchpoint 2: (StgClosure)rctv_closure
&gt;&gt;&gt; disable breakpoint 1
&gt;&gt;&gt; c</code></pre>
<p>This takes forever, gdb starts leaking memory, fills 16G and swaps.</p>
<p>Let’s take a look at static objects again. <code>rctv</code>’s info table pointer somehow gets overwritten. What could cause this? Perhaps an object before <code>rctv</code> has an overlapping field.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981617
rctu_closure + 7 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>It seems like we have <code>rctu</code> before <code>rctv</code>.</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)

&gt;&gt;&gt; print (StgClosure)rctu_closure
{
  header = {
    info = 0x40c908 &lt;rctu_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;rctu_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 1,
  code = 0x40c908 &lt;rctu_info&gt; &quot;H\215E\370L9\370\017\202\277&quot;
}</code></pre>
<p>So locations of <code>rctu</code> and <code>rctv</code></p>
<pre><code>rctu: 0x981610
rctv: 0x981618</code></pre>
<p>There’s only 8 bytes in between. This doesn’t look right. Because <code>rctu</code> is a static object with no payload, so it needs at least two words: info table pointer and static link field. Static link field is missing in the layout, so info table pointer of <code>rctv</code> is used as static link.</p>
<p>At this point I remember different types of objects have link fields in different places so let’s check:</p>
<pre><code>#define FUN_STATIC_LINK(p)   (&amp;(p)-&gt;payload[0])</code></pre>
<p>Because I can’t add watchpoint to this location so I do this:</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981610</code></pre>
<p>Just to count which GC we’re at</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
&gt;&gt;&gt; ignore 2 10000</code></pre>
<p>First hit</p>
<pre><code>&gt;&gt;&gt; print (StgClosure)rctv_closure
$1 = {
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000008e7a73 in evacuate_static_object at rts/sm/Evac.c:340
        stop only if q == 0x981610 (target evals)
        breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 3 times
        ignore next 9997 hits</code></pre>
<p>Let’s see if this breaks it:</p>
<pre><code>&gt;&gt;&gt; fin
&gt;&gt;&gt; print (StgClosure)rctv_closure
$2 = {
  header = {
    info = 0x981561
  },
  payload = 0x8
}</code></pre>
<p>Yep! So this function call breaks rctv:</p>
<pre><code>&gt;&gt;&gt; bt
#0  evacuate_static_object (link_field=0x981618, q=0x981610 (rctu)) at rts/sm/Evac.c:340
#1  0x00000000008e7e20 in
    evacuate (p=0x981628) at rts/sm/Evac.c:546
#2  0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#3  0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#4  0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#5  0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#6  0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#7  0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#8  0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#9  0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#10 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#11 0x000000000040d7da in
    main ()</code></pre>
<p>I’m convinced that layout of <code>rctu</code> is wrong. I’ll add some debug prints to GHC to see why the layout is generated this way, but before that I’m saving all the binaries and dump files of this session.</p>
<p>The bug should be in <code>cgTopRhsClosure</code>, the Cmm code generator for top-level closures.</p>
<p>Good thing GHC is deterministic enough these days so I get the same symbols when I recompile (later I realized that top-level symbols are deterministic enough but local ids usually change).</p>
<pre><code>gen_code
  closure_label: lvl3_rctu_closure
  descr: &lt;Parser.lvl3_rctu&gt;
  info_tbl: label: lvl3_rctu_info
            rep:HeapRep static {
                  Fun {arity: 6 fun_type: ArgGen [True, False, False, True, True]} }
  fv_details: []</code></pre>
<p>This looks fine. Let’s check <code>mkStaticClosureFields</code>:</p>
<pre><code>mkStaticClosureFields
  caf_refs: NoCafRefs
  info_lbl: lvl3_rctu_info
  is_caf: False
  padding: []
  static_link_field: []
  saved_info_field: []
  static_link_value: 3</code></pre>
<p>So this object doesn’t get a static link field. This is because the condition</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">staticClosureNeedsLink (mayHaveCafRefs caf_refs) info_tbl</a></code></pre></div>
<p>doesn’t hold.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">staticClosureNeedsLink ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">CmmInfoTable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="co">-- A static closure needs a link field to aid the GC when traversing</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="co">-- the static closure graph.  But it only needs such a field if either</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="co">--        a) it has an SRT</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="co">--        b) it&#39;s a constructor with one or more pointer fields</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6"><span class="co">-- In case (b), the constructor&#39;s fields themselves play the role</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="co">-- of the SRT.</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">staticClosureNeedsLink has_srt <span class="dt">CmmInfoTable</span>{ cit_rep <span class="fu">=</span> smrep }</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">  <span class="fu">|</span> isConRep smrep         <span class="fu">=</span> not (isStaticNoCafCon smrep)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">  <span class="fu">|</span> otherwise              <span class="fu">=</span> has_srt <span class="co">-- needsSRT (cit_srt info_tbl)</span></a></code></pre></div>
<p>So <code>has_srt</code> is <code>False</code> for this object and <code>idCafInfo</code> of this closure says it’s not caffy.</p>
<p>Just to make sure this is the problem, I modify the code to treat all top-level closures as caffy. Indeed that fixes the bug.</p>
<p>CAFness of bindings are decided in <code>hasCafRefs</code> in <code>TidyPgm</code>. Two conditions for CAFness are</p>
<ul>
<li>Top level and no arguments</li>
<li>Mentions CAFs</li>
</ul>
<p>First one obviously doesn’t hold becasue <code>rctu</code> is a function. I don’t know why the second condition doesn’t hold yet.</p>
<p><code>TidyPgm</code> operates on Core so let’s look at Core of <code>rctu</code>:</p>
<pre><code>-- RHS size: {terms: 80, types: 1,207, coercions: 0, joins: 0/0}
lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s, Packed.Bytes.Parser.Result# s Word #)
[GblId, Arity=2, Caf=NoCafRefs, Str=&lt;S,1*U&gt;&lt;S,U&gt;, Unf=OtherCon []]
lvl3_rctu
  = \ (@ s_a6Ca)
      (leftovers0_a691
         :: Packed.Bytes.Parser.Maybe#
              (Packed.Bytes.Parser.Leftovers# s_a6Ca))
      (s0_a692 :: GHC.Prim.State# s_a6Ca) -&gt;
      case leftovers0_a691 of {
        (#_|#) ds_d6Km -&gt;
          (# s0_a692,
             (# GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ (&#39;GHC.Types.TupleRep
                       &#39;[&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                         &#39;GHC.Types.LiftedRep])
                  @ (# #)
                  @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                  GHC.Prim.(##),
                GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ &#39;GHC.Types.LiftedRep
                  @ (# #)
                  @ Word
                  GHC.Prim.(##) #) #);
        (#|_#) ds_d6Kn -&gt;
          case ds_d6Kn of { (# bytes0_scqD, stream0_scqE #) -&gt;
          case bytes0_scqD of { (# arr0_scqH, off0_scqI, len0_scqJ #) -&gt;
          case GHC.Prim.&gt;# len0_scqJ 0# of {
            __DEFAULT -&gt;
              case Packed.Bytes.Parser.nextNonEmpty @ s_a6Ca stream0_scqE s0_a692
              of
              { (# ipv_s6NZ, ipv1_s6O0 #) -&gt;
              case ipv1_s6O0 of {
                (#_|#) ds3_d6JW -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          GHC.Prim.(##),
                        GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          GHC.Prim.(##) #) #);
                (#|_#) ds3_d6JX -&gt;
                  case ds3_d6JX of { (# bytes1_scqM, stream1_scqN #) -&gt;
                  case bytes1_scqM of { (# arr1_scqQ, off1_scqR, ds4_scqS #) -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          (# (# arr1_scqQ, GHC.Prim.+# off1_scqR 1#,
                                GHC.Prim.-# ds4_scqS 1# #),
                             stream1_scqN #),
                        GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          a1_rcbR #) #)
                  }
                  }
              }
              };
            1# -&gt;
              (# s0_a692,
                 (# GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ (&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                             &#39;GHC.Types.LiftedRep])
                      @ (# #)
                      @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                      (# (# arr0_scqH, GHC.Prim.+# off0_scqI 1#,
                            GHC.Prim.-# len0_scqJ 1# #),
                         stream0_scqE #),
                    GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ &#39;GHC.Types.LiftedRep
                      @ (# #)
                      @ Word
                      a1_rcbR #) #)
          }
          }
          }
      }</code></pre>
<p>This is huge and I’m not going to check this by hand. However at this point I realize that the condition for evacuating a <code>FUN_STATIC</code> is</p>
<pre><code>case FUN_STATIC:
    if (info-&gt;srt_bitmap != 0) {
        evacuate_static_object(FUN_STATIC_LINK((StgClosure *)q), q);
    }
    return;</code></pre>
<p>So this is not marked as CAF, but its SRT bitmap is not empty. Perhaps the bug is in the SRT bitmap.</p>
<p>I also try this in gdb:</p>
<pre><code>&gt;&gt;&gt; set get_itbl(&amp;rctu_closure)-&gt;srt_bitmap = 0</code></pre>
<p>This also fixes it. Now let’s figure out why SRT bitmap of <code>rctu</code> (which is supposed to be a non-CAF) is 1.</p>
<p>I look again at the definition of <code>rctu</code> and it seems like <code>a1_rcbR</code> is a free variable.</p>
<pre><code>a1_rcbR :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [5##];</code></pre>
<p>However because this is not a CAF it shouldn’t make <code>rctu</code> CAF.</p>
<p>I stare at the code aimlessly for a while until I realize something interesting. This is the STG for <code>rctu</code> after unarisation:</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=&lt;S,1*U&gt;&lt;S,U&gt;,
 Unf=OtherCon []] =
    [] \r [us_gcwc us_gcwd us_gcwe us_gcwf us_gcwg void_0E]
        case us_gcwc of tag_gcwh {
          __DEFAULT -&gt;
              (#,,,,,,#) [1#
                          Control.Exception.Base.absentError
                          Control.Exception.Base.absentError
                          0##
                          0##
                          1#
                          Control.Exception.Base.absentError];
          2# -&gt;
              case &gt;# [us_gcwg 0#] of {
                __DEFAULT -&gt;
                    case Packed.Bytes.Parser.nextNonEmpty us_gcwe GHC.Prim.void# of {
                      (#,,,,#) us_gcwi us_gcwj us_gcwk us_gcwl us_gcwm -&gt;
                          case us_gcwi of tag_gcwn {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [1#
                                            Control.Exception.Base.absentError
                                            Control.Exception.Base.absentError
                                            0##
                                            0##
                                            1#
                                            Control.Exception.Base.absentError];
                            2# -&gt;
                                case -# [us_gcwm 1#] of sat_scuk {
                                  __DEFAULT -&gt;
                                      case +# [us_gcwl 1#] of sat_scuj {
                                        __DEFAULT -&gt;
                                            (#,,,,,,#) [2#
                                                        us_gcwj
                                                        us_gcwk
                                                        sat_scuj
                                                        sat_scuk
                                                        2#
                                                        a1_rcbR];
                                      };
                                };
                          };
                    };
                1# -&gt;
                    case -# [us_gcwg 1#] of sat_scur {
                      __DEFAULT -&gt;
                          case +# [us_gcwf 1#] of sat_scuq {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [2# us_gcwd us_gcwe sat_scuq sat_scur 2# a1_rcbR];
                          };
                    };
              };
        };</code></pre>
<p>This has two free variables: <code>a1_rcbR</code> and <code>Control.Exception.Base.absentError</code>. <code>a1_rcbR</code> is clearly not a CAF, but maybe <code>absentError</code> is? Because <code>absentError</code> references are generated in unarise, which happens much later than <code>TidyPgm</code> (right before generating Cmm), <code>TidyPgm</code> can’t take those into account.</p>
<p><code>Id</code> for <code>absentError</code> is generated using <code>vanillaIdInfo</code> which sets the CAF-ness field as <code>MayHaveCafRefs</code>. So clearly <code>absentError</code> is a CAFFY.</p>
<p>So in summary, we introduce references to CAFs in <code>UnariseStg</code> which happens later than <code>TidyPgm</code>. The code generator is somehow handles this correctly by generating a SRT for this function and setting the info table bitmap correctly. However object layout generator (in <code>cgTopRhsClosure</code>) only uses the information generated in <code>TidyPgm</code>, so we get this mismatch of SRT information of this function.</p>
<p>Some ways to fix this:</p>
<ul>
<li>Update binder ids in unarise if we introduced an <code>absentError</code></li>
<li>Conservatively treat unboxed sums as CAFFY in <code>TidyPgm</code></li>
<li>Mark <code>absentError</code> as non-CAF (I don’t know if it has to be a CAF, I think error ids are conservatively marked as CAFs)</li>
</ul>
<p>The whole thing took 4:47 hours.</p>]]></summary>
</entry>
<entry>
    <title>Three runtime optimizations done by GHC's GC</title>
    <link href="http://osa1.net/posts/2018-03-16-gc-optimizations.html" />
    <id>http://osa1.net/posts/2018-03-16-gc-optimizations.html</id>
    <published>2018-03-16T00:00:00Z</published>
    <updated>2018-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working on GHC’s GC code I realized that it does some runtime optimizations. One of those I already knew from another language, but the other two were quite interesting to me because they’re related with laziness. I wouldn’t think consequences of laziness reach this far into the runtime system. It turns out it does; disabling those optimizations make programs run significantly slower.</p>
<p>Because I almost read the whole code line by line, I believe this list is exhaustive. The code is taken from the source code but significantly simplified.</p>
<p>If you’re not familiar with GHC’s heap object layout and info tables etc., I suggest reading <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">the wiki page</a> before moving on the rest of the post.</p>
<h1 id="replacing-small-int-and-char-closures-with-statically-initialized-shared-closures">1. Replacing small Int and Char closures with statically initialized, shared closures</h1>
<p><code>Int</code> and <code>Char</code> closures have one non-pointer field for the actual integer and character values, as can be seen in GHCi:</p>
<pre><code>λ&gt; :info Int
data Int = GHC.Types.I# GHC.Prim.Int#     -- Defined in ‘GHC.Types’
λ&gt; :info Char
data Char = GHC.Types.C# GHC.Prim.Char#   -- Defined in ‘GHC.Types’</code></pre>
<p>The corresponding closure type for closures with one non-pointer and no pointers is <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/includes/rts/storage/ClosureTypes.h#L25"><code>CONSTR_0_1</code></a>. The garbage collector <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L656">needs to check closure type before copying an object</a> to decide how many bytes to copy (and also to decide what pointers to follow and copy the pointed object, but this happens in a later stage). When it finds a <code>CONSTR_0_1</code> it checks if it’s actually an <code>Int</code> or <code>Char</code> closure, if it is, it checks if the payload (the actual <code>Int</code> and <code>Char</code> values) is within a range. If it is then we know that we have statically-allocated <code>Int</code> or <code>Char</code> closure what is identical to the one we’re copying, so we return address to the statically allocated one rather than copying the closure and returning the new address of the copied closure. This way we avoid having multiple closures for <code>1 :: Int</code>, for example. The code (simplified, some comments by me):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="cf">case</span> CONSTR_0_1:</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="co">// Constructor with one non-pointer field. Read the field.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    StgWord w = (StgWord)q-&gt;payload[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="cf">if</span> (<span class="co">// is it a Char?</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        info == Czh_con_info &amp;&amp;</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="co">// is the value in range?</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        (StgChar)w &lt;= MAX_CHARLIKE)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="co">// return address to statically allocated Char closure</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        *p =  TAG_CLOSURE(tag, (StgClosure *)CHARLIKE_CLOSURE((StgChar)w));</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="cf">else</span> <span class="cf">if</span> (<span class="co">// is it an Int?</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">             info == Izh_con_info &amp;&amp;</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">             <span class="co">// is the value in range?</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">             (StgInt)w &gt;= MIN_INTLIKE &amp;&amp; (StgInt)w &lt;= MAX_INTLIKE)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    {</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">        <span class="co">// return address to statically allocated Int closure</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        *p = TAG_CLOSURE(tag, (StgClosure *)INTLIKE_CLOSURE((StgInt)w));</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">    <span class="co">// otherwise copy the object</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24">    {</a>
<a class="sourceLine" id="cb2-25" data-line-number="25">        copy_tag_nolock(p,info,q,sizeofW(StgHeader)+<span class="dv">1</span>,gen_no,tag);</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">}</a></code></pre></div>
<p>What are the ranges here? Looking at the <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/StgMiscClosures.cmm#L679-L974">definition</a>, we see that integers in range [-16, 16] and the whole ASCII character set is covered.</p>
<p>Here’s a small program that shows the effect of this optimization:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">GHC.Stats</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Mem</span> (performMajorGC)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">seqIntList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">seqIntList []       a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">seqIntList (i <span class="fu">:</span> is) a <span class="fu">=</span> i <span class="ot">`seq`</span> is <span class="ot">`seqIntList`</span> a</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">let</span> lst <span class="fu">=</span> [ <span class="dv">0</span> <span class="fu">..</span> <span class="dv">15</span> ]</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="co">-- let lst = [ 17 .. 32 ] -- enable this on the second run</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="co">-- evaluate the list</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    lst <span class="ot">`seqIntList`</span> return ()</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="co">-- collect any thunks, do the optimization if possible, update stats</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    performMajorGC</a>
<a class="sourceLine" id="cb3-20" data-line-number="20"></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    rts_stats <span class="ot">&lt;-</span> getRTSStats</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    putStrLn (<span class="st">&quot;Live data: &quot;</span> <span class="fu">++</span> show (gcdetails_live_bytes (gc rts_stats)) <span class="fu">++</span> <span class="st">&quot; bytes&quot;</span>)</a>
<a class="sourceLine" id="cb3-23" data-line-number="23"></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    <span class="co">-- to make sure our list won&#39;t be collected</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">    lst <span class="ot">`seqIntList`</span> return ()</a></code></pre></div>
<p>Run it with:</p>
<pre><code>ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T</code></pre>
<p>On the second run, disable the first list and enable the second one. You’ll see this output:</p>
<pre><code>$ ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T
[1 of 1] Compiling Main             ( eq.hs, eq.o )
Linking eq ...
Live data: 2224 bytes

$ ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T
[1 of 1] Compiling Main             ( eq.hs, eq.o )
Linking eq ...
Live data: 2480 bytes</code></pre>
<p>So second program has 256 bytes more live data. Let’s check if that makes sense. The first program doesn’t have any heap-allocated <code>Int</code> closures, because all of the <code>Int</code> in the program are within the range of statically allocated <code>Int</code> closures. Second one has 16 <code>Int</code> closures. An <code>Int</code> closure is two words: a pointer to the <code>I#</code> info table, and an actual integer value in the payload, so that’s 16 bytes. 16 (number of <code>Int</code> closures) * 16 (<code>Int</code> closure size) = 256.</p>
<p>I know at least one another language, Python, does this as well:</p>
<pre><code>Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 1
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; x = 100000000000
&gt;&gt;&gt; y = 100000000000
&gt;&gt;&gt; x is y
False</code></pre>
<p>Although I’m not sure if it does this during garbage collection.</p>
<h1 id="shorting-out-indirections">2. Shorting out indirections</h1>
<p>This is related with how lazy evaluation is implemented so we’ll first take a look at the generated code for a simple thunk update. When we compile the following program: (to keep things simple we disable optimizations)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    i <span class="ot">&lt;-</span> readLn</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    print (fib i)</a></code></pre></div>
<p>in STG level we get this function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sat_s31Q <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    \r [i_s31O]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="kw">let</span> { sat_s31P <span class="fu">=</span> \u [] fib_rqh i_s31O;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        } <span class="kw">in</span>  print <span class="fu">$</span>fShowInt sat_s31P;</a></code></pre></div>
<p>Here <code>fib_rqh</code> is the <code>fib</code> function, and <code>sat_s31P</code> is the thunk for <code>fib i</code>. First let’s take a look at how this thunk is evaluated in the use site: (Cmm syntax)</p>
<pre><code>I64[Sp - 16] = stg_upd_frame_info;
P64[Sp - 8] = _s31P::P64;
_s31O::P64 = P64[_s31P::P64 + 16];
R2 = _s31O::P64;
Sp = Sp - 16;
call fib_rqh_info(R2) args: 24, res: 0, upd: 24;</code></pre>
<p>So we push the thunk (<code>_s31P</code>), then <code>stg_upd_frame_info</code> to the stack, and jump to the code for the <code>fib</code> function, passing the argument in <code>R2</code>.</p>
<p>I won’t show the code (because it’s large and complex), but the code for <code>fib</code> puts the return value in <code>R1</code>, pops the stack, and jump to the code for the popped stack frame, which is <code>stg_upd_frame_info</code>.</p>
<p>At this point we have the return value of <code>fib</code> in <code>R1</code>, and thunk to update at the bottom of the stack.</p>
<p>The code for <code>stg_upd_frame_info</code> is as follows: (simplified, see the original version <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/Updates.cmm#L28-L38">here</a>)</p>
<pre><code>INFO_TABLE_RET ( stg_upd_frame, // label
                 UPDATE_FRAME,  // frame type
                 w_ info_ptr,   // info ptr
                 p_ updatee )   // thunk to update at the bottom of the stack
    return (P_ ret) // in R1 we expect the value to update the thunk with
{
    StgInd_indirectee(updatee) = ret;       // (1)
    SET_INFO(updatee, stg_BLACKHOLE_info);  // (2)
    ...
    return (ret);
}</code></pre>
<p>This basically replaces the thunk’s (<code>_s31P</code>) info table pointer with <code>stg_BLACKHOLE_info</code> in line (2) (effectively making the thunk an indirection), and writes pointer to the evaluated object to the payload in line (1).</p>
<p>Now any code that uses this value needs to follow the pointer written to what was originally a thunk in line (1). This is done by the <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/StgMiscClosures.cmm#L295">entry code of <code>stg_BLACKHOLE_info</code></a>.</p>
<p>Now, because the GC copies objects from one heap to another, and updates any references to these moved objects in thread stacks (and in other roots), we can follow any indirections when copying blackhole objects, and replace references in thread stacks to the blackhole object with a reference to the object pointed to by the blackhole object. <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L732-L755">The code</a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="cf">case</span> BLACKHOLE:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    StgClosure *r;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">const</span> StgInfoTable *i;</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    r = ((StgInd*)q)-&gt;indirectee;</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="cf">if</span> (GET_CLOSURE_TAG(r) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        i = r-&gt;header.info;</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="cf">if</span> (IS_FORWARDING_PTR(i)) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">            r = (StgClosure *)UN_FORWARDING_PTR(i);</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">            i = r-&gt;header.info;</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        }</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        <span class="cf">if</span> (i == &amp;stg_TSO_info</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">            || i == &amp;stg_WHITEHOLE_info</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">            || i == &amp;stg_BLOCKING_QUEUE_CLEAN_info</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">            || i == &amp;stg_BLOCKING_QUEUE_DIRTY_info) {</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">            copy(p,info,q,sizeofW(StgInd),gen_no);</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">            <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">        ASSERT(i != &amp;stg_IND_info);</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    q = r;</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">    *p = r;</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">    <span class="cf">goto</span> loop;</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">}</a></code></pre></div>
<p>I don’t understand all the details in this code, but I think the important bits are the <code>q-&gt;indirectee</code> line which follows the pointer written in line (1) above, and <code>goto loop</code> which makes the garbage collector copy and return the object pointed by the blackhole.</p>
<p>After this we no longer have to follow a pointer to our evaluated thunk. Instead references to the thunk become references to the evaluated object.</p>
<h1 id="selector-thunk-evaluation">3. Selector thunk evaluation</h1>
<p>A selector thunk is a thunk of this form: (<a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/compiler/codeGen/StgCmmBind.hs#L267-L297">code</a>)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="dt">C</span> x1 <span class="fu">...</span> xn <span class="ot">-&gt;</span> xm</a></code></pre></div>
<p>where <code>1 &lt;= m &lt;= n</code>, and <code>x</code> is a variable. The problem with such a thunk is that it keeps all of the fields of <code>x</code> live until the selector thunk is evaluated, even when <code>x</code> is evaluated by some other code. As an example where this happens, suppose we have this record:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">R</span> <span class="fu">=</span> <span class="dt">R</span> {<span class="ot"> _i1 ::</span> <span class="dt">Int</span>,<span class="ot"> _i2 ::</span> <span class="dt">Int</span>, <span class="fu">...</span> other fields <span class="fu">...</span> }</a></code></pre></div>
<p>then in a function we take <code>R</code> as parameter, and use the fields:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f r <span class="fu">=</span> _i1 r <span class="fu">+</span> _i2 r</a></code></pre></div>
<p>Here <code>_i1 r</code> and <code>_i2 r</code> are selector thunks. Now suppose that the parameter to this function was already evaluated before the function is called. In this case the thunk that holds the this function application will keep all of <code>r</code> live even though only <code>_i1</code> and <code>_i2</code> are needed.</p>
<p>It turns out this problem was known since around <del>1985</del> 1981. <del>To my knowledge, Wadler was the first one to suggest solving these kind of “leaks” in the garbage collector</del> <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> (see <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> for correction). The idea is that while the GC copies these thunks it checks if the “selectee” is already evaluated. If so the GC evaluates the selector thunk during copying, and copies the evaluated form. Because selectors thunks are so simple (the exact shape of a selector thunk is well specified and it can’t do anything other than accessing a field) evaluation of these are just a matter of indexing the selectee’s payload. The function that does this is <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L1002">here</a>. The whole story is complicated because of concurrency concerns (e.g. another GC thread can also evaluate the thunk at the same time), but the actual optimization starts around line 1104 by looking at info table at the selectee. If it’s a constructor, then we access to the field and return it. Otherwise it’s a thunk and we copy it as usual.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In each cycle a copying garbage collector copies live data in a heap to another heap and abandons the old heap. It turns out this kind of garbage collection is really convenient for implementing optimizations described above. The code that traverses all live data, copies it, and updates the roots is already there. Doing updates on objects while copying is just a matter of adding a few more lines in the copying function.</p>
<p>In a non-copying collector this is much trickier, because the collector doesn’t actually need to update roots or the data. For example, to implement optimizations (2) in a mark-sweep collector we have to somehow keep track of the location where we found the pointer to the object we’re currently marking. Then, if the object became an indirection, we have to update the source location and should not mark the indirection object, because some other object may have a reference to it, and we have to update that reference too. In short, it’s certainly possible, but much trickier. Mark phase gets more complicated.</p>
<p>In summary,</p>
<ul>
<li><p>Generational copying collectors are known to be a good fit for functional languages. It turns out if your language is also lazy they’re even better fit.</p></li>
<li><p>Laziness have far-reaching consequences. The optimizations (2) and (3) are really essential to get good performance out of lazy programs (try commenting out those lines in the GC!), and they require support from the GC.</p></li>
</ul>
<hr />
<p>This post is submitted to <a href="https://www.reddit.com/r/haskell/comments/852jfc/three_runtime_optimizations_done_by_ghcs_gc/">/r/haskell</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>“Fixing some space leaks with a garbage collector”, Wadler, 1987.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Correction: Wadler was the first one to write about it in 1987, but Lennart Augustsson came up with this solution around 1981, and <a href="https://www.reddit.com/r/haskell/comments/852jfc/three_runtime_optimizations_done_by_ghcs_gc/dvuwtl0/">according him him</a> David Turner came up with the solution even before him.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Fuzzy module loading in GHCi</title>
    <link href="http://osa1.net/posts/2017-10-26-ghc-fuzzy-module-loading.html" />
    <id>http://osa1.net/posts/2017-10-26-ghc-fuzzy-module-loading.html</id>
    <published>2017-10-26T00:00:00Z</published>
    <updated>2017-10-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/ghci.html#ghci-cmd-:def">A GHCi macro</a> is just a function of type <code>String -&gt; IO String</code>. The argument is parameter of the macro, and return value is evaluated by GHCi as a command.</p>
<p>Using this and the <a href="http://hackage.haskell.org/package/process"><code>process</code></a> library we can implement a fuzzy module loader that works inside ghci:</p>
<p><img src="/images/fuzzy_ghci_load.gif" /></p>
<p>(sorry for the gif quality)</p>
<p>Here I’m using <a href="https://github.com/junegunn/fzf">fzf</a> as the fuzzy file finder. Code for defining the macro:</p>
<pre><code>import System.IO (withFile, IOMode (WriteMode))
import System.Process (runProcess, waitForProcess)

:{
let loadFuzzy _ = do
      let f = &quot;/tmp/fzf_out&quot;
      withFile f WriteMode $ \h -&gt; do
        p &lt;- runProcess &quot;fzf&quot; [] Nothing Nothing Nothing (Just h) Nothing
        _ &lt;- waitForProcess p
        out &lt;- readFile f
        return (&quot;:load &quot; ++ init out)
:}

:def l loadFuzzy</code></pre>
<p>Add this code to your global ghci config file (<code>~/.ghci</code>) or your project-wide <code>.ghci</code> (at the project root).</p>
<p>Only problem here is the <code>process</code> dependency: when you use <code>stack repl</code> or <code>cabal repl</code>, <code>process</code> won’t be importable in GHCi unless the project you’re loading into GHCi already has it as a dependency. One solution is to pass <code>-package process</code> to <code>cabal repl</code> or <code>--ghci-options=&quot;-package process&quot;</code> to <code>stack repl</code>. Because <code>process</code> is distributed with GHC this will always work.</p>]]></summary>
</entry>
<entry>
    <title>A parallel scheduler in 50 lines of Haskell</title>
    <link href="http://osa1.net/posts/2017-10-16-a-parallel-scheduler.html" />
    <id>http://osa1.net/posts/2017-10-16-a-parallel-scheduler.html</id>
    <published>2017-10-16T00:00:00Z</published>
    <updated>2017-10-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s a problem:</p>
<ul>
<li>You have N resources.</li>
<li>You have M tasks.</li>
<li>Each task requires exclusive access to a subset of the resources.</li>
<li>Tasks can be run in parallel.</li>
</ul>
<p>Implement a scheduler that runs these tasks in parallel, utilizing available resources as much as possible.</p>
<p>The code I’ll show here piggybacks on GHC RTS for scheduling. But for that we first have to implement our resources and tasks in a way that exposes necessary information to GHC’s scheduler. The idea is simple and fun to implement, but I can’t recommended using it in production :-) Scheduling is a hard problem, with many variations, and I’ve only recently started reading about it. This solution is a fun one than anything else.</p>
<hr />
<p>The idea is simple; we implement resources as <code>MVar</code>s and tasks as threads. Threads (tasks) take the <code>MVar</code>s before performing the operation. Because threads are scheduled by GHC RTS, GHC handles scheduling of our tasks. Because of fairness properties of <code>MVar</code>s, our threads are scheduled “fairly”, e.g. all tasks eventually finish even when we have infinitely many tasks.</p>
<p>A resource is an abstract object with a lock and unique identifier:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Resource</span> <span class="fu">=</span> <span class="dt">Resource</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  {<span class="ot"> _resourceName ::</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> _resourceId   ::</span> <span class="dt">Unique</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ,<span class="ot"> _resourceLock ::</span> <span class="dt">MVar</span> ()</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Resource</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  show <span class="fu">=</span> T.unpack <span class="fu">.</span> _resourceName</a></code></pre></div>
<p><code>_resourceName</code> is just a string to be used for tracing program execution.</p>
<p>A <code>Unique</code> is an integer that can be used in at most one resource:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Unique</span> <span class="fu">=</span> <span class="dt">Unique</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>Using <code>Unique</code> we can define a total order for <code>Resource</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Resource</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  (<span class="fu">==</span>) <span class="fu">=</span> (<span class="fu">==</span>) <span class="ot">`on`</span> _resourceId</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Resource</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  compare <span class="fu">=</span> comparing _resourceId</a></code></pre></div>
<p>A task that requires exclusive access to a subset of all resources can be implemented using <code>withResources</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">withResources ::</span> (<span class="dt">MonadLogger</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m) <span class="ot">=&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">withResources locks a <span class="fu">=</span> acquire_locks (S.toList locks)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    acquire_locks ls <span class="fu">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">      [] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        a</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">      l <span class="fu">:</span> ls&#39; <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        logDebug (<span class="st">&quot;taking lock &quot;</span> <span class="fu">&lt;&gt;</span> (_resourceName l))</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">        withMVar (_resourceLock l) <span class="fu">$</span> \() <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">          acquire_locks ls&#39;</a></code></pre></div>
<p>Note that when all tasks are implemented using this function a deadlock won’t occur: resources are ordered, and <code>S.toList</code> generates a sorted list, which in turn causes <code>acquire_locks</code> to take locks in order, effectively implementing <a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">Dijkstra’s resource hierarchy solution to the dining philosophers problem</a>.</p>
<p>Here are three task generators:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Task</span> <span class="fu">=</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  {<span class="ot"> runTask ::</span> forall m <span class="fu">.</span> (<span class="dt">MonadLogger</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m) <span class="ot">=&gt;</span> m () }</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">mkFastTask ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">mkFastTask i res <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="dt">Task</span> <span class="fu">$</span> withResources res <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">      logDebug (<span class="st">&quot;Performing &quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">      threadDelay (<span class="dv">500</span><span class="ot"> ::</span> <span class="dt">Milliseconds</span>)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">      logDebug (<span class="st">&quot;Fast task done (&quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i) <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">mkSlowTask ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">mkSlowTask i res <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="dt">Task</span> <span class="fu">$</span> withResources res <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      logDebug (<span class="st">&quot;Performing &quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i))</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">      threadDelay (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Seconds</span>)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">      logDebug (<span class="st">&quot;Slow task done (&quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i) <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="ot">mkCrashingTask ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">mkCrashingTask i res <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="dt">Task</span> <span class="fu">$</span> withResources res <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">      logDebug (<span class="st">&quot;Performing &quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i))</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">      error <span class="st">&quot;task failed&quot;</span></a></code></pre></div>
<p>Integer arguments are just for tracing task execution in program output. <code>mkFastTask</code> generates a task that takes 500 milliseconds to run. <code>mkSlowTask</code> generates a task that takes 3 seconds. <code>mkCrashingTask</code> makes a task that throws an exception, demonstrating that we release resources properly on exceptions.</p>
<p>Finally, the scheduler just spawns tasks using <code>forkIO</code> or <code>async</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">schedule ::</span> (<span class="dt">MonadLogger</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m, <span class="dt">Forall</span> (<span class="dt">Pure</span> m)) <span class="ot">=&gt;</span> [<span class="dt">Task</span>] <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">schedule tasks <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    thrs <span class="ot">&lt;-</span> forM tasks <span class="fu">$</span> \(<span class="dt">Task</span> task) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">              async (task <span class="ot">`catch`</span> (\(<span class="ot">e ::</span> <span class="dt">SomeException</span>) <span class="ot">-&gt;</span> logDebug <span class="st">&quot;Task failed&quot;</span>))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    forM_ thrs wait</a></code></pre></div>
<p>Here’s an example run</p>
<pre><code>taking lock resource5
Performing 0
taking lock resource0
Performing 1
taking lock resource2
taking lock resource6
taking lock resource7
Performing 2
Task failed
taking lock resource6
Performing 3
taking lock resource8
Performing 4
taking lock resource1
taking lock resource2
Performing 5
Task failed
taking lock resource2
taking lock resource3
taking lock resource8
taking lock resource0
taking lock resource3
taking lock resource4
Performing 9
Fast task done (3)
Fast task done (9)
Fast task done (0)
Slow task done (1)
taking lock resource4
taking lock resource8
Slow task done (4)
Performing 6
Fast task done (6)
taking lock resource7
Performing 8
Task failed
Performing 7
Slow task done (7)</code></pre>
<p>The whole code that randomly generates resources and tasks and then runs them is <a href="https://gist.github.com/osa1/e7416f6a0f299f88f275bb8d56a31da3">here</a>. It uses quite a lot of dependencies because it was extracted from a larger program, and I’m too lazy to make it smaller and simpler. I provided a <code>stack.yaml</code> so hopefully it’s still not too hard to run.</p>]]></summary>
</entry>
<entry>
    <title>Enable these two flags in GHC 8.2</title>
    <link href="http://osa1.net/posts/2017-07-15-two-flags.html" />
    <id>http://osa1.net/posts/2017-07-15-two-flags.html</id>
    <published>2017-07-15T00:00:00Z</published>
    <updated>2017-07-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>As usual, the next major GHC release will be <a href="https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.2.1#Releasehighlights">pretty great</a>. It’ll come with a bunch of new features that I can’t wait to start using, and I’ve contributed to three of the new features<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, but what excites me the most is not any of these features. I’m most excited about the improved <code>-Werror</code> flag.</p>
<p>The summary is that with GHC 8.2 we’ll be able to promote some warnings into errors, without making <em>all warnings</em> errors (which is how <code>-Werror</code> worked pre-8.2). With this we can finally fix some of the Haskell 2010 warts.</p>
<hr />
<p>By the beginning of this year I moved from academia to industry. I was writing Haskell in academia, and I’m still writing Haskell, but the environment, tasks, and constraints are quite different, so the way I write Haskell changed quite a lot during this transition.</p>
<p>What I realized that some of the problems with Haskell 2010 are actually worse than I had previously thought.</p>
<h2 id="problem-1-initializing-records-without-initializing-all-of-its-fields">Problem 1: Initializing records without initializing all of its fields</h2>
<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-520003.15.2">Haskell 2010</a> says that when initializing records using labels, fields not mentioned are initialized as bottoms.</p>
<p>I just can’t fathom how Haskell 2010 people thought this is a good idea. In Haskell we constantly rely on compile-time errors to refactor our code. A common workflow is this: you update your data types, and follow the type errors to adapt your code to the changes. Quite often your program works as expected after this. I did this countless times during my career as a Haskell programmer, and I’m trying to improve GHC to <a href="https://github.com/ghc-proposals/ghc-proposals/pull/43">make this workflow even more efficient</a>.</p>
<p>The problem is this “feature” breaks this workflow, because adding a new field to a type no longer generates a compile error. It generates a warning, but that’s not good enough because (1) not all projects have <code>-Wall</code> enabled (2) not all projects are warning-free, which means new warnings sometimes go unnoticed (this happens in our code base all the time).</p>
<p>Indeed, even very experienced Haskellers release buggy code because of this. For example, warp-3.2.10 added a new field (<code>connFree</code>) to one of its types (<code>Connection</code>), and for some reason only the minor version was bumped (3.2.9 to 3.2.10, which is probably wrong according to <a href="https://pvp.haskell.org/">PVP</a> because the type was exported). The problem was warp-tls-3.2.2 had 3.3 as warp upper bound, so it compiled fine against warp-3.2.10, even though it didn’t initialize the field. This caused bugs in our system, which we thankfully discovered in our test environment rather than on production. The fix was <a href="https://github.com/yesodweb/wai/commit/b63ec0e865cf91af4143416adaf430969ba0ebb5#diff-44ce89cb2a54be5e525d74b83901f561R348">easy</a>, but the damage was done (the buggy warp-tls-3.2.2 is still on Hackage).</p>
<h2 id="problem-2-non-exhaustive-pattern-matching">Problem 2: Non-exhaustive pattern matching</h2>
<p>While I can’t find any mention to exhaustiveness of pattern matching in Haskell 2010, it clearly covers the case where patterns do not cover all values when defining <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3">formal semantics of pattern matching</a> (see case (b)). You only realize that this is a bad idea when (1) your code is not warning-free so new warnings sometimes go unnoticed and (2) you can’t promote individual warnings to errors. This again breaks the workflow I mentioned above, and makes code reviews much harder.</p>
<hr />
<p>The solution that GHC 8.2 brings is we can now make these two warnings errors, using <code>-Werror=missing-fields -Werror=incomplete-patterns</code>. There’s still one problem though, the error message is not good enough. Suppose we had this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Rec</span> <span class="fu">=</span> <span class="dt">Rec</span> {<span class="ot"> f1 ::</span> <span class="dt">Int</span>,<span class="ot"> f2 ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">S</span> <span class="fu">=</span> <span class="dt">C1</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">C2</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="co">-- incomplete pattern</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">sInt s <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">           <span class="dt">C1</span> i <span class="ot">-&gt;</span> i</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="co">-- missing field</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">initRec <span class="fu">=</span> <span class="dt">Rec</span> { f1 <span class="fu">=</span> <span class="dv">1</span> }</a></code></pre></div>
<p>Compile this with <code>ghc -Wall</code> and you get:</p>
<pre><code>[1 of 1] Compiling Lib              ( test.hs, test.o )

test.hs:11:1: warning: [-Wmissing-signatures]
    Top-level binding with no type signature: sInt :: S -&gt; Int
   |
11 | sInt s = case s of
   | ^^^^

test.hs:11:10: warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative: Patterns not matched: (C2 _)
   |
11 | sInt s = case s of
   |          ^^^^^^^^^...

test.hs:15:1: warning: [-Wmissing-signatures]
    Top-level binding with no type signature: initRec :: Rec
   |
15 | initRec = Rec { f1 = 1 }
   | ^^^^^^^

test.hs:15:11: warning: [-Wmissing-fields]
    • Fields of ‘Rec’ not initialised: f2
    • In the expression: Rec {f1 = 1}
      In an equation for ‘initRec’: initRec = Rec {f1 = 1}
   |
15 | initRec = Rec { f1 = 1 }
   |           ^^^^^^^^^^^^^^</code></pre>
<p>We only care about missing fields and incomplete patterns, so with GHC 8.2 we compile this with <code>ghc -Wall -Werror=missing-fields -Werror=incomplete-patterns</code>, which generates the same warnings, but the process exits with non-zero, and prints these extra lines:</p>
<pre><code>&lt;no location info&gt;: error:
Failing due to -Werror.</code></pre>
<p>This is not too useful, because if you get dozens of warnings there’s basically no way of knowing which of those warnings caused this error. One alternative is to disable <code>-Wall</code> and only use <code>-Werror</code>s. That way you know that the warnings you’re seeing are actually errors.</p>
<p>Still, this is not entirely satisfactory, because even though we don’t cause our build to fail when we have warnings, they’re still sometimes useful to see (for example, name shadowing warnings often catches accidental loops). So to improve this I recently <a href="https://phabricator.haskell.org/D3709">submitted a patch</a>, which is merged, but unfortunately won’t make it to GHC 8.2 (hopefully we’ll see it in GHC 8.4). With that patch when you have both <code>-Wall</code> and some <code>-Werror</code>s, you see this instead:</p>
<pre><code>[1 of 1] Compiling Lib              ( test.hs, test.o )

test.hs:11:1: warning: [-Wmissing-signatures]
    Top-level binding with no type signature: sInt :: S -&gt; Int
   |
11 | sInt s = case s of
   | ^^^^

test.hs:11:10: error: [-Wincomplete-patterns, -Werror=incomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative: Patterns not matched: (C2 _)
   |
11 | sInt s = case s of
   |          ^^^^^^^^^...

test.hs:15:1: warning: [-Wmissing-signatures]
    Top-level binding with no type signature: initRec :: Rec
   |
15 | initRec = Rec { f1 = 1 }
   | ^^^^^^^

test.hs:15:11: error: [-Wmissing-fields, -Werror=missing-fields]
    • Fields of ‘Rec’ not initialised: f2
    • In the expression: Rec {f1 = 1}
      In an equation for ‘initRec’: initRec = Rec {f1 = 1}
   |
15 | initRec = Rec { f1 = 1 }
   |           ^^^^^^^^^^^^^^</code></pre>
<p>Much better!</p>
<p>This is probably not as exciting to many people as, say, new features like compact regions or join points, but I think this will significantly improve “refactor types, folow type error, repeat” style workflows and make code reviews much easier.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I discovered and reported <a href="https://ghc.haskell.org/trac/ghc/ticket/10598">#10598</a> two years ago, which led to <code>-XDerivingStrategies</code> work, I was involved in the <a href="http://ezyang.com/papers/ezyang15-cnf.pdf">Compact regions paper</a>, and I implemented <a href="https://phabricator.haskell.org/D2259">unboxed sums</a> during my time at MSR Cambridge last summer.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>IORef and STRef under the hood</title>
    <link href="http://osa1.net/posts/2016-07-25-IORef-STRef-exposed.html" />
    <id>http://osa1.net/posts/2016-07-25-IORef-STRef-exposed.html</id>
    <published>2016-07-25T00:00:00Z</published>
    <updated>2016-07-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this post we’ll take a look at internals of GHC’s mutable variables, and how they’re used by <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-IORef.html"><code>IORef</code></a> and <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-STRef.html"><code>STRef</code></a>. The code is copied from GHC, with minor changes for clarity.</p>
<hr />
<pre><code>λ&gt; :m + Data.IORef
λ&gt; :info IORef
newtype IORef a
  = GHC.IORef.IORef (GHC.STRef.STRef GHC.Prim.RealWorld a)
        -- Defined in ‘GHC.IORef’
instance Eq (IORef a) -- Defined in ‘GHC.IORef’</code></pre>
<p><code>GHC.IORef</code> is defined in <code>libraries/base/GHC/IORef.hs</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- | A mutable variable in the &#39;IO&#39; monad</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">IORef</span> a <span class="fu">=</span> <span class="dt">IORef</span> (<span class="dt">STRef</span> <span class="dt">RealWorld</span> a)</a></code></pre></div>
<p>We’ll look at 3 operations: read, write, and atomic modify.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- | Read the value of an &#39;IORef&#39;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">readIORef   ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">readIORef  (<span class="dt">IORef</span> var) <span class="fu">=</span> stToIO (readSTRef var)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">-- | Write a new value into an &#39;IORef&#39;</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">writeIORef  ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">writeIORef (<span class="dt">IORef</span> var) v <span class="fu">=</span> stToIO (writeSTRef var v)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="ot">atomicModifyIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (a,b)) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">atomicModifyIORef (<span class="dt">IORef</span> (<span class="dt">STRef</span> r<span class="fu">#</span>)) f <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> atomicModifyMutVar<span class="fu">#</span> r<span class="fu">#</span> f s</a></code></pre></div>
<p><code>STRef</code> is defined in <code>libraries/base/GHC/STRef.hs</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- | A value of type `STRef s a` is a mutable variable in state thread `s`,</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- containing a value of type `a`</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">data</span> <span class="dt">STRef</span> s a <span class="fu">=</span> <span class="dt">STRef</span> (<span class="dt">MutVar</span><span class="fu">#</span> s a)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">-- | Read the value of an &#39;STRef&#39;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">readSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">readSTRef (<span class="dt">STRef</span> var<span class="fu">#</span>) <span class="fu">=</span> <span class="dt">ST</span> <span class="fu">$</span> \s1<span class="fu">#</span> <span class="ot">-&gt;</span> readMutVar<span class="fu">#</span> var<span class="fu">#</span> s1<span class="fu">#</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="co">-- | Write a new value into an &#39;STRef&#39;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="ot">writeSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">writeSTRef (<span class="dt">STRef</span> var<span class="fu">#</span>) val <span class="fu">=</span> <span class="dt">ST</span> <span class="fu">$</span> \s1<span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="kw">case</span> writeMutVar<span class="fu">#</span> var<span class="fu">#</span> val s1<span class="fu">#</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">      s2<span class="fu">#</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> s2<span class="fu">#</span>, () <span class="fu">#</span>)</a></code></pre></div>
<p>Note that there’s no <code>atomicModifySTRef</code>, because that only makes sense in IO context. So <code>atomicModifyIORef</code> directly calls the primop.</p>
<p>In summary:</p>
<ul>
<li>IORef: <code>MutVar#</code>, wrapped with <code>STRef</code>. When we unpack an <code>IORef</code> in data constructor fields, internally we store a <code>MutVar#</code>.</li>
<li>writeIORef, writeSTRef: <code>writeMutVar#</code></li>
<li>readIORef, readSTRef: <code>readMutVar#</code></li>
<li>atomicModifyIORef: <code>atomicModifyMutVar#</code></li>
</ul>
<h1 id="readmutvar">readMutVar#</h1>
<p>Primop definition:</p>
<pre><code>primop  ReadMutVarOp &quot;readMutVar#&quot; GenPrimOp
   MutVar# s a -&gt; State# s -&gt; (# State# s, a #)
   {Read contents of {\tt MutVar\#}. Result is not yet evaluated.}
   with
   has_side_effects = True
   can_fail         = True</code></pre>
<p>Code generation is handled by <code>StgCmmPrim.emitPrimOp</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">emitPrimOp ::</span> <span class="dt">DynFlags</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">           <span class="ot">-&gt;</span> [<span class="dt">LocalReg</span>]        <span class="co">-- where to put the results</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">           <span class="ot">-&gt;</span> <span class="dt">PrimOp</span>            <span class="co">-- the op</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">           <span class="ot">-&gt;</span> [<span class="dt">CmmExpr</span>]         <span class="co">-- arguments</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">           <span class="ot">-&gt;</span> <span class="dt">FCode</span> ()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="fu">...</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">emitPrimOp dflags [res] <span class="dt">ReadMutVarOp</span> [mutv]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">   <span class="fu">=</span> emitAssign (<span class="dt">CmmLocal</span> res) (cmmLoadIndexW dflags mutv (fixedHdrSizeW dflags) (gcWord dflags))</a></code></pre></div>
<p>This is just relative addressing, base is the <code>MutVar#</code> we’re reading, and we skip the closure header to read the contents.</p>
<h1 id="writemutvar">writeMutVar#</h1>
<p>Primop definition:</p>
<pre><code>primop  WriteMutVarOp &quot;writeMutVar#&quot;  GenPrimOp
   MutVar# s a -&gt; a -&gt; State# s -&gt; State# s
   {Write contents of {\tt MutVar\#}.}
   with
   has_side_effects = True
   code_size        = { primOpCodeSizeForeignCall }
                         -- for the write barrier
   can_fail         = True</code></pre>
<p>Code generation is again implemented in <code>emitPrimOp</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">emitPrimOp dflags [] <span class="dt">WriteMutVarOp</span> [mutv,var]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">   <span class="fu">=</span> <span class="kw">do</span> emitStore (cmmOffsetW dflags mutv (fixedHdrSizeW dflags)) var</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        emitCCall [<span class="co">{-no results-}</span>]</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                  (<span class="dt">CmmLit</span> (<span class="dt">CmmLabel</span> mkDirty_MUT_VAR_Label))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                  [(<span class="dt">CmmReg</span> (<span class="dt">CmmGlobal</span> <span class="dt">BaseReg</span>), <span class="dt">AddrHint</span>), (mutv,<span class="dt">AddrHint</span>)]</a></code></pre></div>
<p>This is more involved than <code>readMutVar#</code>. First, we write the variable to the <code>MutVar#</code> in the first line (<code>emitStore</code>). Then, we call a function, specified by the variable <code>mkDirty_MUT_VAR_Label</code>, passing two arguments: a global called <code>BaseReg</code>, and the <code>MutVar#</code>. <code>mkDirty_MUT_VAR_Label</code> just holds the name of this function: (defined in <code>rts/sm/Storage.c</code>)</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">   This is the write barrier for MUT_VARs, a.k.a. IORefs.  A</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">   MUT_VAR_CLEAN object is not on the mutable list; a MUT_VAR_DIRTY</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">   is.  When written to, a MUT_VAR_CLEAN turns into a MUT_VAR_DIRTY</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co">   and is put on the mutable list.</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="dt">void</span> dirty_MUT_VAR(StgRegTable *reg, StgClosure *p)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    Capability *cap = regTableToCapability(reg);</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    <span class="cf">if</span> (p-&gt;header.info == &amp;stg_MUT_VAR_CLEAN_info) {</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        p-&gt;header.info = &amp;stg_MUT_VAR_DIRTY_info;</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        recordClosureMutated(cap,p);</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">}</a></code></pre></div>
<p>Remember that for the first argument we passed something called <code>BaseReg</code>, and for the second argument we passed the <code>MutVar#</code>.</p>
<p>This function gets a <code>Capability</code> from the register table, and if the <code>MutVar#</code> is “clean”, it marks it as “dirty” and records in the capability that it’s now mutated.</p>
<p><code>Capability</code> lacks documentation, but it’s not too important, so we just skip that and look at <code>recordClsoureMutated</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="dt">void</span> recordClosureMutated(Capability *cap, StgClosure *p)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    bdescr *bd = Bdescr((StgPtr)p);</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="cf">if</span> (bd-&gt;gen_no != <span class="dv">0</span>) recordMutableCap(p,cap,bd-&gt;gen_no);</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">}</a></code></pre></div>
<p><code>p</code> is our <code>MutVar#</code> here. <code>bdescr</code> stands for “block descriptor”. GHC RTS allocates memory in blocks, and every block belongs to a generation. First generation is special in that if a <code>MutVar#</code> is in the first generation, it can’t point to a younger generation, as the first generation is already the youngest generation. This is from <code>includes/rts/storage/GC.h</code>:</p>
<pre><code>- generation 0 is the allocation area.  It is given a fixed set of blocks
  during initialisation, and these blocks normally stay in G0S0.  In parallel
  execution, each Capability has its own nursery.</code></pre>
<p>This code basically checks if the <code>MutVar#</code> belongs to first generation (generation 0). If that’s not the case, we record the <code>MutVar#</code> in the generation’s “mut list”:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="dt">void</span> recordMutableCap(<span class="dt">const</span> StgClosure *p, Capability *cap, <span class="dt">uint32_t</span> gen)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    bdescr* bd = cap-&gt;mut_lists[gen];</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="cf">if</span> (bd-&gt;free &gt;= bd-&gt;start + BLOCK_SIZE_W) {</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">        bdescr *new_bd = allocBlockOnNode_lock(cap-&gt;node);</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">        new_bd-&gt;link = bd;</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">        bd = new_bd;</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        cap-&gt;mut_lists[gen] = bd;</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    *bd-&gt;free++ = (StgWord)p;</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">}</a></code></pre></div>
<p>Garbage collector then checks that list when collecting younger generations, to avoid collecting young objects kept alive by older generations (i.e. pointers from older generations to younger generations, see <code>scavenge_capability_mut_lists</code> in <code>rts/sm/Scav.c</code>).</p>
<p>We saw in <code>dirty_MUT_VAR</code> that the <code>MutVar#</code> is marked as “dirty” when it’s mutated. When is it marked as “clean” again?</p>
<p>When a <code>MutVar#</code> is copied during GC, the object pointed by it is also copied to the same generation, and then the <code>MutVar#</code> becomes clean again, because it no longer points to a younger generation. This is the related code:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="dt">static</span> <span class="dt">void</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">scavenge_block(bdescr *bd)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    ...</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="cf">case</span> MUT_VAR_DIRTY:</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">        gct-&gt;eager_promotion = rtsFalse;</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        evacuate(&amp;((StgMutVar *)p)-&gt;var);</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">        gct-&gt;eager_promotion = saved_eager_promotion;</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">        <span class="cf">if</span> (gct-&gt;failed_to_evac) {</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">            ((StgClosure *)q)-&gt;header.info = &amp;stg_MUT_VAR_DIRTY_info;</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">            ((StgClosure *)q)-&gt;header.info = &amp;stg_MUT_VAR_CLEAN_info;</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">        p += sizeofW(StgMutVar);</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">    ...</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">}</a></code></pre></div>
<h1 id="atomicmodifymutvar">atomicModifyMutVar#</h1>
<p>Primop definition:</p>
<pre><code>primop  AtomicModifyMutVarOp &quot;atomicModifyMutVar#&quot; GenPrimOp
   MutVar# s a -&gt; (a -&gt; b) -&gt; State# s -&gt; (# State# s, c #)
   with
   out_of_line      = True
   has_side_effects = True
   can_fail         = True</code></pre>
<p><code>out_of_line = True</code> basically tells code generator that this primop is implemented as a function. Code generator then just generates a function call:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">cgOpApp ::</span> <span class="dt">StgOp</span>        <span class="co">-- The op</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">        <span class="ot">-&gt;</span> [<span class="dt">StgArg</span>]     <span class="co">-- Arguments</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">        <span class="ot">-&gt;</span> <span class="dt">Type</span>         <span class="co">-- Result type (always an unboxed tuple)</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">        <span class="ot">-&gt;</span> <span class="dt">FCode</span> <span class="dt">ReturnKind</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="fu">...</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">cgOpApp (<span class="dt">StgPrimOp</span> primop) args res_ty <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    dflags <span class="ot">&lt;-</span> getDynFlags</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    cmm_args <span class="ot">&lt;-</span> getNonVoidArgAmodes args</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    <span class="kw">case</span> shouldInlinePrimOp dflags primop cmm_args <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>  <span class="co">-- out-of-line</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">          <span class="kw">let</span> fun <span class="fu">=</span> <span class="dt">CmmLit</span> (<span class="dt">CmmLabel</span> (mkRtsPrimOpLabel primop))</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">          emitCall (<span class="dt">NativeNodeCall</span>, <span class="dt">NativeReturn</span>) fun cmm_args</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">        <span class="fu">...</span></a></code></pre></div>
<p>The primop is implemented in Cmm, in <code>rts/PrimOps.cmm</code>. The code is a mess, but here’s the important part:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" data-line-number="1">stg_atomicModifyMutVarzh ( gcptr mv, gcptr f )</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  ...</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  retry:</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    x = StgMutVar_var(mv);</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    StgThunk_payload(z,<span class="dv">1</span>) = x;</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="pp">#ifdef THREADED_RTS</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    (h) = ccall cas(mv + SIZEOF_StgHeader + OFFSET_StgMutVar_var, x, y);</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    <span class="cf">if</span> (h != x) { <span class="cf">goto</span> retry; }</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    StgMutVar_var(mv) = y;</a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    <span class="cf">if</span> (GET_INFO(mv) == stg_MUT_VAR_CLEAN_info) {</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">        ccall dirty_MUT_VAR(BaseReg <span class="st">&quot;ptr&quot;</span>, mv <span class="st">&quot;ptr&quot;</span>);</a>
<a class="sourceLine" id="cb16-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="cf">return</span> (r);</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">}</a></code></pre></div>
<p>It’s basically a compare-and-swap loop, and in the end it marks the <code>MutVar#</code> as “dirty”, using the same <code>dirty_MUT_VAR</code> function used by the code generated for <code>writeMutVar#</code>.</p>
<h1 id="the-mutvar-struct">The <code>MutVar#</code> struct</h1>
<p>As the last thing, we look at the definition of <code>MutVar#</code>: (in <code>includes/rts/storage/Closures.h</code>)</p>
<pre><code>typedef struct {
    StgHeader   header;
    StgClosure *var;
} StgMutVar;</code></pre>
<p>Nothing interesting here. See <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects">this Wiki page</a> for GHC’s heap object layout. In our case, payload contains a single closure.</p>
<hr />
<p>This concludes our <code>MutVar#</code> (which is used under the hood for <code>IORef</code> and <code>STRef</code>) tour. I guess lessons here are:</p>
<ol type="1">
<li><p><code>readIORef</code> is fast, but <code>writeIORef</code> is one function call in the best case. In the worst case, it does an expensive allocation (this is not just a heap pointer bump). If you have a tight loop with some state variables, prefer parameter passing instead.</p></li>
<li><p>Unpacking an <code>IORef</code> in a data constructor field does not really make the constructor mutable. Instead, it inlines the <code>MutVar#</code>, which has a mutable pointer field.</p></li>
</ol>
<p>If you think about it a little bit, you may realize that optimizing (2) is actually quite tricky. Imagine having something like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">D</span> <span class="fu">=</span> <span class="dt">D</span> {<span class="ot"> f1 ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">IORef</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">           ,<span class="ot"> f2 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">           }</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="ot">bumpf1 ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">bumpf1 (<span class="dt">D</span> f1 _) <span class="fu">=</span> modifyIORef f1 (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">bumpf2 ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">D</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">bumpf2 (<span class="dt">D</span> f1 f2) <span class="fu">=</span> <span class="dt">D</span> f1 (f2 <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>You’d expect this to print <code>True</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">do</span> ref <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">   <span class="kw">let</span> d1 <span class="fu">=</span> <span class="dt">D</span> ref <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">       d2 <span class="fu">=</span> bumpD2 d1</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">   bumpf1 d1</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">   rv1 <span class="ot">&lt;-</span> readIORef (f1 d1)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">   rv2 <span class="ot">&lt;-</span> readIORef (f1 d2)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">   print (rv1 <span class="fu">==</span> rv2)</a></code></pre></div>
<p>If <code>D</code> becomes mutable after the <code>UNPACK</code>, this code doesn’t work anymore, because we lose sharing after the functional update in line <code>bumpD2 d1</code>.</p>
<p>See also <a href="https://ghc.haskell.org/trac/ghc/ticket/7662#comment:3">this discussion</a> for how other compilers improve this.</p>]]></summary>
</entry>
<entry>
    <title>Unboxed sums FAQ</title>
    <link href="http://osa1.net/posts/2016-07-22-unboxed-sums-faq.html" />
    <id>http://osa1.net/posts/2016-07-22-unboxed-sums-faq.html</id>
    <published>2016-07-22T00:00:00Z</published>
    <updated>2016-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The unboxed sums patch that implements unlifted, unboxed sum types (as described in <a href="https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes">this Wiki page</a>) was merged yesterday, and a <a href="https://www.reddit.com/r/haskell/comments/4txuo7/unboxed_sum_types_with_unpack_support_will_be_in/">/r/haskell discussion</a> emerged shortly after. As the implementor, I tried to answer questions there, but to keep answers more organized I wanted to write a blog post about it.</p>
<p>The reason I’m not writing this to the Wiki page is because this is about current plans and status of the feature. The wiki page may be updated in the future as the feature evolves and/or may be edited by others. This page reflects the current status as of today, future plans, and my own ideas.</p>
<hr />
<h2 id="syntax-is-awful-why">Syntax is awful, why?</h2>
<p>This feature is designed to complement the similar feature for product types (tuples), called <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-tuples">“unboxed tuples”</a>. The syntax is thus chosen to reflect this idea. Instead of commas in the unboxed tuple syntax, we used bars (similar to how bars used in sum type declarations). The syntax looks bad for several reasons:</p>
<ul>
<li><p>Type argument of an alternative have to be a single type. If we want multiple types in an alternative, we have to use an unboxed tuple. For example, unboxed sum version of the type <code>data T = T1 Int | T2 String Bool</code> is <code>(# Int | (# String, Bool #) #)</code>. That’s a lot of parens and hashes.</p></li>
<li><p>Similarly, for nullary alternatives (alternatives/constructors with no arguments) we have to use empty unboxed tuples. So a bool-like type looks like <code>(# (# #) | (# #) #)</code>.</p></li>
<li><p>Data constructors use the same syntax, except we have to put spaces between bars. For example, if you have a type with 10 alternatives, you do something like <code>(# | | | | value | | | | | #)</code>. Space between bars is optional in the type syntax, but not optional in the term syntax. The reason is because otherwise we’d have to steal some existing syntax. For example, <code>(# ||| a #)</code> can be parsed as singleton unboxed tuple of <code>Control.Arrow.|||</code> applied to an argument, or an unboxed sum with 4 alternatives.</p></li>
</ul>
<p>Note that the original Wiki page for unboxed sums included a “design questions” section that discussed some alterantive syntax (see <a href="https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes?version=32">this version</a>). Nobody made any progress to flesh out the ideas, and I updated the Wiki page to reflect the implementation. So it was known that the syntax is not good, but it just wasn’t a major concern.</p>
<p>Answer to the second question is also an answer to this question.</p>
<h2 id="how-is-this-supposed-to-be-used-by-users">How is this supposed to be used by users?</h2>
<p>We’re not expecting users to use this type extensively. It’ll mostly be used by the compiler, for optimizations. In fact, we could have skipped the front-end syntax entirely, and it’d be OK for the most part. If you haven’t used unboxed tuples before, you probably won’t be using unboxed sums.</p>
<p>The only place you may want to use this syntax is when you’re writing a high-performance library or program, and you have a sum type that’s used strictly and can take advantage of removing a level of indirection.</p>
<h2 id="how-is-this-used-by-the-compiler">How is this used by the compiler?</h2>
<p>A detailed answer would take too long, but here’s a summary:</p>
<ul>
<li><p><a href="research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/cpr.ps.gz">Constructed product analysis</a> can now be used for returning sums efficiently. Note that this feature was left as “future work” in the paper (which is from 2004. See section 3.2). The high-level idea is that if a function returns a value that <em>it constructs</em>, then instead of boxing the components of the value and returning a boxed object, it can just return the components instead. In the case where the function result is directly scrutinized (i.e. case expressions), this usually reduces allocations. In other cases, it moves the allocation from the callee to the call site, which in turn leads to stack allocation is some cases (when the object doesn’t escape from the scope).</p>
<p>For product types, unboxed tuples are used for returning the value without heap allocation. For sum types, we use unboxed sums.</p></li>
<li><p>Result of strictness (or “demand”) analysis can now be used to pass sums efficiently. As a result worker/wrapper transformations can now be done for functions that take sum arguments. See <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">this Wiki page for demand analysis</a> and <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/usage-types/cardinality-popl14.pdf">this 2014 paper</a>.</p></li>
<li><p><code>{-# UNPACK #-}</code> pragmas now work on sum types, using unboxed sums under the hood.</p></li>
</ul>
<p>Note that none of these need a concrete syntax for unboxed sums.</p>
<hr />
<p>Hopefully this clarifies some questions and concerns, especially about the syntax. We have plenty of time until the first RC for 8.2 (<a href="https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.2.1">mid-February 2017</a>), so it’s certainly possible to improve the syntax, and I’ll be working on that part once I’m done with the optimizations.</p>]]></summary>
</entry>
<entry>
    <title>On matching bang patterns</title>
    <link href="http://osa1.net/posts/2016-06-27-matching-bang-pattern.html" />
    <id>http://osa1.net/posts/2016-06-27-matching-bang-pattern.html</id>
    <published>2016-06-27T00:00:00Z</published>
    <updated>2016-06-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I thought a bang pattern is all about <code>seq</code>. That may actually be true, but when that <code>seq</code> is happening may not be obvious. Even after ~5 years of Haskell I was initially very confused by this, and in fact at first I thought it was a bug:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">A</span> <span class="fu">|</span> <span class="dt">B</span> <span class="fu">|</span> <span class="dt">C</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">fn5 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">T</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">fn5  i []       <span class="fu">=</span> i</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">fn5  i (<span class="dt">A</span> <span class="fu">:</span> ts) <span class="fu">=</span> fn5 (i <span class="fu">+</span> <span class="dv">1</span>) ts</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">fn5 <span class="fu">!</span>i (<span class="dt">B</span> <span class="fu">:</span> ts) <span class="fu">=</span> fn5 (i <span class="fu">+</span> <span class="dv">2</span>) ts</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">fn5  i (<span class="dt">C</span> <span class="fu">:</span> ts) <span class="fu">=</span> fn5 <span class="dv">0</span> ts</a></code></pre></div>
<p>The question is, given these definitions, what does this evaluate to, and why:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">fn5 undefined [<span class="dt">C</span>]</a></code></pre></div>
<p>This question is basically a <code>BangPatterns</code> question. The key point is that a bang pattern <em>first evaluates the value</em> to match, then looks at the pattern. This is from GHC 8.0.1 user manual, <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#bang-patterns-informal">section 9.28.1</a>:</p>
<blockquote>
<p>Matching an expression e against a pattern !p is done by first evaluating e (to WHNF) and then matching the result against p.</p>
</blockquote>
<p>My initial thought was that this example would not crash because the pattern <code>i</code> always matches, and since second argument is only matched by last case of this definition, which doesn’t evaluate <code>i</code>, <code>i</code> would not get evaluated.</p>
<p>Or in other words, I thought all this bang pattern does is to add a <code>seq</code>, <em>to the RHS</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">fn5 i (<span class="dt">B</span> <span class="fu">:</span> ts) <span class="fu">=</span> i <span class="ot">`seq`</span> fn5 (i <span class="fu">+</span> <span class="dv">2</span>) ts</a></code></pre></div>
<p>which is not what it really does!</p>
<hr />
<p>Before bang patterns, I think this pattern was considered as the standard way of forcing a function argument (mostly used for accumulator arguments):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">f acc _ <span class="fu">|</span> acc <span class="ot">`seq`</span> <span class="dt">False</span> <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">f acc arg <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>The guard in first equation always fails, but it forces the <code>acc</code> by the time it fails. While this looks bad<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, it compiles to nice code after a case-of-case transformation, and it evaluates <code>acc</code> as first thing to do whenever it’s applied to two arguments.</p>
<p>Now, with <code>BangPatterns</code>, we get to do this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">f <span class="fu">!</span>acc arg <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Which is good when we have one equation only, but when we have multiple equations like in <code>fn5</code> above, we need add bang patterns to every equation, or we risk having bugs<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<p>So in short, we don’t have a good solution for saying a function is strict on some arguments, without risking bugs (by trying to add minimum number of bangs) or adding a lot of them.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I don’t like seeing <code>undefined</code>s like this, because I reserve them for code that’s not yet implemented but needs to be implemented. Using <code>undefined</code> as a proxy is also not OK these days, as we have <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#visible-type-application">visible type applications in GHC 8.0.1</a> and <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Proxy.html"><code>Proxy</code> in base</a> since <code>base-4.7</code>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>I don’t mean semantic bugs, rather, unexpected memory usage etc. caused by not forcing thunks on time.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>On -XStrict</title>
    <link href="http://osa1.net/posts/2015-11-16-XStrict-faq.html" />
    <id>http://osa1.net/posts/2015-11-16-XStrict-faq.html</id>
    <published>2015-11-16T00:00:00Z</published>
    <updated>2015-11-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><code>-XStrict</code> has <a href="https://phabricator.haskell.org/D1142">landed in HEAD</a> a couple of days ago, and judged from the <a href="https://www.reddit.com/r/haskell/comments/3sts2t/strict_haskell_xstrict_has_landed/">upvotes</a> it seems like <a href="https://www.reddit.com/r/haskell">/r/haskell</a> was quite excited about it.</p>
<p>In the thread I tried to answer questions about <code>-XStrict</code>s effects on programs’ semantics. Does it make the language effectively call-by-value? Do I still have bottoms in my values? Do I lose infinite lists(streams)? In this post I’ll try to give a more organized answer, with some answers to the questions asked in the Reddit thread.</p>
<hr />
<p>Let’s think about how to create a thunk in Haskell:</p>
<ul>
<li><p>Create a let-binding. The RHS of let-binding is a thunk until actually use it.</p></li>
<li><p>Create a where-binding. This is just a syntactic sugar for a let-binding, so I won’t consider this as a different case.</p></li>
<li><p>Pass an argument to a function or a data constructor. The argument will only be evaluated when it’s actually “used”.</p></li>
</ul>
<p>Here I deliberately don’t define what I mean by “used”, because it’ll complicate the discussion a lot.</p>
<p>Now, with <code>-XStrict</code>, we have a bang pattern in every binder. This means that:</p>
<ol type="1">
<li><p>Let-bindings are now strict. E.g. if we have something like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">let</span> a <span class="fu">=</span> <span class="fu">...</span> <span class="kw">in</span> <span class="fu">&lt;</span>body<span class="fu">&gt;</span></a></code></pre></div>
<p><code>a</code> is now evaluated before <code>&lt;body&gt;</code>, and so we can be sure that it won’t be bottom in <code>&lt;body&gt;</code>. Note however that this isn’t to say that <code>a</code> can’t <em>contain</em> bottoms. Here I’m just saying that <code>a</code> can’t be bottom in <code>&lt;body&gt;</code>.</p></li>
<li><p>Function arguments are now strict. In a function like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">f a b <span class="fu">=</span> <span class="fu">&lt;</span>body<span class="fu">&gt;</span></a></code></pre></div>
<p><code>a</code> and <code>b</code> can’t be bottom in <code>&lt;body&gt;</code>.</p></li>
<li><p>Data constructor arguments(fields) are now strict. If we have this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a></code></pre></div>
<p>The two fields of <code>Cons</code> are now strict. Now, this case may look a bit tricky at first. What we really say here is that once a <code>List</code> is constructed, it can’t contain bottoms. We can still do something like <code>undefined :: List Int</code>, but the program immediately fails, instead of running until you try to pattern match on that <code>undefined</code> value like in the lazy case. This follows from the first two rules. Keep reading for more details.</p></li>
</ol>
<p>When all these combined, it means that our programs are evaluated just like how they would be in a call-by-value language. For example, if we have:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">let</span> a <span class="fu">=</span> <span class="fu">...</span>  <span class="kw">in</span> <span class="fu">&lt;</span>body<span class="fu">&gt;</span></a></code></pre></div>
<p>We can be sure that <code>a</code> won’t be bottom in <code>&lt;body&gt;</code>, and it can’t contain bottoms too! This follows from all the rules above. The first rule only says that <code>a</code> can’t be bottom itself. It doesn’t say anything about the fields(subexpressions) of <code>a</code>. Third rule says that it can’t contain bottom fields.</p>
<p>When we make all the binders and fields strict, including all the modules in all the dependencies(<code>base</code> etc.), we guarantee that we our programs evaluate like in a call-by-value language.</p>
<p>Now, call-by-value, call-by-name(and it’s efficient implementation call-by-need) etc. are really about how to evaluate a function application. In our case since we have a strictness annotation in all the function arguments, arguments will be evaluated before being passed to the function. Which really means evaluating the function application in call-by-value semantics.</p>
<p>Below are some questions and answers that I answered in the Reddit thread and in some follow-up threads.</p>
<hr />
<h2 id="what-about-standard-list-tuple-etc.-types">What about standard list, tuple etc. types?</h2>
<p>Unless we compile modules that define those using <code>-XStrict</code>, they’ll stay non-strict. For the standard types, we need <code>base</code> compiled with <code>-XStrict</code>. In practice this will probably never happen. But I think we can have another base, say, <code>base-strict</code>, which is the same <code>base</code>, except compiled with <code>-XStrict</code>. In this case depending on which one we’re using our lists, tuples etc. become strict or lazy.</p>
<h2 id="what-about-monadic-code">What about monadic code?</h2>
<p>Monadic code is really not special in any sense. When talking about the semantics we should see through the syntactic sugar. Say we have this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">do</span> a <span class="ot">&lt;-</span> m1</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">   b <span class="ot">&lt;-</span> m2 a</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">   return (a <span class="fu">+</span> b)</a></code></pre></div>
<p>This is really just a syntactic sugar for:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">m1 <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> m2 a <span class="fu">&gt;&gt;=</span> (\b <span class="ot">-&gt;</span> return (a <span class="fu">+</span> b)))</a></code></pre></div>
<p>With <code>-XStrict</code>, function arguments <code>a</code> and <code>b</code> and all the arguments of <code>&gt;&gt;=</code> and <code>return</code> will be strict. This makes the whole code strict. In this code this means that <code>m1</code> will be evaluated before <code>m2 a</code> is evaluated, and <code>return</code>s return value will be strict etc.</p>
<h2 id="what-about-list-comprehensions-and-infinite-listsstreams">What about list comprehensions and infinite lists(streams)?</h2>
<p>A list comprehension like <code>[1..]</code> is again a syntactic sugar. It’s expanded form is <code>enumFrom 1</code>. <code>enumFrom</code>’s type is <code>Enum a =&gt; a -&gt; [a]</code>. Let’s say we’re using <code>Enum Int</code> here. Since the instance is defined in <code>base</code>, and lists are also defined in <code>base</code>, this code will still work. However, if we compile <code>base</code> with <code>-XStrict</code>, this code loops because the standard list type will become strict.</p>
<p>In practice we would probably define strict and lazy lists separately to have the laziness when we need.</p>
<h2 id="what-about-higher-order-functions">What about higher-order functions?</h2>
<p>Since we don’t distinguish strict and lazy functions in type level, when we have a higher-order functions it may seem like we’d loose the guarantees. But this is not the case, at least not in general. Suppose we have this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">map _ []       <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">map f (x <span class="fu">:</span> xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</a></code></pre></div>
<p>This is compiled with <code>-XStrict</code>. Now suppose we pass a function <code>f</code> which is lazy in it’s argument. Since <code>(:)</code> is strict in this code, we’ll still evaluate the <code>f x</code> before returning. Our guarantee that the list won’t be bottom and won’t have bottom still holds.</p>
<p>See also the paper <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/strict-core/tacc-hs09.pdf">“Types are calling conventions”</a>.</p>
<h2 id="haskells-denotational-semantics-says-that-lifted-types-have-bottoms">Haskell’s denotational semantics says that lifted types have bottoms</h2>
<p>This is true. Even if we have this strict type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> <span class="fu">!</span>a <span class="fu">!</span>(<span class="dt">List</span> a)</a></code></pre></div>
<p>We can construct bottom values of this type, using, for example, <code>undefined :: List Int</code> or <code>(let x = x in x) :: Blah</code>.</p>
<p>However, if you think about how this value will be evaluated you’ll realize that this is exactly like how it would be evaluated in a call-by-value language. For example, if we try to bind it to a value:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">let</span> a <span class="fu">=</span><span class="ot"> undefined ::</span> <span class="dt">List</span> <span class="dt">Int</span> <span class="kw">in</span> <span class="fu">&lt;</span>body<span class="fu">&gt;</span></a></code></pre></div>
<p>This code will fail before <code>&lt;body&gt;</code> is run. In <code>&lt;body&gt;</code> <code>a</code> can’t be bottom and can’t contain bottoms.</p>
<p>(See also <a href="https://mail.haskell.org/pipermail/ghc-devs/2015-September/009799.html">this ghc-devs thread</a> about adding user defined unlifted data types to GHC. With this we could eliminate all the bottoms in some user-defined types.)</p>
<h2 id="but-haskell-will-still-generate-thunks-in-the-rts-level">But Haskell will still generate thunks in the RTS level?</h2>
<p>This is exactly right. <code>-XStrict</code> is really a very simple compiler pass that adds strictness annotations to every binder and field. We don’t have any changes in the GHC RTS to take advantage of additional strictness.</p>
<p>In other words, operational semantics of the language and implementation of this operational semantics in GHC RTS is still the same. We just do a program transformation to generate a program that evaluates like it would in a call-by-value language.</p>
<p>This means that if we have this program:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">let</span> a <span class="fu">=</span><span class="ot"> undefined ::</span> <span class="dt">List</span> <span class="dt">Int</span> <span class="kw">in</span> <span class="fu">&lt;</span>body<span class="fu">&gt;</span></a></code></pre></div>
<p>A thunk is still constructed in the runtime, but it’s evaluated <em>before</em> the <code>&lt;body&gt;</code> is evaluated. So this code fails before <code>&lt;body&gt;</code> is evaluated, and if we evaluate <code>&lt;body&gt;</code> it means that <code>a</code> is not bottom and doesn’t have bottoms.</p>
<p>This is another potential improvement over the <code>-XStrict</code>. For more details and some optimizations see <a href="https://mail.haskell.org/pipermail/ghc-devs/2015-October/010175.html">this ghc-devs thread</a>.</p>]]></summary>
</entry>

</feed>
