<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged haskell</title>
    <link href="http://osa1.net/tags/haskell.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/haskell.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2015-08-13T00:00:00Z</updated>
    <entry>
    <title>The issue with work sharing(common subexpression elimination)</title>
    <link href="http://osa1.net/posts/2015-08-13-the-issue-with-work-sharing.html" />
    <id>http://osa1.net/posts/2015-08-13-the-issue-with-work-sharing.html</id>
    <published>2015-08-13T00:00:00Z</published>
    <updated>2015-08-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’d expect more work sharing to be always more beneficial. But apparently this is not the case, as pointed out in (Chitil, 1997)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>Here’s an example from the paper: (slightly changed)</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sum [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">1000</span>] <span class="fu">+</span> sum [<span class="fu">-</span><span class="dv">1000</span> <span class="fu">..</span> <span class="fu">-</span><span class="dv">1</span>] <span class="fu">+</span> prod [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">1000</span>]</code></pre>
<p>We can evaluate this expression to WHNF using heap space enough for a single list(to be more specific, we only need a single cons cell at any time). After evaluating a subexpression, we can deallocate and allocate for the next list etc.</p>
<p>However, if we eliminate common subexpressions, and generate this code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> v <span class="fu">=</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">1000</span>]
 <span class="kw">in</span> sum v <span class="fu">+</span> sum [<span class="fu">-</span><span class="dv">1000</span> <span class="fu">..</span> <span class="fu">-</span><span class="dv">1</span>] <span class="fu">+</span> prod v</code></pre>
<p>Now <code>v</code> has to live until the let body is evaluated to a value. We win in allocation/deallocation side, but we lose in residency side. In paper’s words: “Whereas the transformation always decreases total heap usage, it may considerably influence heap residency.”</p>
<p>In general, we can’t do this transformation, without risking increased residency:</p>
<p>\[ e’[e,e] \leadsto \texttt{let}\; x = e\; \texttt{in}\; e’[x,x] \]</p>
<p>As a solution, the paper suggests this:</p>
<ol style="list-style-type: decimal">
<li>We always do CSE if the subexpressions’ WHNF == NF(i.e. if it’s a “safe type” in paper’s terms). According to the paper, “a partially evaluated expression is certain to require only a small, fixed amount of space if it’s not a function, whose environment may refer to arbitrary large data structures, and its WHNF is already its normal form”.</li>
<li>We always do CSE when a named expression is syntactically dominating another equal expression:</li>
</ol>
<p>\[ \texttt{let}\; x = e\; \texttt{in}\; e’[e] \leadsto \texttt{let}\; x = e\; \texttt{in}\; e’[x] \]</p>
<hr />
<p>Note that (1) is not always true, assume an expression with type <code>ForeignPtr a</code> where <code>a</code> is a huge FFI object. This has WHNF == NF property, but it may increase residency significantly. Maybe GHC didn’t have FFI at the time the paper is written.</p>
<p>Also, I’m wondering how is CSE is handled in current GHC.</p>
<hr />
<p>In supercompilation, we want to avoid evaluating same expressions in a loop forever, so we keep some kind of “history”, and when we come across a term that we evaluated before, we fold the process tree and avoid evaluating same term again.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(fib <span class="dv">1000</span>, fib <span class="dv">1000</span>)</code></pre>
<p>Unless we make sure to split it in a way that branches of the process tree are unaware of each other, we may end up eliminating common subexpressions. However, since there are lots of cases where we may want CSE, a splitter that always prevents it is not always desirable. We should instead allow CSE in a controlled way.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Olaf Chitil, “Common Subexpression Elimination in a Lazy Functional Language”, section 3.5.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>The issue of splitting without work duplication</title>
    <link href="http://osa1.net/posts/2015-08-13-the-issue-of-splitting-wo-duplication.html" />
    <id>http://osa1.net/posts/2015-08-13-the-issue-of-splitting-wo-duplication.html</id>
    <published>2015-08-13T00:00:00Z</published>
    <updated>2015-08-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(I’m starting publishing my long list of unpublished blog posts with this post)</p>
<p>(Examples are from <a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-835.html">Bolingbroke’s PhD thesis</a>)</p>
<p><em>Example 1:</em></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> a  <span class="fu">=</span> id y
    id <span class="fu">=</span> \x <span class="ot">-&gt;</span> x
 <span class="kw">in</span> <span class="dt">Just</span> a</code></pre>
<p><em>Problem:</em> The compiler should know about <code>id</code> while compiling <code>a</code>. This is easy to do, just tell the compiler about every binding when compiling RHSs. However, it causes some other problems:</p>
<p><em>Example 2:</em></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> n <span class="fu">=</span> fib <span class="dv">100</span>
    b <span class="fu">=</span> n <span class="fu">+</span> <span class="dv">1</span>
    c <span class="fu">=</span> n <span class="fu">+</span> <span class="dv">2</span>
 <span class="kw">in</span> (b, c)</code></pre>
<p><em>Problem:</em> If we tell about <code>n</code> to the compiler when it’s compiling <code>b</code> and <code>c</code>, we’re taking the risk of work duplication. It may seem like <code>fib 100</code> will be evaluated in compile time and so duplication is not a huge deal, but this is not necessarily the case. First, we can’t know if it’s going to be evaluated to a value in compile time. Second, even if it’s a closed term and we somehow know it’s going to be terminated, termination checker of the evaluator may want to stop it before it’s evaluated to a value. Third, most of the time it’ll be an open term that’ll get stuck in the middle of supercompilation.</p>
<p>And when that happens we will generate a let-binding in residual code. In our case, we’ll be generating two let-bindings, one is for <code>b</code> and one is for <code>c</code>, and those let bindings will be doing same work.</p>
<hr />
<p><em>Question:</em> Can we rely on a post-processsing pass to eliminate common subexpressions? I.e. if we generate a code like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> b <span class="fu">=</span> <span class="kw">let</span> n_supercompiled <span class="fu">=</span> <span class="fu">&lt;</span>supercompiled fib <span class="dv">100</span><span class="fu">&gt;</span>
         <span class="kw">in</span> n_supercompiled <span class="fu">+</span> <span class="dv">1</span>
    c <span class="fu">=</span> <span class="kw">let</span> n_supercompiled <span class="fu">=</span> <span class="fu">&lt;</span>supercompiled fib <span class="dv">100</span><span class="fu">&gt;</span>
         <span class="kw">in</span> n_supercompiled <span class="fu">+</span> <span class="dv">2</span>
 <span class="kw">in</span> (b, c)</code></pre>
<p>It would transform it to obvious residual code that has single <code>n_supercompiled</code> which is in scope of <code>b</code> and <code>c</code>.</p>
<p>What are trade-offs?</p>
<hr />
<p>Finding a good heuristic is hard. Let’s say we try to estimate costs of expressions and decide whether to tell the compiler about them or not. If we decide that <code>ys</code> and <code>xs</code> are expensive in this case:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> map <span class="fu">=</span> <span class="fu">...</span>
    ys <span class="fu">=</span> map f zs
    xs <span class="fu">=</span> map g ys
 <span class="kw">in</span> <span class="dt">Just</span> xs</code></pre>
<p>We miss a deforestation opportunity, because the compiler won’t know about <code>ys</code> while compiling <code>xs</code>.</p>]]></summary>
</entry>
<entry>
    <title>On sufficiently smart compilers</title>
    <link href="http://osa1.net/posts/2015-08-09-sufficiently-smart-compiler.html" />
    <id>http://osa1.net/posts/2015-08-09-sufficiently-smart-compiler.html</id>
    <published>2015-08-09T00:00:00Z</published>
    <updated>2015-08-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been thinking about optimizing functional programs recently, for a project that I’m hoping to make my research topic in the near future. You probably already know about <a href="http://c2.com/cgi/wiki?SufficientlySmartCompiler">The Myth of the Sufficiently Smart Compiler</a>, which basically says that the advanced compiler that optimizes your high-level, highly abstracted programs to efficient low-level code, is basically a myth.</p>
<p>This post is a brain dump on sufficiently smart compilation of functional programs and some compilation techniques. I’ll first make some seemingly unrelated points, and then hopefully use them to argue that the sufficiently smart compiler is not a myth, it just needs some hard-work to be realized.</p>
<h2 id="unreliable-optimizations-and-performance-critical-software">Unreliable optimizations and performance-critical software</h2>
<p>Every once in a while I see some blog posts about optimizing a JIT-compiled program by inspecting JIT trace dumps and generated code carefully, and I find this horrible, for the following reasons:</p>
<ul>
<li><p>It couples your program design with the JIT compiler’s internals. From a software engineering point of view, I think this is really one of the worst things that can happen to a software. You end up structuring your code with the compiler’s convenience in mind. But compilers can’t make sense of high-level, abstracted code(remember the myth?). So you end up code that’s low-level, hard to read, understand and maintain. And what happens when a new version of the compiler is released?</p></li>
<li><p>JIT compilers are highly complex, and as a result they’re very hard to reason about and this complex design makes them unpredictable. A seemingly unrelated change in your program can make the traces go significantly bad, and result in less optimized code, because maybe the change somehow made it to the trace and you now need to refactor your code.</p></li>
<li><p>If you need performance that bad, and you’re willing to read traces and generated assembly output for that, you could probably just write in a language that makes low-level optimizations easy/possible<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Or at least write performance-critical parts in a low-level language. Both of these cases eliminates the need for a JIT compiler.</p></li>
</ul>
<p>I think the last point is worth discussing further. Most JIT compilers we use nowadays are for compiling dynamic languages<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. By their nature dynamic languages are hard to optimize in compile-time, so they rely on runtime knowledge for optimizations. But does that make JIT compilers useless for statically-typed languages that are more amenable to compile-time optimizations? I don’t have a good answer to this, probably because I’m not a JIT expert. I think the fact that <a href="http://openjdk.java.net/groups/hotspot/">HotSpot</a> is doing good job is not an answer to this, because in JVM there’s bytecode interpretation going on, and this adds some room for runtime optimizations. Namely, you have one level of indirection that you can eliminate using JIT compilation.</p>
<p>In other statically-typed, compiled languages like C++, Haskell, OCaml etc. there’s less room for that kind of optimizations. I think applicability of JIT compilation techniques to these type of languages would make an interesting topic for a research project.</p>
<h2 id="compilers-that-can-learn-your-domain-and-manipulate-your-programs">Compilers that can learn your domain and manipulate your programs</h2>
<p>High-level languages and abstractions make efficient execution of programs harder, but there are a couple of things that they can do to help with the compilation. Namely, you can guide the compiler to optimize your domain-specific code.</p>
<p>One nice and simple example is <a href="https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html">rewrite rules of GHC</a>. They’re used quite heavily in <a href="http://hackage.haskell.org/package/base">base</a>(GHC’s standard library) to eliminate intermediate lists. Other libraries use the same mechanism to tell the compiler how to optimize the code that uses their abstractions<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>But for a compiler to support this kind of program transformations the language has to have some properties. In our case, we should be able to reason about the code in compile time, and locally, i.e. without thinking about runtime execution environment(heap, stack, variables in scope etc.) and the interaction of our code with the rest of the code. This is possible in purely functional languages because they make <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html">equational reasoning</a> possible.</p>
<p>This is a very powerful property. This makes it possible to see programs as terms in an algebra, and we can freely manipulate these terms according to our rules. In the most basic sense, these rules can be the rules that define our language’s operational semantics, because by it’s very definition these rules are guaranteed to preserve semantics of programs<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. But we can go even further by adding rewrite rules to these rules. Rewrite rules are a way to say, “trust me, this transformation preserves semantics” and at that point a compiler is free to use the rule.</p>
<p>Furthermore, some properties of the language can give us <a href="http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf">free theorems</a>, which in turn can help us with <a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/deforestation-short-cut.pdf">some optimizations</a><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<p>This type of “algebraic manipulation of programs” is a very powerful concept, and it can do great things. A very good example is this <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.7721">1997 paper about optimizing Haskell</a>. Most(maybe all?) of the transformations described in that paper are still in use.</p>
<h2 id="compilers-that-preserve-the-semantics">Compilers that preserve the semantics</h2>
<p>You probably wouldn’t want a compiler that compiles your programs to programs that do different things. We expect it to preserve the semantics. But that rule is sometimes too strict, and prevents some optimizations.</p>
<p>For example, if floating points and operations on floating points in your language are defined as they’re defined in IEEE-754, then the compiler can’t assume associativity of floating point operations and you lose some optimization opportunities. GCC’s <code>-ffast-math</code> is for relaxing this restriction by letting the compiler assume this associativity.</p>
<p>Another example is termination properties of programs. For example, would you be OK with this transformation in a purely functional language:</p>
<pre><code>(λx . 1) loop ~&gt; 1</code></pre>
<p>In a call-by-name(or call-by-need, which is an efficient implementation of call-by-name) language, this is a valid transformation. But in call-by-value language this would change the semantics. Previously this program were looping, but now it returns 1.</p>
<p>This example is actually a good demonstration of a problem that we have even in purely functional languages. Namely, there are some programs that don’t map to any values in the domain you use to model your language<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. The way these programs are modeled are generally by defining a special value, ⊥(read “bottom”). Non-terminating and exception/error throwing programs are said to be “bottom” and denoted with this value. Bottom values are said to be “less defined” than non-bottom values.</p>
<p>Using this definition, we can say that the transformation shown above transforms a program to a more defined one. You might want this restriction of preserving definedness of programs for different reasons, and here’s an example reason: Without this restriction, your program may terminate or loop depending on how the compiler performed. A seemingly-unrelated change in your program may cause a different termination behavior.</p>
<p>Now this is a hard problem. There are papers about transforming call-by-value functional languages while preserving termination properties(see <a href="https://www.sics.se/~pj/papers/scp/popl09-scp.pdf">this</a> as an example). In general, we can’t decide if a program is bottom or not. First of all, that would be solving the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a>. But more specifically, we can’t do this transformation if <code>y</code> depends on a dynamic input here:</p>
<pre><code>(λx . 1) (1 / y) ~&gt; 1</code></pre>
<p>In most cases though, the compiler is simply not able to propagate enough information to this stage to see if <code>y</code> can be <code>0</code> or not<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>, even if all the necessary information is available in compile time.</p>
<h2 id="making-the-most-out-of-available-input">Making the most out of available input</h2>
<p>There’s an old yet IMHO under-appreciated technique for taking statically-known inputs into account while compiling programs. It’s called “partial evaluation” and described in details in this awesome book <a href="http://www.itu.dk/~sestoft/pebook/jonesgomardsestoft-a4.pdf">“Partial Evaluation and Automatic Program Generation”</a> by Neil D. Jones, Carsten K. Gomard and Peter Sestoft. One very interesting but somewhat esoteric application of this idea is <a href="https://cs.au.dk/~hosc/local/HOSC-12-4-pp381-391.pdf">Futamura projections</a><a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>, but to give a easier to understand example, a C partial evaluator could read your Vim config in compile time and compile Vim to an executable that doesn’t read any Vim files on startup because it’s already specialized to the Vim config it read in compile time<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>. General tools may depend of lots of dynamic input, but in your special case you may fix some of these variables and this is where a partial evaluation comes into the play. See <a href="http://blog.regehr.org/archives/1197">this blog post</a> for another example.</p>
<p>How much further could it propagate this statically known input and specialize rest the code using it? That’s completely different story and comes with some very hard to solve problems. I’ll again come to this later.</p>
<p>The whole point is to generate specialized code for known input. We can shift the stage a little bit and apply this idea in runtime, and that gives us <a href="http://www.cs.rice.edu/~taha/MSP/">multi-stage programming</a>.</p>
<p>MSP allows us to generate code in runtime, link it to the program in a way that the generated code runs in the current execution environment(i.e. the generated code can refer to names in enclosing scope, pretty much like how closures would do).</p>
<p>Traditionally, MSP doesn’t allow code generation in compile-time, and the techniques used for code generation are completely different<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>. But we can generate code specialized to input that is only available in runtime. For example, you can write a game that runs code specialized to the player’s options. Or run a web server that does some optimizations on request dispatch code depending on some analysis on recent requests.</p>
<p>This is again a very powerful concept, and only recently I started to appreciate it’s potential<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>. IMO, MSP is missing a “killer language”<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>(and also a “killer application” but I think that follows the language) and I’m hoping to make some progress on this front in the future.</p>
<h2 id="finally-a-sufficiently-smart-compiler">Finally, a sufficiently smart compiler</h2>
<p>This post may seem to be going nowhere, so let’s back up a bit and come to the point.</p>
<p>I define a sufficiently smart compiler not as a completely automated program, but as a toolchain. This toolchain has a completely automated compiler, but it also gives programmers tools for runtime code generation, and for teaching the compiler domain-specific optimizations. The compiler knows about language’s semantics, and when possible it does reductions in compile time to remove abstractions and also to leave less work to runtime.</p>
<p>While doing reductions in compile time, it takes programmers’ rules into account, and optimizes abstractions accordingly. This allows it to optimize domain-specific abstractions that normally a compiler have no way to know about.</p>
<p>By now it should be clear that such a compiler is only possible with a language that allows these optimizations. For example, without a purely functional language, rewrite rules are not easy, if not impossible.</p>
<p>The compiler gradually compiles the language into languages that are more and more close to the machine language that it has to generate in the end. Reductions and user rules are applied in a level where programs are still expressed in a purely functional language. This language should be sufficient for most optimizations that eliminate programmers’ abstractions in compile time.</p>
<p>This way, programmers don’t need to look at ridiculous bytecode traces or instructions written in a highly-complex assembly language to figure out how things are optimized, and rather they stay in the same level of abstraction that their programs are written in. When they want to know about memory allocations, for example, they should be able to look at the next level in the compilation, which should have explicit memory allocation operations and pointers etc. The main point is that they stay in a level where they can observe some particular behavior(e.g. memory allocation) of a program and they don’t have to read assembly, for example, to see if their higher-order <code>map</code> application that uses an increment function to increment integers in a list is compiled to a loop without any function calls.</p>
<p>In this compiler there’s no room for abstraction-breaking, unreliable optimizations or optimizations that cause coupling with the compiler’s internals, like in the case of JIT compilers.</p>
<p>In the beginning I said that I don’t see a this as a myth. So how I think this is possible to implement? This is already a long-enough post, and I’ll stop for now. Let me just say that almost all of these things are implemented in different projects:</p>
<ul>
<li><p>MSP does runtime code generation and <a href="http://okmij.org/ftp/ML/MetaOCaml.html">MetaOCaml</a> gives us a nice way to do that in a safe way. Another alternative is <a href="http://terralang.org/">Terra</a>, but in Terra generated code is in a different language, so that’s quite different(also, it’s a dynamically typed language that gives no guarantees about generated code).</p></li>
<li><p>Domain-specific optimizations are possible in Haskell thanks to GHC’s rewrite rules, as mentioned in the related section above.</p></li>
<li><p>GHC’s internal languages Core, STG and Cmm allow programmers to gradually go low level and see the details they’re looking for. Most of the time Core is enough to see if your abstractions are eliminated in compile time and if your rules worked as expected.</p></li>
<li><p>Compile time reduction of programs are done by supercompilers. It was a lesser known technique until recently a couple of papers(<a href="http://dl.acm.org/citation.cfm?id=1863588">1</a>, <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/supercompilation/supercomp-by-eval.pdf">2</a>) and a <a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-835.html">PhD thesis</a> explored it in the context of Haskell.</p></li>
</ul>
<p>Some of these features are orthogonal to each other, like MSP and compile-time reduction. But some others are not, for example, we expect the supercompiler to take rewrite rules into account, otherwise it may be impossible to do some optimizations.</p>
<p>The hardest part seems to be compile-time reductions of programs according to operational semantics of the language, which involves some very hard problems, and one of the reasons has to do with preserving semantics. In the next couple of posts I’m hoping to talk about that, and in the meantime you can refer to chapter 9 of the PhD thesis I linked above.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://github.com/SnabbCo/snabbswitch">Snabb Switch</a> project comes to mind here. It’s a Lua project and they rely on LuaJIT to optimize their code. See this series of blog posts: <a href="https://github.com/lukego/blog/issues/5">1</a>, <a href="https://github.com/lukego/blog/issues/6">2</a>, <a href="https://github.com/lukego/blog/issues/8">3</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://developers.google.com/v8/">V8</a> and <a href="https://wiki.mozilla.org/JavaScript:TraceMonkey">TraceMonkey</a> for JavaScript, <a href="http://luajit.org/">LuaJIT</a> for Lua, <a href="http://pypy.org/">PyPy</a> for Python. There are also research-level JIT compilers, like <a href="https://github.com/higgsjs/Higgs">Higgs</a> for JavaScript and <a href="https://github.com/samth/pycket">Pycket</a>(<a href="https://rpython.readthedocs.org/en/latest/">RPython</a> based, created by colleagues from IU) for Racket.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>One example that I like very much is the <a href="http://hackage.haskell.org/package/pipes">pipes library</a>. You can see some of it’s rewrite rules <a href="https://github.com/Gabriel439/Haskell-Pipes-Library/blob/d7b1430b1b35abfde98b32cbc4aae02a4e027dd0/src/Pipes/Core.hs#L869">here</a>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Because operational semantics is what defines semantics of programs.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>One very good question to ask here is, what exactly gives us free theorems? I don’t have an answer to that question yet.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>This type of giving semantics to languages is called “denotational semantics”. I don’t have very good reading material about this but you may want to have a look at <a href="https://en.wikibooks.org/wiki/Haskell/Denotational_semantics">this</a>.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>We’re assuming that it somehow knows that divide-by-zero leads to bottom.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>I wrote about this <a href="http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html">previously</a> and I also have <a href="http://osa1.net/posts/2015-05-13-comp-through-interp.html">this related project</a>.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>In practice this is probably hard to achieve, and it certainly needs some refactoring in current Vim codebase.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>See <a href="http://osa1.net/posts/2015-05-13-comp-through-interp.html">my blog post</a> for a comparison.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>Even though I’ve been working on MSP languages for a while know. See my previous work on this: <a href="/posts/2013-04-15-internship.report.html">1</a>, <a href="/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html">2</a>, <a href="/posts/2015-05-13-comp-through-interp.html">3</a>, and here’s a <a href="/posts/2015-05-17-staging-is-not-just-codegen.html">ranty post</a>.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p><a href="http://terralang.org/">Terra</a> comes quite close, but I have some confusions about it and I’m hoping to write about those in the future.<a href="#fnref12">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Top-down expression parsing is easy</title>
    <link href="http://osa1.net/posts/2015-01-29-top-down-expr-parsing-easy.html" />
    <id>http://osa1.net/posts/2015-01-29-top-down-expr-parsing-easy.html</id>
    <published>2015-01-29T00:00:00Z</published>
    <updated>2015-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently fixed <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>’s 2-years-old expression parsing bug. Previously it was using <a href="http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Expr.html">Parsec’s expression parser</a>, which is actually horrible because it can’t handle chained unary operators.</p>
<p>Two weeks ago I decided to take a look into Lua’s original implementation, and in about an hour or so the algorithm was crystal clear to me. I immediately <a href="https://github.com/osa1/language-lua/commit/b4bebe36e927dcc671dbe6dd19572b83073dc556#diff-630bbd2d118baf109da6ad79d3f168bfR257">implemented it</a> and closed the <a href="https://github.com/osa1/language-lua/issues/2">2-years-old bug report</a>.</p>
<p>This implementation is essentially a port of Lua’s expression parser. Recently I thought about the algorithm and I was wondering if this has a name – the algorithm looked pretty obvious to me once I understand and given how much we know about parsing I thought this should have a name.</p>
<p>I found <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing">this algorithm named “precedence climbing”</a>. This is almost the same algorithm, only difference is that instead of using <code>lookahead</code> I’m just consuming the binary operator and returning it to the caller(which is parsing an expression with lower precedence than current parser) if precedence is lower. Associativity handling is also different(I use different left and right precedences to handle associativity) but the idea is really the same.</p>
<p>Now, there is also another algorithm called Pratt, and I can’t read the original paper(paywall), but according to <a href="http://lambda-the-ultimate.org/node/3682">this LtU discussion</a> it should also be similar. Indeed, <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">this explanation of it</a> looks pretty similar, and <a href="http://stackoverflow.com/a/13637731/691032">this StackOverflow answer</a> says that Lua’s implementation is “Pratt style parsing”.</p>
<p>So it seems like we have two, or maybe one since they’re actually very similar, solution(s) to solve top-down expression parsing problem and Haskell implementation using Parsec is possible in only 12 lines of code.</p>
<h1 id="a-challenge">A challenge</h1>
<p>One challenge might be to modify Parsec’s expression parser so that internally it generates a Pratt/precedence climbing parser. I’m hoping to spare some time to work on this.</p>]]></summary>
</entry>
<entry>
    <title>Loading dynamic Haskell libs in Lua</title>
    <link href="http://osa1.net/posts/2015-01-16-haskell-so-lua.html" />
    <id>http://osa1.net/posts/2015-01-16-haskell-so-lua.html</id>
    <published>2015-01-16T00:00:00Z</published>
    <updated>2015-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Last year I wrote <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">a blog post</a> in which I explained how to call Lua from Haskell and Haskell from Lua using <a href="http://hackage.haskell.org/package/hslua">hslua</a> library. At the end of that blog post I mentioned that it should be possible to compile Haskell code to shared library and load that in Lua.</p>
<p>Today a friend in our research group <a href="https://github.com/iu-parfunc">parfunc</a> asked a question about compiling Haskell to shared libraries and loading generated libraries in other programs and I thought while I’m at it I can just update my blog post as well. So in this post I’m going to explain how to compile Haskell functions to shared libraries and load them in Lua.</p>
<p>Before diving into the code, a few remarks:</p>
<ul>
<li>All the code in this blog post is tried on Linux, with Lua 5.1 and latest LuaJIT.</li>
<li>To be able to load our function in Lua and register it, our functions should have C linkage and <a href="http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><code>lua_CFunction</code></a> type. We can either write Haskell functions directly using this type, or write C wrapper functions around our Haskell functions to be able to use them in Lua. In this post I’m going to do first one.</li>
<li>We’ll need some intermediate C code to expose some Haskell RTS functions to Lua, like <code>hs_init</code> to start Haskell runtime and <code>hs_exit</code> to stop it.</li>
<li>To be able to <code>require</code> our shared library in Lua, we need to implement a <code>int luaopen_&lt;ourlibrary&gt;(lua_State *L)</code> function. While in theory it should be possible to implement that function in Haskell, I’ll implement it in C in this post, because I’m not sure how to write Lua wrappers for <code>hs_init</code> and <code>hs_exit</code> in Haskell.</li>
<li>To keep the code as simple as possible, our Haskell function will be a very dumb addition function.</li>
</ul>
<p>Let’s start.</p>
<h1 id="defining-lua-function-in-haskell">Defining Lua function in Haskell</h1>
<p>This is exactly the same as before: We just define a function with type: <code>LuaState -&gt; IO Int</code>. To keep the code simple, we don’t do error handling at all.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">LibArith</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Scripting.Lua</span> <span class="co">-- this one from hslua</span>

foreign export ccall
<span class="ot">  add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="ot">add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
add l <span class="fu">=</span> <span class="kw">do</span>
  i1 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">1</span>
  i2 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">2</span>
  pop l <span class="dv">2</span>
  push l (i1 <span class="fu">+</span><span class="ot"> i2 ::</span> <span class="dt">Int</span>)
  return <span class="dv">1</span></code></pre>
<h1 id="implementing-intermediate-c">Implementing intermediate C</h1>
<p>In our C glue code, we do two things:</p>
<ol style="list-style-type: decimal">
<li>Wrap <code>hs_init</code> and <code>hs_exit</code> Haskell runtime functions.</li>
<li>Implement Lua C module interface in which we register our functions to Lua. (see <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders">related docs</a> for details)</li>
</ol>
<p>Here’s the code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;LibArith_stub.h&quot;</span>
<span class="ot">#include &quot;lua.h&quot;</span>

<span class="dt">int</span> hs_init_lua(lua_State *L)
{
  hs_init(NULL, NULL);
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> hs_exit_lua(lua_State *L)
{
  hs_exit();
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> luaopen_lualibhelper(lua_State *L)
{
  lua_pushcfunction(L, add);
  lua_setglobal(L, <span class="st">&quot;add_in_haskell&quot;</span>);
  lua_pushcfunction(L, hs_init_lua);
  lua_setglobal(L, <span class="st">&quot;hs_init&quot;</span>);
  lua_pushcfunction(L, hs_exit_lua);
  lua_setglobal(L, <span class="st">&quot;hs_exit&quot;</span>);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Some things to note:</p>
<ul>
<li><code>LibArith_stub.h</code> is generated by GHC. I’ll explain how to compile and link next.</li>
<li>Our Haskell function actually has type <code>HsInt (*)(void *)</code>. While this is not what Lua API expected(it expects <code>int (*)(lua_State *L)</code>), in my x86_64 Linux machine this is working fine. In the worst case, you may need to wrap the Haskell function in C and convert the types using Haskell RTS C API and Lua C API.</li>
</ul>
<h1 id="compiling-and-linking">Compiling and linking</h1>
<p>This is the tricky part, I wasted a good 2 hours trying to figure how to compile to <code>.so</code> and link it with correct set of libraries.</p>
<p>First step is to compile <code>hslua</code> in a sandbox, or at least make it reachable by GHC(by installing globally, using nix environments etc.). I’ll be giving commands assuming that you’re in a sandbox that has <code>hslua</code> installed, if you’re not, then just replace <code>cabal exec ghc --</code> part with <code>ghc</code> and it should just work.</p>
<p>Step 1, compile and link the Haskell code to generate a shared library:</p>
<pre><code>$ cabal exec ghc -- LibArith.hs -shared -dynamic -fPIC -o libarith.so -lHSrts-ghc7.8.3</code></pre>
<p>Note that if you’re using a different version of GHC, you’ll need to modify the last argument to make it link it with corrent GHC RTS library.(alternatively, you can link with debug or profiling versions etc.)</p>
<p>Step 2, compile the Lua module written in C(the C code above) and link it with our shared Haskell library:</p>
<pre><code>$ cabal exec ghc -- libarithhelper.c -no-hs-main -optl -larith -o lualibhelper.so -shared -fPIC -dynamic</code></pre>
<p>Note that you may need to pass extra linker parameters if you have Lua library/headers in non-standard locations. If that’s the case, <code>-optl</code> argument of GHC is used to add linker arguments, just use standard linker arguments with that(<code>-L</code>, <code>-I</code> etc.).</p>
<p>This command should print a warning like this:</p>
<pre><code>/home/omer/opt/luajit_bin/include/luajit-2.0/lua.h:168:16:
     note: expected ‘lua_CFunction’ but argument is of type ‘HsInt (*)(void *)’
     LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);</code></pre>
<p>Like mentioned above, this doesn’t make any difference on my x86_64 Linux machine. If that’s being a problem on your system, just wrap your Haskell function in intermediate C code above using Haskell RTS API.</p>
<p>Now you should have two shared libraries, one for our Haskell code and one for the intermediate C code. One problem is that the shared library generated from C is now depending on the one generated from Haskell. So Haskell library should be in your <code>LD_LIBRARY_PATH</code>.</p>
<p>A good improvement here would be to compile Haskell code to static library, and generate one dynamic library only. (which has Haskell library statically linked to it)</p>
<h1 id="loading-the-code-in-lua">Loading the code in Lua</h1>
<p>Before loading it, make sure that the dynamic linker can really find the shared library generated from Haskell. Run this:</p>
<pre><code>$ ldd lualibhelper.so | grep &quot;not found&quot;</code></pre>
<p>Make sure it’s not printing anything.</p>
<p>Now just run Lua and enjoy the library:</p>
<pre><code>$ luajit-2.0.3
LuaJIT 2.0.3 -- Copyright (C) 2005-2014 Mike Pall. http://luajit.org/
JIT: ON CMOV SSE2 SSE3 SSE4.1 fold cse dce fwd dse narrow loop abc sink fuse
&gt; require &quot;lualibhelper&quot;
&gt; hs_init()
&gt; print(add_in_haskell(1, 2))
3
&gt; print(add_in_haskell(-10, 20))
10</code></pre>
<p>Just for the amusement, let’s crash it by running Haskell function <em>after</em> stopping the Haskell runtime:</p>
<pre><code>&gt; hs_exit()
&gt; add_in_haskell(1, 2)
newBoundTask: RTS is not initialised; call hs_init() first</code></pre>
<p>Fun :)</p>
<h1 id="conclusion">Conclusion</h1>
<p>It turns out that extending Lua using Haskell is almost as easy as the doing it using the technique I explained in my <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">previous blog post on this topic</a>.</p>
<p>This post also demonstrates one other thing, namely, compiling Haskell libraries to shared libraries and dynamically loading them in different programs. I’m hoping that this post helps fellow Haskellers to extend their programs written in different languages with Haskell.</p>]]></summary>
</entry>
<entry>
    <title>GHC + Cabal installation guide for starters</title>
    <link href="http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html" />
    <id>http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html</id>
    <published>2014-09-12T00:00:00Z</published>
    <updated>2014-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I see a lot of starters having problems with installing latest GHC and Cabal, and then keeping their package repository in a sane state(e.g. no thousands of broken packages because of one re-install, no installation problems because of conflicts). I came up with a simple method several years ago, and today when combined with sandboxes, that works really well. I suggest every new Haskeller to do the same. Here’s how I do my GHC/Cabal installation up-to-date and sane:</p>
<p>NEVER USE HASKELL PALTFORM. When I first started, it caused just too much pain. I don’t know how it is today, but I presume same problems should still apply. (globally installing packages)</p>
<p>Most important thing is to keep Cabal and cabal-install up-to-date. You can easily remove a GHC, or install other versions and keep them togerher once you have a working and relatively new(so that it supports sandboxes) Cabal. In fact, I currently have 3 versions of GHC installed, for different projects, and I have no problems at all. Starting from a system with no GHC/Cabal is installed, here’s the way to install latest Cabal and cabal-install:</p>
<ol style="list-style-type: decimal">
<li>Install whatever GHC and Cabal you have in your package manager.</li>
<li>If the GHC you installed from package manager is not latest one, install latest pre-compiled binary from <a href="http://www.haskell.org/ghc/">GHC webpage</a>. Set your <code>$PATH</code>(or move executables to <code>$PATH</code>) and remove the GHC you installed using the package manager.</li>
<li>Run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, then remove Cabal and cabal-install installed using the package manager, and add <code>~/.cabal/bin</code> to $PATH. After doing that, you’ll have latest GHC and Cabal installed. Also, Cabal will be installed locally, so you can update it very easily using <code>cabal udpate &amp;&amp; cabal install Cabal cabal-install</code> whenever you want. Updating for newer GHC is similarly easy, just installed pre-compiled binary from the link above and move it wherever you want. You can use multiple GHC installations at the same time without any problems, Cabal just keeps separate repositories for different GHC versions.</li>
</ol>
<p>The worst thing that can happen is that your package manager may not have Cabal at all. In that case you may need Haskell Platform temporarily, for booting GHC and Cabal. Once you have Haskell Platform(which includes Cabal) and run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, just remove Haskell Platform and download latest GHC as mentioned above and go from there.</p>
<p>Occasionally you may want to remove some directories in <code>~/.cabal/lib</code>. Here’s what I have right now:</p>
<pre><code>➜  lib  pwd
/home/omer/.cabal/lib
➜  lib  ls | xargs du -hs
107M    x86_64-linux-ghc-7.6.3
341M    x86_64-linux-ghc-7.8.3
170M    x86_64-linux-ghcjs-0.1.0_ghc-7.8.2
34M     x86_64-linux-ghcjs-0.1.0_ghc-7.8.3</code></pre>
<p>I have 170M of libraries installed in GHCJS compiled with GHC 7.8.2, but I updated my GHCJS installation and I won’t be using that version anymore, so it’s safe to remove that directory. Similarly you may want to remove versions you won’t be using anymore.</p>
<p>Once you have GHC and Cabal installed, you should be very careful with global installations. Basically all you need to do is to use sandboxes as much as possible. You may want or need to have some programs installed globally, like <code>alex</code> and <code>happy</code> and those are fine since they have almost no dependencies at all.</p>
<p>In all other cases, just create a <code>~/bin</code> directory and add it to your <code>$PATH</code>. Now whenever you need a Haskell program in your path, install it in a sandbox, and symlink it to <code>~/bin</code>.</p>
<p>Another very useful tip: You may still have some installation problems because of dependency conflicts. In that cases always try to install with <code>cabal install --allow-newer</code>. Most of the time this sandbox approach + <code>--allow-newer</code> should solve all your problems.</p>
<p>As a last thing, if you still have problems because you installed some libs globally for some reason, you may want to reset your whole Cabal state. In that case, just copy <code>~/.cabal/bin/cabal</code> to somewhere else and remove <code>~/.cabal</code>. Then using copied <code>cabal</code> executable, run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code> again. Now you have a fresh Cabal state and you can remove copied <code>cabal</code> executable and go with the one just installed at <code>~/.cabal/bin</code>.</p>
<p>I hope this helps.</p>]]></summary>
</entry>
<entry>
    <title>Stack traces in GHCJS</title>
    <link href="http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html" />
    <id>http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html</id>
    <published>2014-06-20T00:00:00Z</published>
    <updated>2014-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m about to finish the first part of my GSoC project and as a part of my project I have implemented stack traces for GHCJS. Currently <code>GHC.Stack</code> functions should work in GHCJS, except for some cases I explain below.</p>
<p>As a demo, I set up <a href="http://osa1.net/files/stacktrace.jsexe/index.html">this page</a>, it runs the Haskell program rendered on the page (some part of the code is copied from Simon Marlow’s <a href="http://www.youtube.com/watch?v=J0c4L-AURDQ">“Why can’t I get stack traces?” presentation</a>). Output is printed to the console. You should be seeing something like this:</p>
<div class="figure">
<img src="http://osa1.net/images/ghcjs-stacktrace.png" />

</div>
<p>My main goal is to implement profiling features of GHC (cost-centres, SCC annotations, reporting allocations/ticks etc.) for GHCJS. It turns out that cost-centre stacks and call stacks are same thing. <code>GHC.Stack.currentCallStack</code> returns the current cost-centre stack, and cost attribution is done to current call-stack(or current cost-centre stack, since they’re exactly the same thing). Similarly, <code>GHC.Stack.whoCreated</code> returns the cost centre stack that was active when the heap object was created.</p>
<p><a href="https://github.com/osa1/ghcjs/compare/ghcjs:master...work3">20 changed files with 810 additions and 527 deletions</a> later, I had <code>GHC.Stack</code> working. You won’t need to do anything different once it’s merged into GHCJS, but for now it requires some effort to install. It also still has some bugs and differences from GHC version. Rest of the post explains how to test it, bugs, and differences from GHC.</p>
<h1 id="how-to-use">How to use</h1>
<p>Because of a horrible bug(see bugs section), you need a 32bit system to use profiling features of GHCJS. You should clone my fork of <a href="https://github.com/osa1/ghcjs">GHCJS</a> and <a href="https://github.com/osa1/shims">shims</a>. For GHCJS, switch to <code>work3</code> branch(that 3 represents how many times I started from scratch :) and for shims switch to <code>work2</code> branch. You need to install <a href="https://github.com/ghcjs/Cabal">modified Cabal for GHCJS</a>. After installing Cabal, install GHCJS and run <code>ghcjs-boot --init -q --prof</code>. This takes about 20 minutes on my system and compiles <code>base</code> and some other libraries. <code>--prof</code> is used to generate profiled versions of libraries.</p>
<p>After GHCJS has been booted, replace ~/.ghcjs/&lt;your platform&gt;/shims folder with my fork of shims(make sure you switched to work2 branch). Now you should be able to compile and run programs with profiling options of GHC. For example, to compile and run the example program given above, run <code>ghcjs stacktrace.hs -prof -fprof-auto</code> and then run generated <code>stacktrace.jsexe/all.js</code> using nodejs. Enabling profiling gives you a debug executable, with more metadata (object names) and longer (non-renamed) variable names.</p>
<h1 id="differences">Differences</h1>
<p>Because GHCJS represents some objects as unboxed numbers and currently we don’t associate any cost-centres with this type of objects, <code>whoCreated</code> returns an empty list. If there’s demand, we can disable unboxing with a command line switch and <code>whoCreated</code> on these values would work. In the example program, second and third lines are printing empty lists because of this.</p>
<h1 id="bugs">Bugs</h1>
<p>Currently we discovered two bugs:</p>
<ol style="list-style-type: decimal">
<li><p>There’s a horrible bug happening outside of GHCJS code, see my <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">blog post</a> and <a href="http://www.haskell.org/pipermail/ghc-devs/2014-May/005059.html">ghc-devs mail</a>. Because of this bug, booting GHCJS with profiling enabled is resulting with a segfault on 64bit systems. I’m developing this project on a 32bit VM, running on a VPS :) I need to make some more progress before tracking this bug.</p></li>
<li><p>We’re having a bug that makes stack traces sometimes a bit different than the ones generated by GHC compiled programs. For example, the example program should have printed this stack trace:</p>
<pre><code>Main.errorM.\ (stacktrace.hs:13:22-54)
Main.errorM (stacktrace.hs:13:1-54)
Main.foo.\.\ (stacktrace.hs:27:23-30)
Main.foo.\ (stacktrace.hs:27:16-33)
Main.foo (stacktrace.hs:27:1-36)
Main.bar (stacktrace.hs:24:1-20)
Main.runM.(...) (stacktrace.hs:16:20-31)
Main.runM (stacktrace.hs:16:1-36)
Main.main (stacktrace.hs:(29,1)-(38,36))
Main.CAF (&lt;entire-module&gt;)</code></pre>
<p>.. but <code>runM</code> calls are missing in GHCJS output. I have no idea what could be the reason for this and I’m currently working to fix this. After fixing this, I think we’ll have exactly same stack traces as the ones produced by GHC compiled programs.</p></li>
</ol>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>I’d like to thank my mentor Luite Stegeman for answering my endless questions, helping me understanding GHC and GHCJS internals and reviewing this blog post.</p>]]></summary>
</entry>
<entry>
    <title>Dependency boundaries and orphan instances</title>
    <link href="http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html" />
    <id>http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>According to the <a href="http://www.haskell.org/haskellwiki/Package_versioning_policy">PVP</a>(Package Versioning Policy), adding a non-orphan instance is not a breaking change and a minor version number should be bumped(<code>C</code> in <code>A.B.C</code>) in case of a non-orphan instance implementation.</p>
<p>This means that if you’re implementing an orphan instance, you should specify minor upper bound of the package that defines the typeclass. Otherwise if the package implements the typeclass for the type in the future, you’re package will be broken.</p>
<p>I want to add <code>StackValue a =&gt; StackValue [a]</code> instance in hslua, but that breaks Pandoc because it implements that instance without using a newtype(an orphan instance) and hslua dependency upper bound is specified as <code>&lt; 0.4</code>.</p>
<p>Good news is that bergmark at Freenode #haskell told me that now it’s possible to change dependency ranges on Hackage without pushing a new version, so there’s an easy fix that’ll keep package working.</p>]]></summary>
</entry>
<entry>
    <title>GHC RTS notes</title>
    <link href="http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html" />
    <id>http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html</id>
    <published>2014-05-30T00:00:00Z</published>
    <updated>2014-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://news.ycombinator.com/item?id=7818768">Someone on HN</a> shared <a href="http://stanford.edu/~adebray/240h_notes.pdf">this class notes</a> of Stanford’s “Functional Systems in Haskell” class. Most of the stuff is very basic but sections 16 and 17 are very useful for me since they’re related with GHC internals which I’m currently studying.</p>
<p>You can see slides of Section 17 <a href="http://ezyang.tumblr.com/post/87048816817/cs240h-lecture-on-the-ghc-runtime-system">here</a>.</p>
<p>These are probably only up-to-date reading materials about GHC RTS you can find. (unless you count source code as a reading material ;_; )</p>
<p>Some other useful GHC Wiki pages that I find useful: (validness of these for current GHC is not guaranteed, but theoretic stuff should be still valid)</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps">PrimOps</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply">Function calls</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#ThreadStateObjects">The layout of heap objects</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Stack">Layout of the stack</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution">The Haskell Execution Model</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode">STG by example</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode">Debugging GHC-compiled code with gdb</a> (I hope you don’t really need this!)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/RuntimeSystem">Debugging the runtime system</a> (same as above)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">The Garbage Collector</a></li>
<li><a href="http://www.mono-project.com/Generational_GC">Generational GC page of Mono project</a> – not really Haskell, but I think it’s a good source to understand GC concepts that is related with GHC’s GC implementation.</li>
</ul>
<p>Now I can close my browser tabs in peace…</p>
<p>Bonus content: Here’s a <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">horror story</a> that is probably related with a GHC RTS bug and making progress in my work impossible.</p>
<p>EDIT: Someone on GHC IRC channel shared <a href="http://arashrouhani.com/papers/master-thesis.pdf">his masters thesis about GHC stack traces</a>, even if you’re not interested in stack traces I think it contains lots of useful information about GHC compilation pipeline.</p>]]></summary>
</entry>
<entry>
    <title>The GHC bug that ruined my day</title>
    <link href="http://osa1.net/posts/2014-05-27-worst-bug.html" />
    <id>http://osa1.net/posts/2014-05-27-worst-bug.html</id>
    <published>2014-05-27T00:00:00Z</published>
    <updated>2014-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just came across a very serious GHC bug that prevents me from making progress on my GHCJS project. It looks like it’s very hard to come up with a minimal program that reproduces the bug. Here’s a very long way to reproduce it:</p>
<ul>
<li><p>Install <a href="https://github.com/ghcjs/Cabal">patched Cabal for GHCJS</a>.</p></li>
<li><p>Clone <a href="https://github.com/osa1/ghcjs">my fork of GHCJS</a>, switch to <code>work</code> branch and install it.</p></li>
<li><p>Delete <code>~/.ghcjs</code> folder if you already have one.</p></li>
<li><p>Run <code>ghcjs-boot --init --prof -v</code> and wait for it to fail with segmentation fault while compiling profiling object files for <code>base</code> library. Segmentation fault is reported as <code>ExitFailure (-11)</code> by Cabal.</p></li>
<li><p>Since we run <code>ghcjs-boot</code> in verbose mode(using <code>-v</code> parameter), at this point it should have printed what command it was running when the error occured. It should be a very very long command, starting with something like <code>/home/omer/.cabal/bin/ghcjs --make -fbuilding-cabal-package -O -prof ...</code>. Copy that command because that’s how we reproduce the error.</p></li>
<li><p>Now to trace the bug, we need to compile GHCJS for debugging. Note that booting GHCJS with debugging build takes forever, so we first installed GHCJS and built some libraries using that fast build. To compile for debugging, first run <code>cabal clean</code> and then <code>cabal install --disable-executable-stripping --ghc-options=-debug</code>.</p></li>
<li><p>Move to <code>~/.ghcjs/&lt;your platform&gt;/ghcjs-boot/boot/base</code> and run the command you copied from <code>ghcjs-boot</code> verbose output when the error happened for first time. You should get the same error very fast.</p></li>
<li><p>At that point you can use gdb and friends. On my system gdb backtrace gives this:</p></li>
</ul>
<pre><code>[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
Detaching after fork from child process 3382.
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
Detaching after fork from child process 3383.
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
Detaching after fork from child process 3384.
[ 51 of 202] Compiling GHC.Fingerprint[boot] ( GHC/Fingerprint.hs-boot, dist/build/GHC/Fingerprint.js_p_o-boot )
Detaching after fork from child process 3385.
[ 55 of 202] Compiling GHC.IO.Exception[boot] ( GHC/IO/Exception.hs-boot, dist/build/GHC/IO/Exception.js_p_o-boot )
Detaching after fork from child process 3386.
[ 75 of 202] Compiling Foreign.C.Types  ( Foreign/C/Types.hs, dist/build/Foreign/C/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x000000000425f776 in scavenge_mutable_list1 (bd=0x7fffe5c02a00, gen=0x4d1fd48) at rts/sm/Scav.c:1400
#2  0x000000000425fa13 in scavenge_capability_mut_Lists1 (cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x0000000004256b66 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2,
    cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x00000000042454a3 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d32b60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x0000000004243de4 in schedule (initialCapability=0x4cfe5c0 &lt;MainCapability&gt;, task=0x4d32b60)
    at rts/Schedule.c:553
#6  0x0000000004246436 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x000000000423e9b4 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x477f850, ret=0x0) at rts/RtsAPI.c:500
#8  0x0000000004241666 in real_main () at rts/RtsMain.c:63
#9  0x0000000004241759 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x477f850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Thanks to Luite Stegeman for helping me with debugging. We could reproduce this error on 64bit Linux and 64bit OS X. I don’t know how to track down this bug but it just made making progress in my project impossible.</p>
<hr />
<p>EDIT: I just found a workaround: run GHCJS with <code>+RTS -G1</code>. I was reading code of functions in the backtrace and I realized some RTS parameters are used. By playing with them changing randomly, I found this. Some details about this parameter is explained in <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">GHC Trac GC section</a>(see “generational gc” parts). Unfortunately with this RTS parameter GHCJS runs at least 100x slower(at least in debug build) so even though I can boot GHCJS with my changes it’s not very usable since I sometimes boot it 10 times a day in this stage of the development.</p>
<hr />
<p>EDIT 2: My workaround did not work great – now compilation is failing in some other stage:</p>
<pre><code>Failed to install base-4.7.0.0
Last 10 lines of the build log ( /home/omer/.cabal/logs/base-4.7.0.0.log ):
[  4 of 202] Compiling Unsafe.Coerce    ( Unsafe/Coerce.hs, dist/build/Unsafe/Coerce.js_p_o )
[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
[  8 of 202] Compiling GHC.Err          ( GHC/Err.lhs, dist/build/GHC/Err.js_p_o )
[  9 of 202] Compiling GHC.Base         ( GHC/Base.lhs, dist/build/GHC/Base.js_p_o )
[ 10 of 202] Compiling Data.Maybe       ( Data/Maybe.hs, dist/build/Data/Maybe.js_p_o )
[ 11 of 202] Compiling GHC.List         ( GHC/List.lhs, dist/build/GHC/List.js_p_o )
[ 12 of 202] Compiling GHC.Num          ( GHC/Num.lhs, dist/build/GHC/Num.js_p_o )
[ 13 of 202] Compiling GHC.Show         ( GHC/Show.lhs, dist/build/GHC/Show.js_p_o )
cabal: Error: some packages failed to install:
base-4.7.0.0 failed during the building phase. The exception was:
ExitFailure (-11)</code></pre>
<p>However, when I tried to run the command that led to this segfault in gdb to see if it gives a different backtrace, it worked fine and no segfaults happened.</p>
<hr />
<p>EDIT 3: There has been some changes in GHCJS codegen and I wanted to try to reproduce this bug using that new codegen, hoping that it may be a workaround for the segfault(I rebased my patches for new version). It’s still happening, but now in different file:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x00000000042565e6 in scavenge_mutable_list1 (bd=0x7fffe5800c40, gen=0x4d17d48) at rts/sm/Scav.c:1400
#2  0x0000000004256883 in scavenge_capability_mut_Lists1 (cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x000000000424d9d6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x000000000423c313 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d2ab60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x000000000423ac54 in schedule (initialCapability=0x4cf6340 &lt;MainCapability&gt;, task=0x4d2ab60)
    at rts/Schedule.c:553
#6  0x000000000423d2a6 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x0000000004235824 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#8  0x00000000042384d6 in real_main () at rts/RtsMain.c:63
#9  0x00000000042385c9 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Backtrace is same. I think it’s interesting that this problem is happening while compiling <code>Types</code> modules in 2/3 of the cases(<code>Foreign.C.Types</code> and <code>System.Posix.Types</code>). As far as I can see this two modules are using <code>INTEGRAL_TYPE</code> extensively, which creates a newtype and implements <code>Read</code> and <code>Show</code> instances. Other problematic module, <code>GHC.Show</code> also implements same instances, but does that manually instead of calling <code>INTEGRAL_TYPE</code>. I wonder if it could be related with that.</p>
<hr />
<p>EDIT 4: When I run GHCJS using <code>--no-native</code>, it failed with an assertion error rather than a segfault:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )
ghcjs: internal error: ASSERTION FAILED: file rts/sm/Scav.c, line 1400

    (GHC version 7.8.2 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug

Program received signal SIGABRT, Aborted.
0x00007ffff687f849 in raise () from /lib64/libc.so.6
(gdb) bt
#0  0x00007ffff687f849 in raise () from /lib64/libc.so.6
#1  0x00007ffff6880cd8 in abort () from /lib64/libc.so.6
#2  0x0000000004238a27 in rtsFatalInternalErrorFn (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;, 
    ap=0x7fffffffbe58) at rts/RtsMessages.c:170
#3  0x000000000423865f in barf (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;) at rts/RtsMessages.c:42
#4  0x00000000042386c2 in _assertFail (filename=0x4559fbd &quot;rts/sm/Scav.c&quot;, linenum=1400) at rts/RtsMessages.c:57
#5  0x00000000042565e9 in scavenge_mutable_list1 (bd=0x7fffe7402dc0, gen=0x4d15d88) at rts/sm/Scav.c:1400
#6  0x0000000004256873 in scavenge_capability_mut_Lists1 (cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#7  0x000000000424d9c6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#8  0x000000000423c303 in scheduleDoGC (pcap=0x7fffffffc188, task=0x4d28ba0, force_major=rtsFalse)
    at rts/Schedule.c:1650
#9  0x000000000423ac44 in schedule (initialCapability=0x4cf49c0 &lt;MainCapability&gt;, task=0x4d28ba0)
    at rts/Schedule.c:553
#10 0x000000000423d296 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2b0) at rts/Schedule.c:2346
#11 0x0000000004235814 in rts_evalLazyIO (cap=0x7fffffffc2b0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#12 0x00000000042384c6 in real_main () at rts/RtsMain.c:63
#13 0x00000000042385b9 in hs_main (argc=238, argv=0x7fffffffc438, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#14 0x0000000000408ea7 in main ()</code></pre>
<p>Not passing <code>--not-native</code> is resulting with a segfault and same backtrace as before.</p>]]></summary>
</entry>

</feed>
