<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged coq</title>
    <link href="http://osa1.net/tags/coq.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/coq.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-07-10T00:00:00Z</updated>
    <entry>
    <title>A complicated proof of a simple theorem</title>
    <link href="http://osa1.net/posts/2014-07-10-complicated-proof-simple-thm.html" />
    <id>http://osa1.net/posts/2014-07-10-complicated-proof-simple-thm.html</id>
    <published>2014-07-10T00:00:00Z</published>
    <updated>2014-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s that time of the year again in which I’m suddenly very interested about verification and interactive theorem proving. I’m currently working on proving properties of some well-known algorithms.</p>
<p>At least in the beginning even the simplest properties may turn out to be very hard to prove. In this post I’m going to give an example of a very simple theorem which turns out to be hard to prove for beginners like me.</p>
<p>Let’s say I want to divide peano nats by 10. I can define <code>div10</code> in two ways: 1) I can implement a function that directly divides by 10 2) I can implement <code>div2</code> and <code>div5</code> and use those two to implement <code>div10</code>:</p>
<pre class="coq"><code>(* first definition *)
Fixpoint div10 (n : nat) : nat :=
  match n with
  | S (S (S (S (S (S (S (S (S (S n&#39;))))))))) =&gt; S (div10 n&#39;)
  | _ =&gt; 0
  end.

(* second definition *)
Fixpoint div5 (n : nat) : nat :=
  match n with
  | S (S (S (S (S n&#39;)))) =&gt; S (div5 n&#39;)
  | _ =&gt; 0
  end.

Fixpoint div2 (n : nat) : nat :=
  match n with
  | S (S n&#39;) =&gt; S (div2 n&#39;)
  | _ =&gt; 0
  end.

Definition div10&#39; (n : nat) : nat := div5 (div2 n).</code></pre>
<p>It may be obvious enough that those two definitions are equal(in the sense that they always terminate and given same arguments they return same values) but as an exercise let’s try to prove it:</p>
<pre class="coq"><code>Theorem divs_eq : forall n, div10 n = div10&#39; n.</code></pre>
<p>It’s obvious that we need to do induction on n, but unfortunately that leads to very complicated induction hypothesis and I can’t make any use of them:</p>
<pre class="coq"><code>Proof.
  unfold div10&#39;. intro.
  do 10 (induction n; auto). simpl. f_equal. 
Abort.</code></pre>
<p>At this point goal is same as our original goal, but induction hypothesis are about a hundred lines long so I can’t make any use of it. (and I don’t understand why induction hypothesis getting that big)</p>
<p>It turns out that by using a different induction scheme we can easily prove this. Instead of using standard induction scheme of nats “prove P 0, assume P n and prove P (S n)” we can use “prove P 0, P 1, … P 9, assume P n and prove P (10 + n)”:</p>
<pre class="coq"><code>Definition nat10ind : forall (P : nat -&gt; Prop),
  P 0 -&gt; P 1 -&gt; P 2 -&gt; P 3 -&gt; P 4 -&gt; P 5 -&gt; P 6 -&gt; P 7 -&gt; P 8 -&gt; P 9 -&gt;
  (forall n, P n -&gt; P (10 + n)) -&gt; forall n, P n.

  intros.
  assert (P n /\ P (1 + n) /\ P (2 + n) /\ P (3 + n) /\ P (4 + n) /\ P (5 + n) /\
          P (6 + n) /\ P (7 + n) /\ P (8 + n) /\ P (9 + n)).
  + induction n.
    - simpl. repeat split; assumption.
    - repeat (match goal with H : _ /\ _ |- _ =&gt; destruct H end).
      repeat split; try assumption.
      apply H9. assumption.
  + destruct H10. assumption.
Defined.</code></pre>
<p>Now our main theorem is very easy to prove:</p>
<pre class="coq"><code>Theorem divs_eq : forall n, div10 n = div10&#39; n.
Proof.
  unfold div10&#39;. intro.
  induction n using nat10ind; auto.
  simpl. f_equal. assumption.
Qed.</code></pre>
<p>One thing that I found weird in <code>nat10ind</code> definition is that the expression <code>match goal with ...</code> is kind of special in that <code>goal</code> is not an identifier that represents some part of the context. Rather, <code>match goal with ...</code> is a special syntax to pattern match against the whole context, with hypothesis and goals<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. <code>H : _ /\ _ |- _</code> part is then matching for any hypothesis with form <code>_ /\ _</code> and binding it to <code>H</code>, ignoring the current goal(RHS of turnstile shown as <code>|-</code>).</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>See <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#sec447">tacexpr_1 production</a> of Coq expression syntax in reference manual for details.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Proving soundness of simply typed multi-staged lambda-calculus</title>
    <link href="http://osa1.net/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html" />
    <id>http://osa1.net/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html</id>
    <published>2014-03-06T00:00:00Z</published>
    <updated>2014-03-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>First part of my first non-trivial(e.g. something other than a Software Foundations exercise) Coq program is finally done. I learned Coq from Software Foundations, but I didn’t finish to book. I still know only very basic tactics, which I think one of the reasons why my proofs are so long. You can see the source <a href="https://github.com/osa1/StagedLambda/blob/master/Lc.v">here</a>.</p>
<p>Some random notes about implementation:</p>
<ul>
<li>I’m looking to improve proofs. I have a lot more to implement for the rest of the program until deadline, so I may not be able to refactor current proofs very much, but at one point I want to simplify the proofs and use more advanced tactics.</li>
<li>Currently only <code>inversion</code>, <code>destruct</code>, <code>induction</code>, <code>rewrite</code>, <code>assumption</code>, <code>assert</code>, <code>constructor</code>, <code>auro</code>, <code>simpl</code>, <code>intro</code>/<code>intros</code>, <code>apply</code>, <code>right</code>/<code>left</code>, <code>exists</code>, <code>unfold</code>, <code>subst</code>, <code>reflexivity</code>, <code>remember</code> and <code>generalize</code> tactics are used.</li>
<li>Language definition is almost the same as in papers. There is one difference, we implemented substitutions as a function. In reality, substitution in multi-staged lambda-calculus is not a function. I believe this doesn’t effect correctness of theorems. At one point I’ll refactor the code and define substitution as a relation.</li>
<li>I used <code>Case</code>, <code>SCase</code>, <code>SSCase</code> … constructs from SFlib extensively.</li>
</ul>
<p>Now I’m going to implement lambda-calculus with row-polymorphic records. I expect this to be at least 2x harder, since polymorphism is involved. Let’s see how it goes …</p>]]></summary>
</entry>
<entry>
    <title>On proof automations -- part 3</title>
    <link href="http://osa1.net/posts/2013-09-23-proof-automation-3.html" />
    <id>http://osa1.net/posts/2013-09-23-proof-automation-3.html</id>
    <published>2013-09-23T00:00:00Z</published>
    <updated>2013-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Over the past several days I learned few things that changed my ideas about proof automation. See my first two posts about proof automation here: <a href="/posts/2013-09-11-proof-automation.html">#1</a> <a href="/posts/2013-09-17-proof-automation-2.html">#2</a></p>
<p>First, it’s really possible to use proof automation without first writing the whole proof. After started working on theorems defined on more complex languages, I realized one thing: Most of the cases of inductions/inversions are trivial to solve. Generally you only interested in one or two cases, while you have in total 20 cases. Why not use automation to eliminate 18 cases automatically? Proving that parts manually only makes it more obscure.</p>
<p>Second thing I learned is that automations like <code>auto</code>, <code>eauto</code>, <code>iauto</code> never perform <code>rewrite</code>, <code>subst</code>, case analysis(<code>inversion</code>, <code>destruct</code>, maybe others?) and induction. I think this is very important point, because this means that your proofs still have to resemble the structure of your non-automated proofs(i.e. structure of your terms). Which prevents your proofs from being too much magical.</p>
<p>Now let’s work on an example to see how some automation is good thing. I’ll prove progress property of STLC(simply-typed lambda calculus), as defined in <a href="www.cis.upenn.edu/~bcpierce/sf/">Software Foundations</a> chapter <a href="http://www.cis.upenn.edu/~bcpierce/sf/Stlc.html">Stlc</a>.</p>
<p>Here’s an initial version without using any kind of automation.</p>
<pre class="coq"><code>Theorem progress_no_auto : forall t T,
     empty |- t \in T -&gt;
     value t \/ exists t&#39;, t ==&gt; t&#39;.
Proof.
  intros t T TD. remember (@empty ty).
  (* induction on typing derivation *)
  has_type_cases (induction TD) Case.
  Case &quot;T_Var&quot;.
    (* this case is impossible because vars are not well-typed in empty env,
       find a contradiction *)
    rewrite Heqp in H. inversion H.
  Case &quot;T_Abs&quot;.
    (* lambdas are values *)
    left. apply v_abs.
  Case &quot;T_App&quot;.
    (* well-typed applications should take a step *)
    right. destruct IHTD1. assumption.
    SCase &quot;t1 is a value&quot;. destruct IHTD2. assumption.
      SSCase &quot;t2 is a value&quot;.
        (* t1 should be a lambda *)
        inversion TD1; subst; inversion H. (* inversion on typing derivation of t1,
                                              most cases can be eliminated with inversion H,
                                              because t1 can only be lambda expression to be well-typed *)
        SSSCase &quot;t1 is tabs&quot;. eexists. apply ST_AppAbs. assumption.
      SSCase &quot;t2 can take a step&quot;.
        inversion H0. eexists. apply ST_App2. assumption. apply H1.
    SCase &quot;t1 can take a step&quot;. inversion H. eexists. apply ST_App1. apply H0.
  Case &quot;T_True&quot;. left. constructor.
  Case &quot;T_False&quot;. left. constructor.
  Case &quot;T_If&quot;.
    (* well-typed T_If can always take a step *)
    destruct IHTD1. assumption.
    SCase &quot;t1 is value&quot;. inversion H; subst.
      SSCase &quot;t1 is a lambda&quot;. inversion TD1.
      SSCase &quot;t1 is ttrue&quot;. right. exists t2. constructor.
      SSCase &quot;t1 is tfalse&quot;. right. exists t3. constructor.
    SCase &quot;t1 can take a step&quot;. inversion H; subst. right.
      exists (tif x0 t2 t3). constructor. assumption.
Qed.</code></pre>
<p>I leave comments to explain what’s going on. The point here is not to get shortest proof, but to show with some automation proofs could be more readable.</p>
<p>When you look to this proof you can realize that our interesting cases are:</p>
<ul>
<li><code>T_Var</code> case, in which we need to show that it’s impossible.</li>
<li><code>T_App</code> and <code>T_If</code> cases, in which we need to use induction hypothesis.</li>
</ul>
<p><code>T_Abs</code>, <code>T_True</code> and <code>T_False</code> cases are completely trivial and we don’t want to make our proof harder to write, read and maintain more.</p>
<p>Second thing to realize that, if you count <code>;</code> operator as a automation, then it makes me using automation even in that proof. In the case of <code>T_App</code>, I’m eliminating all cases of <code>t1</code>(because for <code>T_App</code> to be well-typed, <code>t1</code> can only be a lambda abstraction – other cases should be eliminated with contradictions) with <code>inversion H; subst.</code>. Without <code>;</code> operator, I would have to write this:</p>
<pre class="coq"><code>inversion TD1; subst.
SSSCase &quot;t1 is tvar&quot;. inversion H.
SSSCase &quot;t1 is tabs&quot;. eexists. apply ST_AppAbs. assumption.
SSSCase &quot;t1 is tapp&quot;. inversion H.
SSSCase &quot;t1 is tif&quot;. inversion H.</code></pre>
<p>and when the language gets bigger, more cases with just <code>inversion H</code> would follow.</p>
<p>Now here’s an automated version:</p>
<pre class="coq"><code>Theorem progress : forall t T,
     empty |- t \in T -&gt;
     value t \/ exists t&#39;, t ==&gt; t&#39;.
Proof with eauto.
  intros t T TD. remember (@empty ty). has_type_cases (induction TD) Case; auto.
  Case &quot;T_Var&quot;. rewrite Heqp in H. inversion H.
  Case &quot;T_App&quot;. right. destruct IHTD1...
    SCase &quot;t1 is a value&quot;. destruct IHTD2...
      SSCase &quot;t2 is a value&quot;. inversion TD1; subst; try (solve by inversion)...
      SSCase &quot;t2 can take a step&quot;. inversion H0; subst...
    SCase &quot;t1 can take a step&quot;. inversion H; subst...
  Case &quot;T_If&quot;. right. destruct IHTD1. assumption.
    SCase &quot;t1 is a value&quot;. inversion H; subst; eauto.
      SSCase &quot;t1 is tabs&quot;. solve by inversion.
    SCase &quot;t1 can take a step&quot;. inversion H...
Qed.</code></pre>
<p>IMO this proof is a lot more simple and readable. It eliminates all trivial cases and only leave us with interesting ones. And even in that cases we simply finished with <code>...</code> or explicitly running <code>auto</code>/<code>eauto</code>.</p>]]></summary>
</entry>
<entry>
    <title>On proof automations -- part 2</title>
    <link href="http://osa1.net/posts/2013-09-17-proof-automation-2.html" />
    <id>http://osa1.net/posts/2013-09-17-proof-automation-2.html</id>
    <published>2013-09-17T00:00:00Z</published>
    <updated>2013-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://adam.chlipala.net/">Adam Chilpala’s</a> <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> has a great discussion on writing automated proofs and readability of proofs. Highly recommended. Chapter 16(page 319 on current revision).</p>
<p>I think one key thing to realize about interactive theorem proving is that there is no perfect, or maybe even good, solution to the problem of proof representation. Tactics help, but without automation tactic based proofs are just too fragile(every change in definitions implies changes in proofs) and verbose. But automated proofs are very hard to read, and it’s very hard to modify automated proofs for changes. CPDT book has a great example of this. Let’s think of this proof(I’ll skip the definitions, just think some simple arithmetic expressions language just like you could find in any elementary programming language theory book)</p>
<pre class="coq"><code>Theorem eval_times : forall k e,
    eval (times k e) = k * eval e.
Proof.
  induction e as [| ? IHe1 ? IHe 2]; [
    trivial
    | simpl; rewrite IHe1; rewrite IHe2; rewrite mult_plus_distr_l; trivial ].
Qed.</code></pre>
<p>And now let’s say you added one more constructor to arithmetic expression syntax. How to change this proof to adopt the changes? I don’t think there’s a way to do that without first writing the version without automation. And that brings us back to my first post.</p>
<p>I think the reason why I think too much about this stuff instead of writing some proofs is that I look for elegance and simplicity in my programs. And only if necessary I try to make my programs efficient(fast, small, whatever). After some simple trivial proofs that I did for learning I never found my proofs satisfactory. They are either very very long and repetitive or very hard to understand and modify. It’s very hard to find a sweet-spot in proofs that is not very repetitive and long and still possible to read and understand.</p>
<p>You can always apply methods you learned to make your programs easier to read and modify, like moving some code to a new function with a useful name and formal parameters etc. but in the case of proofs it’s also very hard to find what pieces are considered worthy to be a lemma and what would be useful name for it.</p>
<p>My ideas about proof automation is changed from “no way I use them” to “okay they can be very useful for eliminating repetition without adding obscurity to the proof” in one day. I’ll continue writing Coq proofs for while and probably add new posts on this topic later.</p>]]></summary>
</entry>
<entry>
    <title>On proof automations</title>
    <link href="http://osa1.net/posts/2013-09-11-proof-automation.html" />
    <id>http://osa1.net/posts/2013-09-11-proof-automation.html</id>
    <published>2013-09-11T00:00:00Z</published>
    <updated>2013-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working with constructive systems, at the lowest level you can directly construct proof objects by writing programs. But for realistic scenarios, this is probably too hard to do. Coq and Idris like languages provide an alternative way to construct proof objects: tactics. Tactics provide a way to derive proofs in a way that is somewhat like informal proofs given in spoken languages. But theorems you’re trying to prove is already too complex, and in some parts, very repetitive.</p>
<p>That <em>tactics</em> Coq like theorem provers provide also help you construct proofs with some automation commands. For instance, you can apply same steps several times, until you prove some subgoals. Or you can search for a proof by applying some steps in different combinations.</p>
<p>What doesn’t make sense to me is that in general you cannot really use that automation methods before manually writing long and hard proof by hand and showing that your theorem is really a theorem and it indeed has some repetitive parts.</p>
<p>And at this point you’re probably better off leaving the proof as-is because replacing explicit steps with some magic commands(I’ll come to this point later) only makes the proof harder to read, without any other advantages.</p>
<p>I have similar ideas for <code>auto</code> tactic. What it does is that it searches for a proof by applying different combinations of <code>apply</code> and <code>intros</code> tactics(with some limitations – it only uses apply for hypothesis and hint database which you generate while defining inductive definitions).</p>
<p>Now my problem with <code>auto</code> is that you can only use it when you absolutely sure that your theorem is indeed a theorem – that is, it has a proof. And how can you know that your theorem is correct? The only way to know this is to write a proof for it. Now let’s say <code>auto</code> tactic fails, and when this happens it can’t really say anything. Why did it fail? It may be because your proof is actually too long and it searched for a while but couldn’t find a proof(you can specify search depth as an optional parameter of <code>auto</code> tactic). Or maybe your hint base is not good enough. Or maybe your theorem is not actually a theorem and you cannot prove it.</p>
<p>So both proof search tactics and repetition elimination tactics have this same common problem: you cannot know that they work before writing the proof itself. And automation generally makes the proof unreadable.</p>
<p>Adam Chilpala’s “Certified Programming with Dependent Types” book encourages that automated way of proving. You have that complicated theorem that you don’t even understand what it is saying? No problem, <code>crush</code> tactic(which is not standard, distributed with CPDT book) will prove it for you in one command.</p>
<p>I’m not saying that <code>crush</code> like tactics are necessarily bad and you shouldn’t use it. I’d probably use it in real world when I need a proof that <code>crush</code> can generate and I don’t have time or motivation to do it myself.</p>
<p>And repetition elimination tactics are useful when you have a syntax tree with 15 constructors and you’re proving some theorem that’s relevant with only one of that constructors – 14 subgoals can be easily proved by some clever use of <code>;</code> operator in Coq.</p>
<p>What I’m saying that is several things:</p>
<ul>
<li>Automated proofs can make proofs harder to read and most of the time you already need to have written the long proof to see that it has repetitive parts or at least it is provable. (certainly there are cases where you’ll find yourself trying to prove something wrong)</li>
<li>Once a long proof is written, there is little or no need to remove that proof and replace it with an automated version. (one reason to do that is to have same proof working even after some inductive definitions is expanded/changed)</li>
<li>Most importantly, <code>crush</code> like automation tactics are pure black magic and doesn’t really teach you anthing. As a hobbyist who self-study all this, I prefer learning the principles instead of scripts and magic commands and black boxes.</li>
</ul>
<p>For this reasons I’m trying to use proof automation as little as possible.</p>]]></summary>
</entry>

</feed>
