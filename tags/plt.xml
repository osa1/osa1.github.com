<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged plt</title>
    <link href="http://osa1.net/tags/plt.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/plt.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2021-04-10T00:00:00Z</updated>
    <entry>
    <title>Products and sums, named and anonymous</title>
    <link href="http://osa1.net/posts/2021-04-10-sums-and-products.html" />
    <id>http://osa1.net/posts/2021-04-10-sums-and-products.html</id>
    <published>2021-04-10T00:00:00Z</published>
    <updated>2021-04-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I was recently thinking about why do so many languages have tuples, which can be thought of as simple anonymous products (more on the definition of this below), but not something similar for sums. Both sum and product types are widely used, so it seems inconsistent to have anonymous products but not sums.</p>
<p>I recently <a href="https://twitter.com/_osa1/status/1379260986574667776">tweeted about this</a> and got helpful responses that made me realize that I got my definitions wrong. As I think more about what “anonymous type” means it became clear to me that the it’s not just tuples or other types with special syntax, instead of names. It’s more complicated than that.</p>
<p>So in this post I’d like briefly talk about products and sums, and how are names used in type checking. I will then show a different way of type checking, and some examples from two widely used languages. Finally, I will argue that types are called “named” or “anonymous” depending on how they are checked.</p>
<p>Note that I’m not using any of these words as they are used in category theory or any other field of mathematics. These are mainly how I see them used in widely used PLs like Haskell, Rust, and OCaml, and in PL papers and books.</p>
<h1 id="products">Products</h1>
<p>A value of a product type contains zero or more fields with potentially different types. Some example product types are:</p>
<ul>
<li><code>data Coordinate = Coordinate { x :: Int, y :: Int }</code>: a product with two <code>Int</code> fields</li>
<li><code>data D = D Int String Float</code>: a product with <code>Int</code>, <code>String</code>, and <code>Float</code> fields</li>
<li><code>data Empty = Empty</code>: a product with no fields</li>
</ul>
<p>Note that the way you access the fields does not matter. In the examples above, fields of a <code>Coordinate</code> value can be accessed with pattern matching, or with the generated functions <code>x</code> and <code>y</code>. In the second example, we can only access the fields with pattern matching.</p>
<p>What matters is: products contain zero or more fields. The fields can have different types.</p>
<h1 id="sums">Sums</h1>
<p>A sum type specifies multiple “variants” (or “alternatives”), where each variant has a “name” (or “tag”, more on this later) and some number of fields.</p>
<p>A value of a sum type holds a name (or tag), and the fields of the variant with that name.</p>
<p>For example, if you have a parser for integers, you will want to return an integer when parsing succeeds, or an error message when something goes wrong. The sum type for the return value of your parse function would look like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ParseResult</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Success</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Fail</span> <span class="dt">String</span></span></code></pre></div>
<p>Here, <code>Success</code> and <code>Fail</code> are names of the variants. <code>Success</code> variant has an <code>Int</code> field, and <code>Fail</code> variant has a <code>String</code> field.</p>
<p>A value of this type does not contain an <code>Int</code> and <code>String</code> at the same time. It’s either a <code>Fail</code> with a <code>String</code> field, or a <code>Success</code> with an <code>Int</code> field.</p>
<p>The way you access the fields is with pattern matching:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">case</span> parse_result <span class="kw">of</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>   <span class="dt">Success</span> int <span class="ot">-&gt;</span> <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>   <span class="dt">Fail</span> error_message <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<h1 id="names-in-type-checking-nominal-typing">Names in type checking (nominal typing)</h1>
<p>If I have two types, named <code>T1</code> and <code>T2</code>, no matter how they are defined, they are considered different in Haskell, and most other widely used typed languages (Rust, Java, …). This is called “nominal” type checking, where differently named types are considered different, even if they are “structurally” the same. For example, <code>data T1 = T Int</code> and <code>data T2 = T Int</code> are structurally the same, but you can’t apply a value of type <code>T2</code> to a function that expects <code>T1</code>.</p>
<p>What “structurally same” mean is open to interpretation. We will come to this later.</p>
<p>In addition, all types have names<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, even types like tuples, which may look like they don’t have names, like our <code>Coordinate</code> or <code>ParseResult</code> have.</p>
<p>Tuples in most languages are just a bunch of product types, like the ones you can define yourself. They are often pre-defined for arities 0 to some number, and they have a special, “mixfix” syntax, with parentheses and commas to separate the fields. Other than that, they are no different than the ones you can define yourself.</p>
<p>You can see GHC’s definition of tuples <a href="https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs#L34-L58">here</a>. In GHC, you can use the name directly if you don’t want the mixfix syntax, like <code>(,) 1 2</code>. So the name for an 2-ary tuple is <code>(,)</code> in Haskell, and it has a special syntax so you can write more readable <code>(1, 2)</code> (or <code>(Int, Int)</code> in type context). Other than syntax, there’s nothing special about tuples.</p>
<p>So it’s clear that most languages don’t have anonymous types. All types have some kind of names, and two types are only “compatible” if the names match.</p>
<p>Before defining what anonymous types are, I would like to give two examples, from PureScript and OCaml, where types are not checked based on their names, but based on their “structure”.</p>
<h1 id="structural-type-checking-for-products">Structural type checking for products</h1>
<p>A record is a product type with named (or “labelled”) fields. Our <code>Coordinate</code> example is a record.</p>
<p>In PureScript, records can be defined without giving names to them. For example:</p>
<pre class="purescript"><code>f :: { x :: Int, y :: Int } -&gt; Int
f a = a.x + a.y</code></pre>
<p>Here, <code>f</code> is a function that takes a record with two <code>Int</code> fields, named <code>x</code> and <code>y</code>, as an argument.</p>
<p>Here is a more interesting version of the same function:</p>
<pre class="purescript"><code>f :: forall r . { x :: Int, y :: Int | r } -&gt; Int
f a = a.x + a.y</code></pre>
<p>This version takes a record with <em>at least</em> <code>x :: Int</code> and <code>y :: Int</code> fields, but it can have more fields. Using this version, this code type checks:</p>
<pre class="purescript"><code>f { x: 1, y: 2, z: 3, t: 4 }</code></pre>
<p>The <code>r</code> in this type is not too important. Important part is, in PureScript, records are not type checked nominally. Indeed, in the example above, type of the record with 4 fields is not defined, and no names are used for the record in the type signature of <code>f</code>.</p>
<p>You might think that the record braces and commas are similar to the tuple syntax, so the name could be something like <code>{,}</code>, maybe applied to <code>x :: Int</code> somehow (assuming there is a type-level representation of field names).</p>
<p>However, even if that’s the case, type checking of these types are quite different than tuples. We’ve already seen that we can pass a record with more fields. You can also reorder fields in the function type signature<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, or in the record expression, and it still works.</p>
<p>So type checking for PureScript is quite different than Haskell tuples.</p>
<p>This kind of type checking where you look at the “structure” rather than just the names is called structural type checking.</p>
<p>Now let’s take a look at an example for sum types.</p>
<h1 id="structural-type-checking-for-sum-types">Structural type checking for sum types</h1>
<p>OCaml has named sum types, just like Haskell’s. Here the OCaml version of our <code>ParseResult</code> type:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> parse_result =</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  | Success <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  | Fail <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>Name of this type is <code>parse_result</code> (following OCaml naming conventions), and it is type checked exactly the same way it is type checked in Haskell.</p>
<p>A second way of defining sum types in OCaml, and without names, is with <a href="https://ocaml.org/manual/lablexamples.html#s:polymorphic-variants">polymorphic variants</a>. Here’s the polymorphic variant for the same type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">type</span> parse_result = [ `Success <span class="kw">of</span> <span class="dt">int</span> | `Fail <span class="kw">of</span> <span class="dt">string</span> ]</span></code></pre></div>
<p>Crucially, even though we use a similar syntax with the <code>type</code> keyword, this is a type synonym. The right-hand side of this definition is an anonymous sum with two variants, tagged <code>`Success</code> and <code>`Fail</code>, with <code>int</code> and <code>string</code> fields, respectively.</p>
<p>Now, suppose I have a parse result handler, which, in addition to the success and failure cases, handles some “other” case as well:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">let</span> f = <span class="kw">function</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  | `Success i -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse result: %d</span><span class="ch">\n</span><span class="st">&quot;</span> i</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  | `Fail msg -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse failed: %s</span><span class="ch">\n</span><span class="st">&quot;</span> msg</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  | `Other -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Wat?</span><span class="ch">\n</span><span class="st">&quot;</span></span></code></pre></div>
<p>Type of this function as inferred by the OCaml compiler is:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>[&lt; `Fail <span class="kw">of</span> <span class="dt">string</span> | `Other | `Success <span class="kw">of</span> x ] -&gt; <span class="dt">unit</span></span></code></pre></div>
<p>What this type says is that the function accepts any polymorphic variant that has the tags <code>Fail</code>, <code>Other</code>, and <code>Success</code> (with the specified field types), or some subset of these tags. So if I have a value of type <code>parse_result</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">let</span> x : parse_result = `Success <span class="dv">123</span></span></code></pre></div>
<p>I can pass it to <code>f</code>, even though <code>f</code>’s argument type is not exactly <code>parse_result</code>. Here’s the full example, run in <a href="https://github.com/ocaml-community/utop">utop</a>: (<code>utop #</code> part is the prompt, lines after <code>;;</code> are utop outputs)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>utop # <span class="kw">type</span> parse_result = [ `Success <span class="kw">of</span> <span class="dt">int</span> | `Fail <span class="kw">of</span> <span class="dt">string</span> ];;</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">type</span> parse_result = [ `Fail <span class="kw">of</span> <span class="dt">string</span> | `Success <span class="kw">of</span> <span class="dt">int</span> ]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>utop # <span class="kw">let</span> f = <span class="kw">function</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  | `Success i -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse result: %d</span><span class="ch">\n</span><span class="st">&quot;</span> i</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  | `Fail msg -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse failed: %s</span><span class="ch">\n</span><span class="st">&quot;</span> msg</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  | `Other -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Wat?</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">val</span> f : [&lt; `Fail <span class="kw">of</span> <span class="dt">string</span> | `Other | `Success <span class="kw">of</span> <span class="dt">int</span> ] -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>utop # <span class="kw">let</span> x : parse_result = `Success <span class="dv">123</span>;;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="kw">val</span> x : parse_result = `Success <span class="dv">123</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>utop # f x;;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>Parse result: <span class="dv">123</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
<p>Neat!</p>
<p>Similar to PureScript records, and unlike Haskell tuples, type checking for OCaml polymorhic records is structural, not nominal.</p>
<h1 id="names---nominal---structural">Names -&gt; nominal, ??? -&gt; structural</h1>
<p>Now that we have seen structural type checking as an alternative to name-based (nominal) type checking, and some examples, here is my attempt at defining anonymous types: If named types are type checked nominally, then the types that are structurally type checked are called “anonymous”.</p>
<p>In other words:</p>
<ul>
<li>Nominally type checked types are named</li>
<li>Structurally type checked types are anonymous</li>
</ul>
<p>According to this definition, Haskell and many other languages don’t have anonymous types. PureScript records are an example to anonymous products, and OCaml polymorphic variants are an example to anonymous sums.</p>
<h1 id="conclusions">Conclusions</h1>
<p>Named types are checked nominally, anonymous types are checked structurally. According to this definition, Haskell, and many other languages, don’t have anonymous types, as all types are nominally checked.</p>
<p>Tuples are no exception: they have names, and type checked nominally.</p>
<p>PureScript records and OCaml polymorphic variants are great examples to anonymous products and sums, respectively.</p>
<!---




























# Tuples: named or anonymous?

Tuples in languages like Haskell, Rust, and OCaml, are pre-defined product
types that are often used for returning multiple values from functions, without
having to define a new type for the return value.

For example, the tuple type `(Int, Int)` in Haskell is a product with two `Int`
fields. This type is similar to our `Coordinate` example above.

Because tuples don't have "names", like our `Coordinate` has, it may seem like
tuples are unnamed, or "anonymous". This is actually not true. Tuples in most
languages are just a bunch of product types, like the ones you can define
yourself. They are often pre-defined for arities 0 to some number, and they have
a special, "mixfix" syntax, with parentheses and commas to separate the fields.
Other than that, they are no different than the ones you can define yourself.

As an example, you can see GHC's definition of tuples [here][2]. In GHC, you can
use the name directly if you don't want the mixfix syntax, like `(,) 1 2`. So
the name for an 2-ary tuple is `(,)` in Haskell, and it has a special syntax so
you can write more readable `(1, 2)` (or `(Int, Int)` in type context).

So it's clear that tuples in Haskell are not anonymous, they have names. But
what are anonymous types then? Does Haskell even have anonymous types? Before
defining anonymous types, let's briefly talk about how are names used in type
checking.

# Nominal and structural type checking

If I have two types, named `T1` and `T2`, no matter how they are defined, they
are considered different in Haskell, and most other widely used typed languages
(Rust, Java, ...). This is called "nominal" type checking, where differently
named types are considered different, even if they are "structurally" the same.
For example, `data T1 = T Int` and `data T2 = T Int` are structurally the same,
but you can't apply a value of type `T2` to a function that expects `T1`.


What does "structurally same" mean here is open to interpretation, but the
crucial part is with structural type checking, types can have different set of
fields or variants and still be compatible. We will shortly see examples of
this.

Now, here's the difficulty with defining anonymous types (and a point of
confusion, at least for me). Regardless of the syntax, I will have to introduce
some kind of type constructors for anonymous products and sums. One might always
consider those constructors as the names of the types (with type parameters
applied for the fields/ variants).

For example, if I use `*` syntax for anonymous products, like `Int * Int * Bool`
for a product type like `(Int, Int, Bool)`, you might argue that the "name" here
is `*`, and the desugared version is something like `(*) Int ((*) Int Bool)`,
and you would probably be right! In many (most?) type systems, including
Haskell's, complex types are made by applying types to type constructors. The
type constructors used for constructing product or sum types can be thought of
as the name of the types.

In that sense I think there really isn't any *obviously anonymous* types where
you will know it when you see it. Every type is constructed by applying some
number of arguments to a "name" (usually called "type constructors").

# Names -> nominal, ??? -> structural

With these definitions in mind, here's my attempt at defining anonymous types.
If named types are type checked nominally (where different names mean types are
incompatible), then the types that are structurally type checked are called
"anonymous".

In other words:

- Nominally type checked types are named
- Structurally type checked types are anonymous

In the simple structural type checking rule we've seen above, anonymous
products (constructed with `*`) and tuples (constructed with the mixfix tuple
syntax) are type checked exactly the same way. Let's add one more rule to make
them different:

- Before applying the rules given before, rearrange the type arguments to make
  the first argument of `*` a non-`*` type.

Example: if I have `(Int * Int) * (Int * Int)`, this rule rearranges it to make
it `Int * (Int * (Int * Int))`.

(This rule effectively makes `*` associative)

With this new rule we now accept these two types as compatible:

- `(Int * (Int * Int)) * Int`
- `(Int * Int) * (Int * Int)`

as they are both rearranged before checking as `Int * (Int * (Int * Int))`.

(Whether this rule is useful or desired is a different matter)

With this structural equality rule, type checking of tuples and products
constructed with `*` are different, and we call tuples named types and `*`
products anonymous.

# Anonymous sum types

Instead of inventing syntax and defining type checking for anonymous sum types,
like we did for products, I will show an example of anonymous sums in an
existing programming language: OCaml's [polymorphic variants][3].

Here's the OCaml version of our `ParseResult` type:

```ocaml
type parse_result =
  | Success of int
  | Fail of string
```

This type is nominally checked, so if you have a function that expects
`parse_result` argument, you have to pass it a `Success` or `Fail`. Anything
else will cause a type error.

Here's the polymorphic variant for the same type:

```ocaml
type parse_result = [ `Success of int | `Fail of string ]
```

Crucially, even though we use a similar syntax with the `type` keyword, this is
a type synonym. The right-hand side of this definition is an anonymous sum with
two variants, labelled `` `Success`` and `` `Fail``, with `int` and `string`
fields, respectively.

Here's an example of structural type checking of polymorphic variants. Suppose I
have a parse result handler, which, in addition to the success and failure
cases, handles some "other" case as well:

```ocaml
let f = function
  | `Success i -> Printf.printf "Parse result: %d\n" i
  | `Fail msg -> Printf.printf "Parse failed: %s\n" msg
  | `Other -> Printf.printf "Wat?\n"
```

Type of this function as inferred by the OCaml compiler is:

```ocaml
[< `Fail of string | `Other | `Success of x ] -> unit
```

What this type says is that the function accepts any polymorphic variant that
has the tags `Fail`, `Other`, and `Success` (with the specified field types), or
some subset of these tags. So if I have a value of type `parse_result`:

```ocaml
let x : parse_result = `Success 123
```

I can pass it to `f`, even though `f`'s argument type is not exactly
`parse_result`. Here's the full example, run in [utop][9]: (`utop #` part is the
prompt, lines after `;;` are utop outputs)

```ocaml
utop # type parse_result = [ `Success of int | `Fail of string ];;
type parse_result = [ `Fail of string | `Success of int ]

utop # let f = function
  | `Success i -> Printf.printf "Parse result: %d\n" i
  | `Fail msg -> Printf.printf "Parse failed: %s\n" msg
  | `Other -> Printf.printf "Wat?\n";;
val f : [< `Fail of string | `Other | `Success of int ] -> unit = <fun>

utop # let x : parse_result = `Success 123;;
val x : parse_result = `Success 123

utop # f x;;
Parse result: 123
- : unit = ()
```

Neat!

# Conclusions

Named types are checked nominally, anonymous types are checked structurally.
According to this definition, Haskell, and many other languages, don't have
anonymous types, as all types are nominally checked.

OCaml's [polymorphic variants][3] are a great example to anonymous sums.

For real-world anonymous products, it would be a shame to not mention records
and row types[^1]. A record is a product type with labelled fields, for example:
`{ a : Int, b : Bool }`. Row types allow (among other things) very flexible type
checking of records, where you can (without subtyping) pass a record with more
fields when less is expected. With row types, unlike subtyping, if you have a
function that expects a record type like `{ a : Int, b : Bool }` and returns the
argument after using or modifying the fields `a` and/or `b`, and pass the
function a record with more fields, like `{ a : Int, b : Bool, c : String }`, as
the return type you get your original record with 3 fields. More concretely:

```
{ a : Int, b : Bool, ..r } -> { a : Int, b : Bool, ..r }
```

is the type of a function that takes a record with fields `a` and `b` with the
specified types, and *possibly* more fields. These extra fields are represented
by `r`, which appears in both input and output types. This means you don't lose
the extra fields if you pass a record with more fields to this function, unlike
in a system with subtyping. With subtyping, if you have a function with type

```
{ a : Int, b : Bool } -> { a : Int, b : Bool }
```

and pass `{ a : Int, b : Bool, c : String }` to such a function, you lose the
field `c` in the return value, because the return type only mentions `a` and
`b`, without the "extra stuff" part as we've seen in the row polymorphic
version.

(As as aside, I'd like to mention that I really like row types. My first
exposure to them was back in 2013 ([1][5], [2][6]): I implemented two type
systems, one with row types and one for a multi-stage language, proved soundness
of the systems, gave a type and term translation from one to the other, and
proved that if your program is well-typed, then the translation of it is also
well-typed.)

My favorite paper on row-polymorphic records is probably (1). (2) uses row types
for algebraic effects. (3) uses rows for variants (sums).

-->
<h1 id="acknowledgements">Acknowledgements</h1>
<p>Thanks to <a href="https://twitter.com/_gilmi/">@_gilmi</a> and <a href="https://twitter.com/madgen_/">@madgen_</a> for their helpful comments on a draft of this blog post.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>With the exception of type synonyms. Type synonyms can be considered as simple macros for substituting types for names before type checking.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>In Haskell, reordering stuff at the type level is often done with type families (type-level functions). Types are still checked nominally, but by rearranging them before type checking you can often have something somewhat similar to structural checking.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Proving soundness of simply typed multi-staged lambda-calculus</title>
    <link href="http://osa1.net/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html" />
    <id>http://osa1.net/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html</id>
    <published>2014-03-06T00:00:00Z</published>
    <updated>2014-03-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>First part of my first non-trivial(e.g. something other than a Software Foundations exercise) Coq program is finally done. I learned Coq from Software Foundations, but I didn’t finish to book. I still know only very basic tactics, which I think is one of the reasons why my proofs are so long. You can see the source <a href="https://github.com/osa1/StagedLambda/blob/master/Lc.v">here</a>.</p>
<p>Some random notes about implementation:</p>
<ul>
<li>I’m looking to improve proofs. I have a lot more to implement for the rest of the program until deadline, so I may not be able to refactor current proofs very much, but at one point I want to simplify the proofs and use more advanced tactics.</li>
<li>Currently only <code>inversion</code>, <code>destruct</code>, <code>induction</code>, <code>rewrite</code>, <code>assumption</code>, <code>assert</code>, <code>constructor</code>, <code>auro</code>, <code>simpl</code>, <code>intro</code>/<code>intros</code>, <code>apply</code>, <code>right</code>/<code>left</code>, <code>exists</code>, <code>unfold</code>, <code>subst</code>, <code>reflexivity</code>, <code>remember</code> and <code>generalize</code> tactics are used.</li>
<li>Language definition is almost the same as in papers. There is one difference, we implemented substitutions as a function. In reality, substitution in multi-staged lambda-calculus is not a function. I believe this doesn’t effect correctness of theorems. At one point I’ll refactor the code and define substitution as a relation.</li>
<li>I used <code>Case</code>, <code>SCase</code>, <code>SSCase</code> … constructs from SFlib extensively.</li>
</ul>
<p>Now I’m going to implement lambda-calculus with row-polymorphic records. I expect this to be at least 2x harder, since polymorphism is involved. Let’s see how it goes …</p>]]></summary>
</entry>
<entry>
    <title>Internship report - type inference, row polymorphism, and multi-stage programming</title>
    <link href="http://osa1.net/posts/2013-04-15-internship.report.html" />
    <id>http://osa1.net/posts/2013-04-15-internship.report.html</id>
    <published>2013-04-15T00:00:00Z</published>
    <updated>2013-04-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is the report of my 3.5-month internship fulfilled at <a href="http://ozyegin.edu.tr/">Ozyegin University</a> under <a href="http://faculty.ozyegin.edu.tr/aktemur/">Prof. Baris Aktemur</a>’s supervision.</p>
<p>I wrote this report as a short and informal introduction to the topics I worked on in my internship, and since I know nobody will ever read this internship report, I decided publishing it in my blog with hoping someone benefit from it.</p>
<p>A note before reading: Things went in an unexpected way shortly after I started writing the report: I got bored. So each chapter got shorter and shorter, leaving tons of interesting and important stuff unmentioned. Sorry for that.</p>
<h2 id="contents">Contents:</h2>
<ul>
<li>Introduction to type systems and polymorphism</li>
<li>Hindley-Damas-Milner type system and type inference</li>
<li>Row polymorphism</li>
<li>Multi-stage porgramming</li>
<li>Our work - extending multi-stage language with subtyping and Wallce: a module type inference system</li>
</ul>
<h1 id="introduction-to-type-systems-and-polymorphism">Introduction to type systems and polymorphism</h1>
<p>As far as software engineering concerned, a type system is a static analysis method that aims to prove a program ‘won’t go wrong’<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, meaning that the program will not crash at runtime. Static type checking can also be used for some compiler optimisations. Also, some languages have mechanisms for dispatching on types.</p>
<p>Type systems (in this text, this term is used as ‘static type systems’) do that by inspecting program terms and proving some properties and relations among them. This work is done before run-time, and most type information can be deleted so that it won’t cause any runtime costs.</p>
<p>For most type systems, process of type checking is ‘syntactic’. This means two things; first, the type checker only needs program text and it doesn’t need any information that can only be obtained at run-time. And second, type checking a program term only depends on type checking subterms of that program. These two properties also give us a somewhat simple way to express type checking on terms in a symbolic and formal way.</p>
<p>Type systems are ‘conservative’, meaning they will reject some ‘correct’ programs. A correct program means a program that won’t crash at runtime. For instance, this program(in OCaml syntax):</p>
<pre><code>if true then 1 else 42(5)</code></pre>
<p>is actually correct, and it can be given the type <code>int</code> (since we know it always evaluates to <code>1</code>, which has type <code>int</code>), but almost all type systems reject this program because of the ‘else’ branch expression <code>42(5)</code> that is ill-typed.</p>
<p>Research on type systems aims to have more “powerful” type systems. Being more powerful means accepting <em>more</em> correct programs and also being able to encode more <em>invariants</em> in the type system, so that more <em>incorrect</em> programs will be rejected.</p>
<p>Being wrong and being incorrect is used with different meanings in this text: a wrong program will crash at run-time, but incorrect program will result with a wrong answer. For instance, a wrong implemented algorithm may not be <em>wrong</em>, but it’s <em>incorrect</em>. So it will work fine, but return a wrong result.</p>
<p>As an instance of accepting more correct programs, this code is not typeable under simply-typed lambda calculus:</p>
<pre><code>let id a = a in
(id 1, id true)</code></pre>
<p>But it’s well-typed in polymorphic lambda calculus. As a second example, this is not typeable under polymorphic lambda calculus:</p>
<pre><code>add5 : float -&gt; float
...
add5 10</code></pre>
<p>Here <code>10</code> has type <code>int</code>, so we can’t apply it to a function that expects a float value. Type systems with subtyping overcome this problem by defining a common supertype of types. In our case, <code>float</code> is already a supertype of <code>int</code>, so this example is well-typed in the presence of subtyping.</p>
<p>As an example of being able to encode more <em>invariants</em> in the type system, let’s look to the type of a sort function from a dependently-typed programming language:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<pre><code>sort : List Int -&gt; List Int</code></pre>
<p>This type can be inhabited with some wrong functions. For instance, a function that takes a list and returns an empty list will have this type, just like <em>reverse</em> and <em>shuffle</em> functions.</p>
<pre><code>sort : Vect Int n -&gt; Vect Int n</code></pre>
<p>This type has a invariant encoded in it: length of it’s input and output should be equal. This means our first function that takes a list and returns an empty list now can’t be inhabited by this type. We have a more precise type.</p>
<pre><code>sort : (xs : Vect Int n) -&gt;
       (ys : Vect Int n ** Permutation xs ys)</code></pre>
<p>This type is even more precise, a function that takes a list and returns a list with some random elements can’t get this type.</p>
<p>One problem with more expressive type systems is that there may be some types that can’t be inferred by type system, but the type can be given by programmer. In some cases the type system may not be able to prove that an expresion has the denoted type. In case of dependently typed languages, programmer is required to give some proofs to the type checker. But even in much simpler type systems programmer may have to give some types manually.</p>
<p>–</p>
<p>A word about the terms ‘polymorphism’ and ‘subtyping’: Polymorphic type systems can give multiple types to a single piece of code, thus providing reuse. This is done by giving the code a general type and then creating instances of type depending on the use. As an example, let us start with a simple OCaml function, <code>fst</code>.</p>
<p><code>fst</code> returns first element of any pair, it has the type <code>('a * 'b) -&gt; 'a</code> (the language of types is described in next section). This means for any pair with type of <code>('a * 'b)</code>, <code>fst</code> will return value with type of <code>'a'</code>. When applied on a value typed <code>(bool * int)</code> it will return <code>bool</code>, and when applied on a value typed <code>( (string * bool) * string )</code> it will return <code>(string * bool)</code> etc.</p>
<p>Subtyping defines a relationship that if a type <code>t1</code> is subtype of a type <code>t2</code>, this means that <code>t1</code> can be given to context where <code>t2</code> is expected. This usually means <code>t1</code> already has all properties of <code>t2</code>.</p>
<p>For instance, a record with fields <code>a: int, b: bool</code> can be passed to a function that expects a parameter typed <code>{a: int}</code>. The same effect can also be obtained by row polymorphism, which we’ll see in it’s own chapter.</p>
<p>Subtyping is generally divided into two branches; nominal and structural subtyping. Structural subtyping relation is syntactic, ie. type system can decide if one type is subtype of another type just by inspecting their forms (like in the example above). Nominal subtyping requires definition from the programmer or a pre-defined type lattice from the language designer, ie. there is no way for a type system to infer subtyping relation between int and float types if this relation is not built-in; similarly a Square is not a subtype of Shape unless the programmer manually defines this subtyping relation.</p>
<h1 id="hindley-damas-milner-type-system-and-type-inference">Hindley-Damas-Milner type system and type inference</h1>
<p>Manually giving types to program terms may be impractical, since programs can contain hundreds of definitions. Type inference is the process of deriving types for program terms. As an example of language with type inference, OCaml programs with no type annotations can be type-inferred and checked. This results in more concise programs. Type annotations can still be given for documentation or error reporting purposes.</p>
<p>Hindley-Damas-Milner(abbreviated as HM henceforth) type system is likely to be the most widely-used type system. It has a great property that if a term is typeable under HM type system, HM inference algorithm will result with a most general type (also called ‘principal type’).</p>
<p>HM is the system lies behind statically typed functional languages like the ML family of languages and Haskell.</p>
<p>In HM, a polymorphic type is specified as a ‘type scheme’. A type scheme is a type with universally quantified type variables. Type system’s job then is to give terms of a program type schemes so that for each instantiation of the scheme, the result is well-typed.</p>
<p>HM type system produces polymorphic types (type schemes) only for some expressions, in the case of ML family of languages, it’s the <code>let</code> expression. A <code>let</code> expression binds a name to an expression and introduces a scope that the name is bound to the expression. HM type system gives a most general type to that name, and so every use of this name in the scope is valid if a valid instantiation of the required type can be obtained from the type scheme it’s given.</p>
<pre><code>let id a = a in
(id 1, id true)</code></pre>
<p>Here the <code>id</code> function is given the type scheme of <code>forall a. a -&gt; a</code>. The variable <code>a</code> is called to be ‘universally quantified’. In <code>id 1</code>, <code>id</code>s type is instantiated from type scheme as <code>int -&gt; int</code> by substituting <code>a</code> with <code>int</code>. Same operation is done in <code>id true</code> and <code>id</code> is given the type <code>bool -&gt; bool</code>. So this term is well-typed under HM.</p>
<p>Inferring a type scheme is done by assigning fresh type variables to terms with unknown types and unifying this variables with concrete types while type checking rest of the term. At the end, types that are not unified with concrete types will remain polymorphic.</p>
<p>This is also called let-polymorphism because polymorphic type (type scheme) generation is only done in let expressions.</p>
<p>Note that not all names defined in a let expression can be generalized. As an example, see this classic example:</p>
<pre><code>let c = ref (fun x -&gt; x) in
c := (fun x -&gt; x+1);
!c true</code></pre>
<p>Giving <code>c</code> the type <code>forall a. ('a -&gt; 'a) ref</code> (in OCaml syntax) makes this example well-typed, which is wrong. Instead, type system should have given the type <code>( '_a -&gt; '_a) ref</code>, then during the type checking <code>c := (fun x -&gt; x + 1)</code>, <code>_a</code> should be unified with <code>int</code>. Note that since <code>('_a -&gt; '_a) ref</code> doesn’t quantify the variable <code>a</code>, after this point, type of <code>c</code> will be <code>(int -&gt; int_ ref</code>, so applying it a bool value will fail.</p>
<p>Let-polymorphism has some interesting properties. It’s simple, but it still accepts realistic programs. And even though its worst-case efficiency is exponential on the size of input program, most realistic programs don’t hit the worst case and have linear time complexity. For this reason, let-polymorphism is named as the ‘sweet-spot’ of type systems.</p>
<p>Another great property of HM type system is that it can be reduced to constraint generation and solving steps. These separate steps lead to a more modular algorithm, with changeable constraint generators and solvers. HM(X)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> is a formalization of this observation.</p>
<h1 id="row-polymorphism">Row polymorphism</h1>
<p>Rows are a way to encode ‘labeled products’. A product type is a type that contains some other types; for example, a pair is a product type of two other types (<code>(int * bool)</code> is a product type with <code>int</code> and <code>bool</code> parts).</p>
<p>A ‘labeled sum’ is a product type, but with labels. For instance:</p>
<pre><code>type error = { code : int; reason : string }</code></pre>
<p>is just like an <code>(int * string)</code> type, but it has labels for subparts. There are severals ways to encode labeled products as rows. Here’s one way:</p>
<pre><code>type error = { code : abs int; reason : abs int; rho[code,int] }</code></pre>
<p>This syntax is similar to Rémy’s, which was also used in our project. Last <code>rho</code> is the polymorphic part, it means that an error type is a row type with <code>code</code> and <code>reason</code> fields with gives types, but with a polymorphic part that can be unified with any record except the fields labeled with <code>code</code> or <code>int</code> (some systems accept field repetition, like in Daan Leijen’s “Extensible records with scoped labels”).</p>
<p>Row polymorphism gives us a subtyping-like effect. For example, this function:</p>
<pre><code>fun x -&gt; x.a + 1</code></pre>
<p>Now has the type <code>{ a : int; rho[a] } -&gt; int</code> and we can apply it to the record <code>{ x : some_type; y : some_other_type; a : int; ... }</code>, like in structural subtyping.</p>
<p>The way row polymorphism and structural subtyping accept this term are completely different though. In row polymorphism, parameter type <code>{a : int; rho[a] }</code> is being unified with <code>{ x : some_type; y : some_other_type; a : int; ... }</code>, so parameter type of function is actually getting more specialized. On the other hand, in subtyping, extra fields of actual parameter is being forgotten, like casting a type to it’s super type.</p>
<p>More words will be said about row polymorphism in later sections.</p>
<h1 id="multi-stage-programming">Multi-stage programming</h1>
<p>Multi-stage programming languages makes distinguished evaluation stages in run-time. Some part of the program can be generated depending on some user input.</p>
<p>Evaluation is done at stage 0. A program generated in staged 0 has stage 1, program generated in stage 1 has stage 2 etc. This notion of separate stages has some semantic effects. Each stage has a scope, but most systems offer a mechanism to lift a value from a lower stage.</p>
<p>Being able to generate code in run-time gives us a way to specialize algorithms depending on user input. Let’s look at a classic example:</p>
<pre><code>let rec pow_body_gen n =
  if n = 0 then &lt;1&gt;
  else &lt;a * ~(pow_body_gen (n-1))&gt;;;</code></pre>
<p><code>pow_body_gen</code> takes an integer <code>n</code> and returns the code <code>a * a * a * ... * 1</code>, a to the power of n. With the help of this function, we can generate a specialized function <code>power_five</code> which raises an integer to the power 5, but without running a loop or recursively calling a function:</p>
<pre><code>let rec power_five a = &lt;let a = ~lift(a) in ~(pow_body_gen 5)&gt;;;</code></pre>
<p>For example, output of <code>power_five 12</code> in our interpreter is <code>&lt;let a = 12 in (a * (a * (a * (a * (a * 1)))))&gt;</code>. This is a code value. Notice the <code>a</code> value, which is multiplied by itself, 5 times.</p>
<p>To actually run this code, we can call <code>run</code>(stage primitives will be explained shortly):</p>
<pre><code>&gt; run(power_five 12);;
248832</code></pre>
<p>Our multi-stage language has three primitives for staging operations: angle brackets indicate a staged expression, contents of staged expression will be run in stage <code>n+1</code>, where n is the current stage level. Tilde (~) ‘unboxes’ a staged expression, expressions indicated with a unboxing operator will be run in stage <code>n-1</code>. Unboxing operator can only be used in stages n &gt; 0. Finally, <code>run</code> primitive is used to run a closed code value at stage 0.</p>
<p>Note that code values can be open, but only closed code values can be run. Our <code>pow_body_gen</code> function returns a code value with an unbound variable <code>a</code>, then in <code>power_five</code>, we define <code>a</code> in stage 1, and by unboxing <code>pow_body_gen 5</code>, we actually generate a bigger code value, with <code>a</code> defined. Now our code value is closed, so it can be run.</p>
<p>There is also a relation between multi-stage programming and partial evaluation, but this is out of this text’s scope.</p>
<h1 id="our-work">Our work</h1>
<p>Wallace is a type inference library, supporting subtyping. “Its goal is to serve as a plug-in component in the design of a constraint-based type-checker, regardless of the programming language being analyzed.”<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>We used Wallace to get subtyping in our language. Wallace comes with an example language, called ‘toy’, which has extensible records built-in. For simplicity, instead of generating constraints for Wallace, we first translated our multi-stage language to record calculus. Translation to record calculus preserves semantics, but eliminates staged computations<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Our record calculus is then translated to ‘toy’. ‘toy’ infers types for us, by generating and passing constraints to Wallace.</p>
<p>We then compared our type system with<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. This expression:</p>
<pre><code>run((fun c -&gt; &lt;(let x = 1 in ~c, let y = 1 in ~c)&gt;) &lt;1&gt;);;</code></pre>
<p>is not typeable under polymorphic type system, but is well-typed in our system with subtyping. By mapping the calculated type back to our multi-stage language, we got subtyping in the multi-stage language for free.</p>
<p>Wallace is used as is, without any modifications. But we changed ‘toy’ language for our purposes. We first added some numerical types with subtyping relations. ‘toy’ had a problem that it was generalizing every let bindings, without value restriction. To overcome this problem, we added an extra lambda wrapper in the translator when value restriction is needed. Since our type system already had value restriction, it was trivial to apply the same test to check if an expression is expansive. Expansive expressions are those that may allocate new memory cells. Expansive expressions are not generalized.</p>
<p>Another problem with ‘toy’ language is that it doesn’t support toplevel declarations, and adding that wasn’t easy. To overcome this without any serious modifications in ‘toy’s source, we collected all well-typed toplevel expressions and declarations, and then generated a <code>let .. in ..</code> chain of toplevel declarations to give ’toy’ type checker. This means for every new toplevel phrase, ‘toy’ now type checks all old expressions too. This may not be efficient but works fine with our purposes, and it was easy to implement.</p>
<p>Implementing type inference: Implementing a type inference system is hard to do elegantly. One problem is already discussed <a href="/posts/2013-02-15-rowlar-kindlar.html">in my blog (in Turkish)</a>. Every non-trivial type system requires types to be separated into kinds. After that, every type variable will also have kind information and it’s a type error to unify a type variable with wrong kinds. Type applications also checked with the help of kinds.</p>
<p>Kinds are generally checked at run-time. Type systems with kinds usually lead to a simpler type language. For instance, almost all types mentioned in this text can be represented by this simply type language:</p>
<pre><code>type kind =
  | KStar                 (* kind of term types *)
  | KRow                  (* kind of row types *)
  | KArr of (kind * kind) (* kind of type constructors *)

type ty =
  | TCon of tycon     (* constant *)
  | TVar of tyvar     (* type variable *)
  | TApp of (ty * ty)
      (* type application, to be well-typed
         kind of first ty should be KArr (k2, k)
         and second ty should be k2 *)
and tyvar = (tyvarlink ref * kind)
and tyvarlink =
  | NoLink of id (* just a type variable *)
  | LinkTo of ty (* equated to a ty *)
and tycon = (id * kind) (* kind should be always KStar *)</code></pre>
<p>We decided to take a different path, instead of keeping kind information for every type, we created new type constructors for every type and then separating differently kinded type variables with different types. This lead us to this type language:</p>
<pre><code>type ty =
 | TInt
 | TBool
 | TUnit

 | TPair of ty * ty

 | TList of ty
 | TRef  of ty

 | TFun of ty * ty
 | TRec of tyrec
 | TVar of typevar

 | TBox of tyrec * ty

...

and typevar = (tyvarlink * int) ref
and tyvarlink = ty link

and fieldvar = (fieldvarlink * int) ref
and fieldvarlink = field link

and recvar = (recvarlink * int * IdSet.t) ref
and recvarlink = tyrec link</code></pre>
<p>We also needed a sum type for handling differently kinded type variables:</p>
<pre><code>and linkvar =
 | TV of typevar
 | FV of fieldvar
 | RV of recvar</code></pre>
<p>This also made our algorithms more complex, since we had more cases to handle.</p>
<p>This representation is not without any advantages though. For instance, writing a pretty-printer was very easy, because we could easily print a pair and a function or a list and a ref differently, even though they share similar structure, with simple pattern matching.</p>
<p>A note on pretty-printing: OCaml has a great pretty-printer library in stdlib. It’s simple but powerful at the same time, allowing printing most complex structures easily. It interprets some characters in input strings as boxes/spaces indicators etc. and formats the text. For instance, this code:</p>
<pre><code>printf &quot;@[&lt;hov 2&gt;~(&quot;; print_exp exp; printf &quot;)@]&quot;</code></pre>
<p>Here <code>@[&lt;hov 2&gt;</code> part creates a new “horizontal or vertical” box. This box has a property that when a line is split to two lines, every other newline pointers will also be split into separate lines. So contents of this box is either displayed as a single line, or separated from every newline pointers. Later, <code>print_exp exp;</code> part prints the expression inside the box. And lastly, `printf “)@]” closes the paren, then closes the box, so that the text comes later will not be bound with this line split rule.</p>
<p>This gives an easy and concise way to print even most complex structures.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>A Theory of Type Polymorphism in Programming – Robin Milner<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Code examples taken from <a href="http://vimeo.com/61576198">Dependently Typed Functional Programming with Idris</a> course slides.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.73.3971">Notes on HM(X)</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="http://gallium.inria.fr/~fpottier/wallace/">Wallace</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Choi, Aktemur, Yi, Tatsuta: Static Analysis of Multi-Staged Programs via Unstaging Translation<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Kim, Yi, Calcagno: A Polymorphic Modal Type System for List-Like Multi-Staged Languages<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>

</feed>
