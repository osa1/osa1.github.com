<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-04-25T00:00:00Z</updated>
    <entry>
    <title>Weirdest bug</title>
    <link href="http://osa1.net/posts/2013-04-25-weirdest-bug.html" />
    <id>http://osa1.net/posts/2013-04-25-weirdest-bug.html</id>
    <published>2013-04-25T00:00:00Z</published>
    <updated>2013-04-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Haskell implementation of Shen is stuck because of some weird bugs. I think most of them are related with lazy io.</p>
<p>Weird bug #1: Print functions print not when they’re called, but at some later time. This causes Shen repl to take some input, and then print prompt line:</p>
<pre><code>(+ 1 2)
(0.0-) 3.0</code></pre>
<p>Shen REPL is defined in KLambda source, so we can know it’s implemented correctly. Also, KLambda REPL I wrote in Haskell doesn’t have this kind of problem(it prints the prompt, then gets user input).</p>
<p>Weird bug #2: <strong>REMOVED.</strong> When read this post second time after several hours, I realized his same as <em>Weird bug #3</em>. Writing really helps :-)</p>
<p>Weird bug #3: For some reason, <code>shen.read-file-as-bytelist-help</code> still doesn’t end even after printing the bytes. That’s because even if <code>read-byte</code>s return value is <code>-1</code>, <code>else</code> part of the conditional is taken. I have no idea why. Here’s a demonstration:</p>
<p>The file <code>empty.txt</code> is empty:</p>
<pre><code>➜  cat empty.txt
➜</code></pre>
<p>And reading it with <code>read-byte</code> Shen function returns correct value:</p>
<pre><code>➜ shenhs

Shen 2010, copyright (C) 2010 Mark Tarver
www.shenlanguage.org, version 9.2
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan

(= -1 (let stream (open file &quot;empty.txt&quot; in) (read-byte stream)))
(1.0-) true</code></pre>
<p>But reading file with <code>read-file</code> gets stuck in an infinite tail-call:</p>
<pre><code>(read-file &quot;empty.txt&quot;)
(2.0-) ^C</code></pre>
<p>For debugging purposes, I changed <code>shen.read-file-as-bytelist-help</code> and put some prints:</p>
<pre><code>(defun shen.read-file-as-bytelist-help (V2003 V2004 V2005)
  (cond ((= -1 V2004)
         (do
           (pr &quot;-1&lt;nop&gt;&quot; (value *stoutput*))
           V2005))
        (true
         (do
           (pr (str (= -1 V2004)) (value *stoutput*))
           (do
             (pr &quot;&lt;ok&gt;&quot; (value *stoutput*))
             (shen.read-file-as-bytelist-help V2003 (read-byte V2003) (cons V2004 V2005)))))))</code></pre>
<p>It prints <code>false&lt;ok&gt;</code> forever. Now this is strange because as I showed above, <code>read-byte</code> returns <code>-1</code> so <code>(= -1 V2004)</code> should have returned <code>true</code>. Here’s an even more interesting observation:</p>
<pre><code>(shen.read-file-as-bytelist-help -1 -1 -1)
(0.0-) false&lt;ok&gt;TypeError {foundTy = TyNum, expectedTy = TyStream}</code></pre>
<p>Passing <code>-1</code> as <code>V2004</code> still prints <code>false</code>. Now you can think that the problem is at conditionals, but it works fine hundreds of times until the program comes to this function call.</p>
<hr />
<p><strong>UPDATE:</strong> I solved the <code>read-file</code> bug. That was because the lexer was reading <code>-1</code> as a symbol, not a number. You can see the commit <a href="https://github.com/osa1/Shen.hs/commit/8092d2eef874dabc4a706a96f45ef6a3aab460a7">here</a>. (lexer may still have bugs though, it’s not well-tested, maybe I should take my time and read Shen specification in detail.</p>]]></summary>
</entry>
<entry>
    <title>An interesting case of closures: is closed-over variable reference or value?</title>
    <link href="http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html" />
    <id>http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html</id>
    <published>2013-04-24T00:00:00Z</published>
    <updated>2013-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I discovered an interesting behavior of JavaScript’s closures while writing a nodejs script.</p>
<p>This behavior is pretty easy to observe when writing a nodejs application, because of it’s callback-based asynchronous nature, you’ll be writing callbacks all the time. Let’s say I’ll create a callback function which uses a variable defined in outer-scope, then do some actions using that variable:</p>
<pre class="sourceCode JavaScript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>(<span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
    });
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>What I expect from this program is to print <code>foo\nbar\nbaz</code>, but it instead prints <code>baz\nbaz\nbaz</code>. It’s like <code>say</code> variable used inside the callback is a reference and not a value. But it’s still strange because the reference should be local to for-loop’s body, so each <code>var say = ...</code> assignment should create a separate reference.</p>
<p>I find this behavior very counterintuitive. Before moving to solutions to fix this, I tried same program with several other languages.</p>
<p>Python also has this problem<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback():
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>This prints same wrong output as with JavaScript.</p>
<p>Lua, my favorite dynamic language, does great:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">callbacks</span> <span class="ot">=</span> <span class="ot">{}</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">({</span> <span class="st">&quot;foo&quot;</span><span class="ot">,</span> <span class="st">&quot;bar&quot;</span><span class="ot">,</span> <span class="st">&quot;baz&quot;</span> <span class="ot">})</span> <span class="kw">do</span>
  <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">,</span> <span class="kw">function</span> <span class="ot">()</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;say &quot;</span> <span class="ot">..</span> <span class="kw">v</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="kw">end</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">)</span> <span class="kw">do</span>
  v<span class="ot">()</span>
<span class="kw">end</span></code></pre>
<p>It prints <code>foo\nbar\nbaz</code> as expected. Trying this in functional languages may be pointless, since variables are actually not <em>variables</em>(they’re immutable), but it may be still useful for demonstration purposes, here’s the Haskell code that works as expected:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

main <span class="fu">=</span> <span class="fu">sequence_</span> callbacks
  <span class="kw">where</span> callbacks <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">putStrLn</span> <span class="fu">.</span> (<span class="st">&quot;say &quot;</span> <span class="fu">++</span> )) [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]</code></pre>
<p>I’ll show how to get JavaScript’s behavior in languages that handle this right, and in Haskell it’s harder to get this behavior because we will need to use reference cells explicitly.</p>
<p>I think in Python it’s more understandable, because it doesn’t have any scope declarations. ie. we can’t reason about <code>say</code> variable’s scope by the look of it. In JavaScript, we have <code>var</code> keyword that indicates a new variable is created in the scope. But it still works wrong.</p>
<p>Indeed, in JavaScript, the worst language ever, <code>var</code> keyword is just like any other strange JavaScript feature and works in an unexpected way:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">for</span> (<span class="kw">var</span> v <span class="kw">in</span> [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ]) { <span class="ot">console</span>.<span class="fu">log</span>(v); }
<span class="dv">0</span>
<span class="dv">1</span>
<span class="dv">2</span>
&gt; v
<span class="st">&quot;2&quot;</span></code></pre>
<p>So one explanation of this behavior may be this: In Python, we don’t know the scope of variable and it looks like it’s global. So in closure, it works like a reference. And in JavaScript, <code>var</code> keyword is simply broken(and also variable inside closure works like reference).</p>
<h1 id="fixing-it">Fixing it</h1>
<p>Let’s fix that in JavaScript and Python.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>((<span class="kw">function</span> (say) {
      <span class="kw">return</span> <span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
      }
    })(say));
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>Here we’re creating a new scope with function(remember the JavaScript module pattern?), and then passing <code>say</code> variable to it. This guarantees that we have <code>say</code> variable local to the function. Then in callback returned by wrapper function, we have a reference just like before, but it’s not shared with any other functions.</p>
<p>In Python, there’s a cleaner way to do same thing:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback(say=say):
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>Here the parameter is passed implicitly. (to me it’s still very strange and it shouldn’t be working, but for now I’ll just keep this post short)</p>
<h1 id="breaking-it">Breaking it</h1>
<p>Let’s have JavaScript’s behavior in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Data.IORef

printFromRef r <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">=&lt;&lt;</span> readIORef r

mkCallbacks (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
    ref <span class="ot">&lt;-</span> newIORef w
    r   <span class="ot">&lt;-</span> iter ref ws
    <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> r
  <span class="kw">where</span> iter ref []     <span class="fu">=</span> <span class="fu">return</span> []
        iter ref (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
          writeIORef ref w
          cs <span class="ot">&lt;-</span> iter ref ws
          <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> cs

main <span class="fu">=</span> <span class="kw">do</span>
  callbacks <span class="ot">&lt;-</span> mkCallbacks [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]
  <span class="fu">sequence_</span> callbacks</code></pre>
<p>The reason this code is that long is because we need to create and pass references explicitly.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Calling this behavior <em>problem</em> may be a bit wrong, maybe it’s just a design decision. To me it’s a <em>problem</em> because this behavior is really counterintuitive.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>On typing dynamic langs</title>
    <link href="http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html" />
    <id>http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html</id>
    <published>2013-04-19T00:00:00Z</published>
    <updated>2013-04-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://marijnhaverbeke.nl/blog/tern.html">This excellent post</a> on Tern’s internals reminded me of why I lost interest of my statically typed Lua project.</p>
<p>I lost my interest in a program exponentially with the amount of hacky solutions it involves.</p>
<p>I love Lua, it’s so simple but it is so powerful at the same time, without having any quirks most other dynamic languages have. But when it comes developing a type inference system for such a dynamic language, the result will have to contain a lot of hacks.</p>
<p>Here’s a quote from Tern post, which explains handling dynamically extending objects:</p>
<blockquote>
<p>And now we’re off into dodgy hack land. In order to meet this challenge, Tern uses a special treatment for for/in loops that appear to be copying properties. When it encounters them, it assumes that the properties from the source object will be copied to the target object. It ignores control flow (conditionals and such) and simply copies all properties.</p>
</blockquote>
<p>Similar situation is applied to Lua and this is where I dropped my project. Basically, there is no way to give a type to an object without actually running the program to the point where completion is needed. But even then you can’t have completely correct type information because for instance, you may have a different object in second iteration of loop but your type inference system would be only run it for one iteration. Still, I think running a program in an isolated environment to the point where enough type information is acquired is the best way to infer types in dynamic languages.</p>
<p>Accepting having a subset of Lua and forbidding object extensions in run-time is not a solution because then you can’t even use tables as, well, tables, rather than objects.</p>
<p>The obvious solution is creating a new syntax for defining objects. That syntax should be allowed only in top-level of a file, ie. you can’t use object definition syntax inside of a function.</p>
<p>But then a new language that is not Lua would be invented. I deliberately wanted to avoid this situation because in my opinion, it’s slightly missing the point of that kind of languages. I don’t like CoffeeScript’s additional compile step to my workflow. One nice property of dynamic languages is that we don’t have any visible intermediate steps between writing the source code and running it. All intermediate steps(parsing, compiling to some kind of byte-code, like Python does) are completely hidden to programmer.</p>
<p>Maybe the problem is that I’m looking for a perfect solution which does not exist in reality. I’m not sure how can I overcome this problem, I don’t want to work on programs full of hacks in my free time(well, I don’t want to work on this kind of programs in <em>any</em> time, but doing that as a hobby is more unbearable).</p>]]></summary>
</entry>
<entry>
    <title>THREE.js axis helper</title>
    <link href="http://osa1.net/posts/2013-04-17-THREEjs-axis-helper.html" />
    <id>http://osa1.net/posts/2013-04-17-THREEjs-axis-helper.html</id>
    <published>2013-04-17T00:00:00Z</published>
    <updated>2013-04-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m using <a href="http://threejs.org">THREE.js</a> for a project I’m working on. This is my first experience programming a 3D environment and I’m having hard times wrapping my head around 3D coordinate system.</p>
<p>So I wrote a helper function that draws axis arrows to the scene center to help me see how to translate/rotate my objects.</p>
<pre class="sourceCode coffee"><code class="sourceCode coffee">drawAxisHelpers <span class="kw">=</span> <span class="fu">(params = {}) -&gt;</span>
    params<span class="kw">.</span>radius <span class="kw">=</span> params<span class="kw">.</span>radius <span class="kw">||</span> <span class="fl">0.05</span>
    params<span class="kw">.</span>height <span class="kw">=</span> params<span class="kw">.</span>height <span class="kw">||</span> <span class="dv">2</span>
    params<span class="kw">.</span>scene  <span class="kw">=</span> params<span class="kw">.</span>scene  <span class="kw">||</span> scene

    arrowGeometry <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.CylinderGeometry</span> <span class="dv">0</span><span class="kw">,</span> <span class="dv">2</span> <span class="kw">*</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">5</span>

    xAxisMaterial <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.MeshBasicMaterial</span> color<span class="kw">:</span> <span class="dv">0xFF0000</span>
    xAxisGeometry <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.CylinderGeometry</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>height
    xAxisMesh     <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.Mesh</span> xAxisGeometry<span class="kw">,</span> xAxisMaterial
    xArrowMesh    <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.Mesh</span> arrowGeometry<span class="kw">,</span> xAxisMaterial
    xAxisMesh<span class="kw">.</span>add xArrowMesh
    xArrowMesh<span class="kw">.</span>position<span class="kw">.</span>y <span class="kw">+=</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">2</span>
    xAxisMesh<span class="kw">.</span>rotation<span class="kw">.</span>z  <span class="kw">-=</span> <span class="dv">90</span> <span class="kw">*</span> <span class="ot">Math</span><span class="kw">.</span>PI <span class="kw">/</span> <span class="dv">180</span>
    xAxisMesh<span class="kw">.</span>position<span class="kw">.</span>x  <span class="kw">+=</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">2</span>
    params<span class="kw">.</span>scene<span class="kw">.</span>add xAxisMesh

    yAxisMaterial <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.MeshBasicMaterial</span> color<span class="kw">:</span> <span class="dv">0x00FF00</span>
    yAxisGeometry <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.CylinderGeometry</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>height
    yAxisMesh     <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.Mesh</span> yAxisGeometry<span class="kw">,</span> yAxisMaterial
    yArrowMesh    <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.Mesh</span> arrowGeometry<span class="kw">,</span> yAxisMaterial
    yAxisMesh<span class="kw">.</span>add yArrowMesh
    yArrowMesh<span class="kw">.</span>position<span class="kw">.</span>y <span class="kw">+=</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">2</span>
    yAxisMesh<span class="kw">.</span>position<span class="kw">.</span>y  <span class="kw">+=</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">2</span>
    params<span class="kw">.</span>scene<span class="kw">.</span>add yAxisMesh

    zAxisMaterial <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.MeshBasicMaterial</span> color<span class="kw">:</span> <span class="dv">0x0000FF</span>
    zAxisGeometry <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.CylinderGeometry</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>radius<span class="kw">,</span> params<span class="kw">.</span>height
    zAxisMesh     <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.Mesh</span> zAxisGeometry<span class="kw">,</span> zAxisMaterial
    zArrowMesh    <span class="kw">=</span> <span class="kw">new</span> <span class="dt">THREE.Mesh</span> arrowGeometry<span class="kw">,</span> zAxisMaterial
    zAxisMesh<span class="kw">.</span>add zArrowMesh
    zAxisMesh<span class="kw">.</span>rotation<span class="kw">.</span>x  <span class="kw">+=</span> <span class="dv">90</span> <span class="kw">*</span> <span class="ot">Math</span><span class="kw">.</span>PI <span class="kw">/</span> <span class="dv">180</span>
    zArrowMesh<span class="kw">.</span>position<span class="kw">.</span>y <span class="kw">+=</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">2</span>
    zAxisMesh<span class="kw">.</span>position<span class="kw">.</span>z  <span class="kw">+=</span> params<span class="kw">.</span>height <span class="kw">/</span> <span class="dv">2</span>
    params<span class="kw">.</span>scene<span class="kw">.</span>add zAxisMesh</code></pre>
<p><code>drawAxisHelpers</code> function takes named parameters, all optional. <code>radius</code> and <code>height</code> are for sizes of arrows, and <code>scene</code> is the scene object to draw arrows. When isn’t provided, a global <code>scene</code> object is used.</p>
<p>Here’s an example: (you can zoom in/out with mouse scroll, move around with left/right clicks)</p>
<canvas id="target" width=600 height=600 style="background-color: #39342E; float: center;"></canvas>

<p>In this example I used <code>OrbitAndPanControls</code> class to enable zooming/moving around with mouse. I copied this class from Udacity’s ‘CS291 - Interactive 3D Rendering’ course’s examples. You can see this post’s source to learn more.</p>
<script src="/js/three.min.js"></script>
<script src="/js/OrbitAndPanControls.js"></script>
<script type="text/javascript">
  // Generated by CoffeeScript 1.6.2
  var camera, cameraControls, canvas, clock, drawAxisHelpers, render, renderer;

  canvas = document.getElementById("target");

  renderer = new THREE.WebGLRenderer({
    canvas: canvas
  });

  renderer.setSize(canvas.width, canvas.height);

  clock = new THREE.Clock();

  window.scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

  cameraControls = new THREE.OrbitAndPanControls(camera, renderer.domElement);

  cameraControls.target.set(0, 0, 0);

  drawAxisHelpers = function(params) {
    var arrowGeometry, xArrowMesh, xAxisGeometry, xAxisMaterial, xAxisMesh, yArrowMesh, yAxisGeometry, yAxisMaterial, yAxisMesh, zArrowMesh, zAxisGeometry, zAxisMaterial, zAxisMesh;

    if (params == null) {
      params = {};
    }
    params.radius = params.radius || 0.05;
    params.height = params.height || 2;
    params.scene = params.scene || scene;
    arrowGeometry = new THREE.CylinderGeometry(0, 2 * params.radius, params.height / 5);
    xAxisMaterial = new THREE.MeshBasicMaterial({
      color: 0xFF0000
    });
    xAxisGeometry = new THREE.CylinderGeometry(params.radius, params.radius, params.height);
    xAxisMesh = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
    xArrowMesh = new THREE.Mesh(arrowGeometry, xAxisMaterial);
    xAxisMesh.add(xArrowMesh);
    xArrowMesh.position.y += params.height / 2;
    xAxisMesh.rotation.z -= 90 * Math.PI / 180;
    xAxisMesh.position.x += params.height / 2;
    params.scene.add(xAxisMesh);
    yAxisMaterial = new THREE.MeshBasicMaterial({
      color: 0x00FF00
    });
    yAxisGeometry = new THREE.CylinderGeometry(params.radius, params.radius, params.height);
    yAxisMesh = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
    yArrowMesh = new THREE.Mesh(arrowGeometry, yAxisMaterial);
    yAxisMesh.add(yArrowMesh);
    yArrowMesh.position.y += params.height / 2;
    yAxisMesh.position.y += params.height / 2;
    params.scene.add(yAxisMesh);
    zAxisMaterial = new THREE.MeshBasicMaterial({
      color: 0x0000FF
    });
    zAxisGeometry = new THREE.CylinderGeometry(params.radius, params.radius, params.height);
    zAxisMesh = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
    zArrowMesh = new THREE.Mesh(arrowGeometry, zAxisMaterial);
    zAxisMesh.add(zArrowMesh);
    zAxisMesh.rotation.x += 90 * Math.PI / 180;
    zArrowMesh.position.y += params.height / 2;
    zAxisMesh.position.z += params.height / 2;
    return params.scene.add(zAxisMesh);
  };

  drawAxisHelpers();

  camera.position.z = 5;

  render = function() {
    var delta;

    delta = clock.getDelta();
    cameraControls.update(delta);
    requestAnimationFrame(render);
    return renderer.render(scene, camera);
  };

  render();
</script>




]]></summary>
</entry>
<entry>
    <title>Internship report - type inference, row polymorphism, and multi-stage programming</title>
    <link href="http://osa1.net/posts/2013-04-15-internship.report.html" />
    <id>http://osa1.net/posts/2013-04-15-internship.report.html</id>
    <published>2013-04-15T00:00:00Z</published>
    <updated>2013-04-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is the report of my 3.5-month internship fulfilled at <a href="http://ozyegin.edu.tr/">Ozyegin University</a> under <a href="http://faculty.ozyegin.edu.tr/aktemur/">Prof. Baris Aktemur</a>’s supervision.</p>
<p>I wrote this report as a short and informal introduction to the topics I worked on in my internship, and since I know nobody will ever read this internship report, I decided publishing it in my blog with hoping someone benefit from it.</p>
<p>A note before reading: Things went in an unexpected way shortly after I started writing the report: I got bored. So each chapter got shorter and shorter, leaving tons of interesting and important stuff unmentioned. Sorry for that.</p>
<h2 id="contents">Contents:</h2>
<ul>
<li>Introduction to type systems and polymorphism</li>
<li>Hindley-Damas-Milner type system and type inference</li>
<li>Row polymorphism</li>
<li>Multi-stage porgramming</li>
<li>Our work - extending multi-stage language with subtyping and Wallce: a module type inference system</li>
</ul>
<h1 id="introduction-to-type-systems-and-polymorphism">Introduction to type systems and polymorphism</h1>
<p>As far as software engineering concerned, a type system is a static analysis method that aims to prove a program ‘won’t go wrong’<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>, meaning that the program will not crash at runtime. Static type checking can also be used for some compiler optimisations. Also, some languages have mechanisms for dispatching on types.</p>
<p>Type systems (in this text, this term is used as ‘static type systems’) do that by inspecting program terms and proving some properties and relations among them. This work is done before run-time, and most type information can be deleted so that it won’t cause any runtime costs.</p>
<p>For most type systems, process of type checking is ‘syntactic’. This means two things; first, the type checker only needs program text and it doesn’t need any information that can only be obtained at run-time. And second, type checking a program term only depends on type checking subterms of that program. These two properties also give us a somewhat simple way to express type checking on terms in a symbolic and formal way.</p>
<p>Type systems are ‘conservative’, meaning they will reject some ‘correct’ programs. A correct program means a program that won’t crash at runtime. For instance, this program(in OCaml syntax):</p>
<pre><code>if true then 1 else 42(5)</code></pre>
<p>is actually correct, and it can be given the type <code>int</code> (since we know it always evaluates to <code>1</code>, which has type <code>int</code>), but almost all type systems reject this program because of the ‘else’ branch expression <code>42(5)</code> that is ill-typed.</p>
<p>Research on type systems aims to have more “powerful” type systems. Being more powerful means accepting <em>more</em> correct programs and also being able to encode more <em>invariants</em> in the type system, so that more <em>incorrect</em> programs will be rejected.</p>
<p>Being wrong and being incorrect is used with different meanings in this text: a wrong program will crash at run-time, but incorrect program will result with a wrong answer. For instance, a wrong implemented algorithm may not be <em>wrong</em>, but it’s <em>incorrect</em>. So it will work fine, but return a wrong result.</p>
<p>As an instance of accepting more correct programs, this code is not typeable under simply-typed lambda calculus:</p>
<pre><code>let id a = a in
(id 1, id true)</code></pre>
<p>But it’s well-typed in polymorphic lambda calculus. As a second example, this is not typeable under polymorphic lambda calculus:</p>
<pre><code>add5 : float -&gt; float
...
add5 10</code></pre>
<p>Here <code>10</code> has type <code>int</code>, so we can’t apply it to a function that expects a float value. Type systems with subtyping overcome this problem by defining a common supertype of types. In our case, <code>float</code> is already a supertype of <code>int</code>, so this example is well-typed in the presence of subtyping.</p>
<p>As an example of being able to encode more <em>invariants</em> in the type system, let’s look to the type of a sort function from a dependently-typed programming language:<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<pre><code>sort : List Int -&gt; List Int</code></pre>
<p>This type can be inhabited with some wrong functions. For instance, a function that takes a list and returns an empty list will have this type, just like <em>reverse</em> and <em>shuffle</em> functions.</p>
<pre><code>sort : Vect Int n -&gt; Vect Int n</code></pre>
<p>This type has a invariant encoded in it: length of it’s input and output should be equal. This means our first function that takes a list and returns an empty list now can’t be inhabited by this type. We have a more precise type.</p>
<pre><code>sort : (xs : Vect Int n) -&gt;
       (ys : Vect Int n ** Permutation xs ys)</code></pre>
<p>This type is even more precise, a function that takes a list and returns a list with some random elements can’t get this type.</p>
<p>One problem with more expressive type systems is that there may be some types that can’t be inferred by type system, but the type can be given by programmer. In some cases the type system may not be able to prove that an expresion has the denoted type. In case of dependently typed languages, programmer is required to give some proofs to the type checker. But even in much simpler type systems programmer may have to give some types manually.</p>
<p>–</p>
<p>A word about the terms ‘polymorphism’ and ‘subtyping’: Polymorphic type systems can give multiple types to a single piece of code, thus providing reuse. This is done by giving the code a general type and then creating instances of type depending on the use. As an example, let us start with a simple OCaml function, <code>fst</code>.</p>
<p><code>fst</code> returns first element of any pair, it has the type <code>('a * 'b) -&gt; 'a</code> (the language of types is described in next section). This means for any pair with type of <code>('a * 'b)</code>, <code>fst</code> will return value with type of <code>'a'</code>. When applied on a value typed <code>(bool * int)</code> it will return <code>bool</code>, and when applied on a value typed <code>( (string * bool) * string )</code> it will return <code>(string * bool)</code> etc.</p>
<p>Subtyping defines a relationship that if a type <code>t1</code> is subtype of a type <code>t2</code>, this means that <code>t1</code> can be given to context where <code>t2</code> is expected. This usually means <code>t1</code> already has all properties of <code>t2</code>.</p>
<p>For instance, a record with fields <code>a: int, b: bool</code> can be passed to a function that expects a parameter typed <code>{a: int}</code>. The same effect can also be obtained by row polymorphism, which we’ll see in it’s own chapter.</p>
<p>Subtyping is generally divided into two branches; nominal and structural subtyping. Structural subtyping relation is syntactic, ie. type system can decide if one type is subtype of another type just by inspecting their forms (like in the example above). Nominal subtyping requires definition from the programmer or a pre-defined type lattice from the language designer, ie. there is no way for a type system to infer subtyping relation between int and float types if this relation is not built-in; similarly a Square is not a subtype of Shape unless the programmer manually defines this subtyping relation.</p>
<h1 id="hindley-damas-milner-type-system-and-type-inference">Hindley-Damas-Milner type system and type inference</h1>
<p>Manually giving types to program terms may be impractical, since programs can contain hundreds of definitions. Type inference is the process of deriving types for program terms. As an example of language with type inference, OCaml programs with no type annotations can be type-inferred and checked. This results in more concise programs. Type annotations can still be given for documentation or error reporting purposes.</p>
<p>Hindley-Damas-Milner(abbreviated as HM henceforth) type system is likely to be the most widely-used type system. It has a great property that if a term is typeable under HM type system, HM inference algorithm will result with a most general type (also called ‘principal type’).</p>
<p>HM is the system lies behind statically typed functional languages like the ML family of languages and Haskell.</p>
<p>In HM, a polymorphic type is specified as a ‘type scheme’. A type scheme is a type with universally quantified type variables. Type system’s job then is to give terms of a program type schemes so that for each instantiation of the scheme, the result is well-typed.</p>
<p>HM type system produces polymorphic types (type schemes) only for some expressions, in the case of ML family of languages, it’s the <code>let</code> expression. A <code>let</code> expression binds a name to an expression and introduces a scope that the name is bound to the expression. HM type system gives a most general type to that name, and so every use of this name in the scope is valid if a valid instantiation of the required type can be obtained from the type scheme it’s given.</p>
<pre><code>let id a = a in
(id 1, id true)</code></pre>
<p>Here the <code>id</code> function is given the type scheme of <code>forall a. a -&gt; a</code>. The variable <code>a</code> is called to be ‘universally quantified’. In <code>id 1</code>, <code>id</code>s type is instantiated from type scheme as <code>int -&gt; int</code> by substituting <code>a</code> with <code>int</code>. Same operation is done in <code>id true</code> and <code>id</code> is given the type <code>bool -&gt; bool</code>. So this term is well-typed under HM.</p>
<p>Inferring a type scheme is done by assigning fresh type variables to terms with unknown types and unifying this variables with concrete types while type checking rest of the term. At the end, types that are not unified with concrete types will remain polymorphic.</p>
<p>This is also called let-polymorphism because polymorphic type (type scheme) generation is only done in let expressions.</p>
<p>Note that not all names defined in a let expression can be generalized. As an example, see this classic example:</p>
<pre><code>let c = ref (fun x -&gt; x) in
c := (fun x -&gt; x+1);
!c true</code></pre>
<p>Giving <code>c</code> the type <code>forall a. ('a -&gt; 'a) ref</code> (in OCaml syntax) makes this example well-typed, which is wrong. Instead, type system should have given the type <code>( '_a -&gt; '_a) ref</code>, then during the type checking <code>c := (fun x -&gt; x + 1)</code>, <code>_a</code> should be unified with <code>int</code>. Note that since <code>('_a -&gt; '_a) ref</code> doesn’t quantify the variable <code>a</code>, after this point, type of <code>c</code> will be <code>(int -&gt; int_ ref</code>, so applying it a bool value will fail.</p>
<p>Let-polymorphism has some interesting properties. It’s simple, but it still accepts realistic programs. And even though its worst-case efficiency is exponential on the size of input program, most realistic programs don’t hit the worst case and have linear time complexity. For this reason, let-polymorphism is named as the ‘sweet-spot’ of type systems.</p>
<p>Another great property of HM type system is that it can be reduced to constraint generation and solving steps. These separate steps lead to a more modular algorithm, with changeable constraint generators and solvers. HM(X)<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> is a formalization of this observation.</p>
<h1 id="row-polymorphism">Row polymorphism</h1>
<p>Rows are a way to encode ‘labeled sums’. A sum type is a type that contains some other types; for example, a pair is a sum type of two other types (<code>(int * bool)</code> is a sum type with <code>int</code> and <code>bool</code> parts).</p>
<p>A ‘labeled sum’ is a sum type, but with labels. For instance:</p>
<pre><code>type error = { code : int; reason : string }</code></pre>
<p>is just like an <code>(int * string)</code> type, but it has labels for subparts. There are severals ways to encode labeled sums as rows. Here’s one way:</p>
<pre><code>type error = { code : abs int; reason : abs int; rho[code,int] }</code></pre>
<p>This syntax is similar to Rémy’s, which was also used in our project. Last <code>rho</code> is the polymorphic part, it means that an error type is a row type with <code>code</code> and <code>reason</code> fields with gives types, but with a polymorphic part that can be unified with any record except the fields labeled with <code>code</code> or <code>int</code> (some systems accept field repetition, like in Daan Leijen’s “Extensible records with scoped labels”).</p>
<p>Row polymorphism gives us a subtyping-like effect. For example, this function:</p>
<pre><code>fun x -&gt; x.a + 1</code></pre>
<p>Now has the type <code>{ a : int; rho[a] } -&gt; int</code> and we can apply it to the record <code>{ x : some_type; y : some_other_type; a : int; ... }</code>, like in structural subtyping.</p>
<p>The way row polymorphism and structural subtyping accept this term are completely different though. In row polymorphism, parameter type <code>{a : int; rho[a] }</code> is being unified with <code>{ x : some_type; y : some_other_type; a : int; ... }</code>, so parameter type of function is actually getting more specialized. On the other hand, in subtyping, extra fields of actual parameter is being forgotten, like casting a type to it’s super type.</p>
<p>More words will be said about row polymorphism in later sections.</p>
<h1 id="multi-stage-programming">Multi-stage programming</h1>
<p>Multi-stage programming languages makes distinguished evaluation stages in run-time. Some part of the program can be generated depending on some user input.</p>
<p>Evaluation is done at stage 0. A program generated in staged 0 has stage 1, program generated in stage 1 has stage 2 etc. This notion of separate stages has some semantic effects. Each stage has a scope, but most systems offer a mechanism to lift a value from a lower stage.</p>
<p>Being able to generate code in run-time gives us a way to specialize algorithms depending on user input. Let’s look at a classic example:</p>
<pre><code>let rec pow_body_gen n = 
  if n = 0 then &lt;1&gt; 
  else &lt;a * ~(pow_body_gen (n-1))&gt;;;</code></pre>
<p><code>pow_body_gen</code> takes an integer <code>n</code> and returns the code <code>a * a * a * ... * 1</code>, a to the power of n. With the help of this function, we can generate a specialized function <code>power_five</code> which raises an integer to the power 5, but without running a loop or recursively calling a function:</p>
<pre><code>let rec power_five a = &lt;let a = ~lift(a) in ~(pow_body_gen 5)&gt;;;</code></pre>
<p>For example, output of <code>power_five 12</code> in our interpreter is <code>&lt;let a = 12 in (a * (a * (a * (a * (a * 1)))))&gt;</code>. This is a code value. Notice the <code>a</code> value, which is multiplied by itself, 5 times.</p>
<p>To actually run this code, we can call <code>run</code>(stage primitives will be explained shortly):</p>
<pre><code>&gt; run(power_five 12);;
248832</code></pre>
<p>Our multi-stage language has three primitives for staging operations: angle brackets indicate a staged expression, contents of staged expression will be run in stage <code>n+1</code>, where n is the current stage level. Tilde (~) ‘unboxes’ a staged expression, expressions indicated with a unboxing operator will be run in stage <code>n-1</code>. Unboxing operator can only be used in stages n &gt; 0. Finally, <code>run</code> primitive is used to run a closed code value at stage 0.</p>
<p>Note that code values can be open, but only closed code values can be run. Our <code>pow_body_gen</code> function returns a code value with an unbound variable <code>a</code>, then in <code>power_five</code>, we define <code>a</code> in stage 1, and by unboxing <code>pow_body_gen 5</code>, we actually generate a bigger code value, with <code>a</code> defined. Now our code value is closed, so it can be run.</p>
<p>There is also a relation between multi-stage programming and partial evaluation, but this is out of this text’s scope.</p>
<h1 id="our-work">Our work</h1>
<p>Wallace is a type inference library, supporting subtyping. “Its goal is to serve as a plug-in component in the design of a constraint-based type-checker, regardless of the programming language being analyzed.”<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup></p>
<p>We used Wallace to get subtyping in our language. Wallace comes with an example language, called ‘toy’, which has extensible records built-in. For simplicity, instead of generating constraints for Wallace, we first translated our multi-stage language to record calculus. Translation to record calculus preserves semantics, but eliminates staged computations<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup>. Our record calculus is then translated to ‘toy’. ‘toy’ infers types for us, by generating and passing constraints to Wallace.</p>
<p>We then compared our type system with<sup><a href="#fn6" class="footnoteRef" id="fnref6">6</a></sup>. This expression:</p>
<pre><code>run((fun c -&gt; &lt;(let x = 1 in ~c, let y = 1 in ~c)&gt;) &lt;1&gt;);;</code></pre>
<p>is not typeable under polymorphic type system, but is well-typed in our system with subtyping. By mapping the calculated type back to our multi-stage language, we got subtyping in the multi-stage language for free.</p>
<p>Wallace is used as is, without any modifications. But we changed ‘toy’ language for our purposes. We first added some numerical types with subtyping relations. ‘toy’ had a problem that it was generalizing every let bindings, without value restriction. To overcome this problem, we added an extra lambda wrapper in the translator when value restriction is needed. Since our type system already had value restriction, it was trivial to apply the same test to check if an expression is expansive. Expansive expressions are those that may allocate new memory cells. Expansive expressions are not generalized.</p>
<p>Another problem with ‘toy’ language is that it doesn’t support toplevel declarations, and adding that wasn’t easy. To overcome this without any serious modifications in ‘toy’s source, we collected all well-typed toplevel expressions and declarations, and then generated a <code>let .. in ..</code> chain of toplevel declarations to give ’toy’ type checker. This means for every new toplevel phrase, ‘toy’ now type checks all old expressions too. This may not be efficient but works fine with our purposes, and it was easy to implement.</p>
<p>Implementing type inference: Implementing a type inference system is hard to do elegantly. One problem is already discussed in my blog (in Turkish)<sup><a href="#fn7" class="footnoteRef" id="fnref7">7</a></sup>. Every non-trivial type system requires types to be separated into kinds. After that, every type variable will also have kind information and it’s a type error to unify a type variable with wrong kinds. Type applications also checked with the help of kinds.</p>
<p>Kinds are generally checked at run-time. Type systems with kinds usually lead to a simpler type language. For instance, almost all types mentioned in this text can be represented by this simply type language (code taken from <sup><a href="#fn8" class="footnoteRef" id="fnref8">8</a></sup>) :</p>
<pre><code>type kind =
  | KStar                 (* kind of term types *)
  | KRow                  (* kind of row types *)
  | KArr of (kind * kind) (* kind of type constructors *)

type ty =
  | TCon of tycon     (* constant *)
  | TVar of tyvar     (* type variable *)
  | TApp of (ty * ty)
      (* type application, to be well-typed
         kind of first ty should be KArr (k2, k)
         and second ty should be k2 *)
and tyvar = (tyvarlink ref * kind)
and tyvarlink =
  | NoLink of id (* just a type variable *)
  | LinkTo of ty (* equated to a ty *)
and tycon = (id * kind) (* kind should be always KStar *)</code></pre>
<p>We decided to take a different path, instead of keeping kind information for every type, we created new type constructors for every type and then separating differently kinded type variables with different types. This lead us to this type language:</p>
<pre><code>type ty =
 | TInt
 | TBool
 | TUnit

 | TPair of ty * ty

 | TList of ty
 | TRef  of ty

 | TFun of ty * ty
 | TRec of tyrec
 | TVar of typevar

 | TBox of tyrec * ty

...

and typevar = (tyvarlink * int) ref
and tyvarlink = ty link

and fieldvar = (fieldvarlink * int) ref
and fieldvarlink = field link

and recvar = (recvarlink * int * IdSet.t) ref
and recvarlink = tyrec link</code></pre>
<p>We also needed a sum type for handling differently kinded type variables:</p>
<pre><code>and linkvar =
 | TV of typevar
 | FV of fieldvar
 | RV of recvar</code></pre>
<p>This also made our algorithms more complex, since we had more cases to handle.</p>
<p>This representation is not without any advantages though. For instance, writing a pretty-printer was very easy, because we could easily print a pair and a function or a list and a ref differently, even though they share similar structure, with simple pattern matching.</p>
<p>A note on pretty-printing: OCaml has a great pretty-printer library in stdlib. It’s simple but powerful at the same time, allowing printing most complex structures easily. It interprets some characters in input strings as boxes/spaces indicators etc. and formats the text. For instance, this code:</p>
<pre><code>printf &quot;@[&lt;hov 2&gt;~(&quot;; print_exp exp; printf &quot;)@]&quot;</code></pre>
<p>Here <code>@[&lt;hov 2&gt;</code> part creates a new “horizontal or vertical” box. This box has a property that when a line is split to two lines, every other newline pointers will also be split into separate lines. So contents of this box is either displayed as a single line, or separated from every newline pointers. Later, <code>print_exp exp;</code> part prints the expression inside the box. And lastly, `printf “)@]” closes the paren, then closes the box, so that the text comes later will not be bound with this line split rule.</p>
<p>This gives an easy and concise way to print even most complex structures.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A Theory of Type Polymorphism in Programming – Robin Milner<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Code examples taken from <a href="http://vimeo.com/61576198">Dependently Typed Functional Programming with Idris</a> course slides.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.73.3971">Notes on HM(X)</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://gallium.inria.fr/~fpottier/wallace/">Wallace</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Choi, Aktemur, Yi, Tatsuta: Static Analysis of Multi-Staged Programs via Unstaging Translation<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Kim, Yi, Calcagno: A Polymorphic Modal Type System for List-Like Multi-Staged Languages<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>http://osa1.net/rowlar-kindlar/<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>http://osa1.net/rowlar-kindlar/<a href="#fnref8">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Go channel examples ported to Haskell</title>
    <link href="http://osa1.net/posts/2013-04-08-go-ported-haskell.html" />
    <id>http://osa1.net/posts/2013-04-08-go-ported-haskell.html</id>
    <published>2013-04-08T00:00:00Z</published>
    <updated>2013-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been skimming over <a href="http://tour.golang.org/">gotour</a> recently. I think it’s great introduction to language; it’s short, but concise and it shows some of the interesting features of language.</p>
<p>Last part of the tour is about goroutines and channels. My concurrent programming experience is very limited, and since Haskell is my favorite language, I decided to port goroutine examples to Haskell as a learning exercise.</p>
<p>Any criticism would be appreciated.</p>
<h2 id="goroutines"><a href="http://tour.golang.org/#62">62 - Goroutines</a></h2>
<p>This is a very basic example of a program creating two threads and printing some strings.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent
<span class="kw">import</span> Control.Monad

<span class="ot">say ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
say s <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] <span class="fu">$</span> \ _ <span class="ot">-&gt;</span> <span class="kw">do</span>
  threadDelay <span class="dv">100000</span>
  <span class="fu">putStrLn</span> s

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  forkIO <span class="fu">$</span> say <span class="st">&quot;world&quot;</span>
  say <span class="st">&quot;hello&quot;</span></code></pre>
<h2 id="channels"><a href="http://tour.golang.org/#63">63 - Channels</a></h2>
<p>Simple channels example</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent

<span class="ot">sum&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Chan</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
sum&#39; ints chan <span class="fu">=</span> writeChan chan (<span class="fu">sum</span> ints)
<span class="co">-- alternative, `pointfree` style: </span>
<span class="co">-- sum&#39; = flip writeChan . sum</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> lst <span class="fu">=</span> [<span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="fu">-</span><span class="dv">9</span>, <span class="dv">4</span>, <span class="dv">0</span>]
  chan <span class="ot">&lt;-</span> newChan
  <span class="kw">let</span> (l1, l2) <span class="fu">=</span> <span class="fu">splitAt</span> (<span class="fu">floor</span> <span class="fu">$</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> lst) <span class="fu">/</span> <span class="dv">2</span>) lst
  forkIO <span class="fu">$</span> sum&#39; l1 chan
  forkIO <span class="fu">$</span> sum&#39; l2 chan
  x <span class="ot">&lt;-</span> readChan chan
  y <span class="ot">&lt;-</span> readChan chan
  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">unwords</span> [ <span class="fu">show</span> x, <span class="fu">show</span> y, <span class="fu">show</span> <span class="fu">$</span> x <span class="fu">+</span> y ]</code></pre>
<h2 id="buffered-channels"><a href="http://tour.golang.org/#64">64 - Buffered Channels</a></h2>
<p>This is where porting started getting tricky. Haskell channels are basically linked lists, and do not have length or size. In order to get a similar effect, I created a new channel type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent

<span class="co">-- Buffered chan</span>
<span class="kw">data</span> <span class="dt">BChan</span> a <span class="fu">=</span> <span class="dt">BChan</span> {<span class="ot"> chan ::</span> <span class="dt">Chan</span> a,<span class="ot"> size ::</span> <span class="dt">MVar</span> <span class="dt">Int</span>,<span class="ot"> limit ::</span> <span class="dt">Int</span> }

<span class="ot">newBChan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">BChan</span> a)
newBChan bufsize <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newChan
  bvar <span class="ot">&lt;-</span> newMVar <span class="dv">0</span>
  <span class="fu">return</span> <span class="dt">BChan</span>{chan<span class="fu">=</span>chan, size<span class="fu">=</span>bvar, limit<span class="fu">=</span>bufsize}

<span class="ot">readBChan ::</span> <span class="dt">BChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readBChan <span class="dt">BChan</span>{chan, size, limit} <span class="fu">=</span> <span class="kw">do</span>
  ret <span class="ot">&lt;-</span> readChan chan
  modifyMVar_ size <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="fu">return</span> (i<span class="fu">-</span><span class="dv">1</span>)
  <span class="fu">return</span> ret

<span class="ot">writeBChan ::</span> <span class="dt">BChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeBChan bchan<span class="fu">@</span><span class="dt">BChan</span>{chan, size, limit} val <span class="fu">=</span> <span class="kw">do</span>
  size&#39; <span class="ot">&lt;-</span> readMVar size
  <span class="kw">if</span> size&#39; <span class="fu">==</span> limit
    <span class="kw">then</span> <span class="kw">do</span>
      threadDelay <span class="dv">100000</span>
      writeBChan bchan val
    <span class="kw">else</span> <span class="kw">do</span>
      modifyMVar_ size <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="fu">return</span> (i<span class="fu">+</span><span class="dv">1</span>)
      writeChan chan val

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newBChan <span class="dv">2</span>
  writeBChan chan <span class="dv">1</span>
  writeBChan chan <span class="dv">2</span>

  v1 <span class="ot">&lt;-</span> readBChan chan
  <span class="fu">print</span> v1

  v2 <span class="ot">&lt;-</span> readBChan chan
  <span class="fu">print</span> v2</code></pre>
<p>Here one difference is that Haskell doesn’t fail with a “deadlock!!” error when an extra <code>writeBChan</code> operation is added(or one of them is removed), but just waits forever(like in a <em>real</em> deadlock :-P ). I wonder whether there is a way to get an exception like that, it’s awesome.</p>
<h2 id="range-and-close"><a href="http://tour.golang.org/#65">65 - Range and Close</a></h2>
<p>Same as above, Haskell channels are not working like Go channels. I had to simulate Go channels’ behavior.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns, MultiWayIf #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Control.Concurrent
<span class="kw">import</span> Control.Monad (liftM)

<span class="co">-- Closable channel</span>
<span class="kw">data</span> <span class="dt">CChan</span> a <span class="fu">=</span> <span class="dt">CChan</span> (<span class="dt">MVar</span> ([a], <span class="dt">Int</span>, <span class="dt">Bool</span>))

<span class="ot">newCChan ::</span> <span class="dt">IO</span> (<span class="dt">CChan</span> a)
newCChan <span class="fu">=</span> liftM <span class="dt">CChan</span> (newMVar ([], <span class="dv">0</span>, <span class="kw">False</span>))

<span class="ot">readCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)
readCChan (<span class="dt">CChan</span> mvar) <span class="fu">=</span> <span class="kw">do</span>
  (contents, size, closed) <span class="ot">&lt;-</span> takeMVar mvar
  <span class="kw">if</span> <span class="fu">|</span> size <span class="fu">==</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> <span class="fu">not</span> closed <span class="ot">-&gt;</span> <span class="kw">do</span>
         putMVar mvar (contents, size, closed)
         readCChan (<span class="dt">CChan</span> mvar)
     <span class="fu">|</span> size <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
         putMVar mvar (contents, size, closed)
         <span class="fu">return</span> <span class="kw">Nothing</span>
     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
         <span class="kw">let</span> r <span class="fu">=</span> <span class="fu">head</span> contents
         putMVar mvar (<span class="fu">tail</span> contents, size<span class="fu">-</span><span class="dv">1</span>, closed)
         <span class="fu">return</span> <span class="fu">$</span> <span class="kw">Just</span> r

<span class="ot">writeCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeCChan (<span class="dt">CChan</span> mvar) val <span class="fu">=</span> <span class="kw">do</span>
  (contents, size, closed) <span class="ot">&lt;-</span> takeMVar mvar
  <span class="kw">if</span> closed
    <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;writing to a closed chan&quot;</span>
    <span class="kw">else</span> putMVar mvar (val <span class="fu">:</span> contents, size<span class="fu">+</span><span class="dv">1</span>, closed)

<span class="ot">forChan_ ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
forChan_ cchan f <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> readCChan cchan
  <span class="kw">case</span> v <span class="kw">of</span>
    <span class="kw">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()
    <span class="kw">Just</span> v&#39; <span class="ot">-&gt;</span> f v&#39; <span class="fu">&gt;&gt;</span> forChan_ cchan f

<span class="ot">closeCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
closeCChan (<span class="dt">CChan</span> mvar) <span class="fu">=</span>
    modifyMVar_ mvar <span class="fu">$</span> \(contents, size, closed) <span class="ot">-&gt;</span> <span class="fu">return</span> (contents, size, <span class="kw">True</span>)

<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CChan</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
fib i chan <span class="fu">=</span> <span class="kw">do</span>
    iter i <span class="dv">0</span> <span class="dv">1</span>
    closeCChan chan
  <span class="kw">where</span> iter <span class="dv">1</span> x y <span class="fu">=</span> writeCChan chan x
        iter n x y <span class="fu">=</span> <span class="kw">do</span>
          writeCChan chan x
          iter (n<span class="fu">-</span><span class="dv">1</span>) y (x<span class="fu">+</span>y)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newCChan
  forkIO <span class="fu">$</span> fib <span class="dv">10</span> chan
  forChan_ chan <span class="fu">print</span></code></pre>
<p>This example still doesn’t quite work like Go code. This is because I used a stack instead of a queue. It should be trivial to fix this code though.</p>
<h2 id="select-and-67---default-selection"><a href="http://tour.golang.org/#66">66 - Select</a> and <a href="http://tour.golang.org/#67">67 - Default Selection</a></h2>
<p>Now this is hard. In 66, example program listens multiple channels, and runs some code when any of the channels is ready. If multiple channels are ready at the same time, one of them is chosen randomly. 67 is similar, only difference is when none of the channels are ready, some default action is taken.</p>
<p>I’m actually not sure if it’s implementable with Haskell Chans, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Concurrent-Chan.html#v:isEmptyChan"><code>isEmptyChan :: Chan a -&gt; IO Bool</code></a> is deprecated, and users are directed to TChans(I think it’s mostly same as a Chan, but working on STM).</p>
<p>Anyway, that’s it for now. I’ll go learn(pun intended) some STM, why we need them and what’s different about them, and then maybe I can implement this last two examples.</p>]]></summary>
</entry>
<entry>
    <title>Quick Box2d tips: Terrains, jump behavior and bodies with multiple shapes</title>
    <link href="http://osa1.net/posts/2013-03-06-box2dtips-1.html" />
    <id>http://osa1.net/posts/2013-03-06-box2dtips-1.html</id>
    <published>2013-03-06T00:00:00Z</published>
    <updated>2013-03-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After wasting enough time implementing my own half-baked physics engine and never having an efficiently implemented collision resolution code, I’ve decided to go on with <a href="https://www.love2d.org/wiki/love.physics">physics module</a> my game library of choice provides. It’s based on <a href="http://box2d.org/">Box2d</a> and the API is mostly the same.</p>
<p>My first try of using it was last weekend, me and my brother did a super short(12 hours) game jam, and I used Box2d for the first time. We finished our game, but it was so buggy that I don’t even mention it to anybody. Still, I learned so much about Box2d physics.</p>
<p>After several days, I could finally spare some time and fixed the bugs. I also wrote a simple demo app to demonstrate my points in this post. You can see the code <a href="https://gist.github.com/osa1/5102171">here</a>. It’s a full program, just paste it somewhere and run with Löve2d(the code about chained shapes are based one someone else’s code from Löve2d forums, I don’t remember whose code is this).</p>
<h2 id="implementing-terrains-with-box2d">Implementing terrains with Box2d</h2>
<p>Main bug source of my game was terrain implementation. It was reading the map info from a binary file and then creating lots of <a href="https://www.love2d.org/wiki/love.physics.newRectangleShape">RectangleShapes</a>. The problem with this approach was that other dynamic entities in my game was getting stuck between two RectangleShapes, even though each shape was in touch with other so there was no space between them. Later I realized that this behavior is actually <a href="http://www.box2d.org/manual.html#_Toc258082970">documented</a>(see <em>edge shapes</em> section).</p>
<p>There are two solution mentioned in Box2d manual. Now I’m using ChainShapes in my code and it’s working as expected. In the example game I linked above, you can see that my terrain is implemented with some artificial shapes:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">worldShape</span> <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newChainShape<span class="ot">(</span><span class="st">&quot;false&quot;</span><span class="ot">,</span>
    <span class="dv">80</span><span class="ot">,</span> <span class="ot">-</span><span class="dv">100</span><span class="ot">,</span>
    <span class="dv">80</span><span class="ot">,</span> <span class="dv">680</span><span class="ot">,</span>
    <span class="dv">120</span><span class="ot">,</span> <span class="dv">680</span><span class="ot">,</span>
    <span class="ot">...</span>
    <span class="dv">620</span><span class="ot">,</span> <span class="dv">680</span><span class="ot">,</span>
    <span class="dv">620</span><span class="ot">,</span> <span class="ot">-</span><span class="dv">100</span><span class="ot">)</span></code></pre>
<p>But still none of the dynamic bodies get stuck.</p>
<h2 id="bodies-with-multiple-shapes-and-jump-behavior">Bodies with multiple shapes and jump behavior</h2>
<p>Being able to bind multiple shapes to a body is just an awesome feature. It helps having a more accurate shape of an entity, and also having multiple fixtures mean you can change properties of each fixture and get a more accurate behavior of friction or some other things.</p>
<p>For instance, in my game, I wanted 2 things; 1) I don’t want my main character’s left and right side to have friction, so that it should slide without getting slowed down when left/right side is collided and 2) I want to check if my character is collided in bottom side.</p>
<p>Having multiple fixtures helped for both cases. My character consists of 4 shapes and fixtures:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">o</span><span class="ot">.</span><span class="kw">shapeLeft</span>   <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newCircleShape<span class="ot">(-</span><span class="dv">20</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">5</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">shapeTop</span>    <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newCircleShape<span class="ot">(</span><span class="dv">0</span><span class="ot">,</span> <span class="ot">-</span><span class="dv">50</span><span class="ot">,</span> <span class="dv">5</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">shapeRight</span>  <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newCircleShape<span class="ot">(</span><span class="dv">20</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">5</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">shapeBottom</span> <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newCircleShape<span class="ot">(</span><span class="dv">0</span><span class="ot">,</span> <span class="dv">50</span><span class="ot">,</span> <span class="dv">5</span><span class="ot">)</span>

<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureLeft</span>   <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newFixture<span class="ot">(</span><span class="kw">o</span><span class="ot">.</span><span class="kw">body</span><span class="ot">,</span> <span class="kw">o</span><span class="ot">.</span><span class="kw">shapeLeft</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureTop</span>    <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newFixture<span class="ot">(</span><span class="kw">o</span><span class="ot">.</span><span class="kw">body</span><span class="ot">,</span> <span class="kw">o</span><span class="ot">.</span><span class="kw">shapeTop</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureRight</span>  <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newFixture<span class="ot">(</span><span class="kw">o</span><span class="ot">.</span><span class="kw">body</span><span class="ot">,</span> <span class="kw">o</span><span class="ot">.</span><span class="kw">shapeRight</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureBottom</span> <span class="ot">=</span> <span class="kw">love</span><span class="ot">.</span><span class="kw">physics</span><span class="ot">.</span>newFixture<span class="ot">(</span><span class="kw">o</span><span class="ot">.</span><span class="kw">body</span><span class="ot">,</span> <span class="kw">o</span><span class="ot">.</span><span class="kw">shapeBottom</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">)</span></code></pre>
<p>Then I set each fixtures a different friction factor:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureLeft</span>:setFriction<span class="ot">(</span><span class="dv">0</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureTop</span>:setFriction<span class="ot">(</span><span class="dv">0</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureRight</span>:setFriction<span class="ot">(</span><span class="dv">0</span><span class="ot">)</span>
<span class="kw">o</span><span class="ot">.</span><span class="kw">fixtureBottom</span>:setFriction<span class="ot">(</span><span class="dv">100</span><span class="ot">)</span></code></pre>
<p>And for jump behavior, I’m just checking if <code>fixtureBottom</code> is collided, with the help of <code>beginContact</code> and <code>endContact</code> callbacks:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> beginContact<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="kw">b</span><span class="ot">,</span> <span class="kw">coll</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">a</span> <span class="ot">==</span> <span class="kw">char</span><span class="ot">.</span><span class="kw">fixtureBottom</span> <span class="kw">or</span> <span class="kw">b</span> <span class="ot">==</span> <span class="kw">char</span><span class="ot">.</span><span class="kw">fixtureBottom</span> <span class="kw">then</span>
        <span class="kw">char</span><span class="ot">.</span><span class="kw">jumpEnabled</span> <span class="ot">=</span> <span class="kw">true</span>
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> endContact<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="kw">b</span><span class="ot">,</span> <span class="kw">coll</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">a</span> <span class="ot">==</span> <span class="kw">char</span><span class="ot">.</span><span class="kw">fixtureBottom</span> <span class="kw">or</span> <span class="kw">b</span> <span class="ot">==</span> <span class="kw">char</span><span class="ot">.</span><span class="kw">fixtureBottom</span> <span class="kw">then</span>
        <span class="kw">char</span><span class="ot">.</span><span class="kw">jumpEnabled</span> <span class="ot">=</span> <span class="kw">false</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>With this features implemented, I think I have a good-enough platformer engine. Can’t wait for the next jam. Maybe we can build a game that we can actually mention to people ;-)</p>]]></summary>
</entry>
<entry>
    <title>Epic OCamlYacc fail</title>
    <link href="http://osa1.net/posts/2013-03-01-ocamlyacc-fail.html" />
    <id>http://osa1.net/posts/2013-03-01-ocamlyacc-fail.html</id>
    <published>2013-03-01T00:00:00Z</published>
    <updated>2013-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been trying to compile <a href="http://gallium.inria.fr/~fpottier/wallace/">an OCaml library from 2000</a> recently and I came up against a strange OCamlYacc error; OCamlYacc doesn’t compile the parser file because parser function has a polymorphic type(with a type variable <code>'a</code>).</p>
<p>At first I tried to understand with which concrete type <code>'a</code> type variable is being equated, so that I could replace it with the concrete type and the program would be compiled.</p>
<p>After several hours wasted, I decided to follow some different path. I replaced type variables in <code>.mly</code> with some dummy type like <code>my_epic_dummy_type</code> and compiled it with OCamlYacc. Then I replaced <code>my_epic_dummy_type</code> types with the type variable <code>'a</code> in compiled <code>.ml</code> and <code>.mli</code> files.</p>
<p>And the library worked as expected.</p>
<p>Now the question naturally arises: Why does OCamlYacc refuse to compile parser function with polymorphic type ? I have no idea.</p>]]></summary>
</entry>
<entry>
    <title>Quick Vim Tip for OCaml programmers: Fix OCamlYacc comment syntax</title>
    <link href="http://osa1.net/posts/2013-02-14-quick-vim-tip-for-ocaml.html" />
    <id>http://osa1.net/posts/2013-02-14-quick-vim-tip-for-ocaml.html</id>
    <published>2013-02-14T00:00:00Z</published>
    <updated>2013-02-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been editing OCaml with Vim for several months now, one problem that annoys me with Vim’s built-in OCaml syntax highlighter is it behaves OCamlYacc files like it’s a normal OCaml file.</p>
<p>It generally works fine but OCamlYacc’s comment syntax is different from OCaml’s. When working on big OCamlYacc files this quickly becomes annoying.</p>
<p>I’m not proficient in VimL but I could manage to write a simple solution. I replaced this line in Vim’s built-int OCaml syntax highlighter:</p>
<pre><code>&quot; Comments 
syn region   ocamlComment start=&quot;(\*&quot; end=&quot;\*)&quot; contains=ocamlComment,ocamlTodo</code></pre>
<p>with:</p>
<pre><code>&quot; Comments
if expand(&quot;%:e&quot;) == &quot;mly&quot;
  syn region   ocamlComment start=&quot;/\*&quot; end=&quot;\*/&quot; contains=ocamlComment,ocamlTodo
else
  syn region   ocamlComment start=&quot;(\*&quot; end=&quot;\*)&quot; contains=ocamlComment,ocamlTodo
end</code></pre>
<p>(You can find you Vim’s built-in files’ folders by runing <code>:echo $VIMRUNTIME</code> inside Vim. On my machine, <code>ocaml.vim</code>s path is <code>/usr/share/vim/vim73/syntax/ocaml.vim</code>)</p>
<p>Works great. It can be further simplified but requires a variable declaration and I don’t want to mess with Vim variables without understanding the consequences(scope rules etc.)</p>]]></summary>
</entry>
<entry>
    <title>Quick Vim Tip: Disable cursorline</title>
    <link href="http://osa1.net/posts/2013-01-16-quick-vim-tip-2.html" />
    <id>http://osa1.net/posts/2013-01-16-quick-vim-tip-2.html</id>
    <published>2013-01-16T00:00:00Z</published>
    <updated>2013-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wouldn’t believe how much this seemingly simple feature can affect rendering performance. Vim is being almost unusable when this is enabled. For more details, you can see <a href="https://github.com/dag/vim2hs/issues/28#issuecomment-12208866">my post</a> at vim2hs’s issue tracker.</p>
<p>I used this feature for my entire life spent using vim, but after a few hours without it I realized I actually don’t need it.</p>
<p>In short, disable <code>cursorline</code> (or <code>cul</code> for short) if your vim renders/highlights text too slow.</p>]]></summary>
</entry>

</feed>
