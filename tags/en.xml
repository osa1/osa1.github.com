<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2023-01-23T00:00:00Z</updated>
    <entry>
    <title>Fast polymorphic record access</title>
    <link href="http://osa1.net/posts/2023-01-20-whole-program-parameter-passing.html" />
    <id>http://osa1.net/posts/2023-01-20-whole-program-parameter-passing.html</id>
    <published>2023-01-23T00:00:00Z</published>
    <updated>2023-01-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I like <a href="https://osa1.net/posts/2021-04-10-sums-and-products.html">anonymous records</a> and row polymorphism, but until recently I didn’t know how to generate efficient code for polymorphic record access. In this blog post I will summarize the different compilations of polymorphic record accesses that I’m aware of.</p>
<p>All of the ideas shown in this post can be used to access a record field when the record’s concrete type is not known, but the type system guarantees that it has the accessed field. This includes row polymorphism and record subtyping.</p>
<p>Most of the ideas also work when the record’s type is completely unknown and it may not have the accessed field, but some of the optimizations assume accesses cannot fail. Those optimizations can only be used on statically-typed but polymorphic records.</p>
<p>In some of the examples below I will use row polymorphism.</p>
<hr />
<h1 id="row-polymorphism-and-record-subtyping-briefly">Row polymorphism and record subtyping, briefly</h1>
<p>In this blog post we are interested in a specific application of row polymorphism to records. In short, row polymorphism allows type variables denoting sets of record fields, with their types. For example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>f <span class="op">:</span> <span class="ot">∀</span> r <span class="op">.</span> { x <span class="op">:</span> <span class="dt">Int</span>, y <span class="op">:</span> <span class="dt">Int</span> <span class="op">|</span> r } <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>f a <span class="ot">=</span> a<span class="op">.</span>x <span class="op">+</span> a<span class="op">.</span>y</span></code></pre></div>
<p>Here the type variable <code>r</code> ranges over set of rows (or records). This function accepts any record as argument as long as the record has at least <code>x : Int</code> and <code>y : Int</code> fields.</p>
<p>The main difference between row polymorphism and record subtyping is that the type variable <code>r</code> can be used in the right-hand side of an arrow as well, allowing passing the record around without losing its concrete type. For example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>mapAB <span class="op">:</span> <span class="ot">∀</span> r <span class="op">.</span> { a <span class="op">:</span> <span class="dt">Int</span>, b <span class="op">:</span> <span class="dt">Int</span> <span class="op">|</span> r } <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> { a <span class="op">:</span> <span class="dt">Int</span>, b <span class="op">:</span> <span class="dt">Int</span> <span class="op">|</span> r }</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>mapAB r f <span class="ot">=</span> { a <span class="ot">=</span> f r<span class="op">.</span>a, b <span class="ot">=</span> f r<span class="op">.</span>b, <span class="op">..</span> r }</span></code></pre></div>
<p>This function takes any record that has <code>a : Int</code> and <code>b : Int</code> fields, and returns a new record with updated <code>a</code> and <code>b</code> fields and the rest of the fields. If I pass it a record with type <code>{ a : Int, b : Int, name : String }</code> I get the same type back.</p>
<p>With subtyping, type of this function would look like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>mapAB <span class="op">:</span> { a <span class="op">:</span> <span class="dt">Int</span>, b <span class="op">:</span> <span class="dt">Int</span> } <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> { a <span class="op">:</span> <span class="dt">Int</span>, b <span class="op">:</span> <span class="dt">Int</span> }</span></code></pre></div>
<p>In this version the return type just has <code>a</code> and <code>b</code> fields. Rest of the fields are lost. If I pass this a <code>{ a : Int, b : Int, name : String }</code> I get <code>{ a : Int, b : Int }</code> back. The <code>name</code> field is lost.</p>
<hr />
<p>Without subtyping, when the record type in a field access expression is known, it’s easy to generate efficient code: we use the same offsets used when compiling a record literal with the type.</p>
<p>With subtyping, and with row-polymorphism when the record type is not a concrete record type but is a record type with a row variable, type of <code>r</code> in <code>r.a</code> does not immediately give us where in the record’s payload the field <code>a</code> is.</p>
<p>Let’s look at how we might go about implementing record field access in these cases.</p>
<h1 id="records-as-maps">(0) Records as maps</h1>
<p>I don’t think this idea is used in statically-typed languages, but I wanted to include it for completeness.</p>
<p>We can implement records as maps with string keys. Field access then becomes a map lookup.</p>
<p>This is easy to implement because our language probably already has a map implementation in the standard library.</p>
<p>The disadvantages are:</p>
<ul>
<li><p>Depending on the map implementation, every field access require a <code>O(N)</code> or <code>O(log(N))</code> map lookup.</p></li>
<li><p>Map entries will be stored in a separate memory location (instead of in the record object’s payload), which will require pointer chasing to read the field value.</p></li>
<li><p>Unnecessary memory overhead caused by map fields that are not really necessary for records: such as the <code>capacity</code> and <code>size</code> fields.</p></li>
</ul>
<p>With whole-program compilation, we can improve the constant factors a bit by mapping labels (field names) in the program to unique integers. This way lookups don’t require string hashing or comparison, but this is still slow and memory-inefficient compared to other techniques we will discuss below.</p>
<h1 id="passing-accessors-as-parameters">(1) Passing accessors as parameters</h1>
<p>If you’re familiar with Haskell, this is the Haskell way of implementing row polymorphic records.</p>
<p>The idea is that when we pass a record to a row-polymorphic function, we also pass, implicitly, and as functions, the accessors that the function needs.</p>
<p>In Haskell, type of <code>mapAB</code> we’ve seen above would look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>mapAB <span class="op">:</span> <span class="ot">∀</span> r <span class="op">.</span> (<span class="dt">HasField</span> r <span class="dt">&#39;A</span> <span class="dt">Int</span>, <span class="dt">HasField</span> r <span class="dt">&#39;B</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> <span class="dt">Record</span> r <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Record</span> r</span></code></pre></div>
<p>The runtime values for <code>HasField ...</code> constraints are the accessors. When calling this function we don’t explicitly pass these accessors, the compiler generates them. In a well-typed program, we either have these values in the call site, or we know how to generate them (e.g. the record type is concrete in the call site), so it’s possible for the compiler to generate and pass these arguments.</p>
<p>The main advantage of this approach is that it doesn’t require any language support specifically for records.</p>
<p>The main disadvantages are:</p>
<ul>
<li><p>Every field access is a function call.</p></li>
<li><p>Parameter passing per field per record does not scale well and causes messy and slow generated code. For example, suppose we want to take two records with fields <code>x : Int</code> and <code>y : Int</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>f <span class="op">:</span> <span class="ot">∀</span> r <span class="op">.</span> (<span class="dt">HasField</span> r <span class="dt">&#39;X</span> <span class="dt">Int</span>, <span class="dt">HasField</span> r <span class="dt">&#39;Y</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> <span class="dt">Record</span> r <span class="ot">-&gt;</span> <span class="dt">Record</span> r <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>This function takes two implicit arguments, but it has a limitation that the record arguments need to have the same record types. I can’t call this function with two different records:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>f { x <span class="ot">=</span> <span class="dv">123</span>, y <span class="ot">=</span> <span class="dv">456</span>, a <span class="ot">=</span> <span class="st">&quot;hi&quot;</span> } { x <span class="ot">=</span> <span class="dv">0</span>, y <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, b <span class="ot">=</span> false }</span></code></pre></div>
<p>For this to work I need two row variables:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>f <span class="op">:</span> <span class="ot">∀</span> r1 r2 <span class="op">.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    (<span class="dt">HasField</span> r1 <span class="dt">&#39;X</span> <span class="dt">Int</span>, <span class="dt">HasField</span> r1 <span class="dt">&#39;Y</span> <span class="dt">Int</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>     <span class="dt">HasField</span> r2 <span class="dt">&#39;X</span> <span class="dt">Int</span>, <span class="dt">HasField</span> r2 <span class="dt">&#39;Y</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="dt">Record</span> r1 <span class="ot">-&gt;</span> <span class="dt">Record</span> r2 <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>This version works, but it also takes 4 implicit arguments.</p></li>
</ul>
<h1 id="prerequisite-integers-for-labels">Prerequisite: integers for labels</h1>
<p>Starting with the next approach, we will require mapping labels (field names) to integers in compile-time, to be used as indices.</p>
<p>Because these integers for labels will be used in record allocation and field accesses, it is possible that a label we see later in a program will cause different code generation for a record field access that we’ve already seen.</p>
<p>We have two options:</p>
<ul>
<li><p>We can avoid this problem with a whole-program pass to collect all labels in the program.</p>
<p>This is trivial with a whole-program compiler as a front-end pass can store all labels seen in a component (library, module) somewhere and we can map those labels to integers before code generation.</p></li>
<li><p>We can have a link-time step to update record allocation and field access code with the integers for the labels.</p></li>
</ul>
<p>In the rest of the post, labels will always get integers based on their lexicographical order and we will call these integers for labels just “labels”.</p>
<p>For example, if I have labels <code>a</code>, <code>c</code>, <code>b</code>, <code>d</code> in my program, their numbers will be 1, 3, 2, 4, respectively.</p>
<h1 id="per-record-label-to-field-offset-tables">(2) Per-record label-to-field-offset tables</h1>
<p>With integers as labels we can add a table to every record (records with the same set of keys sharing the same table) mapping labels in the program to offsets in the record’s payload. For example, the table for a record with fields <code>a</code> and <code>c</code> when the program has labels <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, looks like this:</p>
<pre><code>[ 0, _, 1, _ ]</code></pre>
<p>This table is indexed by the label and the value gives the offset in the record’s payload for the field. <code>_</code> means the record does not have the field. In a well-typed program we won’t ever see a <code>_</code> value being read from a table.</p>
<p>This approach is quite wasteful as every table will have as many entries as number of labels in the program, but we will compress these tables below to reasonable sizes.</p>
<p>We will call these tables “record offset tables” or “offset tables” in short. When compiling a record access we need to get the record’s offset table. For this we add an extra word (pointer) to record objects pointing to their offset tables. We then generate this code for a record field access:</p>
<pre><code>record[record[OFFSET_TABLE_INDEX][label]]</code></pre>
<p><code>OFFSET_TABLE_INDEX</code> is the constant for where the offset table pointer is in record objects.</p>
<p>Offset tables are generated per record shape (set of labels), so the total number of tables shouldn’t be too large.</p>
<p>Since the <code>_</code> entries won’t ever be used, we can shrink the tables with trailing <code>_</code> entries. In our example above with a record with <code>a</code> and <code>c</code> fields, the last <code>_</code> entry can be omitted:</p>
<pre><code>[ 0, _, 1 ]</code></pre>
<h1 id="making-the-tables-global">(2.1) Making the tables global</h1>
<p>Because offset tables are per-shape, and the total number of record shapes in a program should be small, if we allocate a few bits in record object headers for the “shape index” of the record, this index can be used to index a global table mapping record shapes to their offset tables.</p>
<p>Generated code for record access expressions will look like:</p>
<pre><code>record[RECORD_OFFSET_TABLES[getRecordShapeId(record)][label]]</code></pre>
<p><code>getRecordShapeId</code> will read the bits in the object header for the record shape id. Depending on the actual header layout, it will look something like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="dt">int</span> getRecordShapeId(Object* object) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="cf">return</span> (object-&gt;header &amp; RECORD_ID_MASK) &gt;&gt; HEADER_BITS;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>With record shape IDs in headers and a global table mapping shape IDs to offset tables, we no longer need an extra word in record objects for the offset table pointer.</p>
<p>Here’s an example of offset tables when we have labels <code>a</code>, <code>b</code>, <code>x</code>, <code>y</code>, and two records <code>0: {a, b}</code> and <code>1: {x, y}</code>:</p>
<pre><code>RECORD_0_OFFSET_TABLE = [
  0, // label a
  1, // label b
  _, // label x
  _, // label y
];

RECORD_1_OFFSET_TABLE = [
  _, // label a
  _, // label b
  0, // label x
  1, // label y
];

RECORD_OFFSET_TABLES = [
  RECORD_0_OFFSET_TABLE, // record 0
  RECORD_1_OFFSET_TABLE, // record 1
];</code></pre>
<p>As before, the offset table for record 0 can be shrunk as:</p>
<pre><code>RECORD_0_OFFSET_TABLE = [
  0, // label a
  1, // label b
];</code></pre>
<h1 id="sharing-label-ids-and-record-shapes">(2.2) Sharing label IDs and record shapes</h1>
<p>Labels that are not used in the same record program can be given the same ID.</p>
<p>In the example above, this allows us to have a single table for both records:</p>
<pre><code>RECORD_0_1_OFFSET_TABLE = [
  0, // label a or x
  1, // label b or y
];

RECORD_OFFSET_TABLES = [
  RECORD_0_1_OFFSET_TABLE, // record 0
  RECORD_0_1_OFFSET_TABLE, // record 1
];</code></pre>
<p>The problem of assigning IDs to labels is very similar to stack allocation when spilling during register allocation. We have practically infinite amount of IDs (stack space), but we want to reuse the same ID for labels as long as they’re never used in the same record (live at the same time).</p>
<p>After sharing label IDs, some of the shapes may be identical, as in our example. We can give those shapes the same ID and avoid redundant entries in the offset tables.</p>
<p>With this, our example with two records <code>{a, b}</code> and <code>{x, y}</code> compiles to just one offset table:</p>
<pre><code>RECORD_0_1_OFFSET_TABLE = [
  0, // label a or x
  1, // label b or y
];

RECORD_OFFSET_TABLES = [
  RECORD_0_1_OFFSET_TABLE, // record 0 and 1
];</code></pre>
<h1 id="flattening-the-table">(2.3) Flattening the table</h1>
<p>Suppose we have these record shapes in a program:</p>
<ul>
<li><code>{a, b, q}</code></li>
<li><code>{x, y, q}</code></li>
</ul>
<p>The <code>RECORD_OFFSET_TABLES</code> table is currently an array of pointers, and indexing the offset table still requires pointer chasing.</p>
<p>To avoid pointer chasing we can flatten the table.</p>
<p>For our current program, the tables, without flattening, look like this:</p>
<pre><code>RECORD_0_OFFSET_TABLE = [
  0, // label a
  1, // label b
  _, // label x
  _, // label y
  2, // label q
];

RECORD_1_OFFSET_TABLE = [
  _, // label a
  _, // label b
  0, // label x
  1, // label y
  2, // label q
];

RECORD_OFFSET_TABLES = [
  RECORD_0_OFFSET_TABLE,
  RECORD_1_OFFSET_TABLE,
];</code></pre>
<p>We can flatten this as:</p>
<pre><code>RECORD_0_OFFSET_TABLE = [
  0, // label a
  1, // label b
  _, // label x
  _, // label y
  2, // label q
];

RECORD_1_OFFSET_TABLE = [
  _, // label a
  _, // label b
  0, // label x
  1, // label y
  2, // label q
];

RECORD_LABEL_OFFSETS = [
  0, // record 0, label a
  1, // record 0, label b
  _, // record 0, label x
  _, // record 0, label y
  2, // record 0, label z

  _, // record 1, label a
  _, // record 1, label b
  0, // record 1, label x
  1, // record 1, label y
  2, // record 1, label z
];</code></pre>
<p>Field indexing then becomes:</p>
<pre><code>record[RECORD_LABEL_OFFSETS[(getRecordShapeId(record) * NUM_LABELS) + label]]</code></pre>
<p>With this version we eliminate one layer of indirection.</p>
<h1 id="removing-the-constant-factor">(2.4) Removing the constant factor</h1>
<p>The idea here is not too important on its own, but it will enable further improvements.</p>
<p>The <code>NUM_LABELS</code> factor in field access code above can be eliminated by incrementing record shape IDs by <code>NUM_LABELS</code> instead of 1. In our example, instead of having record IDs 0 and 1, we will have 0 and 5 (incremented by the number of labels in the program).</p>
<p>Since there may be large number of labels in a program and we may have only a few bits to store the record IDs, an alternative would be to convert the table to label-major order like this:</p>
<pre><code>RECORD_LABEL_OFFSETS = [
  0, // label a, record 0
  _, // label a, record 1

  1, // label b, record 0
  _, // label b, record 1

  _, // label x, record 0
  1, // label x, record 1

  _, // label y, record 0
  2, // label y, record 1

  3, // label z, record 0
  3, // label z, record 1
];</code></pre>
<p>With this table, indexing code becomes:</p>
<pre><code>record[RECORD_LABEL_OFFSETS[(label * NUM_RECORDS) + getRecordShapeId(record)]]</code></pre>
<p>We can then eliminate the <code>NUM_RECORDS</code> factor the same way, by incrementing label IDs by <code>NUM_RECORDS</code> instead of 1, and index with:</p>
<pre><code>record[RECORD_LABEL_OFFSETS[label + getRecordShapeId(record)]]</code></pre>
<h1 id="compacting-the-table-further">(2.5) Compacting the table further</h1>
<p>Now that the table index of a label is <code>label + shape_id</code> and we have a single table, we can shift the entries in the table by decrementing label IDs.</p>
<p>For this it doesn’t matter whether we store in label-major or record-major order. Which one of these will generate a smaller table will probably depend on the program. As an example, suppose we store the table in label-major order, and we have these records in the program:</p>
<ul>
<li><code>0: {x, y, z, t}</code></li>
<li><code>1: {x, y}</code></li>
<li><code>2: {z, t}</code></li>
</ul>
<p>The table will look like:</p>
<pre><code>[ 0, 0, _,   // label x
  1, 1, _,   // label y
  2, _, 0,   // label z
  3, _, 1 ]  // label t</code></pre>
<p>Record IDs will be 0, 1, 2, and label IDs will be 0, 3, 6, 9.</p>
<p>We can use the unused slot for label x, record 2, by decrementing the label index for <code>y</code> by one. If we then do the same for <code>z</code>, the label IDs become 0, 2, 4, 7, and the table becomes:</p>
<pre><code>[ 0, 0,      // label x
  1, 1,      // label y
  2, _, 0,   // label z
  3, _, 1 ]  // label t</code></pre>
<p>This idea can be used to fill any gaps in previous label rows, as long as the used slots in a row fits into the gaps. For example, if we have a table like:</p>
<pre><code>[ 0, _, _, 1,  // label x
  _, 0, 1, _,  // label y
  ... ]</code></pre>
<p>We can decrement <code>y</code>’s ID to fit it into the row for label <code>x</code>:</p>
<pre><code>[ 0, 0, 1, 1,  // label x and y, interleaved
  ... ]</code></pre>
<h1 id="conclusions">Conclusions</h1>
<p>Collecting and numbering all labels in the program allows using a global table for mapping labels to offsets.</p>
<p>These offset tables can be made smaller by</p>
<ul>
<li>Giving same number to labels that don’t occur in the same record</li>
<li>Giving same ID to records that become identical after the previous step</li>
<li>Tweaking label numbers so that rows without overlapping entries can be merged into a single row</li>
</ul>
<p>The result is a very compact representation of record objects (no extra words in the header or unused space in the payload needed) and a fast polymorphic field access.</p>
<p>The offset table should also be small in practice, because different parts of the program will probably use disjoint set of names, and different labels and records will have the same IDs. In the remaining cases, tweaking label IDs to compact the table should help.</p>
<h1 id="references">References</h1>
<p>I’ve learned about the global table approach and some of the optimizations from the Dart compiler, which implements virtual calls using a “global dispatch table” (GDT), indexed by <code>classID + methodID</code> in call sites. See <a href="https://mrale.ph/dartvm/#global-dispatch-table-gdt">“Introduction to Dart VM”</a> for a description of how Dart AOT and JIT generate GDTs.</p>
<p>If you are interested in seeing some code, <a href="https://github.com/dart-lang/sdk/blob/ba8f0bd947c613013ed4659ea44da851bf35a99f/pkg/dart2wasm/lib/dispatch_table.dart#L411-L442">here</a> is where we generate the GDT in dart2wasm (Dart’s Wasm backend). The outer loop finds a selector ID (label ID in our examples) for a row (list of records in our examples, list of classes in dart2wasm). The inner loop <code>do { ... } while (!fits)</code> starts from the first row with gaps, and tries to fit the current row into the gaps. In the worst case it skips all of the rows, in which case rest of the code appends the table with the new row.</p>
<p><a href="https://github.com/dart-lang/language/blob/master/accepted/future-releases/records/records-feature-specification.md">Dart will soon have records</a>, and for the <a href="https://github.com/dart-lang/sdk/issues/50014">dart2wasm implementation of records</a> I’m thinking of using some of the ideas described in this post. Dart records do not support width subtyping (you can’t pass <code>{x, y, z}</code> where <code>{x, y}</code> is expected), but because of the <code>dynamic</code> type, we can have a dynamically typed record that we index.</p>
<hr />
<p>Thanks to <a href="https://twitter.com/josecalderon">José Manuel Calderón Trilla</a> for his feedback on a draft of this blog post.</p>]]></summary>
</entry>
<entry>
    <title>Products and sums, named and anonymous</title>
    <link href="http://osa1.net/posts/2021-04-10-sums-and-products.html" />
    <id>http://osa1.net/posts/2021-04-10-sums-and-products.html</id>
    <published>2021-04-10T00:00:00Z</published>
    <updated>2021-04-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I was recently thinking about why do so many languages have tuples, which can be thought of as simple anonymous products (more on the definition of this below), but not something similar for sums. Both sum and product types are widely used, so it seems inconsistent to have anonymous products but not sums.</p>
<p>I recently <a href="https://twitter.com/_osa1/status/1379260986574667776">tweeted about this</a> and got helpful responses that made me realize that I got my definitions wrong. As I think more about what “anonymous type” means it became clear to me that the it’s not just tuples or other types with special syntax, instead of names. It’s more complicated than that.</p>
<p>So in this post I’d like briefly talk about products and sums, and how are names used in type checking. I will then show a different way of type checking, and some examples from two widely used languages. Finally, I will argue that types are called “named” or “anonymous” depending on how they are checked.</p>
<p>Note that I’m not using any of these words as they are used in category theory or any other field of mathematics. These are mainly how I see them used in widely used PLs like Haskell, Rust, and OCaml, and in PL papers and books.</p>
<h1 id="products">Products</h1>
<p>A value of a product type contains zero or more fields with potentially different types. Some example product types are:</p>
<ul>
<li><code>data Coordinate = Coordinate { x :: Int, y :: Int }</code>: a product with two <code>Int</code> fields</li>
<li><code>data D = D Int String Float</code>: a product with <code>Int</code>, <code>String</code>, and <code>Float</code> fields</li>
<li><code>data Empty = Empty</code>: a product with no fields</li>
</ul>
<p>Note that the way you access the fields does not matter. In the examples above, fields of a <code>Coordinate</code> value can be accessed with pattern matching, or with the generated functions <code>x</code> and <code>y</code>. In the second example, we can only access the fields with pattern matching.</p>
<p>What matters is: products contain zero or more fields. The fields can have different types.</p>
<h1 id="sums">Sums</h1>
<p>A sum type specifies multiple “variants” (or “alternatives”), where each variant has a “name” (or “tag”, more on this later) and some number of fields.</p>
<p>A value of a sum type holds a name (or tag), and the fields of the variant with that name.</p>
<p>For example, if you have a parser for integers, you will want to return an integer when parsing succeeds, or an error message when something goes wrong. The sum type for the return value of your parse function would look like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ParseResult</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Success</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Fail</span> <span class="dt">String</span></span></code></pre></div>
<p>Here, <code>Success</code> and <code>Fail</code> are names of the variants. <code>Success</code> variant has an <code>Int</code> field, and <code>Fail</code> variant has a <code>String</code> field.</p>
<p>A value of this type does not contain an <code>Int</code> and <code>String</code> at the same time. It’s either a <code>Fail</code> with a <code>String</code> field, or a <code>Success</code> with an <code>Int</code> field.</p>
<p>The way you access the fields is with pattern matching:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">case</span> parse_result <span class="kw">of</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>   <span class="dt">Success</span> int <span class="ot">-&gt;</span> <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>   <span class="dt">Fail</span> error_message <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<h1 id="names-in-type-checking-nominal-typing">Names in type checking (nominal typing)</h1>
<p>If I have two types, named <code>T1</code> and <code>T2</code>, no matter how they are defined, they are considered different in Haskell, and most other widely used typed languages (Rust, Java, …). This is called “nominal” type checking, where differently named types are considered different, even if they are “structurally” the same. For example, <code>data T1 = T Int</code> and <code>data T2 = T Int</code> are structurally the same, but you can’t apply a value of type <code>T2</code> to a function that expects <code>T1</code>.</p>
<p>What “structurally same” mean is open to interpretation. We will come to this later.</p>
<p>In addition, all types have names<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, even types like tuples, which may look like they don’t have names, like our <code>Coordinate</code> or <code>ParseResult</code> have.</p>
<p>Tuples in most languages are just a bunch of product types, like the ones you can define yourself. They are often pre-defined for arities 0 to some number, and they have a special, “mixfix” syntax, with parentheses and commas to separate the fields. Other than that, they are no different than the ones you can define yourself.</p>
<p>You can see GHC’s definition of tuples <a href="https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs#L34-L58">here</a>. In GHC, you can use the name directly if you don’t want the mixfix syntax, like <code>(,) 1 2</code>. So the name for an 2-ary tuple is <code>(,)</code> in Haskell, and it has a special syntax so you can write more readable <code>(1, 2)</code> (or <code>(Int, Int)</code> in type context). Other than syntax, there’s nothing special about tuples.</p>
<p>So it’s clear that most languages don’t have anonymous types. All types have some kind of names, and two types are only “compatible” if the names match.</p>
<p>Before defining what anonymous types are, I would like to give two examples, from PureScript and OCaml, where types are not checked based on their names, but based on their “structure”.</p>
<h1 id="structural-type-checking-for-products">Structural type checking for products</h1>
<p>A record is a product type with named (or “labelled”) fields. Our <code>Coordinate</code> example is a record.</p>
<p>In PureScript, records can be defined without giving names to them. For example:</p>
<pre class="purescript"><code>f :: { x :: Int, y :: Int } -&gt; Int
f a = a.x + a.y</code></pre>
<p>Here, <code>f</code> is a function that takes a record with two <code>Int</code> fields, named <code>x</code> and <code>y</code>, as an argument.</p>
<p>Here is a more interesting version of the same function:</p>
<pre class="purescript"><code>f :: forall r . { x :: Int, y :: Int | r } -&gt; Int
f a = a.x + a.y</code></pre>
<p>This version takes a record with <em>at least</em> <code>x :: Int</code> and <code>y :: Int</code> fields, but it can have more fields. Using this version, this code type checks:</p>
<pre class="purescript"><code>f { x: 1, y: 2, z: 3, t: 4 }</code></pre>
<p>The <code>r</code> in this type is not too important. Important part is, in PureScript, records are not type checked nominally. Indeed, in the example above, type of the record with 4 fields is not defined, and no names are used for the record in the type signature of <code>f</code>.</p>
<p>You might think that the record braces and commas are similar to the tuple syntax, so the name could be something like <code>{,}</code>, maybe applied to <code>x :: Int</code> somehow (assuming there is a type-level representation of field names).</p>
<p>However, even if that’s the case, type checking of these types are quite different than tuples. We’ve already seen that we can pass a record with more fields. You can also reorder fields in the function type signature<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, or in the record expression, and it still works.</p>
<p>So type checking for PureScript is quite different than Haskell tuples.</p>
<p>This kind of type checking where you look at the “structure” rather than just the names is called structural type checking.</p>
<p>Now let’s take a look at an example for sum types.</p>
<h1 id="structural-type-checking-for-sum-types">Structural type checking for sum types</h1>
<p>OCaml has named sum types, just like Haskell’s. Here is the OCaml version of our <code>ParseResult</code> type:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> parse_result =</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  | Success <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  | Fail <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>Name of this type is <code>parse_result</code> (following OCaml naming conventions), and it is type checked exactly the same way it is type checked in Haskell.</p>
<p>A second way of defining sum types in OCaml, and without names, is with <a href="https://ocaml.org/manual/lablexamples.html#s:polymorphic-variants">polymorphic variants</a>. Here’s the polymorphic variant for the same type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">type</span> parse_result = [ `Success <span class="kw">of</span> <span class="dt">int</span> | `Fail <span class="kw">of</span> <span class="dt">string</span> ]</span></code></pre></div>
<p>Crucially, even though we use a similar syntax with the <code>type</code> keyword, this is a type synonym. The right-hand side of this definition is an anonymous sum with two variants, tagged <code>`Success</code> and <code>`Fail</code>, with <code>int</code> and <code>string</code> fields, respectively.</p>
<p>Now, suppose I have a parse result handler, which, in addition to the success and failure cases, handles some “other” case as well:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">let</span> f = <span class="kw">function</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  | `Success i -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse result: %d</span><span class="ch">\n</span><span class="st">&quot;</span> i</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  | `Fail msg -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse failed: %s</span><span class="ch">\n</span><span class="st">&quot;</span> msg</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  | `Other -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Wat?</span><span class="ch">\n</span><span class="st">&quot;</span></span></code></pre></div>
<p>Type of this function as inferred by the OCaml compiler is:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>[&lt; `Fail <span class="kw">of</span> <span class="dt">string</span> | `Other | `Success <span class="kw">of</span> x ] -&gt; <span class="dt">unit</span></span></code></pre></div>
<p>What this type says is that the function accepts any polymorphic variant that has the tags <code>Fail</code>, <code>Other</code>, and <code>Success</code> (with the specified field types), or some subset of these tags. So if I have a value of type <code>parse_result</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">let</span> x : parse_result = `Success <span class="dv">123</span></span></code></pre></div>
<p>I can pass it to <code>f</code>, even though <code>f</code>’s argument type is not exactly <code>parse_result</code>. Here’s the full example, run in <a href="https://github.com/ocaml-community/utop">utop</a>: (<code>utop #</code> part is the prompt, lines after <code>;;</code> are utop outputs)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>utop # <span class="kw">type</span> parse_result = [ `Success <span class="kw">of</span> <span class="dt">int</span> | `Fail <span class="kw">of</span> <span class="dt">string</span> ];;</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">type</span> parse_result = [ `Fail <span class="kw">of</span> <span class="dt">string</span> | `Success <span class="kw">of</span> <span class="dt">int</span> ]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>utop # <span class="kw">let</span> f = <span class="kw">function</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  | `Success i -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse result: %d</span><span class="ch">\n</span><span class="st">&quot;</span> i</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  | `Fail msg -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Parse failed: %s</span><span class="ch">\n</span><span class="st">&quot;</span> msg</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  | `Other -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;Wat?</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">val</span> f : [&lt; `Fail <span class="kw">of</span> <span class="dt">string</span> | `Other | `Success <span class="kw">of</span> <span class="dt">int</span> ] -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>utop # <span class="kw">let</span> x : parse_result = `Success <span class="dv">123</span>;;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="kw">val</span> x : parse_result = `Success <span class="dv">123</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>utop # f x;;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>Parse result: <span class="dv">123</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
<p>Neat!</p>
<p>Similar to PureScript records, and unlike Haskell tuples, type checking for OCaml polymorhic records is structural, not nominal.</p>
<h1 id="names---nominal---structural">Names -&gt; nominal, ??? -&gt; structural</h1>
<p>Now that we have seen structural type checking as an alternative to name-based (nominal) type checking, and some examples, here is my attempt at defining anonymous types: If named types are type checked nominally, then the types that are structurally type checked are called “anonymous”.</p>
<p>In other words:</p>
<ul>
<li>Nominally type checked types are named</li>
<li>Structurally type checked types are anonymous</li>
</ul>
<p>According to this definition, Haskell and many other languages don’t have anonymous types. PureScript records are an example to anonymous products, and OCaml polymorphic variants are an example to anonymous sums.</p>
<h1 id="conclusions">Conclusions</h1>
<p>Named types are checked nominally, anonymous types are checked structurally. According to this definition, Haskell, and many other languages, don’t have anonymous types, as all types are nominally checked.</p>
<p>Tuples are no exception: they have names, and type checked nominally.</p>
<p>PureScript records and OCaml polymorphic variants are great examples to anonymous products and sums, respectively.</p>
<!---




























# Tuples: named or anonymous?

Tuples in languages like Haskell, Rust, and OCaml, are pre-defined product
types that are often used for returning multiple values from functions, without
having to define a new type for the return value.

For example, the tuple type `(Int, Int)` in Haskell is a product with two `Int`
fields. This type is similar to our `Coordinate` example above.

Because tuples don't have "names", like our `Coordinate` has, it may seem like
tuples are unnamed, or "anonymous". This is actually not true. Tuples in most
languages are just a bunch of product types, like the ones you can define
yourself. They are often pre-defined for arities 0 to some number, and they have
a special, "mixfix" syntax, with parentheses and commas to separate the fields.
Other than that, they are no different than the ones you can define yourself.

As an example, you can see GHC's definition of tuples [here][2]. In GHC, you can
use the name directly if you don't want the mixfix syntax, like `(,) 1 2`. So
the name for an 2-ary tuple is `(,)` in Haskell, and it has a special syntax so
you can write more readable `(1, 2)` (or `(Int, Int)` in type context).

So it's clear that tuples in Haskell are not anonymous, they have names. But
what are anonymous types then? Does Haskell even have anonymous types? Before
defining anonymous types, let's briefly talk about how are names used in type
checking.

# Nominal and structural type checking

If I have two types, named `T1` and `T2`, no matter how they are defined, they
are considered different in Haskell, and most other widely used typed languages
(Rust, Java, ...). This is called "nominal" type checking, where differently
named types are considered different, even if they are "structurally" the same.
For example, `data T1 = T Int` and `data T2 = T Int` are structurally the same,
but you can't apply a value of type `T2` to a function that expects `T1`.


What does "structurally same" mean here is open to interpretation, but the
crucial part is with structural type checking, types can have different set of
fields or variants and still be compatible. We will shortly see examples of
this.

Now, here's the difficulty with defining anonymous types (and a point of
confusion, at least for me). Regardless of the syntax, I will have to introduce
some kind of type constructors for anonymous products and sums. One might always
consider those constructors as the names of the types (with type parameters
applied for the fields/ variants).

For example, if I use `*` syntax for anonymous products, like `Int * Int * Bool`
for a product type like `(Int, Int, Bool)`, you might argue that the "name" here
is `*`, and the desugared version is something like `(*) Int ((*) Int Bool)`,
and you would probably be right! In many (most?) type systems, including
Haskell's, complex types are made by applying types to type constructors. The
type constructors used for constructing product or sum types can be thought of
as the name of the types.

In that sense I think there really isn't any *obviously anonymous* types where
you will know it when you see it. Every type is constructed by applying some
number of arguments to a "name" (usually called "type constructors").

# Names -> nominal, ??? -> structural

With these definitions in mind, here's my attempt at defining anonymous types.
If named types are type checked nominally (where different names mean types are
incompatible), then the types that are structurally type checked are called
"anonymous".

In other words:

- Nominally type checked types are named
- Structurally type checked types are anonymous

In the simple structural type checking rule we've seen above, anonymous
products (constructed with `*`) and tuples (constructed with the mixfix tuple
syntax) are type checked exactly the same way. Let's add one more rule to make
them different:

- Before applying the rules given before, rearrange the type arguments to make
  the first argument of `*` a non-`*` type.

Example: if I have `(Int * Int) * (Int * Int)`, this rule rearranges it to make
it `Int * (Int * (Int * Int))`.

(This rule effectively makes `*` associative)

With this new rule we now accept these two types as compatible:

- `(Int * (Int * Int)) * Int`
- `(Int * Int) * (Int * Int)`

as they are both rearranged before checking as `Int * (Int * (Int * Int))`.

(Whether this rule is useful or desired is a different matter)

With this structural equality rule, type checking of tuples and products
constructed with `*` are different, and we call tuples named types and `*`
products anonymous.

# Anonymous sum types

Instead of inventing syntax and defining type checking for anonymous sum types,
like we did for products, I will show an example of anonymous sums in an
existing programming language: OCaml's [polymorphic variants][3].

Here's the OCaml version of our `ParseResult` type:

```ocaml
type parse_result =
  | Success of int
  | Fail of string
```

This type is nominally checked, so if you have a function that expects
`parse_result` argument, you have to pass it a `Success` or `Fail`. Anything
else will cause a type error.

Here's the polymorphic variant for the same type:

```ocaml
type parse_result = [ `Success of int | `Fail of string ]
```

Crucially, even though we use a similar syntax with the `type` keyword, this is
a type synonym. The right-hand side of this definition is an anonymous sum with
two variants, labelled `` `Success`` and `` `Fail``, with `int` and `string`
fields, respectively.

Here's an example of structural type checking of polymorphic variants. Suppose I
have a parse result handler, which, in addition to the success and failure
cases, handles some "other" case as well:

```ocaml
let f = function
  | `Success i -> Printf.printf "Parse result: %d\n" i
  | `Fail msg -> Printf.printf "Parse failed: %s\n" msg
  | `Other -> Printf.printf "Wat?\n"
```

Type of this function as inferred by the OCaml compiler is:

```ocaml
[< `Fail of string | `Other | `Success of x ] -> unit
```

What this type says is that the function accepts any polymorphic variant that
has the tags `Fail`, `Other`, and `Success` (with the specified field types), or
some subset of these tags. So if I have a value of type `parse_result`:

```ocaml
let x : parse_result = `Success 123
```

I can pass it to `f`, even though `f`'s argument type is not exactly
`parse_result`. Here's the full example, run in [utop][9]: (`utop #` part is the
prompt, lines after `;;` are utop outputs)

```ocaml
utop # type parse_result = [ `Success of int | `Fail of string ];;
type parse_result = [ `Fail of string | `Success of int ]

utop # let f = function
  | `Success i -> Printf.printf "Parse result: %d\n" i
  | `Fail msg -> Printf.printf "Parse failed: %s\n" msg
  | `Other -> Printf.printf "Wat?\n";;
val f : [< `Fail of string | `Other | `Success of int ] -> unit = <fun>

utop # let x : parse_result = `Success 123;;
val x : parse_result = `Success 123

utop # f x;;
Parse result: 123
- : unit = ()
```

Neat!

# Conclusions

Named types are checked nominally, anonymous types are checked structurally.
According to this definition, Haskell, and many other languages, don't have
anonymous types, as all types are nominally checked.

OCaml's [polymorphic variants][3] are a great example to anonymous sums.

For real-world anonymous products, it would be a shame to not mention records
and row types[^1]. A record is a product type with labelled fields, for example:
`{ a : Int, b : Bool }`. Row types allow (among other things) very flexible type
checking of records, where you can (without subtyping) pass a record with more
fields when less is expected. With row types, unlike subtyping, if you have a
function that expects a record type like `{ a : Int, b : Bool }` and returns the
argument after using or modifying the fields `a` and/or `b`, and pass the
function a record with more fields, like `{ a : Int, b : Bool, c : String }`, as
the return type you get your original record with 3 fields. More concretely:

```
{ a : Int, b : Bool, ..r } -> { a : Int, b : Bool, ..r }
```

is the type of a function that takes a record with fields `a` and `b` with the
specified types, and *possibly* more fields. These extra fields are represented
by `r`, which appears in both input and output types. This means you don't lose
the extra fields if you pass a record with more fields to this function, unlike
in a system with subtyping. With subtyping, if you have a function with type

```
{ a : Int, b : Bool } -> { a : Int, b : Bool }
```

and pass `{ a : Int, b : Bool, c : String }` to such a function, you lose the
field `c` in the return value, because the return type only mentions `a` and
`b`, without the "extra stuff" part as we've seen in the row polymorphic
version.

(As as aside, I'd like to mention that I really like row types. My first
exposure to them was back in 2013 ([1][5], [2][6]): I implemented two type
systems, one with row types and one for a multi-stage language, proved soundness
of the systems, gave a type and term translation from one to the other, and
proved that if your program is well-typed, then the translation of it is also
well-typed.)

My favorite paper on row-polymorphic records is probably (1). (2) uses row types
for algebraic effects. (3) uses rows for variants (sums).

-->
<hr />
<p>Thanks to <a href="https://twitter.com/_gilmi/">@_gilmi</a> and <a href="https://twitter.com/madgen_/">@madgen_</a> for their helpful comments on a draft of this blog post.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>With the exception of type synonyms. Type synonyms can be considered as simple macros for substituting types for names before type checking.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>In Haskell, reordering stuff at the type level is often done with type families (type-level functions). Types are still checked nominally, but by rearranging them before type checking you can often have something somewhat similar to structural checking.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Conditional compilation based on crate type</title>
    <link href="http://osa1.net/posts/2020-12-24-crate-type-conditional.html" />
    <id>http://osa1.net/posts/2020-12-24-crate-type-conditional.html</id>
    <published>2020-12-24T00:00:00Z</published>
    <updated>2020-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Suppose you have a <code>no_std</code> crate that you want to use in two ways:</p>
<ol type="1">
<li>As a self-contained static library, to link with other (non-Rust) code</li>
<li>As a Rust library, to import from another crate to test it</li>
</ol>
<p>(1) is the main use case for this library. (2) is because you want to test this library and you want to be able to use Rust’s <code>std</code> and other Rust libraries for testing.</p>
<p>The Rust crate type for (1) is <code>staticlib</code>. For (2) you need <code>rlib</code>. (<a href="https://doc.rust-lang.org/reference/linkage.html">documentation on crate types</a>)</p>
<p>Here’s the problem. To be able to generate <code>staticlib</code> you need to implement a <a href="https://doc.rust-lang.org/nomicon/panic-handler.html">panic handler</a> as otherwise the code won’t know how to panic<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. However, if you define a panic handler, you won’t be able to use your crate in other crates anymore as your panic handler will clash with the <code>std</code> panic handler.</p>
<p>4 files needed to demonstrate this:</p>
<pre><code>-- Cargo.toml for the library
[package]
name = &quot;nostd_lib&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[lib]
crate-type = [&quot;staticlib&quot;, &quot;rlib&quot;]

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;

-- lib.rs
#![no_std]

#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}

-- Cargo.toml for the importing crate
[package]
name = &quot;nostd_bin&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[dependencies]
nostd_lib = { path = &quot;../nostd_lib&quot; }

-- main.rs
extern crate nostd_lib;

fn main() {}</code></pre>
<p>The library builds fine, but if you try to build <code>nostd_bin</code> you’ll get this error:</p>
<pre><code>error: duplicate lang item in crate `nostd_lib` (which `nostd_bin` depends on): `panic_impl`.
  |
  = note: the lang item is first defined in crate `std` (which `nostd_bin` depends on)
  = note: first definition in `std` loaded from ...
  = note: second definition in `nostd_lib` loaded from ...</code></pre>
<p>Which says you now have two panic handlers: one in <code>std</code> and one in your library.</p>
<p>If you remove the panic handler in the library then you won’t be able to build the library anymore:</p>
<pre><code>error: `#[panic_handler]` function required, but not found</code></pre>
<p>So you need some kind of conditional compilation, to generate panic handler only when generating <code>staticlib</code>. Unfortunately conditional compilation based on crate type is <a href="https://github.com/rust-lang/rust/issues/20267">currently not possible</a>. It is also <a href="https://github.com/rust-lang/cargo/issues/6160">not possible to specify target crate type when invoking cargo</a>.</p>
<p>The least hacky way I could find to solve this (and without using anything other than just <code>cargo build</code> to build) is by having two <code>Cargo.toml</code> files.</p>
<p>Cargo really wants manifest files to be named <code>Cargo.toml</code>, so we put the files in different directories. In my case the top-level one is for <code>staticlib</code> and it looks like this:</p>
<pre><code>[package]
name = &quot;nostd_lib&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[features]
default = [&quot;panic_handler&quot;]
panic_handler = []

[lib]
crate-type = [&quot;staticlib&quot;]

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;</code></pre>
<p>I also update <code>lib.rs</code> to only define the panic handler when the feature is enabled:</p>
<pre><code>#[cfg(feature = &quot;panic_handler&quot;)]
#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    ...
}</code></pre>
<p>Now I can build the library at the library’s top-level with just <code>cargo build</code>. Because the <code>panic_handler</code> feature is enabled by default in this <code>Cargo.toml</code>, the panic handler will be defined by default with just <code>cargo build</code> and static library will build and work fine.</p>
<p>For the <code>rlib</code> I create a similar <code>Cargo.toml</code> in <code>rlib</code> directory:</p>
<pre><code>[package]
name = &quot;nostd_lib&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[lib]
crate-type = [&quot;rlib&quot;]
path = &quot;../src/lib.rs&quot;

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;</code></pre>
<p>The differences are: this one only generates <code>rlib</code>, doesn’t define the <code>panic_handler</code> feature, and specifies the library source path explicitly (as it’s not in the default location relative to this <code>Cargo.toml</code>). It’s fine to refer to a feature that you never define in <code>Cargo.toml</code> in your code, so <code>lib.rs</code> is still fine, and the panic handler will never be built when you build the crate with this <code>Cargo.toml</code>.</p>
<p>Now in the importing crate I use this <code>Cargo.toml</code> instead of the top-level one:</p>
<pre><code>[dependencies]
nostd_lib = { path = &quot;../nostd_lib/rlib&quot; }</code></pre>
<p>And it works fine. The downside is I have two <code>Cargo.toml</code> files now, but in my case that’s not a big deal, as my <code>Cargo.toml</code> is quite small and have no dependencies other than <code>libc</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>I hope this is helpful. If you know any better way to do conditional compilation based on crate types, or to solve the problem of generating usable <code>staticlib</code> and <code>rlib</code>s from a single <code>no_std</code> crate, let me know!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>You need a <code>panic_handler</code> even if you never panic in your crate (assuming that’s possible). For example, you can’t compile <code>fn main() {}</code> with <code>no_std</code>, <code>panic=abort</code>, and without a <code>panic_handler</code>: the compiler complains about the missing panic handler.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>If you’re working on a <code>no_std</code> crate I think you won’t be able to find a lot of libraries that you can use anyway.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>8 years of Haskell</title>
    <link href="http://osa1.net/posts/2020-06-30-8-years-of-haskell.html" />
    <id>http://osa1.net/posts/2020-06-30-8-years-of-haskell.html</id>
    <published>2020-06-30T00:00:00Z</published>
    <updated>2020-06-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>21 Jun 2020 was my last day at Well-Typed and as a GHC maintainer/developer. On 22nd I joined the programming language team at <a href="https://dfinity.org/">DFINITY</a> to work on the <a href="https://sdk.dfinity.org/docs/language-guide/motoko.html">Motoko programming language</a>.</p>
<p>Here’s the summary of my 8 years writing Haskell pretty much non-stop:</p>
<ul>
<li><p>In 2012 I wrote <a href="https://github.com/osa1/dolap-chat">my first Haskell program</a>, which was a chat server. I was reading <a href="http://book.realworldhaskell.org/">“Real World Haskell”</a> and <a href="http://learnyouahaskell.com/">“Learn You a Haskell for Great Good!”</a> at the time and applying what I learned on this project.</p></li>
<li><p>In the same year I implemented <a href="https://github.com/osa1/toylisp">my first programming language in Haskell</a>. I don’t remember much about this project, I think it may be just a few extensions over the excellent Haskell tutorial <a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">“Write Yourself a Scheme in 48 hours”</a>.</p></li>
<li><p>Also in 2012 I made a <a href="https://github.com/faylang/fay/commits?author=osa1">few commits</a> to the programming language Fay. This was my first contribution to an open source compiler not written by me.</p></li>
<li><p>In 2013 I worked on four PL implementations, two of which were implemented from scratch in Haskell: A <a href="https://github.com/osa1/MANTI">Prolog implementation</a> and a <a href="https://github.com/osa1/Shen.hs">K Lambda interpreter</a>.</p>
<p>The other two projects were: <a href="https://github.com/ozusrl/SubtypedQuotedML">A multi-stage ML-like language written in OCaml</a>, and K Framework (in Java).</p></li>
<li><p>In 2014 I was accepted to Google Summer of Code to work on <a href="https://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html">adding stack traces to GHCJS</a>. The project was successful, and I made <a href="https://github.com/ghcjs/ghcjs/graphs/contributors">88 commits</a> to GHCJS during this period.</p>
<p>This was my first introduction to GHC. I made only <a href="https://gitlab.haskell.org/ghc/ghc/commit/b3d9636af37cfafbc947b69dff5747065f437804">one commit</a> to GHC during this time, but I started reading the RTS and code generator to be able to implement cost-centre stacks in GHCJS, which taught me a lot.</p></li>
<li><p>Also in 2014, I briefly worked at a startup where I wrote Haskell.</p></li>
<li><p>In 2015 I joined Indiana University to do PhD in programming languages. In my first semester I worked on the paper <a href="http://ezyang.com/papers/ezyang15-cnf.pdf">“Efficient Communication and Collection with Compact Normal Forms”</a> which was about a GHC extension. The paper was published the same year at ICFP.</p></li>
<li><p>In the same year I briefly worked on a <a href="https://github.com/osa1/rho-torrent">torrent client in Haskell</a>.</p></li>
<li><p>According to git logs, 2015 was the year where I started making some larger commits to GHC. I think I made a few dozen commits that year. What was happening in the background is that I was working on unboxed sums. At Haskell Implementors Workshop in 2015 my advisor gave a presentation on <a href="https://osa1.net/posts/2015-11-13-data-repr-1.html">efficiency of data representation in Haskell</a>. I don’t remember how the story developed, but I think we also talked to a few people at ICFP on how to improve the situation, and one of the idea that came up was unboxed sums. IIRC I started working on it soon after returning from ICFP.</p>
<p>The first somewhat working version was implemented as a plugin, using lots of unsafe coercions under the hood. It was good enough to run some examples.</p></li>
<li><p>(In 2015, I also studied various metaprogramming and partial evaluation ideas quite extensively. If you look at my blog posts published in 2015 you’ll see a lot of related blog posts. There are also a few related git repositories in my Github page. I also gave a related talk at HIW 2015.)</p></li>
<li><p>Early 2016, I don’t remember what I was doing in too much detail. I remember taking an advanced OS class around that time and enjoying it very much. This was also the time where I started to realize that the tools I’m using (mostly GHC) are full of bugs, and very inefficient. I kept studying program transformation ideas, with the goal of making Haskell “fast”. I also started using C more, partly for the OS class, but also in my hobby projects. For example, the first commit of <a href="https://github.com/osa1/tiny">tiny</a> was made in January 2016 and <a href="https://github.com/osa1/tiny/commit/06accfabf941cb17c7efbb37dc55ed0c33dedc20">the code was in C</a>.</p></li>
<li><p>In mid-2016 I left Bloomington for Cambridge, UK, for an internship at Microsoft Research with SPJ. We mainly worked on implementing unboxed sums properly in the compiler (instead of as a hacky plugin), but I also did a lot of GHC maintenance work there with supervision of SPJ.</p>
<p>Unboxed sums was merged <a href="https://gitlab.haskell.org/ghc/ghc/-/commit/714bebff44076061d0a719c4eda2cfd213b7ac3d">during my time at MSR</a>.</p>
<p>In the rest of the internship I did a lot of reading, did GHC maintenance, and biked around Cambridge.</p></li>
<li><p>Most importantly, during my time at MSR I realized that I’m no longer interested in academic research. I don’t enjoy writing papers. I don’t feel like pushing a field forward while most of the tools I use every day are badly broken, inefficient, usually both. I started having job interviews while I was in the UK. I visited two companies for interviews, one in London, another one in Cambridge.</p>
<p>I also emailed my advisor, saying that I don’t want to come back to Bloomington.</p></li>
<li><p>Job interviews went badly, and I was back at Indiana University. Rest of 2016 was pretty horrible. I was depressed. I had no interest in research. I still <a href="https://dl.acm.org/doi/pdf/10.1145/2851141.2851142">helped publishing a paper</a>, but I did not enjoy the process.</p>
<p>I still spent my last semester somewhat productively. I took enough classes this semester to leave IU with a masters degree, instead of empty handed (I was a PhD student, not masters). I also had some good job interviews and met good people from the Haskell community.</p>
<p>By the end of 2016 I accepted a job offer and left IU with masters degree to write Haskell for a startup.</p></li>
<li><p>In 2017 I worked for this startup for a year. I wrote lots of networking and concurrent code, and learned a lot about these topics and exception handling in Haskell. Until this my Haskell experience was mainly in the context of compilers, so this was quite educational for me.</p>
<p>I left the company at the end of that year to join Well-Typed to work on GHC full-time.</p></li>
<li><p>My time at Well-Typed was great, but also full of challenges, mainly related to working remotely.</p>
<p>I worked on GHC between 30 and 40 hours a week (some weeks as little as 24 hours, but no less than that). Few weeks after I joined I started working on <a href="https://osa1.net/posts/2018-10-22-gc-work-presented.html">a new garbage collector</a> with a colleague. When I joined the project there were only type definitions in header files, and almost no code. I implemented the first sequential prototype of the new collector. After that we started collaborating more closely with my colleague while implementing the concurrent version. We found many bugs in both the design and implementation, and sorted out many edge cases during this time. I thoroughly enjoyed working on this project, even though it was clearly the most challenging project I ever worked on.</p>
<p>After the garbage collector I kept working as a maintainer until I left the company on a Sunday, Jun 21st, 2020. I made my last commit to <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3478">a merge request</a> that I was working on 21st.</p></li>
<li><p>On 22 Jun 2020 I joined <a href="https://dfinity.org/">DFINITY</a> to work on the <a href="https://sdk.dfinity.org/docs/language-guide/motoko.html">Motoko programming language</a>, and this is where the story ends.</p></li>
</ul>
<p>At the time of this writing I have 383 commits to GHC and I’m the 14th contributor with most commits. It feels bad to leave a project that I liked and contributed so much, but it’s also the right thing to do. After the GC was merged I started spending my time less and less productively, for many reasons, and I had lost my motivation to improve Haskell-the-language and GHC. Perhaps I can write more about these in another post.</p>]]></summary>
</entry>
<entry>
    <title>gdb breakpoints with conditions on backtrace</title>
    <link href="http://osa1.net/posts/2020-04-25-breakpoint-backtrace-conditionals.html" />
    <id>http://osa1.net/posts/2020-04-25-breakpoint-backtrace-conditionals.html</id>
    <published>2020-04-25T00:00:00Z</published>
    <updated>2020-04-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Being able so specify conditions in gdb breakpoints is quite useful. For example, if I’m interested in <code>mmap(NULL, ...)</code> calls I can do</p>
<pre><code>break mmap if addr == 0</code></pre>
<p>and gdb doesn’t break on <code>mmap</code> when the <code>addr == 0</code> condition doesn’t hold.</p>
<p>I’ve used this many times to great effect, but it’s not always sufficient, sometimes I need to break not when a variable or argument has a specific value but the function is called (directly or indirectly) from another function. For example, when debugging a GHC RTS issue I sometimes want to inspect <code>mmap</code> calls made by the garbage collector.</p>
<p>As far as I know this is not possible using the standard <code>break</code> syntax, but gdb provides a <a href="https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html">Python API</a> that allows setting breakpoints with conditions implemented in Python. Using this API it’s takes a few lines to implement this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> FrameBp(gdb.Breakpoint):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, spec, <span class="op">*</span>args, frame<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kwargs):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>        <span class="va">self</span>.frame <span class="op">=</span> frame</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        <span class="bu">super</span>(FrameBp, <span class="va">self</span>).<span class="fu">__init__</span>(spec, <span class="op">*</span>args, <span class="op">**</span>kwargs)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="kw">def</span> stop (<span class="va">self</span>):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        frame <span class="op">=</span> gdb.selected_frame().older()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="cf">while</span> frame:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>            <span class="cf">if</span> frame.name() <span class="op">==</span> <span class="va">self</span>.frame:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>            frame <span class="op">=</span> frame.older()</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">False</span></span></code></pre></div>
<p>When calling the constructor the first argument is the breakpoint specifier, which is basically the part after <code>break ...</code> in gdb’s break command. The <code>frame</code> argument is the function we look for before actually breaking. We only break if the function exists in the backtrace. Here’s an example use:</p>
<pre><code>&gt;&gt;&gt; python FrameBp(&quot;mmap&quot;, frame=&quot;GarbageCollect&quot;)
Breakpoint 1 at 0x7f3366243f00: file ../sysdeps/unix/sysv/linux/mmap64.c, line 44.</code></pre>
<p>This will only break on <code>mmap</code> if the backtrace has <code>GarbageCollect</code> at some point. An example backtrace when the breakpoint is hit:</p>
<pre><code>Breakpoint 1, __GI___mmap64 (addr=0x4200200000, len=1048576, prot=3, flags=50, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:44
44        if (offset &amp; MMAP_OFF_MASK)

&gt;&gt;&gt; bt
#0  __GI___mmap64 (addr=0x4200200000, len=1048576, prot=3, flags=50, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:44

...

#19 0x0000000003022c83 in GarbageCollect (collect_gen=0, do_heap_census=false, deadlock_detect=false, gc_type=0, cap=0x37ef500
&lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:449

...</code></pre>
<p>With some effort you could probably turn this into a proper gdb command and run it without the <code>python ...</code> part, but so far this works good enough for me.</p>]]></summary>
</entry>
<entry>
    <title>New blog post published on Well-Typed's blog</title>
    <link href="http://osa1.net/posts/2020-03-25-new-blog-post.html" />
    <id>http://osa1.net/posts/2020-03-25-new-blog-post.html</id>
    <published>2020-03-25T00:00:00Z</published>
    <updated>2020-03-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently published a new post on <a href="http://blog.well-typed.com/">Well-Typed’s blog</a>: <a href="http://www.well-typed.com/blog/2020/03/functions-in-compact-regions/">“The problem with adding functions to compact regions”</a>.</p>
<p>It’s also shared on <a href="https://twitter.com/welltyped/status/1242765765658447873">Twitter</a> and <a href="https://www.reddit.com/r/haskell/comments/foob2l/the_problem_with_adding_functions_to_compact/">/r/haskell</a>. If you have any questions/comments feel free to ping me in any of these places, or add a comment below!</p>]]></summary>
</entry>
<entry>
    <title>Knot-tying: two more examples, and an alternative</title>
    <link href="http://osa1.net/posts/2020-02-27-knot-tying-an-alternative.html" />
    <id>http://osa1.net/posts/2020-02-27-knot-tying-an-alternative.html</id>
    <published>2020-02-27T00:00:00Z</published>
    <updated>2020-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="/posts/2020-02-21-knot-tying-why-how-opinions.html">previous post</a> we’ve looked at a representation of expressions in a programming language, what the representation makes easy and where we have to use knot-tying.</p>
<p>In this post I’m going to give two more examples, using the same expression representation from the previous post, and then talk about how to implement our passes using a different representation, without knot-tying.</p>
<h1 id="example-attaching-typing-information-to-ids">Example: attaching typing information to Ids</h1>
<p>Previously we attached arity and unfolding information to <code>Id</code>s. Now suppose that our language is typed, and up to some point our transformations rely on typing information. Similar to arity and unfolding fields we add one more field to <code>Id</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  { <span class="op">..</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  ,<span class="ot"> idType ::</span> <span class="dt">Maybe</span> <span class="dt">Type</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>The <code>Maybe</code> part is because when we no longer need the types we want to be able to clear the type fields to make the AST smaller. While we have only one heap object per <code>Id</code>, in an average program there’s still a lot of different <code>Id</code>s, and <code>Type</code> representation can get quite large, so this is worthwhile. This makes the working set smaller, which causes less GC work and improves compiler performance.</p>
<p>In our cyclic AST representation the only way to implement this without losing sharing is with a full-pass over the entire program, using knot-tying. The code is similar to the ones in the previous post.</p>
<h1 id="example-attaching-unfoldings-to-ids">Example: attaching unfoldings to Ids</h1>
<p>Remember that in the previous post we represented the AST as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  }</span></code></pre></div>
<p>In this representation if I have a recursive definition like</p>
<pre><code>let fac = \x . if x then x * fac (x - 1) else 1 in fac 5</code></pre>
<p>In <code>fac</code> used in lambda body I want to be able to do <code>idUnfolding</code> and get the definition of this lambda. So the lambda refers to the <code>Id</code> for <code>fac</code>, and <code>fac</code> refers to the lambda in its <code>idUnfolding</code> field, forming a cycle.</p>
<p>In this representation only way to implement this is with knot-tying. An implementation that maintains a map from binders to their RHSs to update unfoldings of <code>Id</code>s in occurrence position does not work, because when we update an occurrence of the binder in its own RHS (i.e. in a recursive <code>let</code>) we end up invalidating the <code>RHS</code> that we’ve added to the map.</p>
<p>Here’s a knot-tying implementation that adds unfoldings (only the interesting bits):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>addUnfoldings <span class="ot">=</span> go M.empty</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    go ids e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (M.lookup (idName <span class="fu">id</span>) ids))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>      <span class="dt">Let</span> bndr rhs body <span class="ot">-&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>          ids&#39; <span class="ot">=</span> M.insert (idName bndr) bndr&#39; ids</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>          rhs&#39; <span class="ot">=</span> go ids&#39; rhs</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; }</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>          <span class="dt">Let</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; } rhs&#39; (go ids&#39; body)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>      <span class="op">...</span></span></code></pre></div>
<p>As before we tie the knot in <code>let</code> case and use it in <code>Id</code> case.</p>
<p>It’s also possible to initialize <code>idUnfolding</code> fields when parsing, using monadic knot-tying (<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Fix.html">MonadFix</a>). Full code is shown at the end of this post, but the interesting bit is when parsing <code>let</code>s and <code>Id</code>s:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">parseLet ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>parseLet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;let&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    id_name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;=&#39;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    (<span class="fu">id</span>, rhs) <span class="ot">&lt;-</span> mfix <span class="op">$</span> \ <span class="op">~</span>(id_, _rhs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>      modify (Map.insert id_name id_)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>      rhs <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>      <span class="fu">return</span> (<span class="dt">Id</span>{ idName <span class="ot">=</span> id_name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }, rhs)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;in&quot;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Let</span> <span class="fu">id</span> rhs body)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span class="ot">parseId&#39; ::</span> <span class="dt">Parser</span> <span class="dt">Id</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>parseId&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>    id_map <span class="ot">&lt;-</span> get</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>    <span class="kw">let</span> def <span class="ot">=</span> <span class="dt">Id</span>{ idName <span class="ot">=</span> name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>    <span class="fu">return</span> (fromMaybe def (Map.lookup name id_map))</span></code></pre></div>
<p>The idea is very similar. When parsing a <code>let</code> we add a thunk for the binder with correct unfolding to a map. The map is then used when parsing <code>Id</code>s in the RHS and body of the <code>let</code>.</p>
<h1 id="an-alternative">An alternative</h1>
<p>A well-known way of associating information with identifiers in a compiler is by using a “symbol table”. Instead of adding information about <code>Id</code>s directly in the <code>Id</code> fields, we maintain a table (or multiple tables) that map <code>Id</code>s to the relevant information. Here’s one way to do this in our language:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">String</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">IdInfo</span> <span class="ot">=</span> <span class="dt">IdInfo</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  {<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  }</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SymTbl</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">IdInfo</span></span></code></pre></div>
<p>In this representation we have to refer to the table for <code>idArity</code> or <code>idUnfolding</code>. That’s slightly more work than the previous representation where we could simply use the fields of an <code>Id</code>, but a lot of other things become much simpler and efficient.</p>
<p>Here’s <code>dropUnusedBindings</code> in this representation (only the interesting bits, full code is at the end of this post):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> <span class="dt">Expr</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="fu">fmap</span> <span class="fu">snd</span> <span class="op">.</span> go Set.empty</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    go free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>        <span class="kw">if</span> Set.member bndr free2 <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>          setIdArity bndr (countLambdas e1&#39;)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>          <span class="fu">return</span> (Set.delete bndr (Set.union free1 free2), <span class="dt">Let</span> bndr e1&#39; e2&#39;)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>        <span class="kw">else</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>          <span class="fu">return</span> (free2, e2&#39;)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>      <span class="op">...</span></span></code></pre></div>
<p>Our pass is now stateful (updates the symbol table) and written in monadic style. Knot-tying is gone. We update the symbol table after processing a <code>let</code> RHS. Because <code>Id</code>s no longer have the arity information we don’t need to update anything other than the symbol table.</p>
<p>It’s now trivial to implement <code>addUnfoldings</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>addUnfoldings e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="dt">IdE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>      addUnfoldings body</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>    <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>      addUnfoldings e3</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>    <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>      setIdUnfolding bndr e1</span></code></pre></div>
<p>Doing it during parsing is also trivial, and shown in the full code at the end of this post. Updating typing information when we no longer need them is simply</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">dropTypes ::</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>dropTypes <span class="ot">=</span> modify (Map.map (\id_info <span class="ot">-&gt;</span> id_info{ idType <span class="ot">=</span> <span class="dt">Nothing</span> }))</span></code></pre></div>
<p>We could also maintain a separate table for typing information, in which case all we had to do would be to stop using that table.</p>
<p>Easy!</p>
<h1 id="final-remarks">Final remarks</h1>
<p>Cyclic AST representation in a purely functional language necessitates knot-tying and relies on lazy evaluation. A well-known alternative is using symbol tables. It works across languages (does not rely on lazy evaluation) and keeps the code simple.</p>
<p>Cyclic representations make using the information easier, while symbol tables make updating easier. Code for updating the information is shown above and the previous post. For using the information, compare:</p>
<pre><code>-- Get the information in a cyclic representation
... (idUnfolding id) ...

-- Get the information using a symbol table
arity &lt;- getIdUnfolding id</code></pre>
<p>To me the monadic version is not too bad in terms of verbosity or convenience, especially because Haskell makes state passing so easy.</p>
<p>Some of the problems with knot-tying is as explained at the end of the <a href="/posts/2020-02-21-knot-tying-why-how-opinions.html">previous post</a>. What I did not mention in the previous post is the problems with efficiency, which are demonstrated better in this post.</p>
<ul>
<li><p>In the “typing information” example, with the cyclic representation I need to copy the entire AST to update every single <code>Id</code> occurrence and binder. With the symbol table I need to update just the table, which is much smaller than the AST.</p></li>
<li><p>In the unfolding example, with the cyclic representation I again need to copy the entire AST or use <code>MonadFix</code> if I’m doing it in parsing. With a symbol table the pass does not update the AST, only updates the table. If I’m doing it in parsing then I simply add an entry to the table after parsing a <code>let</code>. (full code at the end of this post)</p></li>
</ul>
<p>In use sites, <code>getIdArity</code> (a map lookup) does more work than <code>idArity</code> (just follows a pointer). While I don’t have any benchmarks on this, I doubt that this is bad enough to make cyclic representation and knot-tying preferable.</p>
<p>Examples in these two posts are inspired by GHC:</p>
<ul>
<li>GHC keeps information about <code>Id</code>s in an <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FbasicTypes%2FVar.hs#L251"><code>Id</code> field</a> with type <code>IdInfo</code>.</li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FbasicTypes%2FIdInfo.hs#L242-275"><code>IdInfo</code></a> type holds information like arity and unfolding.</li>
<li>For type information <code>Id</code> has another field: <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FbasicTypes%2FVar.hs#L248"><code>varType</code></a>.</li>
<li>The process of throwing away information that are no longer needed is called “zapping”. It happens in many places in GHC, one example is the tidying pass (prepares code for interface file generation) that <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2FGHC%2FIface%2FTidy.hs#L1210">zaps unfoldings</a>.</li>
<li>Knot-tying is used in many places in the compiler, <a href="https://gitlab.haskell.org/ghc/ghc/blob/1b1067d14b656bbbfa7c47f156ec2700c9751549/compiler%2Fmain%2FUpdateCafInfos.hs#L36">here’s an example</a> where we use knot-tying to update <code>IdInfo</code>s with code generator-generated information.</li>
</ul>
<p>In the first post I mostly argued that knot-tying makes things more complicated, and in this post I showed that knot-tying is necessary because of the cyclic representation. If we want to do the same without knot-tying we either have to introduce mutable references (e.g. <code>IORef</code>s) in our AST (not shown in this post), or have to use a non-cyclic representation with symbol tables.</p>
<p>Between these two representations, I think non-cyclic representation with symbol tables is a better choice.</p>
<details>
<p><summary>Full code (knot-tying)</summary></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">-- Tried with GHC 8.6.4</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a><span class="co">-- mtl-2.2</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a><span class="co">-- containers-0.6</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a><span class="co">-- megaparsec-7.0</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a><span class="co">-- pretty-show-1.10</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true"></a>  }</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true"></a></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">Id</span> name arity _) <span class="ot">=</span> <span class="st">&quot;(Id &quot;</span> <span class="op">++</span> <span class="fu">show</span> name <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="fu">show</span> arity <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true"></a></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true"></a><span class="co">-- Initializing unfolding fields in parse time via MonadFix</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true"></a></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">IdMap</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true"></a></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">String</span> <span class="dt">String</span> (<span class="dt">State</span> <span class="dt">IdMap</span>)</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true"></a></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true"></a><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true"></a>parseExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true"></a>    exprs <span class="ot">&lt;-</span> some <span class="op">$</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true"></a>      choice <span class="op">$</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true"></a>      <span class="fu">map</span> (\p <span class="ot">-&gt;</span> p <span class="op">&lt;*</span> space)</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true"></a>        [ parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true"></a>          parseLet, try parseId ]</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true"></a>    <span class="fu">return</span> (foldl1&#39; <span class="dt">App</span> exprs)</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true"></a></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true"></a>parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true"></a>  parseLet,<span class="ot"> parseId ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true"></a></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true"></a>parseParens <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;(&#39;</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true"></a>    space</span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true"></a>    expr <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true"></a>    <span class="fu">return</span> expr</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true"></a></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true"></a>parseIf <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;if&quot;</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true"></a>    space</span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true"></a>    condE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true"></a></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;then&quot;</span></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true"></a>    space</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true"></a>    thenE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;else&quot;</span></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true"></a>    space</span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true"></a>    elseE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IfE</span> condE thenE elseE)</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true"></a></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true"></a>parseLam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;\\&#39;</span></span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true"></a>    space</span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true"></a>    <span class="fu">id</span> <span class="ot">&lt;-</span> parseId&#39;</span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true"></a>    space</span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;.&#39;</span></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true"></a>    space</span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Lam</span> <span class="fu">id</span> body)</span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true"></a></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true"></a>parseInt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true"></a>    chars <span class="ot">&lt;-</span> some digitChar</span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IntE</span> (<span class="fu">read</span> chars))</span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true"></a></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true"></a>parseLet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;let&quot;</span></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true"></a>    space</span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true"></a>    id_name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true"></a>    space</span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;=&#39;</span></span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true"></a>    space</span>
<span id="cb11-107"><a href="#cb11-107" aria-hidden="true"></a></span>
<span id="cb11-108"><a href="#cb11-108" aria-hidden="true"></a>    (<span class="fu">id</span>, rhs) <span class="ot">&lt;-</span> mfix <span class="op">$</span> \ <span class="op">~</span>(id_, _rhs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-109"><a href="#cb11-109" aria-hidden="true"></a>      modify (Map.insert id_name id_)</span>
<span id="cb11-110"><a href="#cb11-110" aria-hidden="true"></a>      rhs <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-111"><a href="#cb11-111" aria-hidden="true"></a>      <span class="fu">return</span> (<span class="dt">Id</span>{ idName <span class="ot">=</span> id_name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }, rhs)</span>
<span id="cb11-112"><a href="#cb11-112" aria-hidden="true"></a></span>
<span id="cb11-113"><a href="#cb11-113" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;in&quot;</span></span>
<span id="cb11-114"><a href="#cb11-114" aria-hidden="true"></a>    space</span>
<span id="cb11-115"><a href="#cb11-115" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb11-116"><a href="#cb11-116" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Let</span> <span class="fu">id</span> rhs body)</span>
<span id="cb11-117"><a href="#cb11-117" aria-hidden="true"></a></span>
<span id="cb11-118"><a href="#cb11-118" aria-hidden="true"></a>parseId <span class="ot">=</span> <span class="dt">IdE</span> <span class="op">&lt;$&gt;</span> parseId&#39;</span>
<span id="cb11-119"><a href="#cb11-119" aria-hidden="true"></a></span>
<span id="cb11-120"><a href="#cb11-120" aria-hidden="true"></a><span class="ot">kws ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span></span>
<span id="cb11-121"><a href="#cb11-121" aria-hidden="true"></a>kws <span class="ot">=</span> Set.fromList [<span class="st">&quot;if&quot;</span>, <span class="st">&quot;then&quot;</span>, <span class="st">&quot;else&quot;</span>, <span class="st">&quot;let&quot;</span>, <span class="st">&quot;in&quot;</span>]</span>
<span id="cb11-122"><a href="#cb11-122" aria-hidden="true"></a></span>
<span id="cb11-123"><a href="#cb11-123" aria-hidden="true"></a><span class="ot">parseIdName ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb11-124"><a href="#cb11-124" aria-hidden="true"></a>parseIdName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-125"><a href="#cb11-125" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> some letterChar</span>
<span id="cb11-126"><a href="#cb11-126" aria-hidden="true"></a>    guard (<span class="fu">not</span> (Set.member name kws))</span>
<span id="cb11-127"><a href="#cb11-127" aria-hidden="true"></a>    <span class="fu">return</span> name</span>
<span id="cb11-128"><a href="#cb11-128" aria-hidden="true"></a></span>
<span id="cb11-129"><a href="#cb11-129" aria-hidden="true"></a><span class="ot">parseId&#39; ::</span> <span class="dt">Parser</span> <span class="dt">Id</span></span>
<span id="cb11-130"><a href="#cb11-130" aria-hidden="true"></a>parseId&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-131"><a href="#cb11-131" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> parseIdName</span>
<span id="cb11-132"><a href="#cb11-132" aria-hidden="true"></a>    id_map <span class="ot">&lt;-</span> get</span>
<span id="cb11-133"><a href="#cb11-133" aria-hidden="true"></a>    <span class="kw">let</span> def <span class="ot">=</span> <span class="dt">Id</span>{ idName <span class="ot">=</span> name, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb11-134"><a href="#cb11-134" aria-hidden="true"></a>    <span class="fu">return</span> (fromMaybe def (Map.lookup name id_map))</span>
<span id="cb11-135"><a href="#cb11-135" aria-hidden="true"></a></span>
<span id="cb11-136"><a href="#cb11-136" aria-hidden="true"></a><span class="ot">testPgm ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-137"><a href="#cb11-137" aria-hidden="true"></a>testPgm pgm <span class="ot">=</span></span>
<span id="cb11-138"><a href="#cb11-138" aria-hidden="true"></a>    <span class="kw">case</span> evalState (runParserT parseExpr <span class="st">&quot;&quot;</span> pgm) Map.empty <span class="kw">of</span></span>
<span id="cb11-139"><a href="#cb11-139" aria-hidden="true"></a>      <span class="dt">Left</span> (<span class="ot">err_bundle ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span></span>
<span id="cb11-140"><a href="#cb11-140" aria-hidden="true"></a>        <span class="fu">error</span> (errorBundlePretty err_bundle)</span>
<span id="cb11-141"><a href="#cb11-141" aria-hidden="true"></a>      <span class="dt">Right</span> expr <span class="ot">-&gt;</span></span>
<span id="cb11-142"><a href="#cb11-142" aria-hidden="true"></a>        expr</span>
<span id="cb11-143"><a href="#cb11-143" aria-hidden="true"></a></span>
<span id="cb11-144"><a href="#cb11-144" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> [<span class="dt">Char</span>] <span class="kw">where</span></span>
<span id="cb11-145"><a href="#cb11-145" aria-hidden="true"></a>    showErrorComponent x <span class="ot">=</span> x</span>
<span id="cb11-146"><a href="#cb11-146" aria-hidden="true"></a></span>
<span id="cb11-147"><a href="#cb11-147" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb11-148"><a href="#cb11-148" aria-hidden="true"></a><span class="co">-- Initializing unfoldings with knot-tying</span></span>
<span id="cb11-149"><a href="#cb11-149" aria-hidden="true"></a></span>
<span id="cb11-150"><a href="#cb11-150" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-151"><a href="#cb11-151" aria-hidden="true"></a>addUnfoldings <span class="ot">=</span> go Map.empty</span>
<span id="cb11-152"><a href="#cb11-152" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-153"><a href="#cb11-153" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-154"><a href="#cb11-154" aria-hidden="true"></a>    go ids e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb11-155"><a href="#cb11-155" aria-hidden="true"></a></span>
<span id="cb11-156"><a href="#cb11-156" aria-hidden="true"></a>      <span class="co">-- Interesting bits ------------------------------------------------------</span></span>
<span id="cb11-157"><a href="#cb11-157" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb11-158"><a href="#cb11-158" aria-hidden="true"></a>        <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (Map.lookup (idName <span class="fu">id</span>) ids))</span>
<span id="cb11-159"><a href="#cb11-159" aria-hidden="true"></a></span>
<span id="cb11-160"><a href="#cb11-160" aria-hidden="true"></a>      <span class="dt">Let</span> bndr rhs body <span class="ot">-&gt;</span></span>
<span id="cb11-161"><a href="#cb11-161" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb11-162"><a href="#cb11-162" aria-hidden="true"></a>          ids&#39; <span class="ot">=</span> Map.insert (idName bndr) bndr&#39; ids</span>
<span id="cb11-163"><a href="#cb11-163" aria-hidden="true"></a>          rhs&#39; <span class="ot">=</span> go ids&#39; rhs</span>
<span id="cb11-164"><a href="#cb11-164" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; }</span>
<span id="cb11-165"><a href="#cb11-165" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb11-166"><a href="#cb11-166" aria-hidden="true"></a>          <span class="dt">Let</span> bndr{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs&#39; } rhs&#39; (go ids&#39; body)</span>
<span id="cb11-167"><a href="#cb11-167" aria-hidden="true"></a>      <span class="co">--------------------------------------------------------------------------</span></span>
<span id="cb11-168"><a href="#cb11-168" aria-hidden="true"></a></span>
<span id="cb11-169"><a href="#cb11-169" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb11-170"><a href="#cb11-170" aria-hidden="true"></a>        e</span>
<span id="cb11-171"><a href="#cb11-171" aria-hidden="true"></a></span>
<span id="cb11-172"><a href="#cb11-172" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb11-173"><a href="#cb11-173" aria-hidden="true"></a>        <span class="dt">Lam</span> arg (go ids body)</span>
<span id="cb11-174"><a href="#cb11-174" aria-hidden="true"></a></span>
<span id="cb11-175"><a href="#cb11-175" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb11-176"><a href="#cb11-176" aria-hidden="true"></a>        <span class="dt">App</span> (go ids e1) (go ids e2)</span>
<span id="cb11-177"><a href="#cb11-177" aria-hidden="true"></a></span>
<span id="cb11-178"><a href="#cb11-178" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span></span>
<span id="cb11-179"><a href="#cb11-179" aria-hidden="true"></a>        <span class="dt">IfE</span> (go ids e1) (go ids e2) (go ids e3)</span></code></pre></div>
</details>
<details>
<p><summary>Full code (symbol table)</summary></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">-- Tried with GHC 8.6.4</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a><span class="co">-- mtl-2.2</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a><span class="co">-- containers-0.6</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="co">-- megaparsec-7.0</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a><span class="co">-- pretty-show-1.10</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">String</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">IdInfo</span> <span class="ot">=</span> <span class="dt">IdInfo</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>  {<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a>  ,<span class="ot"> idType ::</span> <span class="dt">Maybe</span> <span class="dt">Type</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a>    <span class="co">-- ^ Type of the id.</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a>  }</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Type</span> <span class="ot">=</span> <span class="dt">Type</span> <span class="co">-- Assume a large type</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true"></a></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">IdInfo</span> <span class="kw">where</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">IdInfo</span> arity _ _) <span class="ot">=</span> <span class="st">&quot;(IdInfo &quot;</span> <span class="op">++</span> <span class="fu">show</span> arity <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true"></a></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SymTbl</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">IdInfo</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true"></a></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true"></a><span class="ot">getIdInfo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> (<span class="dt">Maybe</span> <span class="dt">IdInfo</span>)</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true"></a>getIdInfo <span class="fu">id</span> <span class="ot">=</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true"></a>    Map.lookup <span class="fu">id</span> <span class="op">&lt;$&gt;</span> get</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true"></a></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true"></a><span class="ot">setIdArity ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true"></a>setIdArity <span class="fu">id</span> arity <span class="ot">=</span> modify (Map.alter alter <span class="fu">id</span>)</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true"></a>    alter <span class="dt">Nothing</span> <span class="ot">=</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true"></a>      <span class="dt">Just</span> <span class="dt">IdInfo</span>{ idArity <span class="ot">=</span> arity, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span>, idType <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true"></a>    alter (<span class="dt">Just</span> id_info) <span class="ot">=</span></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true"></a>      <span class="dt">Just</span> id_info{ idArity <span class="ot">=</span> arity }</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true"></a></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true"></a><span class="ot">setIdUnfolding ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true"></a>setIdUnfolding <span class="fu">id</span> unfolding <span class="ot">=</span> modify (Map.alter alter <span class="fu">id</span>)</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true"></a>    alter <span class="dt">Nothing</span> <span class="ot">=</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true"></a>      <span class="dt">Just</span> <span class="dt">IdInfo</span>{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> unfolding, idArity <span class="ot">=</span> <span class="dv">0</span>, idType <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true"></a>    alter (<span class="dt">Just</span> id_info) <span class="ot">=</span></span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true"></a>      <span class="dt">Just</span> id_info{ idUnfolding <span class="ot">=</span> <span class="dt">Just</span> unfolding }</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true"></a></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true"></a><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true"></a>countLambdas (<span class="dt">Lam</span> _ rhs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> countLambdas rhs</span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true"></a>countLambdas _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true"></a></span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> <span class="dt">Expr</span></span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true"></a>    <span class="fu">fmap</span> <span class="fu">snd</span> <span class="op">.</span> go Set.empty</span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true"></a>    go free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true"></a></span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb12-85"><a href="#cb12-85" aria-hidden="true"></a>        <span class="fu">return</span> (Set.insert <span class="fu">id</span> free_vars, e0)</span>
<span id="cb12-86"><a href="#cb12-86" aria-hidden="true"></a></span>
<span id="cb12-87"><a href="#cb12-87" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-88"><a href="#cb12-88" aria-hidden="true"></a>        <span class="fu">return</span> (free_vars, e0)</span>
<span id="cb12-89"><a href="#cb12-89" aria-hidden="true"></a></span>
<span id="cb12-90"><a href="#cb12-90" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-91"><a href="#cb12-91" aria-hidden="true"></a>        (free_vars&#39;, body&#39;) <span class="ot">&lt;-</span> go free_vars body</span>
<span id="cb12-92"><a href="#cb12-92" aria-hidden="true"></a>        <span class="fu">return</span> (Set.delete arg free_vars&#39;, <span class="dt">Lam</span> arg body&#39;)</span>
<span id="cb12-93"><a href="#cb12-93" aria-hidden="true"></a></span>
<span id="cb12-94"><a href="#cb12-94" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-95"><a href="#cb12-95" aria-hidden="true"></a>        (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb12-96"><a href="#cb12-96" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb12-97"><a href="#cb12-97" aria-hidden="true"></a>        <span class="fu">return</span> (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</span>
<span id="cb12-98"><a href="#cb12-98" aria-hidden="true"></a></span>
<span id="cb12-99"><a href="#cb12-99" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-100"><a href="#cb12-100" aria-hidden="true"></a>        (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb12-101"><a href="#cb12-101" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb12-102"><a href="#cb12-102" aria-hidden="true"></a>        (free3, e3&#39;) <span class="ot">&lt;-</span> go free_vars e3</span>
<span id="cb12-103"><a href="#cb12-103" aria-hidden="true"></a>        <span class="fu">return</span> (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</span>
<span id="cb12-104"><a href="#cb12-104" aria-hidden="true"></a></span>
<span id="cb12-105"><a href="#cb12-105" aria-hidden="true"></a>      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-106"><a href="#cb12-106" aria-hidden="true"></a>        (free2, e2&#39;) <span class="ot">&lt;-</span> go free_vars e2</span>
<span id="cb12-107"><a href="#cb12-107" aria-hidden="true"></a>        <span class="kw">if</span> Set.member bndr free2 <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb12-108"><a href="#cb12-108" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">&lt;-</span> go free_vars e1</span>
<span id="cb12-109"><a href="#cb12-109" aria-hidden="true"></a>          trace (ppShow e1&#39;) (<span class="fu">return</span> ())</span>
<span id="cb12-110"><a href="#cb12-110" aria-hidden="true"></a>          setIdArity bndr (countLambdas e1&#39;)</span>
<span id="cb12-111"><a href="#cb12-111" aria-hidden="true"></a>          <span class="fu">return</span> (Set.delete bndr (Set.union free1 free2), <span class="dt">Let</span> bndr e1&#39; e2&#39;)</span>
<span id="cb12-112"><a href="#cb12-112" aria-hidden="true"></a>        <span class="kw">else</span></span>
<span id="cb12-113"><a href="#cb12-113" aria-hidden="true"></a>          <span class="fu">return</span> (free2, e2&#39;)</span>
<span id="cb12-114"><a href="#cb12-114" aria-hidden="true"></a></span>
<span id="cb12-115"><a href="#cb12-115" aria-hidden="true"></a><span class="ot">addUnfoldings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-116"><a href="#cb12-116" aria-hidden="true"></a>addUnfoldings e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb12-117"><a href="#cb12-117" aria-hidden="true"></a></span>
<span id="cb12-118"><a href="#cb12-118" aria-hidden="true"></a>    <span class="dt">IdE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-119"><a href="#cb12-119" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb12-120"><a href="#cb12-120" aria-hidden="true"></a></span>
<span id="cb12-121"><a href="#cb12-121" aria-hidden="true"></a>    <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-122"><a href="#cb12-122" aria-hidden="true"></a>      <span class="fu">return</span> ()</span>
<span id="cb12-123"><a href="#cb12-123" aria-hidden="true"></a></span>
<span id="cb12-124"><a href="#cb12-124" aria-hidden="true"></a>    <span class="dt">Lam</span> _ body <span class="ot">-&gt;</span></span>
<span id="cb12-125"><a href="#cb12-125" aria-hidden="true"></a>      addUnfoldings body</span>
<span id="cb12-126"><a href="#cb12-126" aria-hidden="true"></a></span>
<span id="cb12-127"><a href="#cb12-127" aria-hidden="true"></a>    <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-128"><a href="#cb12-128" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb12-129"><a href="#cb12-129" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb12-130"><a href="#cb12-130" aria-hidden="true"></a></span>
<span id="cb12-131"><a href="#cb12-131" aria-hidden="true"></a>    <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-132"><a href="#cb12-132" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb12-133"><a href="#cb12-133" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb12-134"><a href="#cb12-134" aria-hidden="true"></a>      addUnfoldings e3</span>
<span id="cb12-135"><a href="#cb12-135" aria-hidden="true"></a></span>
<span id="cb12-136"><a href="#cb12-136" aria-hidden="true"></a>    <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-137"><a href="#cb12-137" aria-hidden="true"></a>      addUnfoldings e1</span>
<span id="cb12-138"><a href="#cb12-138" aria-hidden="true"></a>      addUnfoldings e2</span>
<span id="cb12-139"><a href="#cb12-139" aria-hidden="true"></a>      setIdUnfolding bndr e1</span>
<span id="cb12-140"><a href="#cb12-140" aria-hidden="true"></a></span>
<span id="cb12-141"><a href="#cb12-141" aria-hidden="true"></a><span class="ot">dropTypes ::</span> <span class="dt">State</span> <span class="dt">SymTbl</span> ()</span>
<span id="cb12-142"><a href="#cb12-142" aria-hidden="true"></a>dropTypes <span class="ot">=</span> modify (Map.map (\id_info <span class="ot">-&gt;</span> id_info{ idType <span class="ot">=</span> <span class="dt">Nothing</span> }))</span>
<span id="cb12-143"><a href="#cb12-143" aria-hidden="true"></a></span>
<span id="cb12-144"><a href="#cb12-144" aria-hidden="true"></a><span class="ot">pgm ::</span> <span class="dt">Expr</span></span>
<span id="cb12-145"><a href="#cb12-145" aria-hidden="true"></a>pgm <span class="ot">=</span> <span class="dt">Let</span> <span class="st">&quot;fac&quot;</span> rhs body</span>
<span id="cb12-146"><a href="#cb12-146" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-147"><a href="#cb12-147" aria-hidden="true"></a>    rhs <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">IfE</span> (<span class="dt">IdE</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;*&quot;</span>) (<span class="dt">IdE</span> <span class="st">&quot;x&quot;</span>))</span>
<span id="cb12-148"><a href="#cb12-148" aria-hidden="true"></a>                                      (<span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;fac&quot;</span>)</span>
<span id="cb12-149"><a href="#cb12-149" aria-hidden="true"></a>                                           (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;-&quot;</span>) (<span class="dt">IdE</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb12-150"><a href="#cb12-150" aria-hidden="true"></a>                                 (<span class="dt">IntE</span> <span class="dv">1</span>))</span>
<span id="cb12-151"><a href="#cb12-151" aria-hidden="true"></a>    body <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> <span class="st">&quot;fac&quot;</span>) (<span class="dt">IntE</span> <span class="dv">5</span>)</span>
<span id="cb12-152"><a href="#cb12-152" aria-hidden="true"></a></span>
<span id="cb12-153"><a href="#cb12-153" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb12-154"><a href="#cb12-154" aria-hidden="true"></a><span class="co">-- Initializing unfolding fields in parse time, the boring way</span></span>
<span id="cb12-155"><a href="#cb12-155" aria-hidden="true"></a></span>
<span id="cb12-156"><a href="#cb12-156" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">String</span> <span class="dt">String</span> (<span class="dt">State</span> <span class="dt">SymTbl</span>)</span>
<span id="cb12-157"><a href="#cb12-157" aria-hidden="true"></a></span>
<span id="cb12-158"><a href="#cb12-158" aria-hidden="true"></a><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb12-159"><a href="#cb12-159" aria-hidden="true"></a>parseExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-160"><a href="#cb12-160" aria-hidden="true"></a>    exprs <span class="ot">&lt;-</span> some <span class="op">$</span></span>
<span id="cb12-161"><a href="#cb12-161" aria-hidden="true"></a>      choice <span class="op">$</span></span>
<span id="cb12-162"><a href="#cb12-162" aria-hidden="true"></a>      <span class="fu">map</span> (\p <span class="ot">-&gt;</span> p <span class="op">&lt;*</span> space)</span>
<span id="cb12-163"><a href="#cb12-163" aria-hidden="true"></a>        [ parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb12-164"><a href="#cb12-164" aria-hidden="true"></a>          parseLet, try parseId ]</span>
<span id="cb12-165"><a href="#cb12-165" aria-hidden="true"></a>    <span class="fu">return</span> (foldl1&#39; <span class="dt">App</span> exprs)</span>
<span id="cb12-166"><a href="#cb12-166" aria-hidden="true"></a></span>
<span id="cb12-167"><a href="#cb12-167" aria-hidden="true"></a>parseParens, parseIf, parseLam, parseInt,</span>
<span id="cb12-168"><a href="#cb12-168" aria-hidden="true"></a>  parseLet,<span class="ot"> parseId ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb12-169"><a href="#cb12-169" aria-hidden="true"></a></span>
<span id="cb12-170"><a href="#cb12-170" aria-hidden="true"></a>parseParens <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-171"><a href="#cb12-171" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;(&#39;</span></span>
<span id="cb12-172"><a href="#cb12-172" aria-hidden="true"></a>    space</span>
<span id="cb12-173"><a href="#cb12-173" aria-hidden="true"></a>    expr <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-174"><a href="#cb12-174" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb12-175"><a href="#cb12-175" aria-hidden="true"></a>    <span class="fu">return</span> expr</span>
<span id="cb12-176"><a href="#cb12-176" aria-hidden="true"></a></span>
<span id="cb12-177"><a href="#cb12-177" aria-hidden="true"></a>parseIf <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-178"><a href="#cb12-178" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;if&quot;</span></span>
<span id="cb12-179"><a href="#cb12-179" aria-hidden="true"></a>    space</span>
<span id="cb12-180"><a href="#cb12-180" aria-hidden="true"></a>    condE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-181"><a href="#cb12-181" aria-hidden="true"></a></span>
<span id="cb12-182"><a href="#cb12-182" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;then&quot;</span></span>
<span id="cb12-183"><a href="#cb12-183" aria-hidden="true"></a>    space</span>
<span id="cb12-184"><a href="#cb12-184" aria-hidden="true"></a>    thenE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-185"><a href="#cb12-185" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;else&quot;</span></span>
<span id="cb12-186"><a href="#cb12-186" aria-hidden="true"></a>    space</span>
<span id="cb12-187"><a href="#cb12-187" aria-hidden="true"></a>    elseE <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-188"><a href="#cb12-188" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IfE</span> condE thenE elseE)</span>
<span id="cb12-189"><a href="#cb12-189" aria-hidden="true"></a></span>
<span id="cb12-190"><a href="#cb12-190" aria-hidden="true"></a>parseLam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-191"><a href="#cb12-191" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;\\&#39;</span></span>
<span id="cb12-192"><a href="#cb12-192" aria-hidden="true"></a>    space</span>
<span id="cb12-193"><a href="#cb12-193" aria-hidden="true"></a>    <span class="fu">id</span> <span class="ot">&lt;-</span> parseId&#39;</span>
<span id="cb12-194"><a href="#cb12-194" aria-hidden="true"></a>    space</span>
<span id="cb12-195"><a href="#cb12-195" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;.&#39;</span></span>
<span id="cb12-196"><a href="#cb12-196" aria-hidden="true"></a>    space</span>
<span id="cb12-197"><a href="#cb12-197" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-198"><a href="#cb12-198" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Lam</span> <span class="fu">id</span> body)</span>
<span id="cb12-199"><a href="#cb12-199" aria-hidden="true"></a></span>
<span id="cb12-200"><a href="#cb12-200" aria-hidden="true"></a>parseInt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-201"><a href="#cb12-201" aria-hidden="true"></a>    chars <span class="ot">&lt;-</span> some digitChar</span>
<span id="cb12-202"><a href="#cb12-202" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">IntE</span> (<span class="fu">read</span> chars))</span>
<span id="cb12-203"><a href="#cb12-203" aria-hidden="true"></a></span>
<span id="cb12-204"><a href="#cb12-204" aria-hidden="true"></a>parseLet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-205"><a href="#cb12-205" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;let&quot;</span></span>
<span id="cb12-206"><a href="#cb12-206" aria-hidden="true"></a>    space</span>
<span id="cb12-207"><a href="#cb12-207" aria-hidden="true"></a>    <span class="fu">id</span> <span class="ot">&lt;-</span> parseId&#39;</span>
<span id="cb12-208"><a href="#cb12-208" aria-hidden="true"></a>    space</span>
<span id="cb12-209"><a href="#cb12-209" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> char <span class="ch">&#39;=&#39;</span></span>
<span id="cb12-210"><a href="#cb12-210" aria-hidden="true"></a>    space</span>
<span id="cb12-211"><a href="#cb12-211" aria-hidden="true"></a>    rhs <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-212"><a href="#cb12-212" aria-hidden="true"></a>    _ <span class="ot">&lt;-</span> string <span class="st">&quot;in&quot;</span></span>
<span id="cb12-213"><a href="#cb12-213" aria-hidden="true"></a>    space</span>
<span id="cb12-214"><a href="#cb12-214" aria-hidden="true"></a>    body <span class="ot">&lt;-</span> parseExpr</span>
<span id="cb12-215"><a href="#cb12-215" aria-hidden="true"></a>    lift (setIdUnfolding <span class="fu">id</span> rhs)</span>
<span id="cb12-216"><a href="#cb12-216" aria-hidden="true"></a>    <span class="fu">return</span> (<span class="dt">Let</span> <span class="fu">id</span> rhs body)</span>
<span id="cb12-217"><a href="#cb12-217" aria-hidden="true"></a></span>
<span id="cb12-218"><a href="#cb12-218" aria-hidden="true"></a>parseId <span class="ot">=</span> <span class="dt">IdE</span> <span class="op">&lt;$&gt;</span> parseId&#39;</span>
<span id="cb12-219"><a href="#cb12-219" aria-hidden="true"></a></span>
<span id="cb12-220"><a href="#cb12-220" aria-hidden="true"></a><span class="ot">kws ::</span> <span class="dt">Set.Set</span> <span class="dt">String</span></span>
<span id="cb12-221"><a href="#cb12-221" aria-hidden="true"></a>kws <span class="ot">=</span> Set.fromList [<span class="st">&quot;if&quot;</span>, <span class="st">&quot;then&quot;</span>, <span class="st">&quot;else&quot;</span>, <span class="st">&quot;let&quot;</span>, <span class="st">&quot;in&quot;</span>]</span>
<span id="cb12-222"><a href="#cb12-222" aria-hidden="true"></a></span>
<span id="cb12-223"><a href="#cb12-223" aria-hidden="true"></a><span class="ot">parseId&#39; ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb12-224"><a href="#cb12-224" aria-hidden="true"></a>parseId&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-225"><a href="#cb12-225" aria-hidden="true"></a>    name <span class="ot">&lt;-</span> some letterChar</span>
<span id="cb12-226"><a href="#cb12-226" aria-hidden="true"></a>    guard (<span class="fu">not</span> (Set.member name kws))</span>
<span id="cb12-227"><a href="#cb12-227" aria-hidden="true"></a>    <span class="fu">return</span> name</span>
<span id="cb12-228"><a href="#cb12-228" aria-hidden="true"></a></span>
<span id="cb12-229"><a href="#cb12-229" aria-hidden="true"></a><span class="ot">testPgm ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb12-230"><a href="#cb12-230" aria-hidden="true"></a>testPgm pgm <span class="ot">=</span></span>
<span id="cb12-231"><a href="#cb12-231" aria-hidden="true"></a>    <span class="kw">case</span> evalState (runParserT parseExpr <span class="st">&quot;&quot;</span> pgm) Map.empty <span class="kw">of</span></span>
<span id="cb12-232"><a href="#cb12-232" aria-hidden="true"></a>      <span class="dt">Left</span> (<span class="ot">err_bundle ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span></span>
<span id="cb12-233"><a href="#cb12-233" aria-hidden="true"></a>        <span class="fu">error</span> (errorBundlePretty err_bundle)</span>
<span id="cb12-234"><a href="#cb12-234" aria-hidden="true"></a>      <span class="dt">Right</span> expr <span class="ot">-&gt;</span></span>
<span id="cb12-235"><a href="#cb12-235" aria-hidden="true"></a>        expr</span>
<span id="cb12-236"><a href="#cb12-236" aria-hidden="true"></a></span>
<span id="cb12-237"><a href="#cb12-237" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> [<span class="dt">Char</span>] <span class="kw">where</span></span>
<span id="cb12-238"><a href="#cb12-238" aria-hidden="true"></a>    showErrorComponent x <span class="ot">=</span> x</span></code></pre></div>
</details>]]></summary>
</entry>
<entry>
    <title>Knot-tying: why and how (and my opinions on it)</title>
    <link href="http://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html" />
    <id>http://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html</id>
    <published>2020-02-21T00:00:00Z</published>
    <updated>2020-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Suppose I have this simple language:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>When generating code, for an identifier that stands for a lambda, I want to know the arity of the lambda, so that I can generate more efficient code. While in this language a lambda takes only one argument, if I have something like</p>
<pre><code>let f = \x . \y . \z . ...
 in ...</code></pre>
<p>I consider <code>f</code> as having arity 3.</p>
<p>One way to implement this is having this information attached to every <code>Id</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  }</span></code></pre></div>
<p>This way of associating information to <code>Id</code>s makes some things very simple. For example, if I’m generating code for this application:</p>
<pre><code>f 1 2</code></pre>
<p>In AST:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="ot">=</span> <span class="dv">3</span> })) (<span class="dt">IntE</span> <span class="dv">1</span>)) (<span class="dt">IntE</span> <span class="dv">2</span>)</span></code></pre></div>
<p>I can simply use the <code>idArity</code> field to see the arity of the function being applied. It doesn’t get any simpler than this.</p>
<h1 id="problem-1-redundant-allocations">Problem 1: redundant allocations</h1>
<p>In a program we usually have many references to a single Id, whether it’s for a top-level function or an argument. If we allocate an Id for every occurrence that’s a lot of redundant allocations that make the AST representation larger, and affects compiler performance.</p>
<p>For example, if I have this expression:</p>
<pre><code>f x + f y</code></pre>
<p>A naive representation of this would be</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">App</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }))</span></code></pre></div>
<p>Here for every occurrence of <code>f</code> we have a new <code>Id</code>, and these <code>Id</code>s all have the same arity. This is two <code>Id</code> heap objects used for the same identifier.</p>
<p>A more efficient representation would be</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">let</span> f <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="kw">in</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="dt">App</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> f)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>     (<span class="dt">IdE</span> f)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }))</span></code></pre></div>
<p>Here we only have one heap object for <code>f</code>, and all uses refer to that one object.</p>
<p>This is actually not hard to fix: we maintain a map from <code>Id</code> names to the actual <code>Id</code>s. When we see a <code>let</code> we add the LHS to the map. When we see an identifier we lookup. Easy.</p>
<h1 id="problem-2-invalidating-information-during-transformations">Problem 2: invalidating information during transformations</h1>
<p>Suppose I want to implement a pass that drops unused bindings. For example:</p>
<pre><code>let f = let a = e1
         in \x . e2
 in f z + f t</code></pre>
<p>Here if <code>e2</code> doesn’t use <code>a</code> I want to drop the binding:</p>
<pre><code>let f = \x . e2
 in f z + f t</code></pre>
<p>The AST for the original program is:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  (<span class="dt">Let</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>     <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;a&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>     <span class="op">&lt;</span>e1<span class="op">&gt;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>     (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="op">&lt;</span>e2<span class="op">&gt;</span>))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span></code></pre></div>
<p>Here’s a naive implementation of this pass:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> go Set.empty</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    go free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>        (Set.insert (idName <span class="fu">id</span>) free_vars, e0)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>        (free_vars, e0)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>        bimap (Set.delete (idName arg)) (<span class="dt">Lam</span> arg)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>              (go free_vars body)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go free_vars e1</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go free_vars e2</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>          (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go free_vars e1</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go free_vars e2</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a>          (free3, e3&#39;) <span class="ot">=</span> go free_vars e3</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>          (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> first (Set.delete (idName bndr)) (go free_vars e1)</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go free_vars e2</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a>          <span class="kw">if</span> Set.member (idName bndr) free2</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a>            <span class="kw">then</span> (Set.delete (idName bndr) (Set.union free1 free2),</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>                  <span class="dt">Let</span> (updateIdArity bndr e1&#39;) e1&#39; e2&#39;)</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>            <span class="kw">else</span> (free2, e2&#39;)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a>updateIdArity <span class="fu">id</span> rhs <span class="ot">=</span> <span class="fu">id</span>{ idArity <span class="ot">=</span> countLambdas rhs }</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a>countLambdas (<span class="dt">Lam</span> _ rhs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> countLambdas rhs</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a>countLambdas _ <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>The problem with this pass is that it changes arity of binders, but doesn’t update the <code>idArity</code>s of occurrences. Here’s what I get if I run this over the original AST:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">1</span> }</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="op">&lt;</span>e2<span class="op">&gt;</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span></code></pre></div>
<p>Note how <code>f</code>, which was not a lambda binder previously, became a lambda binder with arity 1. The pass correctly updated <code>f</code>’s <code>idArity</code> in the binder position, but it did not update it in the occurrences! Indeed, in this representation it’s not easy to do this efficiently.</p>
<p>Even if we solved the first problem and had only one closure for <code>f</code>, the <code>updateIdArity</code> step in this pass allocates a new <code>Id</code> and loses sharing. So we would end up with something like:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">let</span> f <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="kw">in</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="ot">=</span> <span class="dv">1</span> }</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> } <span class="op">&lt;</span>e2<span class="op">&gt;</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  (<span class="dt">App</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="ot">=</span> <span class="dv">2</span> })</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>           (<span class="dt">IdE</span> f)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>     (<span class="dt">App</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>        (<span class="dt">IdE</span> f)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="ot">=</span> <span class="dv">0</span> })))</span></code></pre></div>
<p>The arity of <code>f</code> in the use sites are still wrong, and we lost sharing.</p>
<h1 id="knot-tying">Knot-tying</h1>
<p>Knot-tying is a way of solving both of these in one step. I find it quite hard to explain in words so I’ll show the code (only the interesting bits):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="fu">snd</span> <span class="op">.</span> go Map.empty Set.empty</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    go binders free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>        (Set.insert (idName <span class="fu">id</span>) free_vars, <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (Map.lookup (idName <span class="fu">id</span>) binders)))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>      <span class="dt">Let</span> bndr<span class="op">@</span><span class="dt">Id</span>{ idName <span class="ot">=</span> bndr_name } e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> updateIdArity bndr e1&#39;</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>          binders&#39; <span class="ot">=</span> Map.insert bndr_name bndr&#39; binders</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> first (Set.delete bndr_name) (go binders&#39; free_vars e1)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders&#39; free_vars e2</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>          <span class="kw">if</span> Set.member bndr_name free2</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>            <span class="kw">then</span> (Set.delete bndr_name (Set.union free1 free2),</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>                  <span class="dt">Let</span> bndr&#39; e1&#39; e2&#39;)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>            <span class="kw">else</span> (free2, e2&#39;)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>      <span class="op">...</span></span></code></pre></div>
<p>The differences from the original version:</p>
<ul>
<li><p>We now pass around a “binders” map that maps identifier names to actual <code>Id</code>s. This is used to common-up uses of identifiers with one shared heap object with correct arity info.</p></li>
<li><p>In <code>IdE</code> case we now do lookup on this map, and replace the <code>Id</code> with the shared <code>Id</code> with correct arity info from the map.</p></li>
<li><p>The tricky bit is the <code>Let</code> case where we have a cyclic group of let bindings. <code>binders'</code> is the binder map with <code>bndr</code> with correct arity information. However to be able to generate that map we first need to process <code>e1</code>, and while processing <code>e1</code> we want to replace any occurrences of <code>bndr</code> with correct <code>Id</code> too! This gives us the cyclic bindings:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>bndr&#39; <span class="ot">=</span> updateIdArity bndr e1&#39;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>binders&#39; <span class="ot">=</span> Map.insert bndr_name bndr&#39; binders</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>(<span class="op">...</span>, e1&#39;) <span class="ot">=</span> <span class="op">...</span> (go binders&#39; free_vars e1)</span></code></pre></div></li>
</ul>
<p>This technique relies heavily on lazy evaluation. In the original example the AST is not recursive, but suppose we also want to record RHSs of let binders in <code>Id</code>s, to be used for inlining:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  { <span class="op">...</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a let binding, used for inlining</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  }</span></code></pre></div>
<p>Now once we implement sharing (solving problem 1) ASTs with recursive definitions will become cyclic. A simple example:</p>
<pre><code>let fac = \x . if x then x * fac (x - 1) else 1 in fac 5</code></pre>
<p>This will be represented as something like</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>pgm <span class="ot">=</span> <span class="dt">Let</span> fac_id rhs body</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    fac_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;fac&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    rhs <span class="ot">=</span> <span class="dt">Lam</span> x_id (<span class="dt">IfE</span> (<span class="dt">IdE</span> x_id)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>                        (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> star_id) (<span class="dt">IdE</span> x_id))</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>                             (<span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> minus_id) (<span class="dt">IdE</span> x_id))</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>                                                    (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>                                  (<span class="dt">IntE</span> <span class="dv">1</span>))</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    body <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">IntE</span> <span class="dv">5</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    x_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>    star_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;*&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>    minus_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;-&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span></code></pre></div>
<p>Here <code>fac_id</code> refers to <code>rhs</code>, which refers to <code>fac_id</code>, forming a cycle.</p>
<p>The knot-tying implementation of <code>dropUnusedBindings</code> works even in cases like this. We just need to update <code>updateIdArity</code> to update the unfolding, when it’s available:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>updateIdArity <span class="fu">id</span> rhs <span class="ot">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="fu">id</span>{ idArity <span class="ot">=</span> countLambdas rhs</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>      , idUnfolding <span class="ot">=</span> idUnfolding <span class="fu">id</span> <span class="op">$&gt;</span> rhs }</span></code></pre></div>
<p>This is a bit hard to try, but if I implement a <code>Show</code> instance for <code>Id</code> that doesn’t print the unfolding (to avoid looping), make <code>fac_id</code>’s arity <code>0</code>, and call <code>dropUnusedBindings</code> this is the AST I get:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">Let</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  (<span class="dt">Lam</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>     (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>     (<span class="dt">IfE</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>        (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>))</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>        (<span class="dt">App</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>           (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;*&quot;</span> <span class="dv">2</span>)) (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>)))</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>           (<span class="dt">App</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>              (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>))</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>              (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;-&quot;</span> <span class="dv">2</span>)) (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>))) (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>        (<span class="dt">IntE</span> <span class="dv">1</span>)))</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>  (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>)) (<span class="dt">IntE</span> <span class="dv">5</span>))</span></code></pre></div>
<p>All uses of <code>fac</code> have correct arity! Similarly I can do something hacky like this in GHCi to check that the unfolding has correct arity for uses of <code>fac</code> too:</p>
<pre><code>ghci&gt; let Let lhs _ _ = dropUnusedBindings pgm
ghci&gt; putStrLn (ppShow (idUnfolding lhs))
Just
  (Lam
     (Id &quot;x&quot; 0)
     (IfE
        (IdE (Id &quot;x&quot; 0))
        (App
           (App (IdE (Id &quot;*&quot; 2)) (IdE (Id &quot;x&quot; 0)))
           (App
              (IdE (Id &quot;fac&quot; 1))
              (App (App (IdE (Id &quot;-&quot; 2)) (IdE (Id &quot;x&quot; 0))) (IntE 1))))
        (IntE 1)))</code></pre>
<p>Nice!</p>
<h1 id="or-is-it">… or is it?</h1>
<p>The main problem with this technique is that it’s very difficult to understand. Even after working on different knot-tying code in GHC and implementing my own knot-tying passes, the recursive let bindings in the <code>Let</code> case above is still mind-boggling to me.</p>
<p>Secondly, it’s really hard to reason about the evaluation order of things in knot-tying code. You might think that this shouldn’t be an issue in a purely functional implementation, but in my experience any non-trivial compiler pass, even when implemented in a purely functional style, still needs debugging. Even if it’s not buggy, you may want to trace the evaluation and print a few things to understand how the code works.</p>
<p>Knot-tying code makes this, which should be absolutely trivial in any reasonable code base, very difficult. If you end up evaluating just the right places with your print statements you end looping. For example, here’s our AST with a few bang patterns:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="op">!</span><span class="dt">Id</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="op">!</span><span class="dt">Expr</span> <span class="op">!</span><span class="dt">Expr</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="op">!</span><span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>  }</span></code></pre></div>
<p>If you run the same program above using this AST definition you’ll see that the pass now loops. Note that I’ve removed the <code>idUnfolding</code> field just to demonstrate that this doesn’t happen because we have a loop in the AST.</p>
<p>It’s even more frustrating when what you’re debugging is a loop. You add a few prints, and scratch your head thinking why none of your prints are working even though the algorithm is clearly looping. What’s really happening is that the code is indeed looping, but for a different reason…</p>
<p>Finally, because making things more strict potentially breaks things, knot-tying makes fixing some memory leaks very hard. For example, we may have many passes on our AST, one of them being our knot-tying pass. Some of these passes may be very leaky, and instead of adding strict applications or bang patterns to dozens of places, we may want to add bangs to only a few places in the AST. But that, as demonstrated above, causes our knot-tying pass to loop.</p>
<h1 id="opinions">Opinions</h1>
<p>GHC makes use of knot-tying extensively, which has always been one of the pain points for me since my first days contributing to GHC. I vaguely remember, I was a graduate student at Indiana University at the time, making my first contributions to GHC. I remember finding it refreshing to be able to simply do <code>idType</code> and get type of an identifier in GHC, as opposed to using a symbol table, which I’d been doing in some of the other compilers I worked on in the past.</p>
<p>At the same time, I was constantly confused that my simple print statements added in some front-end pass makes the compiler loop. I had no idea what could be the reason. I had no idea that the thing I found so refreshing is also the reason why debugging and tracing were so much harder.</p>
<p>Suffice it to say, I don’t like knot-tying. If I had to use knot-tying in my project I’d probably reconsider how I represent my data instead. For example, if we simply used an unique number for our identifiers and maintained a symbol table to map the unique numbers to actual <code>Id</code>s then we wouldn’t have cycles for recursive functions in the AST and wouldn’t need knot-tying. Updating something about an <code>Id</code> would be a simple update in the symbol table.</p>
<details>
<p><summary>Full code</summary></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">-- Tried with GHC 8.6.4</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Functor</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span class="co">-- containers-0.6</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a><span class="co">-- pretty-show-1.10</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a><span class="co">data Expr</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a><span class="co">  = IdE !Id</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a><span class="co">  | IntE Int</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a><span class="co">  | Lam Id Expr</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a><span class="co">  | App !Expr !Expr</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a><span class="co">  | IfE Expr !Expr Expr</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a><span class="co">  | Let Id Expr Expr</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true"></a><span class="co">  | Placeholder String</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true"></a><span class="co">  deriving (Show)</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true"></a></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true"></a><span class="co">data Id = Id</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true"></a><span class="co">  { idName :: String</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true"></a><span class="co">    -- ^ Unique name of the identifier</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true"></a><span class="co">  , idArity :: !Int</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true"></a><span class="co">    -- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true"></a><span class="co">  }</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true"></a></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Placeholder</span> <span class="dt">String</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true"></a></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true"></a>  {<span class="ot"> idName ::</span> <span class="dt">String</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true"></a>    <span class="co">-- ^ Unique name of the identifier</span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true"></a>  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true"></a>    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true"></a>  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true"></a>    <span class="co">-- ^ RHS of a binder, used for inlining</span></span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true"></a>  }</span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true"></a></span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">Id</span> name arity _) <span class="ot">=</span> <span class="st">&quot;(Id &quot;</span> <span class="op">++</span> <span class="fu">show</span> name <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="fu">show</span> arity <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true"></a></span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true"></a><span class="co">f_id = Id { idName = &quot;f&quot;, idArity = 0 }</span></span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true"></a><span class="co">a_id = Id { idName = &quot;a&quot;, idArity = 0 }</span></span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true"></a><span class="co">x_id = Id { idName = &quot;x&quot;, idArity = 0 }</span></span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true"></a><span class="co">z_id = Id { idName = &quot;z&quot;, idArity = 0 }</span></span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true"></a><span class="co">t_id = Id { idName = &quot;t&quot;, idArity = 0 }</span></span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true"></a><span class="co">plus_id = Id { idName = &quot;+&quot;, idArity = 2 }</span></span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true"></a></span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true"></a></span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true"></a><span class="co">f_x_plus_f_y = (App (App (IdE plus_id) (App (IdE f_id) (IdE z_id)))</span></span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true"></a><span class="co">                     (App (IdE f_id) (IdE t_id)))</span></span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true"></a></span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true"></a><span class="co">ast1 = Let f_id (Let a_id (Placeholder &quot;e1&quot;) (Lam x_id (Placeholder &quot;e2&quot;))) f_x_plus_f_y</span></span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true"></a></span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true"></a><span class="co">ast2 = Let a_id (Placeholder &quot;e1&quot;)</span></span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true"></a><span class="co">           (Let f_id (Lam x_id (Placeholder &quot;e2&quot;))</span></span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true"></a><span class="co">                     f_x_plus_f_y)</span></span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb24-78"><a href="#cb24-78" aria-hidden="true"></a></span>
<span id="cb24-79"><a href="#cb24-79" aria-hidden="true"></a><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></span>
<span id="cb24-80"><a href="#cb24-80" aria-hidden="true"></a>updateIdArity <span class="fu">id</span> rhs <span class="ot">=</span></span>
<span id="cb24-81"><a href="#cb24-81" aria-hidden="true"></a>  <span class="fu">id</span>{ idArity <span class="ot">=</span> countLambdas rhs,</span>
<span id="cb24-82"><a href="#cb24-82" aria-hidden="true"></a>      idUnfolding <span class="ot">=</span> idUnfolding <span class="fu">id</span> <span class="op">$&gt;</span> rhs }</span>
<span id="cb24-83"><a href="#cb24-83" aria-hidden="true"></a></span>
<span id="cb24-84"><a href="#cb24-84" aria-hidden="true"></a><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-85"><a href="#cb24-85" aria-hidden="true"></a>countLambdas (<span class="dt">Lam</span> _ rhs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> countLambdas rhs</span>
<span id="cb24-86"><a href="#cb24-86" aria-hidden="true"></a>countLambdas _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb24-87"><a href="#cb24-87" aria-hidden="true"></a></span>
<span id="cb24-88"><a href="#cb24-88" aria-hidden="true"></a><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb24-89"><a href="#cb24-89" aria-hidden="true"></a>dropUnusedBindings <span class="ot">=</span></span>
<span id="cb24-90"><a href="#cb24-90" aria-hidden="true"></a>    <span class="fu">snd</span> <span class="op">.</span> go Map.empty Set.empty</span>
<span id="cb24-91"><a href="#cb24-91" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb24-92"><a href="#cb24-92" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</span>
<span id="cb24-93"><a href="#cb24-93" aria-hidden="true"></a>    go binders free_vars e0 <span class="ot">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></span>
<span id="cb24-94"><a href="#cb24-94" aria-hidden="true"></a></span>
<span id="cb24-95"><a href="#cb24-95" aria-hidden="true"></a>      <span class="dt">IdE</span> <span class="fu">id</span> <span class="ot">-&gt;</span></span>
<span id="cb24-96"><a href="#cb24-96" aria-hidden="true"></a>        (Set.insert (idName <span class="fu">id</span>) free_vars, <span class="dt">IdE</span> (fromMaybe <span class="fu">id</span> (Map.lookup (idName <span class="fu">id</span>) binders)))</span>
<span id="cb24-97"><a href="#cb24-97" aria-hidden="true"></a></span>
<span id="cb24-98"><a href="#cb24-98" aria-hidden="true"></a>      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></span>
<span id="cb24-99"><a href="#cb24-99" aria-hidden="true"></a>        (free_vars, e0)</span>
<span id="cb24-100"><a href="#cb24-100" aria-hidden="true"></a></span>
<span id="cb24-101"><a href="#cb24-101" aria-hidden="true"></a>      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></span>
<span id="cb24-102"><a href="#cb24-102" aria-hidden="true"></a>        bimap (Set.delete (idName arg)) (<span class="dt">Lam</span> arg)</span>
<span id="cb24-103"><a href="#cb24-103" aria-hidden="true"></a>              (go binders free_vars body)</span>
<span id="cb24-104"><a href="#cb24-104" aria-hidden="true"></a></span>
<span id="cb24-105"><a href="#cb24-105" aria-hidden="true"></a>      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb24-106"><a href="#cb24-106" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb24-107"><a href="#cb24-107" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go binders free_vars e1</span>
<span id="cb24-108"><a href="#cb24-108" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders free_vars e2</span>
<span id="cb24-109"><a href="#cb24-109" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb24-110"><a href="#cb24-110" aria-hidden="true"></a>          (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</span>
<span id="cb24-111"><a href="#cb24-111" aria-hidden="true"></a></span>
<span id="cb24-112"><a href="#cb24-112" aria-hidden="true"></a>      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span></span>
<span id="cb24-113"><a href="#cb24-113" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb24-114"><a href="#cb24-114" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> go binders free_vars e1</span>
<span id="cb24-115"><a href="#cb24-115" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders free_vars e2</span>
<span id="cb24-116"><a href="#cb24-116" aria-hidden="true"></a>          (free3, e3&#39;) <span class="ot">=</span> go binders free_vars e3</span>
<span id="cb24-117"><a href="#cb24-117" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb24-118"><a href="#cb24-118" aria-hidden="true"></a>          (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</span>
<span id="cb24-119"><a href="#cb24-119" aria-hidden="true"></a></span>
<span id="cb24-120"><a href="#cb24-120" aria-hidden="true"></a>      <span class="dt">Let</span> bndr<span class="op">@</span><span class="dt">Id</span>{ idName <span class="ot">=</span> bndr_name } e1 e2 <span class="ot">-&gt;</span></span>
<span id="cb24-121"><a href="#cb24-121" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb24-122"><a href="#cb24-122" aria-hidden="true"></a>          bndr&#39; <span class="ot">=</span> updateIdArity bndr e1&#39;</span>
<span id="cb24-123"><a href="#cb24-123" aria-hidden="true"></a>          binders&#39; <span class="ot">=</span> Map.insert bndr_name bndr&#39; binders</span>
<span id="cb24-124"><a href="#cb24-124" aria-hidden="true"></a>          (free1, e1&#39;) <span class="ot">=</span> first (Set.delete bndr_name) (go binders&#39; free_vars e1)</span>
<span id="cb24-125"><a href="#cb24-125" aria-hidden="true"></a>          (free2, e2&#39;) <span class="ot">=</span> go binders&#39; free_vars e2</span>
<span id="cb24-126"><a href="#cb24-126" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb24-127"><a href="#cb24-127" aria-hidden="true"></a>          <span class="kw">if</span> Set.member bndr_name free2</span>
<span id="cb24-128"><a href="#cb24-128" aria-hidden="true"></a>            <span class="kw">then</span> (Set.delete bndr_name (Set.union free1 free2),</span>
<span id="cb24-129"><a href="#cb24-129" aria-hidden="true"></a>                  <span class="dt">Let</span> bndr&#39; e1&#39; e2&#39;)</span>
<span id="cb24-130"><a href="#cb24-130" aria-hidden="true"></a>            <span class="kw">else</span> (free2, e2&#39;)</span>
<span id="cb24-131"><a href="#cb24-131" aria-hidden="true"></a></span>
<span id="cb24-132"><a href="#cb24-132" aria-hidden="true"></a>      <span class="dt">Placeholder</span>{} <span class="ot">-&gt;</span></span>
<span id="cb24-133"><a href="#cb24-133" aria-hidden="true"></a>        (free_vars, e0)</span>
<span id="cb24-134"><a href="#cb24-134" aria-hidden="true"></a></span>
<span id="cb24-135"><a href="#cb24-135" aria-hidden="true"></a><span class="ot">pgm ::</span> <span class="dt">Expr</span></span>
<span id="cb24-136"><a href="#cb24-136" aria-hidden="true"></a>pgm <span class="ot">=</span> <span class="dt">Let</span> fac_id rhs body</span>
<span id="cb24-137"><a href="#cb24-137" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb24-138"><a href="#cb24-138" aria-hidden="true"></a>    fac_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;fac&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Just</span> rhs }</span>
<span id="cb24-139"><a href="#cb24-139" aria-hidden="true"></a>    rhs <span class="ot">=</span> <span class="dt">Lam</span> x_id (<span class="dt">IfE</span> (<span class="dt">IdE</span> x_id) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> star_id) (<span class="dt">IdE</span> x_id))</span>
<span id="cb24-140"><a href="#cb24-140" aria-hidden="true"></a>                                        (<span class="dt">App</span> (<span class="dt">IdE</span> fac_id)</span>
<span id="cb24-141"><a href="#cb24-141" aria-hidden="true"></a>                                             (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> minus_id) (<span class="dt">IdE</span> x_id)) (<span class="dt">IntE</span> <span class="dv">1</span>))))</span>
<span id="cb24-142"><a href="#cb24-142" aria-hidden="true"></a>                                   (<span class="dt">IntE</span> <span class="dv">1</span>))</span>
<span id="cb24-143"><a href="#cb24-143" aria-hidden="true"></a>    body <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">IntE</span> <span class="dv">5</span>)</span>
<span id="cb24-144"><a href="#cb24-144" aria-hidden="true"></a></span>
<span id="cb24-145"><a href="#cb24-145" aria-hidden="true"></a>    x_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;x&quot;</span>, idArity <span class="ot">=</span> <span class="dv">0</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb24-146"><a href="#cb24-146" aria-hidden="true"></a>    star_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;*&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb24-147"><a href="#cb24-147" aria-hidden="true"></a>    minus_id <span class="ot">=</span> <span class="dt">Id</span> { idName <span class="ot">=</span> <span class="st">&quot;-&quot;</span>, idArity <span class="ot">=</span> <span class="dv">2</span>, idUnfolding <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb24-148"><a href="#cb24-148" aria-hidden="true"></a></span>
<span id="cb24-149"><a href="#cb24-149" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-150"><a href="#cb24-150" aria-hidden="true"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> (ppShow (dropUnusedBindings pgm))</span></code></pre></div>
</details>
<p>Thanks to Oleg Grenrus for reading a draft of this.</p>]]></summary>
</entry>
<entry>
    <title>Some arguments against small syntax extensions in GHC</title>
    <link href="http://osa1.net/posts/2020-01-22-no-small-syntax-extensions.html" />
    <id>http://osa1.net/posts/2020-01-22-no-small-syntax-extensions.html</id>
    <published>2020-01-22T00:00:00Z</published>
    <updated>2020-01-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently realized that I haven’t published a single post in 2019. I think that’s the longest break I ever took to blogging, and it kinda made me motivated to publish some of the draft posts that I’ve been keeping in private Github gists.</p>
<p>This post is originally written in 11 January 2019. Because it is more of an angry rant than a constructive piece, I wasn’t sure at the time that publishing it is a good idea. However reading it again now, I see that it’s not directed at a person, a group, or a specific proposal/patch, so I think it shouldn’t be offensive to anyone and I should be able to publish it on my personal blog.</p>
<p>(original post starts below)</p>
<hr />
<p>So I woke up at 5AM today and felt like writing about one of my frustrations. These are my personal opinions, and I don’t represent GHC HQ here.</p>
<hr />
<p>At this point adding new syntax to GHC/Haskell is a bad idea. Before moving on to examples, here are some facts:</p>
<ul>
<li><p>The language that GHC supports is incredibly complex. GHC 8.6.3 man page lists 115 language pragmas.</p></li>
<li><p>You just can’t have a good understanding of <em>all</em> of these features and know interactions of the proposed syntax with all combinations of these.</p></li>
<li><p>GHC is a complex and old compiler with parts that today no active contributor knows well. The compiler (ignoring all the libraries, the RTS, tools etc.) currently has 189,699 lines of code (ignoring comments and whitespace). That’s a lot of complexity to deal with.</p></li>
<li><p>When you propose a new syntax, what you’re actually proposing is:</p>
<ul>
<li>At least one more pragma</li>
<li>More user manual sections</li>
<li>MVP implementation of your syntax (which is usually not bug-free)</li>
<li>A few common-case tests (which are usually not enough)</li>
<li>More headache for tool developers</li>
<li>Scaring more potential new Haskell developers away</li>
<li>Adding to the frustration of existing Haskell developers</li>
<li>Adding maintenance burden to GHC devs</li>
</ul></li>
<li><p>Because you can’t predict all the interactions of your new syntax (conceptually, or in the implementation) your syntax will cause a ton of problems.</p></li>
<li><p>Those problems will sit there unfixed for months/years.</p></li>
<li><p>GHC maintainers barely have enough time and manpower to provide stable releases. 8.6.1 and 8.6.2 are completely broken (<a href="https://gitlab.haskell.org/ghc/ghc/issues/15544">#15544</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15696">#15696</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15892">#15892</a>), and 8.6.3 doesn’t <a href="https://gitlab.haskell.org/ghc/ghc/issues/16057">work well on Windows</a>.</p></li>
</ul>
<p>You might not accept some of these, however in my experience these are facts. If you disagree with any of these let me know and I can elaborate.</p>
<p>I’ll have only two examples for now, because I don’t normally work on front-end parts of the compiler I don’t notice most of the problems.</p>
<h1 id="example-1-tiny-addition-to-ghci-syntax">Example 1: Tiny addition to GHCi syntax</h1>
<p><a href="https://gitlab.haskell.org/ghc/ghc/issues/7253">#7253</a> proposed a tiny new syntax in GHCi. A few years later a new contributor picked it up and submitted a <a href="https://phabricator.haskell.org/D1299">patch</a>. This trivial new syntax later caused <a href="https://gitlab.haskell.org/ghc/ghc/issues/11606">#11606</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/12091">#12091</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15721">#15721</a>. That’s 3 too many tickets for a trivial syntax that buys us so little. It also generated at least one <a href="https://stackoverflow.com/questions/53898220/sprint-and-seq-together-missing-evaluation">SO question</a>, and invalidated an answer to <a href="https://stackoverflow.com/questions/14052093/ghci-let-what-does-it-do/14052220#14052220">another SO question</a> by making things more complicated.</p>
<p>The implementation is finally <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/97">fixed by a frustrated maintainer</a>, but the additional complexity (both in the implementation, and as the GHCi syntax to be explained to users) it added won’t be fixed.</p>
<h1 id="example-2--xblockarguments">Example 2: -XBlockArguments</h1>
<p>This was proposed as <a href="https://github.com/ghc-proposals/ghc-proposals/pull/90">a GHC proposal</a>. It’s a trivial syntax change that in the best case can save 3 characters (including spaces). So far it generated two tickets: <a href="https://gitlab.haskell.org/ghc/ghc/issues/16137">#16137</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/16097">#16097</a>. Even worse than the previous example is none of these tickets mention <code>-XBlockArguments</code>, they don’t even use it! Yet the error messages got significantly worse because of it.</p>
<hr />
<h1 id="just-to-be-clear">Just to be clear</h1>
<p>I think some of the extensions are quite useful. However I also think that at this point new syntax extensions are doing more harm than good. Problems from a maintainer’s point of view are as listed above (arguably maintainers’ problems are also users’ problems because they lead to poor product, but let’s ignore this aspect for now). Now I want to add one more problem, this time from a software developer/engineer’s point of view:</p>
<ul>
<li>Adding a different way of doing things, especially when the difference is so small, does more harm than good.</li>
</ul>
<p>Here’s why. Now that we have two ways of using <code>do</code> syntax:</p>
<pre><code>-- (1)
atomically $ do
  ...

-- (2) with -XBlockArguments
atomically do
  ...</code></pre>
<p>with my team I have to do one of these</p>
<ol type="1">
<li>Decide which one to use, and somehow manually make sure to use it consistently (this can’t be done automatically as we lack the tooling)</li>
<li>Let everyone use whatever they want.</li>
</ol>
<p>(1) means wasting the team’s time and energy on endless bikeshedding. (2) means being inconsistent in the source code. Either way we lose.</p>
<p>You might argue that with good tooling (1) is not a problem, and I’d agree. However as we add new syntax the tooling story will only get worse. GHC Haskell syntax is already so complex we don’t even have a good formatter. We should first stop making it even more complex if we want the tooling story to get better.</p>
<h1 id="what-we-need">What we need</h1>
<p>In my opinion what we need is principles to guide the language and the compiler. Currently <a href="https://github.com/ghc-proposals/ghc-proposals/pull/190#issuecomment-450440245">we don’t have this</a> (last paragraph), and the result is 100+ pragmas, a buggy compiler, and frustrated users and maintainers.</p>
<h1 id="my-advice-to-users">My advice to users</h1>
<p>If you’re proposing a new syntax; don’t! If you know someone who will, point them to this blog post.</p>]]></summary>
</entry>
<entry>
    <title>A project we've been working on presented at MuniHac 2018</title>
    <link href="http://osa1.net/posts/2018-10-22-gc-work-presented.html" />
    <id>http://osa1.net/posts/2018-10-22-gc-work-presented.html</id>
    <published>2018-10-22T00:00:00Z</published>
    <updated>2018-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new low-latency garbage collector for GHC that <a href="http://bgamari.github.io/">Ben Gamari</a> and I have been working on for the last year or so has recently been presented at <a href="https://munihac.github.io/">MuniHac 2018</a>. I’d like to thank Ben for the great talk.</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7_ig6r2C-d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
<p>I’ve been answering some questions on the <a href="https://www.reddit.com/r/haskell/comments/9ygoy1/munihac_2018_keynote_a_lowlatency_garbage/">/r/haskell thread</a> (I’m /u/semanticistZombie on Reddit). If you have any questions please don’t hesitate to add a comment in the reddit thread (make sure to ping me so that I get a notification), or even better, add a comment below.</p>]]></summary>
</entry>

</feed>
