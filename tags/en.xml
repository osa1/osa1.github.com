<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2015-01-29T00:00:00Z</updated>
    <entry>
    <title>Some benchmarks for meta-tracing BF JIT and traditional BF implementations</title>
    <link href="http://osa1.net/posts/2015-04-11-some-bf-benchmarks.html" />
    <id>http://osa1.net/posts/2015-04-11-some-bf-benchmarks.html</id>
    <published>2015-01-29T00:00:00Z</published>
    <updated>2015-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I found RPython very interesting for several reasons which I may be talking about later, and I need to use it for a project, so I started running some tutorials. However, I had some concerns about the idea(I still have, and I’ll defer the discussion to some other post for now), and I wanted to experiment with different implementations of same interpreter and compare results.</p>
<p>What I wanted to see is, given a very good and mature JIT compiler(LuaJIT in this case), how hard would it be to have similar optimizations without annotating code manually to give hints to the JIT compiler.</p>
<p>So I implemented a simple BF interpreter in Lua, and started experimenting with different optimizations. As for benchmarking, I used <code>bench</code> program from this <a href="https://bitbucket.org/brownan/pypy-tutorial/">RPython tutorial repository</a>.</p>
<p>Before diving into Lua implementation, here results of running them with RPython compiled interpreter, Python and PyPy:</p>
<pre><code>./example5-rpython bench.b    0.94s user 0.00s system 99% cpu 0.947 total
pypy example5.py   bench.b   15.57s user 0.01s system 99% cpu 15.597 total
python example5.py bench.b  597.34s user 0.04s system 99% cpu 9:57.87 total</code></pre>
<p>The Lua implementation started with this:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> mainloop<span class="ot">(</span>program<span class="ot">,</span> bracket_map<span class="ot">,</span> dispatch_fn<span class="ot">)</span>
    <span class="kw">local</span> pc <span class="ot">=</span> <span class="dv">1</span>
    <span class="kw">local</span> tape <span class="ot">=</span> <span class="ot">{</span><span class="dv">0</span><span class="ot">}</span>
    <span class="kw">local</span> tape_pos <span class="ot">=</span> <span class="dv">1</span>

    <span class="kw">local</span> code
    <span class="kw">while</span> pc <span class="ot">&lt;=</span> <span class="ot">#</span>program <span class="kw">do</span>
        code <span class="ot">=</span> program<span class="ot">[</span>pc<span class="ot">]</span>
        <span class="kw">if</span> code <span class="ot">==</span> <span class="st">&quot;&gt;&quot;</span> <span class="kw">then</span>
            tape_pos <span class="ot">=</span> tape_pos <span class="ot">+</span> <span class="dv">1</span>
            <span class="kw">if</span> <span class="ot">#</span>tape <span class="ot">&lt;</span> tape_pos <span class="kw">then</span>
                <span class="fu">table.insert</span><span class="ot">(</span>tape<span class="ot">,</span> <span class="dv">0</span><span class="ot">)</span>
            <span class="kw">end</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;&lt;&quot;</span> <span class="kw">then</span>
            tape_pos <span class="ot">=</span> tape_pos <span class="ot">-</span> <span class="dv">1</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;+&quot;</span> <span class="kw">then</span>
            tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">=</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;-&quot;</span> <span class="kw">then</span>
            tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">=</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">-</span> <span class="dv">1</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;.&quot;</span> <span class="kw">then</span>
            <span class="fu">io.write</span><span class="ot">(</span><span class="fu">string.char</span><span class="ot">(</span>tape<span class="ot">[</span>tape_pos<span class="ot">]))</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;[&quot;</span> <span class="kw">and</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">==</span> <span class="dv">0</span> <span class="kw">then</span>
            pc <span class="ot">=</span> bracket_map<span class="ot">[</span>pc<span class="ot">]</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;]&quot;</span> <span class="kw">and</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">then</span>
            pc <span class="ot">=</span> bracket_map<span class="ot">[</span>pc<span class="ot">]</span>
        <span class="kw">end</span>
        pc <span class="ot">=</span> pc <span class="ot">+</span> <span class="dv">1</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>I’m not sure how many reasonable different implementations one can come up with, given that the language is this small. Still, there are some optimizations that we can do and I’ve tried some of them. Here are some things I tried:</p>
<ul>
<li>I tried replacing one character strings with ASCII code equivalents. Since Lua doesn’t have character constants, I thought this may give us a few instructions per branch. But results were just the same.</li>
<li>I tried replacing table getters and setters with <code>rawget</code> and <code>rawset</code>s. Nothing changed. Apparently it’s not worth the effort unless you have a metatable for your table.</li>
<li><p>I tried generating a huge “if-then-else” statement for <code>bracket_map</code>, and used it as a jump table kind of thing. Here’s the code:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> gen_dispatch_fn<span class="ot">(</span>bracket_map<span class="ot">,</span> fun_name<span class="ot">)</span>
    <span class="kw">local</span> first <span class="ot">=</span> <span class="kw">true</span>
    <span class="kw">local</span> acc <span class="ot">=</span> <span class="ot">{}</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;function &quot;</span> <span class="ot">..</span> fun_name <span class="ot">..</span> <span class="st">&quot;(arg)</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="kw">for</span> k<span class="ot">,</span>v <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">(</span>bracket_map<span class="ot">)</span> <span class="kw">do</span>
        <span class="kw">if</span> first <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    if arg == &quot;</span> <span class="ot">..</span> k <span class="ot">..</span> <span class="st">&quot; then</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
            first <span class="ot">=</span> <span class="kw">false</span>
        <span class="kw">else</span>
            <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    elseif arg == &quot;</span> <span class="ot">..</span> k <span class="ot">..</span> <span class="st">&quot; then</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
        <span class="kw">end</span>
        <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;        return &quot;</span> <span class="ot">..</span> v <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    else</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;        error(</span><span class="ot">\&quot;</span><span class="st">invalid arg: </span><span class="ot">\&quot;</span><span class="st"> .. arg)</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    end</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;end</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="fu">table.concat</span><span class="ot">(</span>acc<span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>I loaded this code using standard <code>load()</code> function. This also didn’t work. The reason is that, even if this is faster(which is probably not always the case), profiling showed that interpreter spents only 4% of the time for <code>bracket_map</code> lookups. So if this implementation only slightly faster, it just can’t make a big difference.</p></li>
</ul>
<p>Profiling output revealed that, 85% of the time spent on fetching the next instruction:</p>
<pre><code>@@ 69 @@
      |
      |     local code
      |     while pc &lt;= #program do
  85% |         code = program[pc]
      |         if code == 62 then
      |             tape_pos = tape_pos + 1
      |             if #tape &lt; tape_pos then
@@ 89 @@
      |             pc = bracket_map[pc]
      |         elseif code == 93 and tape[tape_pos] ~= 0 then
   4% |             pc = bracket_map[pc]
      |         end
      |         pc = pc + 1</code></pre>
<p>Which really means that you can’t optimize anything, because there’s nothing optimizable in <code>code = program[pc]</code>, since this is one of the most primitive operations that you can do in this language. (note that we don’t have metamethod assigned to this table, so <code>rawget</code> is not an optimization)</p>
<p>At this point the Lua results were like this:</p>
<pre><code>luajit example_lua.lua bench.b  34.41s user 0.00s system 99% cpu 34.442 total</code></pre>
<p>The fact that PyPy did better job than LuaJIT here is surprising and impressive. It seems like RPython and PyPy is doing a very good job here.</p>
<p>Since I already started gradually compiling things, I thought why not go further and compile everything. Here’s a simple BF to Lua compiler:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> compile<span class="ot">(</span>str<span class="ot">)</span>
    <span class="kw">local</span> pgm <span class="ot">=</span> <span class="ot">{}</span>
    <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> <span class="st">[[</span>
<span class="st">function pgm()</span>
<span class="st">    local tape = {0}</span>
<span class="st">    local tape_pos = 1</span>
<span class="st">]]</span><span class="ot">)</span>

    <span class="kw">local</span> adv <span class="ot">=</span> <span class="st">[[</span>
<span class="st">    tape_pos = tape_pos + 1</span>
<span class="st">    if #tape &lt; tape_pos then</span>
<span class="st">        table.insert(tape, 0)</span>
<span class="st">    end</span>
<span class="st">]]</span>
    <span class="kw">local</span> <span class="kw">function</span> dev<span class="ot">(</span>i<span class="ot">)</span> <span class="kw">return</span> <span class="st">&quot;    tape_pos = tape_pos - &quot;</span> <span class="ot">..</span> i <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span> <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> inc<span class="ot">(</span>i<span class="ot">)</span> <span class="kw">return</span> <span class="st">&quot;    tape[tape_pos] = tape[tape_pos] + &quot;</span> <span class="ot">..</span> i <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span> <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> dec<span class="ot">(</span>i<span class="ot">)</span> <span class="kw">return</span> <span class="st">&quot;    tape[tape_pos] = tape[tape_pos] - &quot;</span> <span class="ot">..</span> i <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span> <span class="kw">end</span>
    <span class="kw">local</span> out  <span class="ot">=</span> <span class="st">&quot;    io.write(string.char(tape[tape_pos]))</span><span class="ot">\n</span><span class="st">&quot;</span>
    <span class="kw">local</span> inp  <span class="ot">=</span> <span class="st">&quot;&quot;</span> <span class="co">-- no need for this</span>
    <span class="kw">local</span> jmpF <span class="ot">=</span> <span class="st">&quot;    while tape[tape_pos] ~= 0 do</span><span class="ot">\n</span><span class="st">&quot;</span>
    <span class="kw">local</span> jmpB <span class="ot">=</span> <span class="st">&quot;    if tape[tape_pos] == 0 then break end end</span><span class="ot">\n</span><span class="st">&quot;</span>

    <span class="co">-- these are used to combine consecutive same instructions</span>
    <span class="kw">local</span> devs <span class="ot">=</span> <span class="dv">0</span>
    <span class="kw">local</span> incs <span class="ot">=</span> <span class="dv">0</span>
    <span class="kw">local</span> decs <span class="ot">=</span> <span class="dv">0</span>

    <span class="kw">local</span> indent <span class="ot">=</span> <span class="dv">0</span><span class="ot">;</span>

    <span class="kw">for</span> i<span class="ot">=</span><span class="dv">1</span><span class="ot">,</span> <span class="ot">#</span>str <span class="kw">do</span>
        <span class="kw">local</span> char <span class="ot">=</span> <span class="fu">string.char</span><span class="ot">(</span><span class="fu">string.byte</span><span class="ot">(</span>str<span class="ot">,</span> i<span class="ot">))</span>

        <span class="kw">if</span> devs <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">and</span> char <span class="ot">~=</span> <span class="st">&quot;&lt;&quot;</span> <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> dev<span class="ot">(</span>devs<span class="ot">)))</span>
            devs <span class="ot">=</span> <span class="dv">0</span>
        <span class="kw">elseif</span> incs <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">and</span> char <span class="ot">~=</span> <span class="st">&quot;+&quot;</span> <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> inc<span class="ot">(</span>incs<span class="ot">)))</span>
            incs <span class="ot">=</span> <span class="dv">0</span>
        <span class="kw">elseif</span> decs <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">and</span> char <span class="ot">~=</span> <span class="st">&quot;-&quot;</span> <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> dec<span class="ot">(</span>decs<span class="ot">)))</span>
            decs <span class="ot">=</span> <span class="dv">0</span>
        <span class="kw">end</span>

        <span class="kw">if</span> char <span class="ot">==</span> <span class="st">&quot;&gt;&quot;</span> <span class="kw">then</span> <span class="co">-- 62</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> adv<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;&lt;&quot;</span> <span class="kw">then</span> <span class="co">-- 60</span>
            devs <span class="ot">=</span> devs <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;+&quot;</span> <span class="kw">then</span> <span class="co">-- 43</span>
            incs <span class="ot">=</span> incs <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;-&quot;</span> <span class="kw">then</span> <span class="co">-- 45</span>
            decs <span class="ot">=</span> decs <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;.&quot;</span> <span class="kw">then</span> <span class="co">-- 46</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> out<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;,&quot;</span> <span class="kw">then</span> <span class="co">-- 44</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> inp<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;[&quot;</span> <span class="kw">then</span> <span class="co">-- 91</span>
            indent <span class="ot">=</span> indent <span class="ot">+</span> <span class="dv">4</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> jmpF<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;]&quot;</span> <span class="kw">then</span> <span class="co">-- 93</span>
            indent <span class="ot">=</span> indent <span class="ot">-</span> <span class="dv">4</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> jmpB<span class="ot">))</span>
        <span class="kw">end</span>
    <span class="kw">end</span>

    <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> <span class="st">&quot;end&quot;</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="fu">table.concat</span><span class="ot">(</span>pgm<span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>One thing to note here is that loops in BF programs correspond to loops in generated Lua. There’s another way to implement this compiler and it might turn out to be more efficient, but I didn’t try it. (see BF-to-C compiler below) Also, I’m merging some instructions together. This has significant performance impact, but it’s also necessary because if the generated code is too big, both PUC-Lua and LuaJIT is rejecting to load it. (this is documented, but the limit is not specified)</p>
<p>Results:</p>
<pre><code>luajit example_lua.lua bench.b  0.53s user 0.00s system 99% cpu 0.532 total</code></pre>
<p>Note that runtime code generation and loading is NOT included in this number, but code generation takes less than 0.01s, so I might just include that.</p>
<p>Just for completeness, I also tried a <a href="https://github.com/kgabis/brainfuck-c/blob/master/brainfuck.c">C interpreter</a>, and <a href="http://awk.info/?doc/bfc.html">BF-to-C</a> compiler:</p>
<pre><code>./c-int bench.b  2.44s user 0.00s system 99% cpu 2.443 total
./c-compiled     0.00s user 0.00s system 82% cpu 0.004 total</code></pre>
<p>A fun thing about C compiler is that compiling generated C programs takes long time:</p>
<pre><code>gcc -O3 awk_output.c  14.07s user 0.14s system 99% cpu 14.219 total</code></pre>
<p>RPython once again does an impressive job here, because it’s even faster than C interpreter. I didn’t bother profiling C code and optimizing it, because it looks like a reasonable implementation: A simple “fetch instruction and run it in a case statement” loop.</p>
<p>So I think the conclusion is that RPython and PyPy is doing really good job.</p>]]></summary>
</entry>
<entry>
    <title>Top-down expression parsing is easy</title>
    <link href="http://osa1.net/posts/2015-01-29-top-down-expr-parsing-easy.html" />
    <id>http://osa1.net/posts/2015-01-29-top-down-expr-parsing-easy.html</id>
    <published>2015-01-29T00:00:00Z</published>
    <updated>2015-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently fixed <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>’s 2-years-old expression parsing bug. Previously it was using <a href="http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Expr.html">Parsec’s expression parser</a>, which is actually horrible because it can’t handle chained unary operators.</p>
<p>Two weeks ago I decided to take a look into Lua’s original implementation, and in about an hour or so the algorithm was crystal clear to me. I immediately <a href="https://github.com/osa1/language-lua/commit/b4bebe36e927dcc671dbe6dd19572b83073dc556#diff-630bbd2d118baf109da6ad79d3f168bfR257">implemented it</a> and closed the <a href="https://github.com/osa1/language-lua/issues/2">2-years-old bug report</a>.</p>
<p>This implementation is essentially a port of Lua’s expression parser. Recently I thought about the algorithm and I was wondering if this has a name – the algorithm looked pretty obvious to me once I understand and given how much we know about parsing I thought this should have a name.</p>
<p>I found <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing">this algorithm named “precedence climbing”</a>. This is almost the same algorithm, only difference is that instead of using <code>lookahead</code> I’m just consuming the binary operator and returning it to the caller(which is parsing an expression with lower precedence than current parser) if precedence is lower. Associativity handling is also different(I use different left and right precedences to handle associativity) but the idea is really the same.</p>
<p>Now, there is also another algorithm called Pratt, and I can’t read the original paper(paywall), but according to <a href="http://lambda-the-ultimate.org/node/3682">this LtU discussion</a> it should also be similar. Indeed, <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">this explanation of it</a> looks pretty similar, and <a href="http://stackoverflow.com/a/13637731/691032">this StackOverflow answer</a> says that Lua’s implementation is “Pratt style parsing”.</p>
<p>So it seems like we have two, or maybe one since they’re actually very similar, solution(s) to solve top-down expression parsing problem and Haskell implementation using Parsec is possible in only 12 lines of code.</p>
<h1 id="a-challenge">A challenge</h1>
<p>One challenge might be to modify Parsec’s expression parser so that internally it generates a Pratt/precedence climbing parser. I’m hoping to spare some time to work on this.</p>]]></summary>
</entry>
<entry>
    <title>Loading dynamic Haskell libs in Lua</title>
    <link href="http://osa1.net/posts/2015-01-16-haskell-so-lua.html" />
    <id>http://osa1.net/posts/2015-01-16-haskell-so-lua.html</id>
    <published>2015-01-16T00:00:00Z</published>
    <updated>2015-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Last year I wrote <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">a blog post</a> in which I explained how to call Lua from Haskell and Haskell from Lua using <a href="http://hackage.haskell.org/package/hslua">hslua</a> library. At the end of that blog post I mentioned that it should be possible to compile Haskell code to shared library and load that in Lua.</p>
<p>Today a friend in our research group <a href="https://github.com/iu-parfunc">parfunc</a> asked a question about compiling Haskell to shared libraries and loading generated libraries in other programs and I thought while I’m at it I can just update my blog post as well. So in this post I’m going to explain how to compile Haskell functions to shared libraries and load them in Lua.</p>
<p>Before diving into the code, a few remarks:</p>
<ul>
<li>All the code in this blog post is tried on Linux, with Lua 5.1 and latest LuaJIT.</li>
<li>To be able to load our function in Lua and register it, our functions should have C linkage and <a href="http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><code>lua_CFunction</code></a> type. We can either write Haskell functions directly using this type, or write C wrapper functions around our Haskell functions to be able to use them in Lua. In this post I’m going to do first one.</li>
<li>We’ll need some intermediate C code to expose some Haskell RTS functions to Lua, like <code>hs_init</code> to start Haskell runtime and <code>hs_exit</code> to stop it.</li>
<li>To be able to <code>require</code> our shared library in Lua, we need to implement a <code>int luaopen_&lt;ourlibrary&gt;(lua_State *L)</code> function. While in theory it should be possible to implement that function in Haskell, I’ll implement it in C in this post, because I’m not sure how to write Lua wrappers for <code>hs_init</code> and <code>hs_exit</code> in Haskell.</li>
<li>To keep the code as simple as possible, our Haskell function will be a very dumb addition function.</li>
</ul>
<p>Let’s start.</p>
<h1 id="defining-lua-function-in-haskell">Defining Lua function in Haskell</h1>
<p>This is exactly the same as before: We just define a function with type: <code>LuaState -&gt; IO Int</code>. To keep the code simple, we don’t do error handling at all.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">LibArith</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Scripting.Lua</span> <span class="co">-- this one from hslua</span>

foreign export ccall
<span class="ot">  add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="ot">add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
add l <span class="fu">=</span> <span class="kw">do</span>
  i1 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">1</span>
  i2 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">2</span>
  pop l <span class="dv">2</span>
  push l (i1 <span class="fu">+</span><span class="ot"> i2 ::</span> <span class="dt">Int</span>)
  return <span class="dv">1</span></code></pre>
<h1 id="implementing-intermediate-c">Implementing intermediate C</h1>
<p>In our C glue code, we do two things:</p>
<ol style="list-style-type: decimal">
<li>Wrap <code>hs_init</code> and <code>hs_exit</code> Haskell runtime functions.</li>
<li>Implement Lua C module interface in which we register our functions to Lua. (see <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders">related docs</a> for details)</li>
</ol>
<p>Here’s the code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;LibArith_stub.h&quot;</span>
<span class="ot">#include &quot;lua.h&quot;</span>

<span class="dt">int</span> hs_init_lua(lua_State *L)
{
  hs_init(NULL, NULL);
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> hs_exit_lua(lua_State *L)
{
  hs_exit();
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> luaopen_lualibhelper(lua_State *L)
{
  lua_pushcfunction(L, add);
  lua_setglobal(L, <span class="st">&quot;add_in_haskell&quot;</span>);
  lua_pushcfunction(L, hs_init_lua);
  lua_setglobal(L, <span class="st">&quot;hs_init&quot;</span>);
  lua_pushcfunction(L, hs_exit_lua);
  lua_setglobal(L, <span class="st">&quot;hs_exit&quot;</span>);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Some things to note:</p>
<ul>
<li><code>LibArith_stub.h</code> is generated by GHC. I’ll explain how to compile and link next.</li>
<li>Our Haskell function actually has type <code>HsInt (*)(void *)</code>. While this is not what Lua API expected(it expects <code>int (*)(lua_State *L)</code>), in my x86_64 Linux machine this is working fine. In the worst case, you may need to wrap the Haskell function in C and convert the types using Haskell RTS C API and Lua C API.</li>
</ul>
<h1 id="compiling-and-linking">Compiling and linking</h1>
<p>This is the tricky part, I wasted a good 2 hours trying to figure how to compile to <code>.so</code> and link it with correct set of libraries.</p>
<p>First step is to compile <code>hslua</code> in a sandbox, or at least make it reachable by GHC(by installing globally, using nix environments etc.). I’ll be giving commands assuming that you’re in a sandbox that has <code>hslua</code> installed, if you’re not, then just replace <code>cabal exec ghc --</code> part with <code>ghc</code> and it should just work.</p>
<p>Step 1, compile and link the Haskell code to generate a shared library:</p>
<pre><code>$ cabal exec ghc -- LibArith.hs -shared -dynamic -fPIC -o libarith.so -lHSrts-ghc7.8.3</code></pre>
<p>Note that if you’re using a different version of GHC, you’ll need to modify the last argument to make it link it with corrent GHC RTS library.(alternatively, you can link with debug or profiling versions etc.)</p>
<p>Step 2, compile the Lua module written in C(the C code above) and link it with our shared Haskell library:</p>
<pre><code>$ cabal exec ghc -- libarithhelper.c -no-hs-main -optl -larith -o lualibhelper.so -shared -fPIC -dynamic</code></pre>
<p>Note that you may need to pass extra linker parameters if you have Lua library/headers in non-standard locations. If that’s the case, <code>-optl</code> argument of GHC is used to add linker arguments, just use standard linker arguments with that(<code>-L</code>, <code>-I</code> etc.).</p>
<p>This command should print a warning like this:</p>
<pre><code>/home/omer/opt/luajit_bin/include/luajit-2.0/lua.h:168:16:
     note: expected ‘lua_CFunction’ but argument is of type ‘HsInt (*)(void *)’
     LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);</code></pre>
<p>Like mentioned above, this doesn’t make any difference on my x86_64 Linux machine. If that’s being a problem on your system, just wrap your Haskell function in intermediate C code above using Haskell RTS API.</p>
<p>Now you should have two shared libraries, one for our Haskell code and one for the intermediate C code. One problem is that the shared library generated from C is now depending on the one generated from Haskell. So Haskell library should be in your <code>LD_LIBRARY_PATH</code>.</p>
<p>A good improvement here would be to compile Haskell code to static library, and generate one dynamic library only. (which has Haskell library statically linked to it)</p>
<h1 id="loading-the-code-in-lua">Loading the code in Lua</h1>
<p>Before loading it, make sure that the dynamic linker can really find the shared library generated from Haskell. Run this:</p>
<pre><code>$ ldd lualibhelper.so | grep &quot;not found&quot;</code></pre>
<p>Make sure it’s not printing anything.</p>
<p>Now just run Lua and enjoy the library:</p>
<pre><code>$ luajit-2.0.3
LuaJIT 2.0.3 -- Copyright (C) 2005-2014 Mike Pall. http://luajit.org/
JIT: ON CMOV SSE2 SSE3 SSE4.1 fold cse dce fwd dse narrow loop abc sink fuse
&gt; require &quot;lualibhelper&quot;
&gt; hs_init()
&gt; print(add_in_haskell(1, 2))
3
&gt; print(add_in_haskell(-10, 20))
10</code></pre>
<p>Just for the amusement, let’s crash it by running Haskell function <em>after</em> stopping the Haskell runtime:</p>
<pre><code>&gt; hs_exit()
&gt; add_in_haskell(1, 2)
newBoundTask: RTS is not initialised; call hs_init() first</code></pre>
<p>Fun :)</p>
<h1 id="conclusion">Conclusion</h1>
<p>It turns out that extending Lua using Haskell is almost as easy as the doing it using the technique I explained in my <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">previous blog post on this topic</a>.</p>
<p>This post also demonstrates one other thing, namely, compiling Haskell libraries to shared libraries and dynamically loading them in different programs. I’m hoping that this post helps fellow Haskellers to extend their programs written in different languages with Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Understanding Futamura Projections</title>
    <link href="http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html" />
    <id>http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html</id>
    <published>2015-01-11T00:00:00Z</published>
    <updated>2015-01-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s a way to understand Futamura projections<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<p>(Quick note: “Partial evaluator” == “specializer”. As far as I can see these words are also used interchangeably in the literature)</p>
<p>We call our specializer <code>specialize</code>. We specify languages using capital letters, <code>S</code>, <code>T</code>, <code>L</code> etc. We use Haskell syntax for applications. (e.g. <code>f a1 a2 a3</code> is a function application of <code>f</code> to three arguments, applications are left-associative in the case of currying)</p>
<p><code>specialize</code> takes two arguments, first argument is the program(function) to specialize, second argument is the input to specialize the program(function) on.</p>
<p>Note that our specializers are “correct”: For all specializer <code>s</code>, program <code>f</code> and program arguments <code>a</code> and <code>b</code>, <code>(s f a) b</code> is semantically same as <code>f a b</code>.</p>
<p>We show a specializer written in L which operates on programs written in T as <code>specialize_L_T</code>.</p>
<p>Now there are three interesting “Futamura projections”. Let’s say we have an interpreter for a language <code>L</code>, called <code>int</code>, which is written in <code>T</code>. We use <code>*</code> as a wildcard for languages. (e.g. it can be substituted with any language)</p>
<ol style="list-style-type: decimal">
<li><p><code>specialize_*_T int int_pgm</code>: We specialized the interpreter on a program <code>int_pgm</code>, resulting program is in <code>T</code>. We now have a program in <code>T</code> which just gets arguments of the interpreted program and produces output. This gives us a compiled version of <code>int_pgm</code> to <code>T</code>.</p></li>
<li><p><code>specialize_T_T specialize_T_T int</code>: We specialized the specializer on an interpreter. Generated program will be in <code>T</code>, and it’ll be expecting interpreter programs as input. The output will be specialized version of <code>int</code> for the given interpreter program. So we got a compiler for the interpreter <code>int</code>!</p>
<p>Note that specializers now need to be written in the language that they operate on. Alternatively, we could use two different specializers: One for specialize the interpreter, and one for specializing the interpreter specializer. (e.g. in most general form, we can have <code>specialize_A_B specialize_B_C int</code> where <code>int</code> is written in <code>C</code>)</p></li>
<li><p><code>specialize_T_T specialize_T_T specialize T_T</code>: This one is tricky. Let’s try to think what will be the generated program. We know from (2) is that <code>specialize_T_T specialize_T_T int</code> is a compiler for the language that <code>int</code> interprets. Now, we know from the note above that specializing doesn’t change meaning of the program, so our term from (2) <code>specialize_T_T specialize_T_T int</code> should be same with <code>(specialize_T_T specialize_T_T specialize_T_T) int</code>. What happens if we don’t apply the last <code>int</code>? Then we got a program that takes an interpreter and specializes it, resulting with a program in <code>T</code> that doesn’t expect interpreter argument. This is a compiler-compiler. Given an interpreter in <code>T</code>, it gives us a compiled version.</p></li>
</ol>
<p>Futamura projections are originally introduced in Futamura’s <a href="https://cs.au.dk/~hosc/local/HOSC-12-4-pp381-391.pdf">“Partial Evaluation of Computation Process – An Approach to a Compiler-Compiler”</a> and also described in <a href="http://www.itu.dk/people/sestoft/pebook/jonesgomardsestoft-letter.pdf">“Partial Evaluation and Automatic Program Generation”</a>.</p>
<p>Thinking about languages and interpreters are good way to have an intuition about how partial evaluation, specializing specializers etc. work, and “writing interpreters on problem domain” may be a good and general approach to solving problems<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, but I’m wondering what interesting programs and results we would get if we apply the these to different domains. Any ideas and pointers would be appreciated.</p>
<h1 id="problem-with-implementing-the-idea">Problem with implementing the idea</h1>
<p>Implementing ideas are generally a good way to learn, but in this case it’s a bit tricky. If we want to specialize specializers(like in projection (2) and (3)) we need to write one specializer in the language that it specializes, so we need a <code>specialize_T_T</code> for a <code>T</code>.</p>
<p>To be more concrete, if we want to write the specializer in Haskell, then it has to be operating on Haskell so that we could specialize it on itself. Now this is no trivial work, Haskell is a big and complicated language.</p>
<p>On the other hand, if we want to roll our own language just to try this idea, then we’ll have to write the specializer in our language. This is also not trivial, because we need implement a language that is expressive enough to write a specializer for itself.</p>
<p>Designing a minimal language that is expressive enough to implement the idea may be a good challenge.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Futamura projections are what you get when you apply partial evaluators to interpreters and to themselves. Have a look at <a href="http://en.wikipedia.org/wiki/Partial_evaluation#Futamura_projections">related Wikipedia page</a> and see bottom of the post for more resources.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>I recently stumbled upon this <a href="http://stackoverflow.com/questions/27852709/enterprise-patterns-with-functional-programming/27860072#27860072">SO answer</a> to a question about functional design patterns. It’s interesting how forcing yourself to a particular paradigm leads to different approaches and ways to solving problems. This is one of the reasons why I’m trying to learn a new paradigm using a language that is specifically crafted for that paradigm(e.g. Haskell for functional programming instead of Lisps, Scala etc.).<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Two challenges for dependently typed languages</title>
    <link href="http://osa1.net/posts/2014-09-23-two-challenges-for-dep-typed-langs.html" />
    <id>http://osa1.net/posts/2014-09-23-two-challenges-for-dep-typed-langs.html</id>
    <published>2014-09-23T00:00:00Z</published>
    <updated>2014-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

I propose two challenges that I think are very useful to see how easy to use a dependently typed language is. Different dependently typed languages use different type theories as their trusted cores and admit different axioms. In my experience, this significantly effects user experience. For example, lack of dependent pattern matching in Coq is leading to horribly verbose, hard to write, read and understand pattern matching code(see convoy and transport patterns).

<div class="paragraph"> </div>

Adding some extra axioms to Coq's trusted but sometimes too simple core can make the experience significantly better(see <a href="http://coq.inria.fr/distrib/current/stdlib/Coq.Logic.JMeq.html">JMec</a>, <a href="http://coq.inria.fr/distrib/current/stdlib/Coq.Program.Equality.html">Program</a> and <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual010.html">dependent destruction</a>). On the other hand, languages like Idris handles some of the cases that Coq can't handle by default.

<div class="paragraph"> </div>

The challenge is to solve two problems defined below in different dependently typed languages. We can then compare programs for 1) simplicity of code 2) use of extra axioms 3) giving away totality or some other useful properties.

<div class="paragraph"> </div>

Solutions of one of the challenges may also be compared for erasure of types. Problems are defined in Coq.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Challenge 1: Cardinality</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

This is a theorem proving exercise. <span class="inlinecode"><span class="id" type="var">Cardinality</span></span> of a type is defined as bijection of the type with <span class="inlinecode"><span class="id" type="var">Fin.t</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> for some <span class="inlinecode"><span class="id" type="var">n</span></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="cardinality"><span class="id" type="inductive">cardinality</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <span class="id" type="keyword">Prop</span> :=<br />
| <a name="cardinality_intro"><span class="id" type="constructor">cardinality_intro</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">to_fin</span>    : <span class="id" type="var">A</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Vectors.Fin.html#t"><span class="id" type="inductive">Fin.t</span></a> <span class="id" type="var">n</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">from_fin</span>  : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Vectors.Fin.html#t"><span class="id" type="inductive">Fin.t</span></a> <span class="id" type="var">n</span> → <span class="id" type="var">A</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">bijection</span> :<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#from_fin"><span class="id" type="variable">from_fin</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#to_fin"><span class="id" type="variable">to_fin</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">y</span>, <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#to_fin"><span class="id" type="variable">to_fin</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#from_fin"><span class="id" type="variable">from_fin</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#y"><span class="id" type="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

You may want to solve this simple exercise just to warm-up:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="cardinality_bool"><span class="id" type="lemma">cardinality_bool</span></a> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#cardinality"><span class="id" type="inductive">cardinality</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> 2.<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now the challenge is to prove that cardinality of

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="T"><span class="id" type="inductive">T</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br />
| <a name="T1"><span class="id" type="constructor">T1</span></a> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <span class="id" type="var">A</span><br />
| <a name="T2"><span class="id" type="constructor">T2</span></a> : <span class="id" type="var">A</span> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <span class="id" type="var">A</span><br />
| <a name="T3"><span class="id" type="constructor">T3</span></a> : <span class="id" type="var">A</span> → <span class="id" type="var">A</span> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <span class="id" type="var">A</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

.. is <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">N</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">N</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" type="var">N</span></span> where <span class="inlinecode"><span class="id" type="var">N</span></span> is cardinality of <span class="inlinecode"><span class="id" type="var">A</span></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="cardinality_T"><span class="id" type="lemma">cardinality_T</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">N</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#cardinality"><span class="id" type="inductive">cardinality</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#cardinality"><span class="id" type="inductive">cardinality</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#A"><span class="id" type="variable">A</span></a>) (1 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a>).<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

UPDATE: First solution for this challange came from <a href="http://homes.cs.washington.edu/~jrw12/">jrw</a>, in Coq: <a href="http://lpaste.net/111568">http://lpaste.net/111568</a>. UPDATE: He wrote an awesome blog post: <a href="http://homes.cs.washington.edu/~jrw12/more-cardinality.html">Reasoning about Cardinalities of Sums and Products</a>.

<div class="paragraph"> </div>

UPDATE 2: See comments for more solutions.

<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">Challenge 2: Verified, CoInductive definition of Pascal's Triangle</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

This should be easier. What's good about this one is that we can compare languages for performance and/or erasure properties. Basically we expect type arguments to be absent in extracted/executed code.

<div class="paragraph"> </div>

Here's one way to define the problem:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">CoInductive</span> <a name="triangle_t"><span class="id" type="inductive">triangle_t</span></a> (<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Type</span> :=<br />
| <a name="triangle"><span class="id" type="constructor">triangle</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Vectors.Vector.html#t"><span class="id" type="inductive">Vector.t</span></a> <span class="id" type="var">T</span> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#triangle_t"><span class="id" type="inductive">triangle_t</span></a> <span class="id" type="var">T</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a>) → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#triangle_t"><span class="id" type="inductive">triangle_t</span></a> <span class="id" type="var">T</span> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="pascal"><span class="id" type="definition">pascal</span></a> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#triangle_t"><span class="id" type="inductive">triangle_t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> 0. <span class="id" type="var">Admitted</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="pascal_nth"><span class="id" type="definition">pascal_nth</span></a> (<span class="id" type="var">row</span> <span class="id" type="var">col</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>. <span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Extracted/executed version of <span class="inlinecode"><span class="id" type="var">pascal_nth</span></span> and any auxiliary function should be clean from type arguments.

<div class="paragraph"> </div>

Now the verification part:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="pascal_first_col_is_1"><span class="id" type="lemma">pascal_first_col_is_1</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> 0 (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Le.html#le_0_n"><span class="id" type="lemma">le_0_n</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1.<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
<span class="id" type="keyword">Theorem</span> <a name="pascal_last_col_is_1"><span class="id" type="lemma">pascal_last_col_is_1</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#le_n"><span class="id" type="constructor">le_n</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1.<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
<span class="id" type="keyword">Lemma</span> <a name="pascal_correct_aux"><span class="id" type="lemma">pascal_correct_aux</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span> <span class="id" type="var">col</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1.<br />
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">omega</span>. <span class="id" type="keyword">Qed</span>.<br />

<br />
<span class="id" type="keyword">Lemma</span> <a name="lt_le"><span class="id" type="lemma">lt_le</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#b"><span class="id" type="variable">b</span></a> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#b"><span class="id" type="variable">b</span></a>.<br />
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">omega</span>. <span class="id" type="keyword">Qed</span>.<br />

<br />
<span class="id" type="keyword">Lemma</span> <a name="pascal_correct_aux'"><span class="id" type="lemma">pascal_correct_aux'</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span> <span class="id" type="var">col</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1.<br />
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">omega</span>. <span class="id" type="keyword">Qed</span>.<br />

<br />
<span class="id" type="keyword">Theorem</span> <a name="pascal_correct"><span class="id" type="lemma">pascal_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span> <span class="id" type="var">col</span><br />
&nbsp;&nbsp;(<span class="id" type="var">pf</span> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a>)<br />
&nbsp;&nbsp;(<span class="id" type="var">pf_row</span> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1)<br />
&nbsp;&nbsp;(<span class="id" type="var">pf_col</span> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1),<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#lt_le"><span class="id" type="lemma">lt_le</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf"><span class="id" type="variable">pf</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1) (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1) (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_correct_aux"><span class="id" type="lemma">pascal_correct_aux</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf"><span class="id" type="variable">pf</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_row"><span class="id" type="variable">pf_row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_col"><span class="id" type="variable">pf_col</span></a>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1) <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_correct_aux'"><span class="id" type="lemma">pascal_correct_aux'</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf"><span class="id" type="variable">pf</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_row"><span class="id" type="variable">pf_row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_col"><span class="id" type="variable">pf_col</span></a>).<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Feel free to change the definitions. The point is to 1) have strict <span class="inlinecode"><span class="id" type="var">nth</span></span> function that fail 2) prove that the data structure has property of <a href="http://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's triangle</a>.

<div class="paragraph"> </div>

I'm hoping to come up with some solutions given in Coq over the next couple of weeks.

<div class="paragraph"> </div>


</div>
<div class="code">
</div>
]]></summary>
</entry>
<entry>
    <title>Problems with tactic generated programs</title>
    <link href="http://osa1.net/posts/2014-09-13-problems-with-tactics.html" />
    <id>http://osa1.net/posts/2014-09-13-problems-with-tactics.html</id>
    <published>2014-09-13T00:00:00Z</published>
    <updated>2014-09-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I never managed to write anything with dependent types in Coq, without using tactics. Pattern matching is never giving enough information in cases to allow me to generate the term I want. <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> book describes “Convoy pattern”, which is a way to write dependently typed terms in Coq without using tactics. I later learned that standard <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual010.html#hevea_tactic87">inversion</a> tactic also uses something like a convoy pattern, except it’s not as fine grained as what a user would write by hand.</p>
<p>Unfortunately, even after learning about convoy pattern, I’m still not satisfied with what I get when I write dependently typed definitions without using tactics. The reason is that convoy pattern is incredibly ugly and hard to read and understand. Even if I embrace the ugliness, most of the time I have no idea how to use the pattern so that 1) it’s not horribly verbose 2) does what I want.</p>
<p>I had a small verification idea: I was going to implement <a href="http://en.wikipedia.org/wiki/Pascals_triangle">Pascal’s triangle</a> as a co-inductive type and implement operations on it. Later I was hoping to prove that <code>p(n, k) = p(n-1, k-1) + p(n-1, k)</code> where <code>k</code> is column and <code>p</code> is row.</p>
<p>I struggled for this for a long time. The problem was that I was not comfortable with tactics and I couldn’t define dependently typed terms using fixpoints or definitions. Now that I’m comfortable enough with tactics, I finally managed to <a href="https://gist.github.com/osa1/47ed1dd4267fa379259d">implement what I want</a>.</p>
<p>Here are a few things that I also mentioned in <a href="https://sympa.inria.fr/sympa/arc/coq-club/2014-09/msg00088.html">my mail to Coq-club</a>:</p>
<ul>
<li>The whole thing looks a bit complex but actually implementing it was very easy. Definitely a lot easier than how it’d be if I wanted to implement it without tactics.</li>
<li>Even though generated Coq terms are huge, generated OCaml is actually very good. It still has some problems though. <code>snoc</code> has a redundant argument which could be eliminated by using OCaml lists for vectors. First argument of <code>sum-pairs</code> is redundant because it’s just vector’s length so we could use <code>Vector.t</code>’s field instead. Similarly, I think <code>pascal_aux</code>’s first argument may also be removed etc. (see generated OCaml from the Github link above)</li>
</ul>
<p>If you look at the Coq code, you’ll realize that I couldn’t prove even the simplest fact about my definition. This is the problem with tactic-generated terms. The reason I can’t prove anything is that <code>simpl</code> just doesn’t work anymore, and there are no workarounds. The terms are so huge and complex, nothing is provable anymore.</p>
<p>I got very good responses about alternatives and problems in Coq-club mailing list. One of them was the suggestion of giving functions types that 1) show the properties I’m trying to show in separate theorems 2) still subject to erasure.</p>
<p>This approach has an obvious problem. There won’t be a program/proof distinction anymore. As a programmer I don’t like this at all. Also, making sure that proof terms will be erased is hard.(see rest of the discussion from the mailing list link above) I don’t think I’ll follow this idea.</p>
<p>Another alternative is just using Agda. I have my problems with Agda which I’m deferring to another post for now. Some of my excuses may actually not be Agda’s problem but rather they may be Coq’s advantage. In any case, I probably won’t be using Agda.</p>
<p>So now I’m stuck with Coq – I can’t define anything without using tactics, but when I use tactics for definitions(instead of proofs) then I can’t prove anything.</p>]]></summary>
</entry>
<entry>
    <title>GHC + Cabal installation guide for starters</title>
    <link href="http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html" />
    <id>http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html</id>
    <published>2014-09-12T00:00:00Z</published>
    <updated>2014-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I see a lot of starters having problems with installing latest GHC and Cabal, and then keeping their package repository in a sane state(e.g. no thousands of broken packages because of one re-install, no installation problems because of conflicts). I came up with a simple method several years ago, and today when combined with sandboxes, that works really well. I suggest every new Haskeller to do the same. Here’s how I do my GHC/Cabal installation up-to-date and sane:</p>
<p>NEVER USE HASKELL PALTFORM. When I first started, it caused just too much pain. I don’t know how it is today, but I presume same problems should still apply. (globally installing packages)</p>
<p>Most important thing is to keep Cabal and cabal-install up-to-date. You can easily remove a GHC, or install other versions and keep them togerher once you have a working and relatively new(so that it supports sandboxes) Cabal. In fact, I currently have 3 versions of GHC installed, for different projects, and I have no problems at all. Starting from a system with no GHC/Cabal is installed, here’s the way to install latest Cabal and cabal-install:</p>
<ol style="list-style-type: decimal">
<li>Install whatever GHC and Cabal you have in your package manager.</li>
<li>If the GHC you installed from package manager is not latest one, install latest pre-compiled binary from <a href="http://www.haskell.org/ghc/">GHC webpage</a>. Set your <code>$PATH</code>(or move executables to <code>$PATH</code>) and remove the GHC you installed using the package manager.</li>
<li>Run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, then remove Cabal and cabal-install installed using the package manager, and add <code>~/.cabal/bin</code> to $PATH. After doing that, you’ll have latest GHC and Cabal installed. Also, Cabal will be installed locally, so you can update it very easily using <code>cabal udpate &amp;&amp; cabal install Cabal cabal-install</code> whenever you want. Updating for newer GHC is similarly easy, just installed pre-compiled binary from the link above and move it wherever you want. You can use multiple GHC installations at the same time without any problems, Cabal just keeps separate repositories for different GHC versions.</li>
</ol>
<p>The worst thing that can happen is that your package manager may not have Cabal at all. In that case you may need Haskell Platform temporarily, for booting GHC and Cabal. Once you have Haskell Platform(which includes Cabal) and run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, just remove Haskell Platform and download latest GHC as mentioned above and go from there.</p>
<p>Occasionally you may want to remove some directories in <code>~/.cabal/lib</code>. Here’s what I have right now:</p>
<pre><code>➜  lib  pwd
/home/omer/.cabal/lib
➜  lib  ls | xargs du -hs
107M    x86_64-linux-ghc-7.6.3
341M    x86_64-linux-ghc-7.8.3
170M    x86_64-linux-ghcjs-0.1.0_ghc-7.8.2
34M     x86_64-linux-ghcjs-0.1.0_ghc-7.8.3</code></pre>
<p>I have 170M of libraries installed in GHCJS compiled with GHC 7.8.2, but I updated my GHCJS installation and I won’t be using that version anymore, so it’s safe to remove that directory. Similarly you may want to remove versions you won’t be using anymore.</p>
<p>Once you have GHC and Cabal installed, you should be very careful with global installations. Basically all you need to do is to use sandboxes as much as possible. You may want or need to have some programs installed globally, like <code>alex</code> and <code>happy</code> and those are fine since they have almost no dependencies at all.</p>
<p>In all other cases, just create a <code>~/bin</code> directory and add it to your <code>$PATH</code>. Now whenever you need a Haskell program in your path, install it in a sandbox, and symlink it to <code>~/bin</code>.</p>
<p>Another very useful tip: You may still have some installation problems because of dependency conflicts. In that cases always try to install with <code>cabal install --allow-newer</code>. Most of the time this sandbox approach + <code>--allow-newer</code> should solve all your problems.</p>
<p>As a last thing, if you still have problems because you installed some libs globally for some reason, you may want to reset your whole Cabal state. In that case, just copy <code>~/.cabal/bin/cabal</code> to somewhere else and remove <code>~/.cabal</code>. Then using copied <code>cabal</code> executable, run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code> again. Now you have a fresh Cabal state and you can remove copied <code>cabal</code> executable and go with the one just installed at <code>~/.cabal/bin</code>.</p>
<p>I hope this helps.</p>]]></summary>
</entry>
<entry>
    <title>Proving sorting algorithms correct</title>
    <link href="http://osa1.net/posts/2014-09-08-proving-sorting-correct.html" />
    <id>http://osa1.net/posts/2014-09-08-proving-sorting-correct.html</id>
    <published>2014-09-08T00:00:00Z</published>
    <updated>2014-09-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

I've been working on proving some sorting algorithms correct in Coq. After 600 lines of Coq proofs, I managed to prove correctness of <a href="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>, <a href="http://en.wikipedia.org/wiki/Selection_sort">selection sort</a>, and a weird sorting algorithm called <a href="http://austingwalters.com/everyday-algorithms-pancake-sort/">pancake sort</a>. This post is a <a href="https://github.com/osa1/blog/blob/master/theories/SortingCorrect.v">literate Coq file</a> which you can download and execute in a Coq IDE, step by step. To keep the post shorter and easier to read and make it more like an exercise, I hided most of the proofs in HTML version.

<div class="paragraph"> </div>

Goals of this post are:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Provide some guidance for starters who are interested in proving algorithms correct.

</li>
<li> Demonstrate how to prove properties of functions with accumulators and functions that work on list indexes, instead of elements of the list.

</li>
<li> Demonstrate how to use "timeout" arguments to convince Coq that a function is really terminating on all inputs.

</li>
</ul>
A note before starting: I deliberately ignored advanced proof automation tools and go with more primitive way of proving. This is for two reasons: 1) I don't like magic, and since I don't understand underlying mechanics of advanced proofs tactics like <span class="inlinecode"><span class="id" type="var">crush</span></span>, it's magic to me 2) They're sometimes so powerful, they get in your way to understand what's really happening in the proof.

<div class="paragraph"> </div>

If you're reading this post as an exercise and filling the proofs yourself, that should not be a problem for you. Otherwise you may find my proofs more verbose than what's necessary.

<div class="paragraph"> </div>

Let's start with standard stuff: imports. These are for some list helpers, list syntax, Peano definitions + functions etc. Just standard stuff. Only exception is the <span class="inlinecode"><span class="id" type="var">Permutation</span></span> library, which I'll soon explain why it's necessary.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#"><span class="id" type="library">List</span></a>.<br />
<span class="id" type="keyword">Import</span> <span class="id" type="var">ListNotations</span>.<br />
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list_scope</span>.<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Arith.html#"><span class="id" type="library">Arith</span></a>.<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.omega.Omega.html#"><span class="id" type="library">Omega</span></a>.<br />
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#"><span class="id" type="library">Permutation</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Our goal is to define some sorting algorithms and then prove them correct, but for that we first need to define what we mean by for a sorting algorithm to be "correct". For some functions definition of correctness may be tricky to give, but in the context of sorting I think it's obvious:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Result should be a permutation of it's parameter.

</li>
<li> Result should be in sorted order.

</li>
</ul>
Definition of a "permutation" is defined in the <span class="inlinecode"><span class="id" type="var">Permutation</span></span> library we've just included, and it comes with lots of very useful lemmas. I suggest you to go to <span class="inlinecode"><span class="id" type="var">Permutation</span></span> library's documentation(you can go to the docs by clicking <span class="inlinecode"><span class="id" type="var">Permutation</span></span> link in the imports part above) and just skim through the definition and lemmas, and convince yourself that the definition is really enough to show that two lists are really a permutation.

<div class="paragraph"> </div>

For being sorted, we need to define what does that mean.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="sorted"><span class="id" type="inductive">sorted</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br />
| <a name="Sorted_nil"><span class="id" type="constructor">Sorted_nil</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
| <a name="Sorted_singleton"><span class="id" type="constructor">Sorted_singleton</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br />
| <a name="Sorted_cons"><span class="id" type="constructor">Sorted_cons</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Again, convince yourself that <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> really encodes what we intuitively know about being sorted. Main property that should hold for any <span class="inlinecode"><span class="id" type="var">l</span></span> that is <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> is that for any consecutive elements <span class="inlinecode"><span class="id" type="var">a</span></span> and <span class="inlinecode"><span class="id" type="var">b</span></span> in the list, <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" type="var">b</span></span> should hold, which our third constructor shows.

<div class="paragraph"> </div>

Using <span class="inlinecode"><span class="id" type="var">Permutation</span></span> and <span class="inlinecode"><span class="id" type="var">sorted</span></span>, we can define what does being correct for a sorting algorithm mean:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> (<span class="id" type="var">algo</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) :=<br />
| <a name="sorting_correct_intro"><span class="id" type="constructor">sorting_correct_intro</span></a> :<br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<span class="id" type="var">algo</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<span class="id" type="var">algo</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>)) → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <span class="id" type="var">algo</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Note that in both definition of <span class="inlinecode"><span class="id" type="var">sorted</span></span> and <span class="inlinecode"><span class="id" type="var">Sorting_correct</span></span>, we used list of nats instead of any lists of ordered elements. This is really just to make definitions and proofs simpler. Generalization may be done as an exercise.

<div class="paragraph"> </div>

Now with those definitions, we can prove our first and easiest-to-prove algorithm.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Insertion sort</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

We define insertion sort as a right fold:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="insert"><span class="id" type="definition">insert</span></a> (<span class="id" type="var">i</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a><br />
&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Compare_dec.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <span class="id" type="var">h</span> <span class="id" type="keyword">then</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> <span class="id" type="keyword">else</span> <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <span class="id" type="var">t</span><br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="insertion_sort"><span class="id" type="definition">insertion_sort</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#fold_right"><span class="id" type="definition">fold_right</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now if we could show that <span class="inlinecode"><span class="id" type="var">insert</span></span> <span class="inlinecode"><span class="id" type="var">h</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> on list <span class="inlinecode"><span class="id" type="var">h</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">t</span></span> returns a permutation, we could easily show that insertion sort returns a permutation, because all it does is to call <span class="inlinecode"><span class="id" type="var">insert</span></span> on list elements, using <span class="inlinecode"><span class="id" type="var">fold_right</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="insert_perm"><span class="id" type="lemma">insert_perm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use <span class="inlinecode"><span class="id" type="var">insert_perm</span></span> and transitivity, symmetry and reflexivity of <span class="inlinecode"><span class="id" type="var">Permutation</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="Permutation_insertion_sort"><span class="id" type="lemma">Permutation_insertion_sort</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort"><span class="id" type="definition">insertion_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

To show that it returns sorted, we use a similar approach. We first show that if <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>, then <span class="inlinecode"><span class="id" type="var">sorted</span></span> <span class="inlinecode">(<span class="id" type="var">insert</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span>. Empty and singleton lists are sorted by definition. Using these facts, we can easily prove that insertion sort really return sorted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 star. You need to use some lemmas about <span class="inlinecode"><span class="id" type="var">leb</span></span> that are already included. Use <span class="inlinecode"><span class="id" type="keyword">SearchAbout</span></span> <span class="inlinecode"><span class="id" type="var">leb</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="insert_sorted_preserve"><span class="id" type="lemma">insert_sorted_preserve</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">l</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insert"><span class="id" type="definition">insert</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 star. Use <span class="inlinecode"><span class="id" type="var">insert_sorted_preserve</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="insertion_sort_sorted"><span class="id" type="lemma">insertion_sort_sorted</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort"><span class="id" type="definition">insertion_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

With permutation and sorted properties proved, we can show that our insertion sort implementation is correct:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="insertion_sort_correct"><span class="id" type="lemma">insertion_sort_correct</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort"><span class="id" type="definition">insertion_sort</span></a>.<br />
<span class="id" type="keyword">Proof</span>.<br />
&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#insertion_sort_sorted"><span class="id" type="lemma">insertion_sort_sorted</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Permutation_insertion_sort"><span class="id" type="lemma">Permutation_insertion_sort</span></a>.<br />
<span class="id" type="keyword">Qed</span>.<br />

<br />
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Selection sort</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Next, we move to selection sort. This one is significantly harder and most stuff we define in this section will be used in the next section.

<div class="paragraph"> </div>

Before implementing the algorithm, we need some auxiliary functions. <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> is both used in selection sort and pancake sort. As you can imagine from the name, it returns index of one of the smallest elements in a list.

<div class="paragraph"> </div>

Note that it's very very hard to reason about this definition. The reason is that we're using index of a list, instead of head/tail of it. Simple induction-based proofs that we do before simply don't work on this definition.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">min</span> <span class="id" type="var">min_idx</span> <span class="id" type="var">cur_idx</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a><br />
&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Compare_dec.html#leb"><span class="id" type="definition">leb</span></a> <span class="id" type="var">h</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min"><span class="id" type="variable">min</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">h</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#cur_idx"><span class="id" type="variable">cur_idx</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#cur_idx"><span class="id" type="variable">cur_idx</span></a>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min"><span class="id" type="variable">min</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#cur_idx"><span class="id" type="variable">cur_idx</span></a>)<br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="find_min_idx"><span class="id" type="definition">find_min_idx</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ 0<br />
&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">h</span> 0 1<br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

An invariant of <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span>:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="find_min_idx_len_inv"><span class="id" type="lemma">find_min_idx_len_inv</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span> <span class="id" type="var">m</span> <span class="id" type="var">mi</span> <span class="id" type="var">ci</span> <span class="id" type="var">r</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#mi"><span class="id" type="variable">mi</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#ci"><span class="id" type="variable">ci</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#r"><span class="id" type="variable">r</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#mi"><span class="id" type="variable">mi</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#ci"><span class="id" type="variable">ci</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#r"><span class="id" type="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#ci"><span class="id" type="variable">ci</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Make sure you understand what it's saying. We need this lemma to eliminate some impossible cases in proofs.

<div class="paragraph"> </div>

We also need a "membership" predicate. This is used to express the idea of "for all elements in the list ...", which is expressed in Coq like <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">e</span>,</span> <span class="inlinecode"><span class="id" type="var">member</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">→</span> <span class="inlinecode">...</span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="member"><span class="id" type="inductive">member</span></a> {<span class="id" type="var">A</span>} : <span class="id" type="var">A</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">A</span> → <span class="id" type="keyword">Prop</span> :=<br />
| <a name="Member_head"><span class="id" type="constructor">Member_head</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>)<br />
| <a name="Member_tail"><span class="id" type="constructor">Member_tail</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Again, convince yourself that this really expresses that idea. Here's a property of member:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="member_preserved_by_perm"><span class="id" type="lemma">member_preserved_by_perm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) <span class="id" type="var">l'</span> <span class="id" type="var">e</span>,<br />
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now using <span class="inlinecode"><span class="id" type="var">member</span></span>, we can express correctness of <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> and prove it. Note that this is a very hard exercise. I couldn't solve it for a week, and even after that period I couldn't solve it without help from Coq IRC channel. Feel free to cheat by looking the source of this post.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
</div>

<div class="doc">
***** Exercise: 5 stars. <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> really returns index of smallest element. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="find_min_idx_correct"><span class="id" type="lemma">find_min_idx_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx"><span class="id" type="definition">find_min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now, in selection sort, we run several operations on argument. One of them is <span class="inlinecode"><span class="id" type="var">find_min_idx</span></span> which we already defined. Another one of them is <span class="inlinecode"><span class="id" type="tactic">replace</span></span> operation, which replaces nth element in a list with given element. Here's a definition and some properties:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="replace"><span class="id" type="definition">replace</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">idx</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">e</span> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#idx"><span class="id" type="variable">idx</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">idx'</span> ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <span class="id" type="var">t</span> <span class="id" type="var">idx'</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. First part of correctness proof of <span class="inlinecode"><span class="id" type="tactic">replace</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="replace_nth"><span class="id" type="lemma">replace_nth</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> <span class="id" type="var">e</span> <span class="id" type="var">l'</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>.<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. Second part of correctness proof of <span class="inlinecode"><span class="id" type="tactic">replace</span></span>. <span class="inlinecode"><span class="id" type="tactic">replace</span></span> preserves length of the list. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="replace_len"><span class="id" type="lemma">replace_len</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> (<span class="id" type="var">e</span> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Using <span class="inlinecode"><span class="id" type="tactic">replace</span></span>, we can define <span class="inlinecode"><span class="id" type="var">selection_sort</span></span>. Note that our naive implementation doesn't convince Coq that it terminates on all input. An easy workaround is to add a <span class="inlinecode"><span class="id" type="var">step</span></span> parameter. Observing that selection sort algorithm terminates in <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> steps, where <span class="inlinecode"><span class="id" type="var">l</span></span> is the input, we can define this:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">step</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#step"><span class="id" type="variable">step</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| 0       ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">step'</span> ⇒<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx_aux"><span class="id" type="definition">find_min_idx_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">h</span> 0 1 <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0     ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> <span class="id" type="var">t</span> <span class="id" type="var">step'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">min</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <span class="id" type="var">min</span> <span class="id" type="var">t</span> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <span class="id" type="var">t</span> <span class="id" type="var">min</span> <span class="id" type="var">h</span>) <span class="id" type="var">step'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="selection_sort"><span class="id" type="definition">selection_sort</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> := <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort_aux"><span class="id" type="definition">selection_sort_aux</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

We have all we need to prove permutation property. It's still not easy though. I'm putting an extra lemma here as a tip.

</div>
<div class="code">

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="replace_perm_head"><span class="id" type="lemma">replace_perm_head</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 3 stars. Use <span class="inlinecode"><span class="id" type="var">replace_perm_head</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="Permutation_selection_sort"><span class="id" type="lemma">Permutation_selection_sort</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort"><span class="id" type="definition">selection_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Proving sorted property is again, not easy. I'm putting some lemmas as pointers. Lemmas are very easy to prove, leaving only the master theorem as a challange.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="member_replace"><span class="id" type="lemma">member_replace</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#x"><span class="id" type="variable">x</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#y"><span class="id" type="variable">y</span></a>) →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>.<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use <span class="inlinecode"><span class="id" type="var">member_replace</span></span> and <span class="inlinecode"><span class="id" type="var">find_min_idx_correct</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="swap_min_replace"><span class="id" type="lemma">swap_min_replace</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span> <span class="id" type="var">min_idx</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx"><span class="id" type="definition">find_min_idx</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#replace"><span class="id" type="definition">replace</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a>) → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="sorted_min_tail"><span class="id" type="lemma">sorted_min_tail</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>) →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use <span class="inlinecode"><span class="id" type="var">member_preserved_by_perm</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="min_preserved_by_perm"><span class="id" type="lemma">min_preserved_by_perm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">m</span> <span class="id" type="var">l</span> <span class="id" type="var">l'</span>,<br />
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>) →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 4 stars. Selection sort returns sorted. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="selection_sort_sorted"><span class="id" type="lemma">selection_sort_sorted</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort"><span class="id" type="definition">selection_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. Show that selection sort is correct. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="selection_sort_correct"><span class="id" type="lemma">selection_sort_correct</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#selection_sort"><span class="id" type="definition">selection_sort</span></a>.<br />

<br />
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">Pancake sort</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

This is getting harder and harder. We'll define pancake sort in terms of <span class="inlinecode"><span class="id" type="var">rev_at</span></span> which reverses a list at given index and <span class="inlinecode"><span class="id" type="var">map_rest</span></span> which is like <span class="inlinecode"><span class="id" type="var">map</span></span>, but applies the function to the rest of the list.

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="rev_at"><span class="id" type="definition">rev_at</span></a> {<span class="id" type="var">A</span>} <span class="id" type="var">idx</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#idx"><span class="id" type="variable">idx</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| 0      ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">idx'</span> ⇒<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a>     ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <span class="id" type="var">idx'</span> <span class="id" type="var">t</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Fixpoint</span> <a name="map_rest_aux"><span class="id" type="definition">map_rest_aux</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">timeout</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#timeout"><span class="id" type="variable">timeout</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;| 0 ⇒ <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a><br />
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">timeout'</span> ⇒<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#ListNotations.:list_scope:'['_']'"><span class="id" type="notation">[]</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <span class="id" type="var">t</span> ⇒ <span class="id" type="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest_aux"><span class="id" type="definition">map_rest_aux</span></a> <span class="id" type="var">t</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> <span class="id" type="var">timeout'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br />
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="map_rest"><span class="id" type="definition">map_rest</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> :=<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest_aux"><span class="id" type="definition">map_rest_aux</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Two things to note: 1) <span class="inlinecode"><span class="id" type="var">rev_at</span></span> returns the original list if <span class="inlinecode"><span class="id" type="var">idx</span></span> is larger than <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">-</span> <span class="inlinecode">1</span>. 2) <span class="inlinecode"><span class="id" type="var">map_rest</span></span> only works as expected if <span class="inlinecode"><span class="id" type="var">f</span></span> preserves length of it's argument in it's return value.

<div class="paragraph"> </div>

There's a very useful property that we need to show before showing that pancake sort returns a permutation: if <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> returns a permutation, than <span class="inlinecode"><span class="id" type="var">map_rest</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode"><span class="id" type="var">f</span></span> returns a permutation:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 stars. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Permutation_map_rest"><span class="id" type="lemma">Permutation_map_rest</span></a> :<br />
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> (<span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>)) →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest"><span class="id" type="definition">map_rest</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#f"><span class="id" type="variable">f</span></a>)).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Using this definition we can define pancake sort:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Definition</span> <a name="flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br />
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">min_idx</span> := <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#find_min_idx"><span class="id" type="definition">find_min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">in</span><br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> 0 (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#min_idx"><span class="id" type="variable">min_idx</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="pancake_sort"><span class="id" type="definition">pancake_sort</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> := <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#map_rest"><span class="id" type="definition">map_rest</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Showing permutation property is actually very easy. All we need is two simple lemmas:

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 stars. Use already included standard permutation lemmas. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Permutation_rev_at"><span class="id" type="lemma">Permutation_rev_at</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">n</span> (<span class="id" type="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#A"><span class="id" type="variable">A</span></a>),<br />
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 2 stars. Use transitivity of permutation and <span class="inlinecode"><span class="id" type="var">Permutation_rev_at</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="Permutation_flip_pancakes"><span class="id" type="lemma">Permutation_flip_pancakes</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. Use <span class="inlinecode"><span class="id" type="var">Permutation_flip_pancakes</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="Permutation_pancake_sort"><span class="id" type="lemma">Permutation_pancake_sort</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sort"><span class="id" type="definition">pancake_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now the hard part. I needed a lot of lemmas for showing sorted property. I'm listing lemmas I used in no particular order.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 ***** Exercise: 2 stars. Smallest element is still smallest in a permutation. I found this a bit tricky. You may need to use another lemma we defined. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="min_permutation"><span class="id" type="lemma">min_permutation</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">e</span> <span class="id" type="var">l</span>,<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e'</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a>) →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">l'</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Sorting.Permutation.html#Permutation"><span class="id" type="inductive">Permutation</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> →<br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e'</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l'"><span class="id" type="variable">l'</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a>)).<br />

<br />
</div>

<div class="doc">
***** Exercise: 1 star. <span class="inlinecode"><span class="id" type="var">flip_pancakes</span></span> preserves the length. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="flip_pancakes_len"><span class="id" type="lemma">flip_pancakes_len</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />

<br />
</div>

<div class="doc">
***** Exercise: 4 stars. We can use <span class="inlinecode"><span class="id" type="var">rev_at</span></span> to move smallest element to the end of the list, and then to the beginning of the list. Very tricky. Feel free to cheat. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="rev_at_n"><span class="id" type="lemma">rev_at_n</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> 0 (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#rev_at"><span class="id" type="definition">rev_at</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t"><span class="id" type="variable">t</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Lists.List.html#nth"><span class="id" type="definition">nth</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> 0.<br />

<br />

<br />
</div>

<div class="doc">
***** Exercise: 3 stars. <span class="inlinecode"><span class="id" type="var">flip_pancakes</span></span> moves smallest element to the head of the list. 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="flip_pancakes_min"><span class="id" type="lemma">flip_pancakes_min</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span> <span class="id" type="var">h'</span> <span class="id" type="var">t'</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#flip_pancakes"><span class="id" type="definition">flip_pancakes</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h'"><span class="id" type="variable">h'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:list_scope:x_'::'_x"><span class="id" type="notation">::</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t'"><span class="id" type="variable">t'</span></a> →<br />
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">e'</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#member"><span class="id" type="inductive">member</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#t'"><span class="id" type="variable">t'</span></a> → <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#h'"><span class="id" type="variable">h'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#e'"><span class="id" type="variable">e'</span></a>).<br />

<br />
</div>

<div class="doc">
***** Exercise: 4 stars. You need a lot of lemmas we defined before, and it's a very long proof. Still not as hard as <span class="inlinecode"><span class="id" type="var">find_min_idx_correct</span></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="pancake_sorted"><span class="id" type="lemma">pancake_sorted</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">l</span>, <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#sorted"><span class="id" type="inductive">sorted</span></a> (<a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sort"><span class="id" type="definition">pancake_sort</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#l"><span class="id" type="variable">l</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

And finally, our master theorem:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="pancake_sort_correct"><span class="id" type="lemma">pancake_sort_correct</span></a> : <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Sorting_correct"><span class="id" type="inductive">Sorting_correct</span></a> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sort"><span class="id" type="definition">pancake_sort</span></a>.<br />
<span class="id" type="keyword">Proof</span>.<br />
&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">intro</span>. <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#pancake_sorted"><span class="id" type="lemma">pancake_sorted</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="/posts/2014-09-08-proving-sorting-correct.html#Permutation_pancake_sort"><span class="id" type="lemma">Permutation_pancake_sort</span></a>.<br />
<span class="id" type="keyword">Qed</span>.<br />

<br />
</div>

<div class="doc">
<a name="lab4"></a><h1 class="section">Notes and lessons learned</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Implementation of algorithms are not what you'd expect to have in an imperative language. Rather than mutable arrays with O(1) access, I used classic functional style, using persistent linked lists. While that doesn't affect runtime asymptotic complexities of sorting algorithms I used, it causes a lot of redundant allocations and worse iteration performance. Even the OCaml/Haskell extractions are not usable.

<div class="paragraph"> </div>

Still, proving on those purely functional definitions were very hard. The reason is that once you move away from basic "induction of subterm" style proofs, proving gets very hard very fast. Specifically, I found working on indexes and accumulators very hard.

<div class="paragraph"> </div>

As a next step, I'm hoping to define an imperative language in Coq, like IMP of Software Foundations but with mutable arrays, and prove same algorithms defined in that language correct.

<div class="paragraph"> </div>


</div>
<div class="code">
</div>
]]></summary>
</entry>
<entry>
    <title>Two awesome blogs</title>
    <link href="http://osa1.net/posts/2014-07-20-two-awesome-blogs.html" />
    <id>http://osa1.net/posts/2014-07-20-two-awesome-blogs.html</id>
    <published>2014-07-20T00:00:00Z</published>
    <updated>2014-07-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just want to link this two awesome blogs here. I’ve been spending my last couple of weekends trying to read every single post in those blogs.</p>
<ul>
<li><a href="http://existentialtype.wordpress.com">Robert Harper’s blog</a>: About programming language semantics, type theory, type systems, sometimes HoTT and constructive mathematics related stuff.</li>
<li><a href="http://math.andrej.com">Andrej Bauer’s blog</a>: About maths and computation. I don’t understand 80% of the posts(hopefully this will change). Rest of them is about constructive mathematics/proofs, Coq, sometimes Haskell and types.</li>
</ul>
<p>Bonus content:</p>
<ul>
<li><a href="http://poleiro.info/" class="uri">http://poleiro.info/</a> is a great blog with beginner-intermediate level Coq posts. I hope the author keeps new posts coming.</li>
<li><a href="http://homotopytypetheory.org/2012/08/18/a-master-thesis-on-homotopy-type-theory/">A master thesis on HoTT</a>: I just started reading this and it looks like easy to understand even for people with not much understanding of type theory or related topics, like me. The author was a student of Andrej Bauer.</li>
</ul>
<p>Side note: I’ll hopefully publish a blog post about verification of a somewhat weird and useless sorting algorithm soon.</p>]]></summary>
</entry>
<entry>
    <title>Coq exercises for beginners</title>
    <link href="http://osa1.net/posts/2014-07-12-fun-coq-exercises.html" />
    <id>http://osa1.net/posts/2014-07-12-fun-coq-exercises.html</id>
    <published>2014-07-12T00:00:00Z</published>
    <updated>2014-07-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<style>
.solution {
  background-color: rgb(245, 245, 245);
  padding-left: 1em;
}
</style>
<p>Formalizing abstractions/data structures and proving theorems about them in Coq is so much fun. I made up some simple exercises that consist of encoding some abstractions and laws we know from algebra and functional programming and then proving that some particular set + some operations on that set obeys the laws.</p>
<p>Using my amazing(!) JavaScript skills, I set up some “show/hide answer” buttons after each exercise. Exercises are easy, but the latter ones are relatively harder. Some abstractions/laws are inspired by Haskell.</p>
<p>Please note that I’m a beginner so my solutions probably have some flaws if you want to use them in large-scale verified programs :) I’m currently learning about typeclasses and records of Coq and I’m open to suggestions for improvements.</p>
<p>In exercises, when we talk that an abstraction should obey some laws, you need to enforce it in construction. e.g. You need to make constructors in a way that user would have to prove that the data structure + operations obey the laws.</p>
<pre class="coq"><code>Require Import List.
Import ListNotations.

Open Scope list_scope.</code></pre>
<h1 id="exercise-1">Exercise 1</h1>
<p>A <a href="http://en.wikipedia.org/wiki/Semigroup">semigroup</a> is a set together with an associative binary function. For example, natural numbers and addition function form a semigroup, because we know/can prove that addition function is associative. More precisely: (in Coq syntax)</p>
<pre class="coq"><code>forall (n1 n2 n3 : nat), n1 + (n2 + 3) = (n1 + n2) + n3.</code></pre>
<p>Encode semigroups in Coq.</p>
<div id="ex-div-1.1" class="solution">
<pre class="coq"><code>Inductive semigroup (A : Type) (Op : A -&gt; A -&gt; A) : Prop :=
| Semigroup_intro :
    (forall (a1 a2 a3 : A), Op a1 (Op a2 a3) = Op (Op a1 a2) a3) -&gt; semigroup A Op.</code></pre>
</div>
<button id="ex-btn-1.1">
</button>
<p>Now prove that lists together with append operation form a semigroup. Use standard Coq lists and <code>app</code> function.</p>
<div id="ex-div-1.2" class="solution">
<pre class="coq"><code>Theorem list_semigroup : forall A, semigroup (list A) (@app A).
Proof.
  intro. apply Semigroup_intro. intros.
  induction a1.
  + reflexivity.
  + simpl. f_equal. induction a2; auto.
Qed.</code></pre>
</div>
<button id="ex-btn-1.2">
</button>
<h1 id="exercise-2">Exercise 2</h1>
<p>A <a href="http://en.wikipedia.org/wiki/Monoid">monoid</a> is a semigroup with an identity element. In our addition example, identity element is 0, because when applied to the monoid function(addition) as first or second argument, results is the other argument:</p>
<pre class="coq"><code>forall (n : nat), 0 + n = n /\ n + 0 = n.</code></pre>
<p>Encode monoids in Coq.</p>
<div id="ex-div-2.1" class="solution">
<pre class="coq"><code>Inductive monoid A Op (sg : semigroup A Op) (U : A) : Prop :=
| Monoid_intro :
    semigroup A Op -&gt; (forall (a : A), Op U a = Op a U /\ Op U a = a) -&gt; monoid A Op sg U.</code></pre>
</div>
<button id="ex-btn-2.1">
</button>
<p>Now prove that lists with empty list as unit element together with the proof that lists are monoids as we proved in previous exercise, form a monoid.</p>
<div id="ex-div-2.2" class="solution">
<pre class="coq"><code>Theorem list_monoid : forall A, monoid (list A) (@app A) (@list_semigroup A) [].
Proof.
  intro. apply Monoid_intro. apply list_semigroup.
  intro. split.
  + rewrite app_nil_r. reflexivity.
  + reflexivity.
Qed.</code></pre>
</div>
<button id="ex-btn-2.2">
</button>
<h1 id="exercise-3">Exercise 3</h1>
<p>In this exercise and exercise 4, we’ll be talking about Haskell definitions of abstractions, instead of algebra definitions. (although they may coincide)</p>
<p>A functor is a type with one argument(in Haskell terms, a type with kind <code>* -&gt; *</code>) and a function, together with some laws. If you’re unfamiliar with functors of Haskell, you may want to skip this, or read <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#Functor">Typeclassopedia</a>.</p>
<p>A Coq definition would use these to encode functors:</p>
<ul>
<li>Functor type: <code>F : Type -&gt; Type</code></li>
<li>Functor operation: <code>forall t1 t2, (t1 -&gt; t2) -&gt; f t1 -&gt; f t2</code> (let’s call it fmap)</li>
</ul>
<p>A functor should obey these laws:</p>
<ul>
<li><code>fmap id = id</code></li>
<li><code>fmap (fun x =&gt; g (h x)) = fun x =&gt; (fmap g (fmap h x))</code></li>
</ul>
<p>Encode functors in Coq.</p>
<div id="ex-div-3.1" class="solution">
<pre class="coq"><code>Inductive functor (F : Type -&gt; Type) : (forall t1 t2, (t1 -&gt; t2) -&gt; f t1 -&gt; f t2) -&gt; Prop :=
| Functor_intro
    (fmap : forall t1 t2, (t1 -&gt; t2) -&gt; F t1 -&gt; F t2)
    (l1   : forall t f, fmap t t id f = f)
    (l2   : forall t1 t2 t3, forall (f : F t1) (p : t2 -&gt; t3) (q : t1 -&gt; t2),
              fmap t1 t3 (fun a =&gt; p (q a)) f = fmap t2 t3 p (fmap t1 t2 q f)) :
    functor F fmap.</code></pre>
</div>
<button id="ex-btn-3.1">
</button>
<p>Now prove that lists with standard map function form a functor.</p>
<div id="ex-div-3.2" class="solution">
<pre class="coq"><code>Theorem list_functor : functor list map.
Proof.
  apply Functor_intro.
  + intros. induction f. reflexivity. simpl. rewrite IHf. reflexivity.
  + intros. induction f. reflexivity. simpl. f_equal. apply IHf.
Qed.</code></pre>
</div>
<button id="ex-btn-3.2">
</button>
<h1 id="exercise-4">Exercise 4</h1>
<p>A monad is a functor with two more operations; let’s call <code>bind</code> and <code>lift</code> and some more laws. In Coq syntax: (<code>F</code> is our functor type)</p>
<ul>
<li>bind: <code>forall t1 t2, F t1 -&gt; (t1 -&gt; F t2) -&gt; F t2</code></li>
<li>lift: <code>forall t, t -&gt; F t</code></li>
</ul>
<p>Laws:</p>
<ul>
<li>Left identity: <code>forall t1 t2 a f, bind t1 t2 (lift t1 a) f = f a</code></li>
<li>Right identity: <code>right_id : forall t m, bind t t m (lift t) = m</code></li>
<li>Associativity: <code>forall t1 t2 t3 m f g, bind t2 t3 (bind t1 t2 m f) g = bind t1 t3 m (fun x =&gt; bind t2 t3 (f x) g)</code></li>
</ul>
<p>Encode monads in Coq.</p>
<div id="ex-div-4.1" class="solution">
<pre class="coq"><code>Inductive monad : (Type -&gt; Type) -&gt; Prop :=
| Monad_intro
    (F        : Type -&gt; Type)
    (fmap     : forall t1 t2, (t1 -&gt; t2) -&gt; F t1 -&gt; F t2)
    (Fp       : functor F fmap)
    (lift     : forall t, t -&gt; F t)
    (bind     : forall t1 t2, F t1 -&gt; (t1 -&gt; F t2) -&gt; F t2)
    (left_id  : forall t1 t2 a f, bind t1 t2 (lift t1 a) f = f a)
    (right_id : forall t m, bind t t m (lift t) = m)
    (assoc    : forall t1 t2 t3 m f g,
                  bind t2 t3 (bind t1 t2 m f) g = bind t1 t3 m (fun x =&gt; bind t2 t3 (f x) g)) :
    monad F.</code></pre>
</div>
<button id="ex-btn-4.1">
</button>
<p>Now prove that lists form a monad. You need to figure out what functions to use for <code>lift</code> and <code>bind</code>.</p>
<div id="ex-div-4.2" class="solution">
<p><code>lift</code> function:</p>
<pre class="coq"><code>(* I couldn&#39;t find this in stdlib so let&#39;s define *)
Definition singleton (A : Type) (x : A) := [x].</code></pre>
<p>For <code>bind</code>, you can use standard <code>flat_map</code> function, but it’s argument order is reversed. So instead I rolled my own version:</p>
<pre class="coq"><code>Fixpoint concat {A : Type} (l : list (list A)) : list A :=
  match l with
  | []     =&gt; []
  | h :: t =&gt; app h (concat t)
  end.

(* I don&#39;t like argument order of flat_map in stdlib ... *)
Definition concatMap (A : Type) (B : Type) (l : list A) (f : A -&gt; list B) : list B :=
  concat (map f l).</code></pre>
<p>Now most involved proof in this exercises: (still very easy)</p>
<pre class="coq"><code>Theorem list_monad : monad list.
Proof.
  apply Monad_intro with (fmap := map) (lift := singleton) (bind := concatMap).
  + apply list_functor.
  + intros. unfold concatMap. simpl. rewrite app_nil_r. reflexivity.
  + intros. unfold concatMap. induction m.
    - reflexivity.
    - simpl. f_equal. apply IHm.
  + intros. induction m as [|h t].
    - reflexivity.
    - unfold concatMap in *. simpl. rewrite &lt;- IHt. 
      assert (forall A (l1 : list (list A)) (l2 : list (list A)),
                concat l1 ++ concat l2 = concat (l1 ++ l2)) as H.
        intros. induction l1; auto.
          simpl. rewrite &lt;- app_assoc. rewrite IHl1. auto.
      rewrite H. f_equal. rewrite map_app. reflexivity.
Qed.</code></pre>
</div>
<button id="ex-btn-4.2">
</button>
<h1 id="exercise-5">Exercise 5</h1>
<p>Prove that standard <code>option</code> type with some operations form a semigroup, monoid, functor and monad. You need to find relevant operations.</p>
<p>What restrictions do you need on <code>option</code>s type argument? (<code>A</code> in <code>option A</code>) Does it need to form a monoid for <code>option</code> to form a monoid?</p>
<div id="ex-div-5.1" class="solution">
<pre class="coq"><code>Definition map_option (A B : Type) (f : A -&gt; B) (opt : option A) :=
  match opt with
  | None =&gt; None
  | Some t =&gt; Some (f t)
  end.

Definition append_option A OpA (sg : semigroup A OpA) (a b : option A) : option A :=
  match a, b with
  | None, None =&gt; None
  | None, Some b&#39; =&gt; Some b&#39;
  | Some a&#39;, None =&gt; Some a&#39;
  | Some a&#39;, Some b&#39; =&gt; Some (OpA a&#39; b&#39;)
  end.

Theorem option_semigroup : forall A OpA (sg : semigroup A OpA),
  semigroup (option A) (append_option A OpA sg).
Proof.
  intros. apply Semigroup_intro. intros. destruct a1.
  + destruct a2.
    - destruct a3.
      * simpl. f_equal. inversion sg. apply H.
      * simpl. reflexivity.
    - destruct a3; simpl; reflexivity.
  + destruct a2; destruct a3; auto.
Qed.

Theorem option_monoid : forall A OpA (sg : semigroup A OpA),
  monoid (option A) (append_option A OpA sg) (option_semigroup A OpA sg) None.
Proof.
  intros. apply Monoid_intro. apply option_semigroup.
  intros. split. auto. destruct a; auto.
Qed.

Definition option_map A B (f : A -&gt; B) (o : option A) : option B :=
  match o with
  | None =&gt; None
  | Some a =&gt; Some (f a)
  end.

Theorem option_functor : functor option option_map.
Proof.
  apply Functor_intro; intros; destruct f; auto.
Qed.

Definition option_bind A B (o1 : option A) (f : A -&gt; option B) : option B :=
  match o1 with
  | None =&gt; None
  | Some a =&gt; f a
  end.

Theorem option_monad : monad option.
Proof.
  apply Monad_intro with (fmap := option_map) (lift := Some) (bind := option_bind).
  + apply option_functor.
  + intros. auto.
  + intros. destruct m; auto.
  + intros. destruct m; auto.
Qed.</code></pre>
</div>
<button id="ex-btn-5.1">
</button>
<h1 id="exercise-6">Exercise 6</h1>
<p>I only have a partial solution to this one and it’s not strictly a Coq exercise, but it’s still fun :)</p>
<p>A <a href="http://en.wikipedia.org/wiki/Group_(mathematics)">group</a> is a monoid with inverse element of every element. In Coq syntax:</p>
<pre class="coq"><code>forall e, exists e_i -&gt; op e e_1 = U</code></pre>
<p>where <code>op</code> is monoid operation and <code>U</code> is unit of monoid.</p>
<p>Can you come up with a data structure that forms a group?</p>
<div id="ex-div-6.1" class="solution">
<p>Someone at Coq IRC channel suggested diffs. Do you think a diff could form a group? What would associative operation, unit element, and inverse elements be?</p>
<div id="ex-div-6.2" class="solution">
<p>Diffs don’t form a group. Composing two diffs is the merge operation, which is partial function. We can’t always merge two diffs. (merge conflicts)</p>
<p>So I don’t have an answer to this exercise, If you know examples to this one, please write at comments :)</p>
</div>
<button id="ex-btn-6.2">
</button>
</div>
<button id="ex-btn-6.1">
</button>
<script>
function showMsg(exNum) {
  return "Show solution (ex. " + exNum + ")";
}

function hideMsg(exNum) {
  return "Hide solution (ex. " + exNum + ")";
}

function setUpShowHide(exNum) {
  var div = document.getElementById("ex-div-" + exNum);
  var btn = document.getElementById("ex-btn-" + exNum);
  btn.innerHTML = showMsg(exNum);
  btn.onclick = function() {
    if (div.style.display !== 'none') {
      div.style.display = 'none';
      btn.innerHTML = showMsg(exNum);
    } else {
      div.style.display = 'block';
      btn.innerHTML = hideMsg(exNum);
    }
  }
  div.style.display = 'none';
}

setUpShowHide(1.1);
setUpShowHide(1.2);
setUpShowHide(2.1);
setUpShowHide(2.2);
setUpShowHide(3.1);
setUpShowHide(3.2);
setUpShowHide(4.1);
setUpShowHide(4.2);
setUpShowHide(5.1);
setUpShowHide(6.2);
setUpShowHide(6.1);
</script>]]></summary>
</entry>

</feed>
