<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-07-31T00:00:00Z</updated>
    <entry>
    <title>MANTI - Prolog implementation in 515 lines of Haskell</title>
    <link href="http://osa1.net/posts/2013-07-31-announce-manti.html" />
    <id>http://osa1.net/posts/2013-07-31-announce-manti.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/osa1/MANTI">MANTI</a> is a pure Prolog implementation in 515 lines of Haskell. It’s only implements pure parts, meaning it doesn’t have cuts, IO predicates, non-pure arithmetic(<code>is</code> structures in modern Prolog implementation) or other structures that break logical reasoning of Prolog programs.</p>
<p>Here are some example Prolog programs that currently runs under MANTI: (you can find these in <code>tests/</code> folder in source repository)</p>
<ul>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/einstein.pl">Einstein’s riddle</a> – also called Zebra Puzzle. You can see problem definition in <a href="http://en.wikipedia.org/wiki/Zebra_Puzzle">Wikipedia - Zebra Puzzle</a>.</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/nqueens.pl">N-queens problem</a> (not that it takes some time to solve it for board bigger than 5x5, reasons for that slowness explained below)</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/zurg.pl">Escape from Zurg puzzle</a> - you can see a paper with definition of this problem <a href="http://web.engr.oregonstate.edu/~erwig/zurg/">here</a>.</li>
</ul>
<p>My aim while writing MANTI was to make it as simple as possible, yet a complete Prolog implementation that is capable to solve some real problems. For this reasons, it doesn’t have arithmetic, list structures and list operations built-in. Instead, arithmetic is implemented using <a href="http://en.wikipedia.org/wiki/Peano_axioms">Peano definitions</a>, you can see the implementation <a href="https://github.com/osa1/MANTI/blob/master/tests/peano.pl">here</a>. List operations are also implemented in MANTI itself, you can see definitions <a href="https://github.com/osa1/MANTI/blob/master/tests/list.pl">here</a>. List syntax is nothing special, it’s just a syntactic sugar that destructs to ordinary Prolog functors(you can see parser for list syntax <a href="https://github.com/osa1/MANTI/blob/master/src/Parser.hs#L80">here</a>).</p>
<p>For these reasons(and probably others, for instance, unification and <code>not</code> connective are implemented in most inefficient ways possible), it’s very slow. Also, there’s no way to disable occurs check without recompiling MANTI.</p>
<p>It’s mostly done and I don’t think I’ll work more on that. I hope you find MANTI useful(for learning purposes or others).</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: My first academic work is now open source</title>
    <link href="http://osa1.net/posts/2013-07-22-sqml-open-sourced.html" />
    <id>http://osa1.net/posts/2013-07-22-sqml-open-sourced.html</id>
    <published>2013-07-22T00:00:00Z</published>
    <updated>2013-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Our work at Ozyegin University with Prof. Baris Aktemur is now open source.</p>
<ul>
<li>Home page: <a href="http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/">http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/</a></li>
<li>Github repository: <a href="https://github.com/ozusrl/SubtypedQuotedML">https://github.com/ozusrl/SubtypedQuotedML</a></li>
</ul>
<p>If you have trouble compiling/running it, please file an issue at Github page.</p>]]></summary>
</entry>
<entry>
    <title>Non-local returns in functional programs</title>
    <link href="http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html" />
    <id>http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html</id>
    <published>2013-07-21T00:00:00Z</published>
    <updated>2013-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s say we want to get nth visited element in depth-first traversal of a tree. Doing this is almost too easy in a language with statements(all imperative languages, some functional ones): Just run the depth-first traversal algorithm with explicit stack, and use <code>return</code> when you visit nth node.</p>
<p>In an expression language(Haskell, some Lisp languages) this is somewhat tricky.</p>
<p>Since I almost always prefer simplest possible solution of a problem, this would be my first attempt in a real-world situation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Branch</span> [<span class="dt">Tree</span> a]
    <span class="fu">|</span> <span class="dt">Leaf</span> a

<span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> [a]

<span class="ot">dfsNth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth tree n <span class="fu">=</span> listToMaybe <span class="fu">.</span> <span class="fu">drop</span> n <span class="fu">$</span> toList tree</code></pre>
<p>One concern about this function may be that the complexity of list generation. It’s hard to predict complexity of this function, but traversing the whole tree just to get first element of it would be costly anyway.</p>
<p>But thanks to lazy evaluation, this function still not very bad. Because only required parts of the intermediate list will be generated. To see why you can do two things: 1) Just place some <code>Debug.Trace.trace</code> calls in <code>toList</code> function and see how many times a leaf node is visited and 2) evaluate this function by hand and observe unevaluated thunks.</p>
<p>Let’s just do the first one, since it’s easier:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> trace <span class="st">&quot;leaf node visited&quot;</span> [a]

<span class="fu">...</span>

testTree <span class="fu">=</span> <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">1</span>, <span class="dt">Leaf</span> <span class="dv">2</span> ], <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">3</span> ], <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">4</span> ] ] ] ]</code></pre>
<pre><code>ghci&gt; dfsNth testTree 0
leaf node visited
Just 1

ghci&gt; dfsNth testTree 1
leaf node visited
leaf node visited
Just 2

ghci&gt; dfsNth testTree 10
leaf node visited
leaf node visited
leaf node visited
leaf node visited
Nothing</code></pre>
<hr />
<p>Other solutions are still worth exploring. When I think of “returning in the middle of a function” in Haskell, I always think <code>Either</code>. It’s monad definition is a great fit for this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">Either</span> e) <span class="kw">where</span>
    <span class="fu">return</span>        <span class="fu">=</span> <span class="kw">Right</span>
    <span class="kw">Left</span>  l <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Left</span> l
    <span class="kw">Right</span> r <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k r</code></pre>
<p>So when <code>Left data</code> used in monadic bind(<code>&gt;&gt;=</code>), second parameter just ignored and <code>Left data</code> is returned. Just like returning in the middle of a function in imperative setting, by ignoring rest of statements.</p>
<p>Using monad instance of Either, we can easily implement our function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dfsNth&#39; ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth&#39; tree n <span class="fu">=</span>
    <span class="kw">case</span> iter tree n <span class="kw">of</span>
      <span class="kw">Left</span> a  <span class="ot">-&gt;</span> <span class="kw">Just</span> a
      <span class="kw">Right</span> i <span class="ot">-&gt;</span> <span class="kw">Nothing</span>
  <span class="kw">where</span>
<span class="ot">    iter ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> a <span class="dt">Int</span>
    iter (<span class="dt">Branch</span> []) n     <span class="fu">=</span> <span class="fu">return</span> n
    iter (<span class="dt">Branch</span> (b<span class="fu">:</span>bs)) n <span class="fu">=</span> <span class="kw">do</span>
      n&#39; <span class="ot">&lt;-</span> iter b n
      iter (<span class="dt">Branch</span> bs) n&#39;
    iter (<span class="dt">Leaf</span> a) <span class="dv">0</span> <span class="fu">=</span> <span class="kw">Left</span> a
    iter <span class="dt">Leaf</span>{}   n <span class="fu">=</span> <span class="fu">return</span> (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<p>It works exactly like our first implementation, but without generating an intermediate list.</p>
<h2 id="exceptions-and-either-monad">Exceptions and Either monad</h2>
<p>If I were using OCaml, I’d probably implement this function using an exception.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">exception</span> <span class="dt">NonLocal</span> <span class="kw">of</span> <span class="dt">int</span>

<span class="kw">type</span> &#39;a tree =
  | <span class="dt">Branch</span> <span class="kw">of</span> (&#39;a tree) <span class="dt">list</span>
  | <span class="dt">Leaf</span>   <span class="kw">of</span> &#39;a

<span class="kw">let</span> dfs_nth tree n =
  <span class="kw">let</span> <span class="kw">rec</span> iter tree n =
    <span class="kw">match</span> tree <span class="kw">with</span>
    | <span class="dt">Branch</span> [] -&gt;
        n
    | <span class="dt">Branch</span> (b :: bs) -&gt;
        iter (<span class="dt">Branch</span> bs) (iter b n)
    | <span class="dt">Leaf</span> a -&gt;
        <span class="kw">if</span> n = 0 <span class="kw">then</span> raise (<span class="dt">NonLocal</span> a) <span class="kw">else</span> n - 1
  <span class="kw">in</span>
  <span class="kw">try</span>
    iter tree n;
    <span class="dt">None</span>
  <span class="kw">with</span>
    | <span class="dt">NonLocal</span> a -&gt; <span class="dt">Some</span> a</code></pre>
<p>An interesting thing to realize here is that this solution is very similar to our Haskell solution. In Haskell, Either is an instance of <code>MonadError</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Error</span> e <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span>
    throwError             <span class="fu">=</span> <span class="kw">Left</span>
    <span class="kw">Left</span>  l <span class="ot">`catchError`</span> h <span class="fu">=</span> h l
    <span class="kw">Right</span> r <span class="ot">`catchError`</span> _ <span class="fu">=</span> <span class="kw">Right</span> r</code></pre>
<p>This means if you replace <code>Left</code>s with <code>throwError</code> (just like <code>raise</code> in OCaml code), you have a similar solution with OCaml.</p>
<p>This doesn’t mean exceptions are same thing as Either types in functional programming. There are just too many differences that I won’t delve into in this post. With an exception, you can return from arbitrary deep contexts(ie. function calls), which is not easily possible with Either types. This is why exceptions sometimes referred as <em>non-local returns</em>.</p>
<p>We discussed this stuff over OCaml IRC channel, and smart people over there gave me some really good insights about non-local returns and exceptions. I’ll probably delve into details in another blog post. I’m especially interested in functional solutions that we can have in Haskell.</p>
<p>For the curious, for now I’ll just leave these two links here: (I haven’t read that links yet, but they’re probably related)</p>
<ul>
<li><a href="https://ocaml.janestreet.com/?q=node/91">https://ocaml.janestreet.com/?q=node/91</a></li>
<li><a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html</a></li>
</ul>
<p>Several other ideas also discussed at IRC channel, some of them were using delimited continuations, or passing a handler function as parameter and just calling it instead of raising an exception. I’ll continue investigating this stuff later.</p>
<p>I also came across this <a href="http://stackoverflow.com/questions/6915701/is-non-local-return-in-scala-new">StackOverflow post</a> that explains how Scala’s non-local returns implemented as exceptions internally. Interesting stuff.</p>]]></summary>
</entry>
<entry>
    <title>Apparently I'm not going to Jane Street</title>
    <link href="http://osa1.net/posts/2013-07-16-jane-street-interview-2.html" />
    <id>http://osa1.net/posts/2013-07-16-jane-street-interview-2.html</id>
    <published>2013-07-16T00:00:00Z</published>
    <updated>2013-07-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had written about my first interview experience <a href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html">here</a>. After that interview, we did two more interviews with Jane Street, the last one was done yesterday.</p>
<p>Today I’ve got an email saying that I’ve failed.</p>
<p>I won’t write about last two interviews because I’m asked to not to write about questions.</p>
<p>Now I’m looking for Haskell jobs for my last internship and I just applied to Galois. I’ll keep posting updates here. Wish me luck.</p>
<p><em>EDIT: I got response to my job application email from Galois, saying that they would not be able to sponsor me for my visa application. Which means I’m still looking for jobs.</em></p>]]></summary>
</entry>
<entry>
    <title>fmap fix return</title>
    <link href="http://osa1.net/posts/2013-07-07-fmap-fix-return.html" />
    <id>http://osa1.net/posts/2013-07-07-fmap-fix-return.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While floating across the internets, I came across a blog with title <code>fmap fix return</code>. I immediately run ghci and queried it’s type:</p>
<pre class="ghci"><code>ghci&gt; :t fmap fix return
fmap fix return :: a -&gt; a</code></pre>
<p>We know that only value with type <code>forall a. a -&gt; a</code> (other than bottom) is identity function(<code>id</code> in Haskell). I found it very interesting, <code>fmap fix return</code> gives us identity function!</p>
<p>I got a pen and paper and started evaluating expressions to understand how does that give us the identity function.</p>
<p>First, let’s note our actors:</p>
<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- instance specific implementation

fix  :: (a -&gt; a) -&gt; a
fix f = let x = f x in x

return :: Monad m =&gt; a -&gt; m a
-- instance specific implementation</code></pre>
<p>A very important thing to realize at this point is which monad and functor instances are used for <code>return</code> and <code>fmap</code>. To realize this, observe that we get a function as return value of <code>fmap</code>. Which means <code>Functor f =&gt; f b</code> is <code>a -&gt; a</code>, or written in a different style to see it’s functor property: <code>((-&gt;) a) a</code>, so our functor here is <code>(-&gt;) a</code>.</p>
<p>After that, we need to look up functor and monad instances for <code>(-&gt;) a</code>. Since it’s 2:30 AM here, I wanted to derive that too.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
     <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>It’s very easy to derive just by looking specialized version of <code>fmap</code>s type for <code>((-&gt;) a)</code>: <code>fmap :: (a1 -&gt; b) -&gt; (a -&gt; a1) -&gt; (a -&gt; b)</code>.</p>
<p>We can easily prove that it satisfies functor laws:</p>
<pre><code>fmap id f
= id . f
= f

fmap (p . q) &lt;-&gt; (fmap p) . (fmap q)
(fmap p) . (fmap q) f
= fmap p . (q . f)
= p . q . f
= fmap (p . q) f</code></pre>
<p>Monad instance can also be derived from types of <code>return</code> and <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
    <span class="fu">return</span>   <span class="fu">=</span> <span class="fu">const</span>
    f <span class="fu">&gt;&gt;=</span> fn <span class="fu">=</span> \r <span class="ot">-&gt;</span> fn (f r) r</code></pre>
<p>(I found Monad instance of <code>((-&gt;) a)</code> very interesting, especially the <code>&gt;&gt;=</code> part. I couldn’t come up with a problem that makes use of this instance, I’ll investigate that after some sleep)</p>
<p>It satisfies monad laws:</p>
<pre><code>-- left identity
return a &gt;&gt;= f
= const a &gt;&gt;= f
= \r -&gt; f ((const a) r) r
= \r -&gt; f a r
= f a

-- right identity
m &gt;&gt;= return
= \r -&gt; return (m r) r
= \r -&gt; (const (m r) r)
= \r -&gt; m r
= m

-- associativity
(m &gt;&gt;= f) &gt;&gt;= g &lt;-&gt; m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

let&#39;s first write `p` for `m &gt;&gt;= f`

= p &gt;&gt;= g
= \r1 -&gt; g (p r1) r1

let&#39;s also evaluaute p

p = m &gt;&gt;= f
= \r2 -&gt; f (m r2) r2

substitute new p

= \r1 -&gt; g ((\r2 -&gt; f (m r2) r2) r1) r1
= \r1 -&gt; g (f (m r1) r1) r1
= \r -&gt; g (f (m r) r) r

now let&#39;s also evaluate right hand side of equation

m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
= m &gt;&gt;= (\x -&gt; (    f x &gt;&gt;= g    )) -- just added a paren for clarity
= m &gt;&gt;= (\x -&gt; (\r -&gt; g (f x r) r))

let write `p` for `\x -&gt; (\r -&gt; g (f x r) r)`

= m &gt;&gt;= p
= \r1 -&gt; p (m r1) r1

put p back

= \r1 -&gt; (\x -&gt; (\r -&gt; g (f x r) r)) (m r1) r1
= \r1 -&gt; (\r -&gt; g (f (m r1) r)) r1
= \r1 -&gt; g (f (m r1) r1)</code></pre>
<p>For those who have no idea what’s above, I’m basically proving some equalities by substituting expressions with their equivalents. This is a benefit for working on a purely functional language, which means referential transparency.</p>
<p>OK, now with these <code>return</code> and <code>fmap</code> implementations in mind, let’s evaluate <code>fmap fix return</code>:</p>
<pre><code>fmap fix return
= fix . return
= \r -&gt; fix (return r)
= \r -&gt; fix (const r)
= \r -&gt; (\f = let x = f x in x) (const r)
= \r -&gt; let x = (const r) x in x

since `const a _ = a`, we have x = r here

= \r -&gt; r</code></pre>
<p>.. which is the identity function.</p>
<p>Thus <code>fmap fix return</code> demystified.</p>]]></summary>
</entry>
<entry>
    <title>Shen.hs FFI</title>
    <link href="http://osa1.net/posts/2013-06-29-shenhs-ffi.html" />
    <id>http://osa1.net/posts/2013-06-29-shenhs-ffi.html</id>
    <published>2013-06-29T00:00:00Z</published>
    <updated>2013-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Shen.hs now has a simple way to call Haskell functions. As an example, I removed some non-standard KLambda functions from <a href="https://github.com/osa1/Shen.hs/blob/master/src/KLambda/Fun.hs"><code>Fun.hs</code></a>(standard primitive functions are defined there). Instead, they live in a <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs">separate module</a> now, and I load them in run-time when I’m debugging.</p>
<h2 id="how-it-works">How it works</h2>
<p>Shen.hs is now exports it’s modules as a library. This is required to allow writing Shen.hs functions in Haskell.</p>
<p><code>KLambda.Types</code> module export all required type information to start writing Shen.hs functions in Haskell. All your functions should have the type <code>KlFun1</code>. To make converting Haskell functions with higher arity(ie. <code>KlFun2</code>, <code>KlFun3</code>) to <code>KlFun1</code>, all <code>KlFun</code> instances now have a <code>mkFun1 :: a -&gt; KlFun1</code> method.</p>
<p>As an example, <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs"><code>Debug.hs</code></a> module functions with types <code>KlFun2</code>, <code>KlFun3</code> etc. To call them from within Shen.hs, they are all wrapped with <code>mkFun1</code> function.</p>
<p>After defining functions with type <code>KlFun1</code> and compiling it, you should call <code>dynload</code> primitive to load functions. Here’s an example session that demonstrates loading and using debugging functions:</p>
<pre><code>$ Shen.hs --shen &quot;/home/omer/Shen/hs_yeni/K Lambda&quot;
loading file: /home/omer/Shen/hs_yeni/K Lambda/toplevel.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/core.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sys.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sequent.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/yacc.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/reader.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/prolog.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/track.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/load.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/writer.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/macros.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/declarations.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/t-star.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/types.kl ...loaded.

Shen 2010, copyright (C) 2010 Mark Tarver
released under the Shen license
www.shenlanguage.org, version 12
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan


(0-) (cd &quot;/home/omer/Shen/hs_yeni/dynload_test&quot;)
&quot;/home/omer/Shen/hs_yeni/dynload_test/&quot;

(1-) (dynload &quot;Debug.o&quot; &quot;debug1F&quot;)
&lt;function&gt;

(2-) (debug1F &quot;calling haskell function -- &quot; 1 2)
calling haskell function -- 1 :: TyNum

2

(3-)</code></pre>
<p>Note that you need both <code>.hi</code> and <code>.o</code> files to be able to load the library dynamically.</p>
<h2 id="status-of-shen.hs">Status of Shen.hs</h2>
<p>Before this additional feature I had fixed a bug and now Shen.hs fails in 8 tests in Test Suite distributed with Shen source. All errors are related and probably there is only one bug. Unfortunately narrowing bug’s scope is very hard at this point. Pull requests are welcome.</p>
<p>If you encounter any bugs please open an issue in <a href="https://github.com/osa1/Shen.hs">Github repository</a>.</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: Shen.hs -- Haskell port of Shen</title>
    <link href="http://osa1.net/posts/2013-06-21-ann-shen-hs.html" />
    <id>http://osa1.net/posts/2013-06-21-ann-shen-hs.html</id>
    <published>2013-06-21T00:00:00Z</published>
    <updated>2013-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m copying <a href="https://groups.google.com/forum/?hl=en#!topic/qilang/GKVN4E_ntWw">my email</a> sent to Shen mailing list:</p>
<blockquote>
<p>Hi all,</p>
<p>I had started writing a port of Shen in Haskell some time ago. Unfortunately it never reached a stable state. And now I can’t spare enough time to fix bugs and improve performance. So I thought maybe it’s a good time to announce it and wait for contributions.</p>
<p>By ‘not stable’ I don’t mean it’s in a terrible state. For example, Shen test suite runs with following results:</p>
<pre><code>passed ... 94.0 
failed ...34.0 
pass rate ...73.4375% </code></pre>
<p>.. it’s not hopelessly bad. It probably has one or two deadly bugs and that causes dozens of tests to fail.</p>
<p>Anyway, that’s it for now. Github repository is here: <a href="https://github.com/osa1/Shen.hs">https://github.com/osa1/Shen.hs</a> .</p>
<p>If you try please tell me your thoughts!</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>My first interview experience: Jane Street</title>
    <link href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html" />
    <id>http://osa1.net/posts/2013-06-20-first-interview-jane-street.html</id>
    <published>2013-06-20T00:00:00Z</published>
    <updated>2013-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A few hours ago I had my first interview ever. I had applied to Jane Street’s software development internship position last Sunday(16 June), and they returned to me on Monday(17 June), and we had an interview today(20 June). It was overall a very good experience.</p>
<p>I should say I’m a bit sad about this interview, because I couldn’t answer the questions with details I could answer and I gave wrong answers to some questions that I know very well. Still, I think I wasn’t bad in general. What happens next will be clear in few days.</p>
<p>We started with some generic personal questions like what I know, what I write, why did I applied to this internship etc. and I couldn’t give good answers even to this questions. For example, at some point I’m asked “what do you like about functional programs”, if you sit next to me in a class and ask me same question, I can give you a 50-minute lecture, but while at interview I just couldn’t do that.</p>
<p>Anyway, we then moved to technical question.</p>
<p>As for first question I’m asked to list 5 unix programs with 2 letters. I immediately listed <code>vi</code> and <code>ls</code>, after some thought I added <code>sh</code>, <code>ld</code>, <code>ln</code> and <code>nm</code>. I’m asked for what does <code>ld</code> do, and I wrongly answered “shows dynamically loaded libraries of an ELF binary”. My interviewer later asked me if I ever used that command, lol. It was funny that I said yes and explained how I used it, haha. The program I explained here is actually <code>ldd</code>, and <code>ld</code> is actually a linker(and I knew it very well, even though I have never called it manually). I also gave wrong answer to <code>nm</code>, I said “it shows string in a binary”, which was wrong because that what <code>strings</code> does. I should have said “shows symbols in a binary”. And I use these tools frequently!</p>
<p>For second question I’m asked “how would I count a list of files in a folder and it’s subfolders”. I said I’m not that good in shell environment so I wrote a small Python program instead. This was easy. (btw, I made a mistake even in this code by first writing a Python program that prints file paths instead of counting files, haha. Later I’m warned and I fixed the code :-D )</p>
<p>For third question I’m asked to tell what I know about garbage collectors and garbage collection techniques. I said the purpose of garbage collectors, and then mentioned reference counting technique. Later I’m asked to list some languages that does and doesn’t have automatic garbage collection.</p>
<p>Fourth question was to write and explain a <code>map</code> function that works on lists. It was trivial.</p>
<p>Fifth question was to write and explain <code>fold</code> function. I mentioned both left and right folds, wrote <code>foldl</code> in Haskell syntax and said that it’s a tail recursive process. At this point I’m also asked why is it tail recursive and what does tail recursive mean.</p>
<p>I think one nice question at this part is that the question of “does being tail-recursive matters in Haskell, because it’s lazy by default”. I think my interviewer wanted to test me if I understand orthogonality of laziness and tail recursion.</p>
<p>Last question, which I failed to give a correct answer was “you have a 5-sided fair dice, and you want to make a fair choice between 7 choices, how can you do it?”. Now this is by no means a hard question and I solved harder problems, but at that time I just couldn’t answer it.</p>
<p>One interesting observation I made while I’m trying to solve this problem was that thinking in a language and translating ideas to another one at the same time is hard. After few seconds of silence my interviewer asked me to say what I’m thinking. I was bad at this.</p>
<p>Anyway, I think I did good enough. I’ll post on updates, wish me luck :-) .</p>
<p><strong>EDIT: I’ve just got an email from Jane Street, we will make another interview, this time with someone from NY office :-)</strong></p>]]></summary>
</entry>
<entry>
    <title>Type checking with Prolog</title>
    <link href="http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html" />
    <id>http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html</id>
    <published>2013-06-13T00:00:00Z</published>
    <updated>2013-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There is a deep relation between a type inference system and a logic programming system. I don’t fully understand this relation. <a href="http://stackoverflow.com/questions/13899586/haskells-type-system-and-logic-programming-how-to-port-prolog-programs-to-typ">This question</a> I asked at StackOverflow a few months ago gives some tips, but doesn’t explain much.</p>
<p>I could finally spare some time and play with a type checker implementation in Prolog. What I had in mind before starting writing this code was that having a unification mechanism at hand should make type checking easier.</p>
<p>Indeed that is the case, as you’ll see shortly. Type inference is harder, and I also explain the reason and how could it be done.</p>
<hr />
<p>I will not formally define the type system here, but I think it can be seen as a simple Damas-Hindley-Milner style type system.</p>
<p>This implementation basically embeds type definitions in Prolog. This is what makes this implementation simple. You can always implement a fully-featured type system in Prolog just like you can do it in any other language. What I’m trying to show here that it’s very simple to do when there is a way to implement types as rules in Prolog.</p>
<p>Here’s knowledge base of types:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">nat(o)<span class="kw">.</span>
nat(s(<span class="dt">N</span>)) <span class="kw">:-</span> nat(<span class="dt">N</span>)<span class="kw">.</span>

bool(<span class="kw">true</span>)<span class="kw">.</span>
bool(<span class="kw">false</span>)<span class="kw">.</span>

type(<span class="dt">A</span><span class="kw">,</span> nat) <span class="kw">:-</span> nat(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span>
type(<span class="dt">A</span><span class="kw">,</span> bool) <span class="kw">:-</span> bool(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span>
type(id<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)) <span class="kw">:-</span> <span class="kw">!.</span>
type(add<span class="kw">,</span> arrow(nat<span class="kw">,</span> arrow(nat<span class="kw">,</span> nat))) <span class="kw">:-</span> <span class="kw">!.</span>
type(not<span class="kw">,</span> arrow(bool<span class="kw">,</span> bool)) <span class="kw">:-</span> <span class="kw">!.</span>
type(const<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> arrow(<span class="er">_, </span><span class="dt">A</span>)))<span class="kw">.</span></code></pre>
<p>Implementing type definitions as rules in a Prolog system is what makes this implementation simple. Here <code>id</code> is a function with type <code>forall a. a -&gt; a</code>, <code>add</code> is <code>nat -&gt; nat</code>, <code>not</code> is <code>bool -&gt; bool</code>, and <code>const</code> is <code>forall a b. a -&gt; b -&gt; a</code>.</p>
<p>Type checking of function applications is also simple:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">R</span>))<span class="kw">,</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></code></pre>
<p>And we’re done. This much code is enough for type checking polymorphic functions. Here are some examples:</p>
<pre><code>?- type(app(id, false), T).
T = bool.

?- type(app(id, o), T).
T = nat.

?- type(app(add, o), T).
T = arrow(nat, nat).

?- type(app(app(add, o), s(o)), T).
T = nat.

?- type(app(app(add, o), false), T).
false.

?- type(app(app(const, false), o), T).
T = bool.

?- type(app(app(const, false), true), T).
T = bool.</code></pre>
<p>One major limitation of this implementation is that there is no way to implement monomorphic functions. To do this, we should somehow have two different kinds of Prolog variables, one for polymorphic variables and one for monomorphic ones.</p>
<p>Since there’s no way to directly express this in Prolog, I had to extend this code with a typing environment. In the implementation above, if parameter of a function is an atom and not a variable, then it’s looked in a global environment.</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">var</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% polymorphic parameter</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">,</span>
    <span class="dt">R</span> <span class="kw">=</span> <span class="dt">B</span><span class="kw">,</span>
    <span class="kw">!.</span>

type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span>
    get<span class="er">_</span><span class="dt">type</span>(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span>
    <span class="co">% type already exists in environment</span>
    <span class="kw">!,</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span>
    type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span>
    <span class="kw">!.</span>

type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span>
    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span>
    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span>
    <span class="co">% type doesn&#39;t exist in environment</span>
    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span>
    add<span class="er">_</span><span class="dt">type</span>(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span>
    type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span>
    <span class="kw">!.</span></code></pre>
<p>First rule is for polymorphic parameters, only difference from the first code is <code>var(A)</code>, which ensures the parameter type is a variable.</p>
<p>Second rule does a similar check, but this time to ensure the parameter is an atom and not a variable. After that, type of this parameter is looked from an environment and checked against it. The third rule is when a type is not found in the environment. In that case, a new type is added to the environment.</p>
<p>Note that first cut is required in second rule. Because otherwise, when a type checking fails, third rule would be executed and a new type would be added to the environment.</p>
<p>Here are environment operations:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">init<span class="er">_</span><span class="dt">state</span>(<span class="dt">Name</span>) <span class="kw">:-</span>
    empty<span class="er">_</span><span class="dt">assoc</span>(<span class="dt">A</span>)<span class="kw">,</span>
    nb<span class="er">_</span><span class="dt">setval</span>(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>

add<span class="er">_</span><span class="dt">type</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span>
    nb<span class="er">_</span><span class="dt">getval</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span>
    put<span class="er">_</span><span class="dt">assoc</span>(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">,</span>
    nb<span class="er">_</span><span class="dt">setval</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">.</span>

get<span class="er">_</span><span class="dt">type</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span>
    nb<span class="er">_</span><span class="dt">getval</span>(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span>
    get<span class="er">_</span><span class="dt">assoc</span>(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span>)<span class="kw">.</span></code></pre>
<p>Environment operations get a environment name to keep the state local. ie. you can be sure your state is local if name of the state is not used somewhere else :-)</p>
<p>This helper is used to get type of a term when term is an atom, and it’s type is available in environment. Otherwise it returns the term itself.</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>) <span class="kw">:-</span> get<span class="er">_</span><span class="dt">type</span>(types<span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>)<span class="kw">.</span>
type<span class="er">_</span><span class="dt">in</span><span class="er">_</span><span class="dt">env</span>(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span></code></pre>
<p>An example monomorphic function rule:</p>
<pre class="sourceCode prolog"><code class="sourceCode prolog">type(mono<span class="er">_</span><span class="dt">id</span><span class="kw">,</span> arrow(mono<span class="er">_</span><span class="dt">id</span><span class="er">__</span><span class="dt">a</span><span class="kw">,</span> mono<span class="er">_</span><span class="dt">id</span><span class="er">__</span><span class="dt">a</span>)) <span class="kw">:-</span> <span class="kw">!.</span></code></pre>
<p>It should be guaranteed by the programmer that <code>mono_id__a</code> atom is only used for <code>mono_id</code> function.</p>
<p>Here are some examples for checking monomorphic functions(others work as before):</p>
<pre><code>?- init_state(types).
true.

?- type(app(mono_id, o), T).
T = nat.

?- type(app(mono_id, s(o)), T).
T = nat.

?- type(app(mono_id, false), T).
false.

?- init_state(types).
true.

?- type(app(mono_id, false), T).
T = bool.

?- type(app(mono_id, o), T).
false.</code></pre>
<p>This code should demonstrate how easy it’s to implement a type checker when there’s a way to express typing rules as Prolog rules. We had type checker for polymorphic and monomorphic functions in 57 lines of Prolog.</p>
<p>For type inference, we need to generate new rules in runtime. I’m looking for ways to do this. <code>assert/1</code> and <code>dynamic/1</code> predicates make this possible, but I still couldn’t find a way to generate fresh Prolog variables(like <code>gensym</code>, but for variables). I’ll update this post later.</p>]]></summary>
</entry>
<entry>
    <title>lcl -- Lua Container Library and The One Data Structure to Rule Them All</title>
    <link href="http://osa1.net/posts/2013-06-08-lcl-and-one-data-structure.html" />
    <id>http://osa1.net/posts/2013-06-08-lcl-and-one-data-structure.html</id>
    <published>2013-06-08T00:00:00Z</published>
    <updated>2013-06-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><strong>Note: Sorry for organization of this post. We were talking about this stuff over #lua IRC channel for an hour, and before that I had worked on various bugs and I’m incredibly tired now.</strong></p>
<p>I’ve been working with an experimental Lua library lately. It had started as a learning exercise, and after first iteration, it turned out to be an experiment about Lua’s internals, dynamic linking, and data structures.</p>
<p>Lua Container Lib(lcl or liblcl for short) is a Lua library to use C++ STL containers from within Lua. It’s compiled to a single <code>.so</code>(or <code>.dll</code>) and it can be loaded from Lua 5.1.5, 5.2.2, LuaJIT 2.0.2 and Love2D with <code>package.loadlib</code> standard function. It provides some STL containers with an object-oriented interface.</p>
<p>You can see the source <a href="https://github.com/osa1/lcl">here</a>. There isn’t any tutorials yet, I think it’s simple enough to learn it from examples, see <code>tests/</code> folder.</p>
<p>For now, it only contains set and deque containers, but it should be very easy to add more. Also, not all operations on sets and deques are supported yet. Again, this should also be very easy to add. Current code base should have all kinds of code to implement more containers/operations on containers by just looking for others’ implementations. Pull requests are welcome!</p>
<p><code>tests/</code> folder also have a simple benchmark. Output of benchmark is in files <code>benchmark.output</code> and <code>benchmark.output_luajit</code>. I think most people find the output interesting. Before explaining what’s going on in that benchmark, here are some stuff I learned while developing this library:</p>
<h2 id="lessons-learned">Lessons learned</h2>
<p>Lua has some rules about the use of C API, but when you don’t follow the rules, you don’t immediately get caught. For instance, you should return the number of elements placed to the stack in your C functions. I had a bug in my code and one of my functions was returning 1 even though it returns with an empty stack. Nevertheless, the library worked fine until I tried it with LuaJIT.</p>
<p>LuaJIT is more picky about that rules and it fails in strange ways. Sometimes my program was failing with strange memory allocation errors, but program was still running. In the best case, I was getting a segmentation fault.</p>
<p>After several hours of debugging and some help from mailing list(see my mail <a href="http://www.freelists.org/post/luajit/cant-load-so-with-packageloadlib-undefined-symbol-error">here</a>) I could solve it. Best helper was the <code>LUA_USE_APICHECK</code> debug macro. It’s added to Lua in somewhere between Lua 5.1.5 and 5.2.2. When you compile Lua with <code>LUA_USE_APICHECK</code> defined, Lua makes some assertions in code to make sure stack is in correct state. You should always develop C libraries to Lua with this enabled.</p>
<p>Now, as for benchmarks; two things can be seen immediately from benchmarks: 1) All operations on STL containers are slower 2) LuaJIT is awesome.</p>
<p>Let’s first start from second point. LuaJIT is awesome. It’s best thing happened to Lua. It’s binary compatible with Lua 5.1.5, which means with minimal effort, you can gain some real performance benefits. You can see the difference by comparing <code>benchmark.output</code> and <code>benchmark.output_luajit</code> files. All I had to do was to run program with LuaJIT instead of Lua.</p>
<p>Now, as for STL containers .. Before starting this project, I was considering having a better performance for specialized data structures, ie. STL deques should be faster than Lua tables used as deques. As can be seen from benchmarks, that’s not the case. I made a simplest possible deque implementation possible in Lua(you can see it <a href="https://github.com/osa1/lcl/blob/master/tests/deque.lua">here</a>) and it’s still faster than STL deque(with minor difference).</p>
<p>I think there are several reasons for that.</p>
<p>There is no way to get a Lua value out of Lua interpreter. Lua C API deliberately avoid this because this may lead to memory leaks or memory corruptions.</p>
<p>You can only have a reference to a Lua value, and in that case, that value has to be written in some table. <a href="http://www.lua.org/manual/5.2/manual.html#luaL_ref"><code>luaL_ref</code></a> creates a reference and writes it to a Lua table, and then return that reference(as an <code>int</code>). Generally, you would use global register at <code>LUA_REGISTRYINDEX</code> to save Lua values.</p>
<p>This implies that you cannot have a container with insertion faster than Lua table insertion. Because every insertion also have to insert to a Lua table. This table is generally the global register at index <code>LUA_REGISTRYINDEX</code>. For example, when I add 1000000 elements to a set, all those elements is also added to the register.</p>
<p>You can see that STL deque insertions time is almost the same as Lua implementation’s. The reason for this is that even though STL deque insertion is O(1) with a minimal constant factor, you have to insert to a Lua table like explained above.</p>
<p>In case of set data structure: STL’s set implementation is generally a kind of tree, and elements are stored in sorted order(this makes possible to use STL sets as heaps like I did in <a href="https://github.com/osa1/lcl/blob/master/tests/dynload.lua"><code>dynload.lua</code></a> example). This causes extra O(log N) function calls for comparisons, where N is number of elements in tree. ie. when a new element added, it’s place is determined by comparing it with elements at each level and then moving down to next level in tree. In case of Lua tables, all insertions are amortized O(1) and no comparison functions are called.</p>
<p>These are my explanations to reasons of why STL operations are slower.</p>
<p>Still, I don’t think adding C/C++ containers in Lua is completely pointless. Significant memory savings may be possible with C/C++ containers. For example, 32 flags can be held in a 32bit integer in C/C++, but to do this in Lua, you need to use a double for every flag, and a table. A double is 8 bytes in my 64bit machine. And with 32 flags it costs you 32*8 = 256 bytes. In C/C++ you can have it with only 4 bytes.</p>
<p>There may be also performance advantages for really complex algorithms, but I don’t have a particular example in mind.</p>]]></summary>
</entry>

</feed>
