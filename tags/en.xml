<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-09-17T00:00:00Z</updated>
    <entry>
    <title>On proof automations -- part 2</title>
    <link href="http://osa1.net/posts/2013-09-17-proof-automation-2.html" />
    <id>http://osa1.net/posts/2013-09-17-proof-automation-2.html</id>
    <published>2013-09-17T00:00:00Z</published>
    <updated>2013-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://adam.chlipala.net/">Adam Chilpala’s</a> <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> has a great discussion on writing automated proofs and readability of proofs. Highly recommended. Chapter 16(page 319 on current revision).</p>
<p>I think one key thing to realize about interactive theorem proving is that there is no perfect, or maybe even good, solution to the problem of proof representation. Tactics help, but without automation tactic based proofs are just too fragile(every change in definitions implies changes in proofs) and verbose. But automated proofs are very hard to read, and it’s very hard to modify automated proofs for changes. CPDT book has a great example of this. Let’s think of this proof(I’ll skip the definitions, just think some simple arithmetic expressions language just like you could find in any elementary programming language theory book)</p>
<pre class="coq"><code>Theorem eval_times : forall k e,
    eval (times k e) = k * eval e.
Proof.
  induction e as [| ? IHe1 ? IHe 2]; [
    trivial
    | simpl; rewrite IHe1; rewrite IHe2; rewrite mult_plus_distr_l; trivial ].
Qed.</code></pre>
<p>And now let’s say you added one more constructor to arithmetic expression syntax. How to change this proof to adopt the changes? I don’t think there’s a way to do that without first writing the version without automation. And that brings us back to my first post.</p>
<p>I think the reason why I think too much about this stuff instead of writing some proofs is that I look for elegance and simplicity in my programs. And only if necessary I try to make my programs efficient(fast, small, whatever). After some simple trivial proofs that I did for learning I never found my proofs satisfactory. They are either very very long and repetitive or very hard to understand and modify. It’s very hard to find a sweet-spot in proofs that is not very repetitive and long and still possible to read and understand.</p>
<p>You can always apply methods you learned to make your programs easier to read and modify, like moving some code to a new function with a useful name and formal parameters etc. but in the case of proofs it’s also very hard to find what pieces are considered worthy to be a lemma and what would be useful name for it.</p>
<p>My ideas about proof automation is changed from “no way I use them” to “okay they can be very useful for eliminating repetition without adding obscurity to the proof” in one day. I’ll continue writing Coq proofs for while and probably add new posts on this topic later.</p>]]></summary>
</entry>
<entry>
    <title>On proof automations</title>
    <link href="http://osa1.net/posts/2013-09-11-proof-automation.html" />
    <id>http://osa1.net/posts/2013-09-11-proof-automation.html</id>
    <published>2013-09-11T00:00:00Z</published>
    <updated>2013-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working with constructive systems, at the lowest level you can directly construct proof objects by writing programs. But for realistic scenarios, this is probably too hard to do. Coq and Idris like languages provide an alternative way to construct proof objects: tactics. Tactics provide a way to derive proofs in a way that is somewhat like informal proofs given in spoken languages. But theorems you’re trying to prove is already too complex, and in some parts, very repetitive.</p>
<p>That <em>tactics</em> Coq like theorem provers provide also help you construct proofs with some automation commands. For instance, you can apply same steps several times, until you prove some subgoals. Or you can search for a proof by applying some steps in different combinations.</p>
<p>What doesn’t make sense to me is that in general you cannot really use that automation methods before manually writing long and hard proof by hand and showing that your theorem is really a theorem and it indeed has some repetitive parts.</p>
<p>And at this point you’re probably better off leaving the proof as-is because replacing explicit steps with some magic commands(I’ll come to this point later) only makes the proof harder to read, without any other advantages.</p>
<p>I have similar ideas for <code>auto</code> tactic. What it does is that it searches for a proof by applying different combinations of <code>apply</code> and <code>intros</code> tactics(with some limitations – it only uses apply for hypothesis and hint database which you generate while defining inductive definitions).</p>
<p>Now my problem with <code>auto</code> is that you can only use it when you absolutely sure that your theorem is indeed a theorem – that is, it has a proof. And how can you know that your theorem is correct? The only way to know this is to write a proof for it. Now let’s say <code>auto</code> tactic fails, and when this happens it can’t really say anything. Why did it fail? It may be because your proof is actually too long and it searched for a while but couldn’t find a proof(you can specify search depth as an optional parameter of <code>auto</code> tactic). Or maybe your hint base is not good enough. Or maybe your theorem is not actually a theorem and you cannot prove it.</p>
<p>So both proof search tactics and repetition elimination tactics have this same common problem: you cannot know that they work before writing the proof itself. And automation generally makes the proof unreadable.</p>
<p>Adam Chilpala’s “Certified Programming with Dependent Types” book encourages that automated way of proving. You have that complicated theorem that you don’t even understand what it is saying? No problem, <code>crush</code> tactic(which is not standard, distributed with CPDT book) will prove it for you in one command.</p>
<p>I’m not saying that <code>crush</code> like tactics are necessarily bad and you shouldn’t use it. I’d probably use it in real world when I need a proof that <code>crush</code> can generate and I don’t have time or motivation to do it myself.</p>
<p>And repetition elimination tactics are useful when you have a syntax tree with 15 constructors and you’re proving some theorem that’s relevant with only one of that constructors – 14 subgoals can be easily proved by some clever use of <code>;</code> operator in Coq.</p>
<p>What I’m saying that is several things:</p>
<ul>
<li>Automated proofs can make proofs harder to read and most of the time you already need to have written the long proof to see that it has repetitive parts or at least it is provable. (certainly there are cases where you’ll find yourself trying to prove something wrong)</li>
<li>Once a long proof is written, there is little or no need to remove that proof and replace it with an automated version. (one reason to do that is to have same proof working even after some inductive definitions is expanded/changed)</li>
<li>Most importantly, <code>crush</code> like automation tactics are pure black magic and doesn’t really teach you anthing. As a hobbyist who self-study all this, I prefer learning the principles instead of scripts and magic commands and black boxes.</li>
</ul>
<p>For this reasons I’m trying to use proof automation as little as possible.</p>]]></summary>
</entry>
<entry>
    <title>MANTI - Prolog implementation in 515 lines of Haskell</title>
    <link href="http://osa1.net/posts/2013-07-31-announce-manti.html" />
    <id>http://osa1.net/posts/2013-07-31-announce-manti.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/osa1/MANTI">MANTI</a> is a pure Prolog implementation in 515 lines of Haskell. It’s only implements pure parts, meaning it doesn’t have cuts, IO predicates, non-pure arithmetic(<code>is</code> structures in modern Prolog implementation) or other structures that break logical reasoning of Prolog programs.</p>
<p>Here are some example Prolog programs that currently runs under MANTI: (you can find these in <code>tests/</code> folder in source repository)</p>
<ul>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/einstein.pl">Einstein’s riddle</a> – also called Zebra Puzzle. You can see problem definition in <a href="http://en.wikipedia.org/wiki/Zebra_Puzzle">Wikipedia - Zebra Puzzle</a>.</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/nqueens.pl">N-queens problem</a> (not that it takes some time to solve it for board bigger than 5x5, reasons for that slowness explained below)</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/zurg.pl">Escape from Zurg puzzle</a> - you can see a paper with definition of this problem <a href="http://web.engr.oregonstate.edu/~erwig/zurg/">here</a>.</li>
</ul>
<p>My aim while writing MANTI was to make it as simple as possible, yet a complete Prolog implementation that is capable to solve some real problems. For this reasons, it doesn’t have arithmetic, list structures and list operations built-in. Instead, arithmetic is implemented using <a href="http://en.wikipedia.org/wiki/Peano_axioms">Peano definitions</a>, you can see the implementation <a href="https://github.com/osa1/MANTI/blob/master/tests/peano.pl">here</a>. List operations are also implemented in MANTI itself, you can see definitions <a href="https://github.com/osa1/MANTI/blob/master/tests/list.pl">here</a>. List syntax is nothing special, it’s just a syntactic sugar that destructs to ordinary Prolog functors(you can see parser for list syntax <a href="https://github.com/osa1/MANTI/blob/master/src/Parser.hs#L80">here</a>).</p>
<p>For these reasons(and probably others, for instance, unification and <code>not</code> connective are implemented in most inefficient ways possible), it’s very slow. Also, there’s no way to disable occurs check without recompiling MANTI.</p>
<p>It’s mostly done and I don’t think I’ll work more on that. I hope you find MANTI useful(for learning purposes or others).</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: My first academic work is now open source</title>
    <link href="http://osa1.net/posts/2013-07-22-sqml-open-sourced.html" />
    <id>http://osa1.net/posts/2013-07-22-sqml-open-sourced.html</id>
    <published>2013-07-22T00:00:00Z</published>
    <updated>2013-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Our work at Ozyegin University with Prof. Baris Aktemur is now open source.</p>
<ul>
<li>Home page: <a href="http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/">http://srl.ozyegin.edu.tr/projects/subtypedQuotedML/</a></li>
<li>Github repository: <a href="https://github.com/ozusrl/SubtypedQuotedML">https://github.com/ozusrl/SubtypedQuotedML</a></li>
</ul>
<p>If you have trouble compiling/running it, please file an issue at Github page.</p>]]></summary>
</entry>
<entry>
    <title>Non-local returns in functional programs</title>
    <link href="http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html" />
    <id>http://osa1.net/posts/2013-07-21-nonlocal-return-in-fp.html</id>
    <published>2013-07-21T00:00:00Z</published>
    <updated>2013-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s say we want to get nth visited element in depth-first traversal of a tree. Doing this is almost too easy in a language with statements(all imperative languages, some functional ones): Just run the depth-first traversal algorithm with explicit stack, and use <code>return</code> when you visit nth node.</p>
<p>In an expression language(Haskell, some Lisp languages) this is somewhat tricky.</p>
<p>Since I almost always prefer simplest possible solution of a problem, this would be my first attempt in a real-world situation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
    <span class="fu">=</span> <span class="dt">Branch</span> [<span class="dt">Tree</span> a]
    <span class="fu">|</span> <span class="dt">Leaf</span> a

<span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> [a]

<span class="ot">dfsNth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth tree n <span class="fu">=</span> listToMaybe <span class="fu">.</span> <span class="fu">drop</span> n <span class="fu">$</span> toList tree</code></pre>
<p>One concern about this function may be that the complexity of list generation. It’s hard to predict complexity of this function, but traversing the whole tree just to get first element of it would be costly anyway.</p>
<p>But thanks to lazy evaluation, this function still not very bad. Because only required parts of the intermediate list will be generated. To see why you can do two things: 1) Just place some <code>Debug.Trace.trace</code> calls in <code>toList</code> function and see how many times a leaf node is visited and 2) evaluate this function by hand and observe unevaluated thunks.</p>
<p>Let’s just do the first one, since it’s easier:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
toList (<span class="dt">Branch</span> bs) <span class="fu">=</span> <span class="fu">concatMap</span> toList bs
toList (<span class="dt">Leaf</span> a)    <span class="fu">=</span> trace <span class="st">&quot;leaf node visited&quot;</span> [a]

<span class="fu">...</span>

testTree <span class="fu">=</span> <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">1</span>, <span class="dt">Leaf</span> <span class="dv">2</span> ], <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">3</span> ], <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Branch</span> [ <span class="dt">Leaf</span> <span class="dv">4</span> ] ] ] ]</code></pre>
<pre><code>ghci&gt; dfsNth testTree 0
leaf node visited
Just 1

ghci&gt; dfsNth testTree 1
leaf node visited
leaf node visited
Just 2

ghci&gt; dfsNth testTree 10
leaf node visited
leaf node visited
leaf node visited
leaf node visited
Nothing</code></pre>
<hr />
<p>Other solutions are still worth exploring. When I think of “returning in the middle of a function” in Haskell, I always think <code>Either</code>. It’s monad definition is a great fit for this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">Either</span> e) <span class="kw">where</span>
    <span class="fu">return</span>        <span class="fu">=</span> <span class="kw">Right</span>
    <span class="kw">Left</span>  l <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Left</span> l
    <span class="kw">Right</span> r <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k r</code></pre>
<p>So when <code>Left data</code> used in monadic bind(<code>&gt;&gt;=</code>), second parameter just ignored and <code>Left data</code> is returned. Just like returning in the middle of a function in imperative setting, by ignoring rest of statements.</p>
<p>Using monad instance of Either, we can easily implement our function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dfsNth&#39; ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
dfsNth&#39; tree n <span class="fu">=</span>
    <span class="kw">case</span> iter tree n <span class="kw">of</span>
      <span class="kw">Left</span> a  <span class="ot">-&gt;</span> <span class="kw">Just</span> a
      <span class="kw">Right</span> i <span class="ot">-&gt;</span> <span class="kw">Nothing</span>
  <span class="kw">where</span>
<span class="ot">    iter ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> a <span class="dt">Int</span>
    iter (<span class="dt">Branch</span> []) n     <span class="fu">=</span> <span class="fu">return</span> n
    iter (<span class="dt">Branch</span> (b<span class="fu">:</span>bs)) n <span class="fu">=</span> <span class="kw">do</span>
      n&#39; <span class="ot">&lt;-</span> iter b n
      iter (<span class="dt">Branch</span> bs) n&#39;
    iter (<span class="dt">Leaf</span> a) <span class="dv">0</span> <span class="fu">=</span> <span class="kw">Left</span> a
    iter <span class="dt">Leaf</span>{}   n <span class="fu">=</span> <span class="fu">return</span> (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<p>It works exactly like our first implementation, but without generating an intermediate list.</p>
<h2 id="exceptions-and-either-monad">Exceptions and Either monad</h2>
<p>If I were using OCaml, I’d probably implement this function using an exception.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">exception</span> <span class="dt">NonLocal</span> <span class="kw">of</span> <span class="dt">int</span>

<span class="kw">type</span> &#39;a tree =
  | <span class="dt">Branch</span> <span class="kw">of</span> (&#39;a tree) <span class="dt">list</span>
  | <span class="dt">Leaf</span>   <span class="kw">of</span> &#39;a

<span class="kw">let</span> dfs_nth tree n =
  <span class="kw">let</span> <span class="kw">rec</span> iter tree n =
    <span class="kw">match</span> tree <span class="kw">with</span>
    | <span class="dt">Branch</span> [] -&gt;
        n
    | <span class="dt">Branch</span> (b :: bs) -&gt;
        iter (<span class="dt">Branch</span> bs) (iter b n)
    | <span class="dt">Leaf</span> a -&gt;
        <span class="kw">if</span> n = 0 <span class="kw">then</span> raise (<span class="dt">NonLocal</span> a) <span class="kw">else</span> n - 1
  <span class="kw">in</span>
  <span class="kw">try</span>
    iter tree n;
    <span class="dt">None</span>
  <span class="kw">with</span>
    | <span class="dt">NonLocal</span> a -&gt; <span class="dt">Some</span> a</code></pre>
<p>An interesting thing to realize here is that this solution is very similar to our Haskell solution. In Haskell, Either is an instance of <code>MonadError</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Error</span> e <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span>
    throwError             <span class="fu">=</span> <span class="kw">Left</span>
    <span class="kw">Left</span>  l <span class="ot">`catchError`</span> h <span class="fu">=</span> h l
    <span class="kw">Right</span> r <span class="ot">`catchError`</span> _ <span class="fu">=</span> <span class="kw">Right</span> r</code></pre>
<p>This means if you replace <code>Left</code>s with <code>throwError</code> (just like <code>raise</code> in OCaml code), you have a similar solution with OCaml.</p>
<p>This doesn’t mean exceptions are same thing as Either types in functional programming. There are just too many differences that I won’t delve into in this post. With an exception, you can return from arbitrary deep contexts(ie. function calls), which is not easily possible with Either types. This is why exceptions sometimes referred as <em>non-local returns</em>.</p>
<p>We discussed this stuff over OCaml IRC channel, and smart people over there gave me some really good insights about non-local returns and exceptions. I’ll probably delve into details in another blog post. I’m especially interested in functional solutions that we can have in Haskell.</p>
<p>For the curious, for now I’ll just leave these two links here: (I haven’t read that links yet, but they’re probably related)</p>
<ul>
<li><a href="https://ocaml.janestreet.com/?q=node/91">https://ocaml.janestreet.com/?q=node/91</a></li>
<li><a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html</a></li>
</ul>
<p>Several other ideas also discussed at IRC channel, some of them were using delimited continuations, or passing a handler function as parameter and just calling it instead of raising an exception. I’ll continue investigating this stuff later.</p>
<p>I also came across this <a href="http://stackoverflow.com/questions/6915701/is-non-local-return-in-scala-new">StackOverflow post</a> that explains how Scala’s non-local returns implemented as exceptions internally. Interesting stuff.</p>]]></summary>
</entry>
<entry>
    <title>Apparently I'm not going to Jane Street</title>
    <link href="http://osa1.net/posts/2013-07-16-jane-street-interview-2.html" />
    <id>http://osa1.net/posts/2013-07-16-jane-street-interview-2.html</id>
    <published>2013-07-16T00:00:00Z</published>
    <updated>2013-07-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had written about my first interview experience <a href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html">here</a>. After that interview, we did two more interviews with Jane Street, the last one was done yesterday.</p>
<p>Today I’ve got an email saying that I’ve failed.</p>
<p>I won’t write about last two interviews because I’m asked to not to write about questions.</p>
<p>Now I’m looking for Haskell jobs for my last internship and I just applied to Galois. I’ll keep posting updates here. Wish me luck.</p>
<p><em>EDIT: I got response to my job application email from Galois, saying that they would not be able to sponsor me for my visa application. Which means I’m still looking for jobs.</em></p>]]></summary>
</entry>
<entry>
    <title>fmap fix return</title>
    <link href="http://osa1.net/posts/2013-07-07-fmap-fix-return.html" />
    <id>http://osa1.net/posts/2013-07-07-fmap-fix-return.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While floating across the internets, I came across a blog with title <code>fmap fix return</code>. I immediately run ghci and queried it’s type:</p>
<pre class="ghci"><code>ghci&gt; :t fmap fix return
fmap fix return :: a -&gt; a</code></pre>
<p>We know that only value with type <code>forall a. a -&gt; a</code> (other than bottom) is identity function(<code>id</code> in Haskell). I found it very interesting, <code>fmap fix return</code> gives us identity function!</p>
<p>I got a pen and paper and started evaluating expressions to understand how does that give us the identity function.</p>
<p>First, let’s note our actors:</p>
<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- instance specific implementation

fix  :: (a -&gt; a) -&gt; a
fix f = let x = f x in x

return :: Monad m =&gt; a -&gt; m a
-- instance specific implementation</code></pre>
<p>A very important thing to realize at this point is which monad and functor instances are used for <code>return</code> and <code>fmap</code>. To realize this, observe that we get a function as return value of <code>fmap</code>. Which means <code>Functor f =&gt; f b</code> is <code>a -&gt; a</code>, or written in a different style to see it’s functor property: <code>((-&gt;) a) a</code>, so our functor here is <code>(-&gt;) a</code>.</p>
<p>After that, we need to look up functor and monad instances for <code>(-&gt;) a</code>. Since it’s 2:30 AM here, I wanted to derive that too.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
     <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>It’s very easy to derive just by looking specialized version of <code>fmap</code>s type for <code>((-&gt;) a)</code>: <code>fmap :: (a1 -&gt; b) -&gt; (a -&gt; a1) -&gt; (a -&gt; b)</code>.</p>
<p>We can easily prove that it satisfies functor laws:</p>
<pre><code>fmap id f
= id . f
= f

fmap (p . q) &lt;-&gt; (fmap p) . (fmap q)
(fmap p) . (fmap q) f
= fmap p . (q . f)
= p . q . f
= fmap (p . q) f</code></pre>
<p>Monad instance can also be derived from types of <code>return</code> and <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
    <span class="fu">return</span>   <span class="fu">=</span> <span class="fu">const</span>
    f <span class="fu">&gt;&gt;=</span> fn <span class="fu">=</span> \r <span class="ot">-&gt;</span> fn (f r) r</code></pre>
<p>(I found Monad instance of <code>((-&gt;) a)</code> very interesting, especially the <code>&gt;&gt;=</code> part. I couldn’t come up with a problem that makes use of this instance, I’ll investigate that after some sleep)</p>
<p>It satisfies monad laws:</p>
<pre><code>-- left identity
return a &gt;&gt;= f
= const a &gt;&gt;= f
= \r -&gt; f ((const a) r) r
= \r -&gt; f a r
= f a

-- right identity
m &gt;&gt;= return
= \r -&gt; return (m r) r
= \r -&gt; (const (m r) r)
= \r -&gt; m r
= m

-- associativity
(m &gt;&gt;= f) &gt;&gt;= g &lt;-&gt; m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

let&#39;s first write `p` for `m &gt;&gt;= f`

= p &gt;&gt;= g
= \r1 -&gt; g (p r1) r1

let&#39;s also evaluaute p

p = m &gt;&gt;= f
= \r2 -&gt; f (m r2) r2

substitute new p

= \r1 -&gt; g ((\r2 -&gt; f (m r2) r2) r1) r1
= \r1 -&gt; g (f (m r1) r1) r1
= \r -&gt; g (f (m r) r) r

now let&#39;s also evaluate right hand side of equation

m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
= m &gt;&gt;= (\x -&gt; (    f x &gt;&gt;= g    )) -- just added a paren for clarity
= m &gt;&gt;= (\x -&gt; (\r -&gt; g (f x r) r))

let write `p` for `\x -&gt; (\r -&gt; g (f x r) r)`

= m &gt;&gt;= p
= \r1 -&gt; p (m r1) r1

put p back

= \r1 -&gt; (\x -&gt; (\r -&gt; g (f x r) r)) (m r1) r1
= \r1 -&gt; (\r -&gt; g (f (m r1) r)) r1
= \r1 -&gt; g (f (m r1) r1)</code></pre>
<p>For those who have no idea what’s above, I’m basically proving some equalities by substituting expressions with their equivalents. This is a benefit for working on a purely functional language, which means referential transparency.</p>
<p>OK, now with these <code>return</code> and <code>fmap</code> implementations in mind, let’s evaluate <code>fmap fix return</code>:</p>
<pre><code>fmap fix return
= fix . return
= \r -&gt; fix (return r)
= \r -&gt; fix (const r)
= \r -&gt; (\f = let x = f x in x) (const r)
= \r -&gt; let x = (const r) x in x

since `const a _ = a`, we have x = r here

= \r -&gt; r</code></pre>
<p>.. which is the identity function.</p>
<p>Thus <code>fmap fix return</code> demystified.</p>]]></summary>
</entry>
<entry>
    <title>Shen.hs FFI</title>
    <link href="http://osa1.net/posts/2013-06-29-shenhs-ffi.html" />
    <id>http://osa1.net/posts/2013-06-29-shenhs-ffi.html</id>
    <published>2013-06-29T00:00:00Z</published>
    <updated>2013-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Shen.hs now has a simple way to call Haskell functions. As an example, I removed some non-standard KLambda functions from <a href="https://github.com/osa1/Shen.hs/blob/master/src/KLambda/Fun.hs"><code>Fun.hs</code></a>(standard primitive functions are defined there). Instead, they live in a <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs">separate module</a> now, and I load them in run-time when I’m debugging.</p>
<h2 id="how-it-works">How it works</h2>
<p>Shen.hs is now exports it’s modules as a library. This is required to allow writing Shen.hs functions in Haskell.</p>
<p><code>KLambda.Types</code> module export all required type information to start writing Shen.hs functions in Haskell. All your functions should have the type <code>KlFun1</code>. To make converting Haskell functions with higher arity(ie. <code>KlFun2</code>, <code>KlFun3</code>) to <code>KlFun1</code>, all <code>KlFun</code> instances now have a <code>mkFun1 :: a -&gt; KlFun1</code> method.</p>
<p>As an example, <a href="https://github.com/osa1/Shen.hs/blob/master/dynload_test/Debug.hs"><code>Debug.hs</code></a> module functions with types <code>KlFun2</code>, <code>KlFun3</code> etc. To call them from within Shen.hs, they are all wrapped with <code>mkFun1</code> function.</p>
<p>After defining functions with type <code>KlFun1</code> and compiling it, you should call <code>dynload</code> primitive to load functions. Here’s an example session that demonstrates loading and using debugging functions:</p>
<pre><code>$ Shen.hs --shen &quot;/home/omer/Shen/hs_yeni/K Lambda&quot;
loading file: /home/omer/Shen/hs_yeni/K Lambda/toplevel.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/core.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sys.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/sequent.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/yacc.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/reader.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/prolog.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/track.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/load.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/writer.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/macros.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/declarations.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/t-star.kl ...loaded.
loading file: /home/omer/Shen/hs_yeni/K Lambda/types.kl ...loaded.

Shen 2010, copyright (C) 2010 Mark Tarver
released under the Shen license
www.shenlanguage.org, version 12
running under Haskell, implementation: GHC
port 0.1 ported by Ömer Sinan Ağacan


(0-) (cd &quot;/home/omer/Shen/hs_yeni/dynload_test&quot;)
&quot;/home/omer/Shen/hs_yeni/dynload_test/&quot;

(1-) (dynload &quot;Debug.o&quot; &quot;debug1F&quot;)
&lt;function&gt;

(2-) (debug1F &quot;calling haskell function -- &quot; 1 2)
calling haskell function -- 1 :: TyNum

2

(3-)</code></pre>
<p>Note that you need both <code>.hi</code> and <code>.o</code> files to be able to load the library dynamically.</p>
<h2 id="status-of-shen.hs">Status of Shen.hs</h2>
<p>Before this additional feature I had fixed a bug and now Shen.hs fails in 8 tests in Test Suite distributed with Shen source. All errors are related and probably there is only one bug. Unfortunately narrowing bug’s scope is very hard at this point. Pull requests are welcome.</p>
<p>If you encounter any bugs please open an issue in <a href="https://github.com/osa1/Shen.hs">Github repository</a>.</p>]]></summary>
</entry>
<entry>
    <title>ANNOUNCE: Shen.hs -- Haskell port of Shen</title>
    <link href="http://osa1.net/posts/2013-06-21-ann-shen-hs.html" />
    <id>http://osa1.net/posts/2013-06-21-ann-shen-hs.html</id>
    <published>2013-06-21T00:00:00Z</published>
    <updated>2013-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m copying <a href="https://groups.google.com/forum/?hl=en#!topic/qilang/GKVN4E_ntWw">my email</a> sent to Shen mailing list:</p>
<blockquote>
<p>Hi all,</p>
<p>I had started writing a port of Shen in Haskell some time ago. Unfortunately it never reached a stable state. And now I can’t spare enough time to fix bugs and improve performance. So I thought maybe it’s a good time to announce it and wait for contributions.</p>
<p>By ‘not stable’ I don’t mean it’s in a terrible state. For example, Shen test suite runs with following results:</p>
<pre><code>passed ... 94.0 
failed ...34.0 
pass rate ...73.4375% </code></pre>
<p>.. it’s not hopelessly bad. It probably has one or two deadly bugs and that causes dozens of tests to fail.</p>
<p>Anyway, that’s it for now. Github repository is here: <a href="https://github.com/osa1/Shen.hs">https://github.com/osa1/Shen.hs</a> .</p>
<p>If you try please tell me your thoughts!</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>My first interview experience: Jane Street</title>
    <link href="http://osa1.net/posts/2013-06-20-first-interview-jane-street.html" />
    <id>http://osa1.net/posts/2013-06-20-first-interview-jane-street.html</id>
    <published>2013-06-20T00:00:00Z</published>
    <updated>2013-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A few hours ago I had my first interview ever. I had applied to Jane Street’s software development internship position last Sunday(16 June), and they returned to me on Monday(17 June), and we had an interview today(20 June). It was overall a very good experience.</p>
<p>I should say I’m a bit sad about this interview, because I couldn’t answer the questions with details I could answer and I gave wrong answers to some questions that I know very well. Still, I think I wasn’t bad in general. What happens next will be clear in few days.</p>
<p>We started with some generic personal questions like what I know, what I write, why did I applied to this internship etc. and I couldn’t give good answers even to this questions. For example, at some point I’m asked “what do you like about functional programs”, if you sit next to me in a class and ask me same question, I can give you a 50-minute lecture, but while at interview I just couldn’t do that.</p>
<p>Anyway, we then moved to technical question.</p>
<p>As for first question I’m asked to list 5 unix programs with 2 letters. I immediately listed <code>vi</code> and <code>ls</code>, after some thought I added <code>sh</code>, <code>ld</code>, <code>ln</code> and <code>nm</code>. I’m asked for what does <code>ld</code> do, and I wrongly answered “shows dynamically loaded libraries of an ELF binary”. My interviewer later asked me if I ever used that command, lol. It was funny that I said yes and explained how I used it, haha. The program I explained here is actually <code>ldd</code>, and <code>ld</code> is actually a linker(and I knew it very well, even though I have never called it manually). I also gave wrong answer to <code>nm</code>, I said “it shows string in a binary”, which was wrong because that what <code>strings</code> does. I should have said “shows symbols in a binary”. And I use these tools frequently!</p>
<p>For second question I’m asked “how would I count a list of files in a folder and it’s subfolders”. I said I’m not that good in shell environment so I wrote a small Python program instead. This was easy. (btw, I made a mistake even in this code by first writing a Python program that prints file paths instead of counting files, haha. Later I’m warned and I fixed the code :-D )</p>
<p>For third question I’m asked to tell what I know about garbage collectors and garbage collection techniques. I said the purpose of garbage collectors, and then mentioned reference counting technique. Later I’m asked to list some languages that does and doesn’t have automatic garbage collection.</p>
<p>Fourth question was to write and explain a <code>map</code> function that works on lists. It was trivial.</p>
<p>Fifth question was to write and explain <code>fold</code> function. I mentioned both left and right folds, wrote <code>foldl</code> in Haskell syntax and said that it’s a tail recursive process. At this point I’m also asked why is it tail recursive and what does tail recursive mean.</p>
<p>I think one nice question at this part is that the question of “does being tail-recursive matters in Haskell, because it’s lazy by default”. I think my interviewer wanted to test me if I understand orthogonality of laziness and tail recursion.</p>
<p>Last question, which I failed to give a correct answer was “you have a 5-sided fair dice, and you want to make a fair choice between 7 choices, how can you do it?”. Now this is by no means a hard question and I solved harder problems, but at that time I just couldn’t answer it.</p>
<p>One interesting observation I made while I’m trying to solve this problem was that thinking in a language and translating ideas to another one at the same time is hard. After few seconds of silence my interviewer asked me to say what I’m thinking. I was bad at this.</p>
<p>Anyway, I think I did good enough. I’ll post on updates, wish me luck :-) .</p>
<p><strong>EDIT: I’ve just got an email from Jane Street, we will make another interview, this time with someone from NY office :-)</strong></p>]]></summary>
</entry>

</feed>
