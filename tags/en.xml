<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2012-08-30T00:00:00Z</updated>
    <entry>
    <title>Separating lexing and parsing stages in Parsec</title>
    <link href="http://osa1.net/posts/2012-08-30-separating-lexing-and-parsing-in-parsec.html" />
    <id>http://osa1.net/posts/2012-08-30-separating-lexing-and-parsing-in-parsec.html</id>
    <published>2012-08-30T00:00:00Z</published>
    <updated>2012-08-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I really love Parsec. After using it several months now, I can’t think of parsing anything other than Parsec.</p>
<p>After I started working on more complex grammars, I thought maybe it could be good idea to separate lexing stage, since it may lead parser with simpler code. After some experimenting, a SO question, and reading some part of Parsec’s source, I finally managed to separate lexing and parsing. Now I’ll explain how to do that.</p>
<p>In lexing stage, other than writing ordinary token parsers, we also need to handle token positions. Each token moves the cursor, and saving this is needed for error reporing(and maybe some other reasons). In our case, simplest tokens are characters, and since we’re using Parsec’s built-in <code>Char</code> token, we don’t need to handle characters’ positions. But we need to save each token’s positions because we won’t be using Char tokens in parsing stage, we will be using our custom tokens.</p>
<p>You can see the full source <a href="https://gist.github.com/3507011">here</a>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">Ide</span> <span class="dt">String</span>
           <span class="fu">|</span> <span class="dt">LBrack</span>
           <span class="fu">|</span> <span class="dt">RBrack</span>
           <span class="fu">|</span> <span class="dt">LBrace</span>
           <span class="fu">|</span> <span class="dt">RBrace</span>
           <span class="fu">|</span> <span class="dt">Keyword</span> <span class="dt">String</span>
    <span class="kw">deriving</span> (<span class="kw">Show</span>, <span class="kw">Eq</span>)</code></pre>
<p>Token types should be instances of <code>Eq</code> to be able to test for equality while parsing, and <code>Show</code> to be able to print in error situations(actually you can use any function for testing for equality and printing, but I find this way easier).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TokenPos</span> <span class="fu">=</span> (<span class="dt">Token</span>, <span class="dt">SourcePos</span>)</code></pre>
<p>So we will be using <code>(Token, SourcePos)</code> pairs for tokens with positions of them in source. Now parsers are simple:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ide ::</span> <span class="dt">Parser</span> <span class="dt">TokenPos</span>
ide <span class="fu">=</span> <span class="kw">do</span>
    pos <span class="ot">&lt;-</span> getPosition
    fc  <span class="ot">&lt;-</span> oneOf firstChar
    r   <span class="ot">&lt;-</span> optionMaybe (many <span class="fu">$</span> oneOf rest)
    spaces
    <span class="fu">return</span> <span class="fu">$</span> <span class="fu">flip</span> (,) pos <span class="fu">$</span> <span class="kw">case</span> r <span class="kw">of</span>
                 <span class="kw">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Ide</span> [fc]
                 <span class="kw">Just</span> s  <span class="ot">-&gt;</span> <span class="dt">Ide</span> <span class="fu">$</span> [fc] <span class="fu">++</span> s
  <span class="kw">where</span> firstChar <span class="fu">=</span> [<span class="ch">&#39;A&#39;</span><span class="fu">..</span><span class="ch">&#39;Z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>] <span class="fu">++</span> <span class="st">&quot;_&quot;</span>
        rest      <span class="fu">=</span> firstChar <span class="fu">++</span> [<span class="ch">&#39;0&#39;</span><span class="fu">..</span><span class="ch">&#39;9&#39;</span>]</code></pre>
<p>This is a simple identifier parser(or lexer). Note the <code>pos &lt;- getPosition</code> part.</p>
<p>After more lexers like this, we need a <code>tokenize</code> function to generate token stream:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tokenize ::</span> <span class="dt">SourceName</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">TokenPos</span>]
tokenize <span class="fu">=</span> runParser tokens ()</code></pre>
<p>In parsing stage, we have several problems. One is that now we can’t use Parsec’s <code>parseTest</code> function, which I almost always use for testing purposes. Because now we need to pass the string to lexer, and then pass it’s output to parser. So I wrote this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Text.Parsec <span class="kw">as</span> P
<span class="fu">...</span>
<span class="ot">parseTest  ::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Parsec</span> [<span class="dt">TokenPos</span>] () a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
parseTest p s <span class="fu">=</span>
    <span class="kw">case</span> tokenize <span class="st">&quot;test&quot;</span> s <span class="kw">of</span>
        <span class="kw">Left</span> e    <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">show</span> e
        <span class="kw">Right</span> ts&#39; <span class="ot">-&gt;</span> P.parseTest p ts&#39;</code></pre>
<p><code>satisfy</code> gets a predicate on token, and return a token parser using Parsec’s <code>tokenPrim</code> function, which takes 3 functions as parameters, one for printing the token(to be used in error reporting), one for updating the current position, and one for returning the result after calling predicate. I adapted this function from Parsec’s string parsers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">advance ::</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> [<span class="dt">TokenPos</span>] <span class="ot">-&gt;</span> <span class="dt">SourcePos</span>
advance _ _ ((_, pos) <span class="fu">:</span> _) <span class="fu">=</span> pos
advance pos _ [] <span class="fu">=</span> pos
<span class="ot">satisfy ::</span> (<span class="dt">TokenPos</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Token</span>
satisfy f <span class="fu">=</span> tokenPrim <span class="fu">show</span>
                      advance
                      (\c <span class="ot">-&gt;</span> <span class="kw">if</span> f c <span class="kw">then</span> <span class="kw">Just</span> (<span class="fu">fst</span> c) <span class="kw">else</span> <span class="kw">Nothing</span>)</code></pre>
<p>Last function, <code>tok</code>, takes a token and returns a token parser:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tok ::</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Token</span>
tok t <span class="fu">=</span> (satisfy <span class="fu">$</span> (<span class="fu">==</span> t) <span class="fu">.</span> <span class="fu">fst</span>) <span class="fu">&lt;?&gt;</span> <span class="fu">show</span> t</code></pre>
<p><code>.. &lt;?&gt; show t</code> part is required for error reporting. See my <a href="http://stackoverflow.com/questions/12167329/haskell-parsec-error-messages-are-less-helpful-while-using-custom-tokens">SO question</a> for details.</p>
<p>Now, when using Parsec, generally there’s no need to separate lexing stage. Because as you can see above, it just makes code more complex, and adds no more flexibility. Instead of writing <code>tok $ Ide &quot;some-identifier&quot;</code>, you can always write <code>ide &quot;some-identifier&quot;</code> with a <code>ide</code> parser.</p>
<p>Still, I think understanding how to make this helps for at least two reasons. First, now you can work on any streams, not just character streams using Parsec’s <code>Char</code> token. And second, writing lexers can still help in some situations, like parsing indentation-based grammars. In that case, you can generate indent-dedent tokens in lexing stage, and make parser code more clean because it will be less <em>context-dependent</em> (I never tried that with Parsec, though) .</p>]]></summary>
</entry>
<entry>
    <title>Some GHC extensions I use</title>
    <link href="http://osa1.net/posts/2012-07-31-some-ghc-extensions.html" />
    <id>http://osa1.net/posts/2012-07-31-some-ghc-extensions.html</id>
    <published>2012-07-31T00:00:00Z</published>
    <updated>2012-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>GHC is a huge compiler. On GHC 7.4.1, I can see 85 optional language extensions<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Some of them are just adding some syntactic sugar(<code>NamedFieldPuns</code>, <code>RecordWildCards</code>), and some of them are extensions to type system(<code>GADTs</code>, <code>Rank2Types</code>). As a new Haskeller, I only know and use a small subset of this features, and in this post I’ll write about it.</p>
<h3 id="namedfieldpuns-and-recordwildcards">NamedFieldPuns and RecordWildCards</h3>
<p>This is some really simple syntactic sugar for pattern matching some names in records. Normally you’d do:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">someFun ::</span> <span class="dt">T</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
someFun <span class="dt">T</span>{n2<span class="fu">=</span>n2, n3<span class="fu">=</span>n3} <span class="fu">=</span> (n2, n3)</code></pre>
<p>But instead of assigning some names to members of a record with same names, with help of <code>NamedFieldPuns</code>, you could just write:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">someFun ::</span> <span class="dt">T</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
someFun <span class="dt">T</span>{n3, n2} <span class="fu">=</span> (n2, n3)</code></pre>
<p>It’s that simple. <code>RecordWildCards</code> doing something similar. Instead of writing <code>someFun T{n1,n2,n3}</code>, you just write <code>someFun T{..}</code>.</p>
<p>These are purely syntactic, so they can be used for any place that you can use pattern matching or destructuring(ie. <code>let .. in ..</code> or <code>where</code> clauses). Really helpful when working on data constructors that have 4+ members.</p>
<p>Most interesting use of <code>RecordWildCards</code> I’ve seen was <a href="http://hpaste.org/71626">this implementation</a> of localised module imports(I think this implementation can also be used for first-class modules).</p>
<h3 id="overloadedstrings">OverloadedStrings</h3>
<p>This really helps when working on <a href="http://hackage.haskell.org/package/text-0.11.2.2"><code>Text</code></a> data. When you are passing a function a <code>Text</code> data, instead of using <code>pack &quot;some string&quot;</code>, you can just use <code>&quot;some string&quot;</code> and compiler resolves the type of the string, adds required code etc.</p>
<p>Basically it provides a way to create instances of <code>class IsString a where fromString :: String -&gt; a</code> using string syntax. It’s mostly used with <code>Data.Text</code>, <code>ByteString.Text</code> etc.</p>
<h3 id="gadts">GADTs</h3>
<p>This is by far my favorite type system extension. This is mostly because I’m working on an interpreter, and GADTs are great for representing syntax trees.</p>
<p>To understand advantages of GADTs, first let’s think about how we can represent syntax tree for a simple language. Let some part of our sytax be(in a BNF-like format):</p>
<pre><code>&lt;var&gt;   = String
&lt;abst&gt;  = &quot;(&quot; &quot;λ&quot; &quot;(&quot; {&lt;var&gt; [&quot; &quot;]}* &quot;)&quot; &lt;term&gt; &quot;)&quot;
&lt;app&gt;   = &quot;(&quot; &lt;term&gt; {&lt;term&gt; [&quot; &quot;]}* &quot;)&quot;
&lt;term&gt;  = &lt;var&gt; | &lt;abst&gt; | &lt;app&gt;</code></pre>
<p>So, variables, lambda abstractions, and applications. Just like in untyped lambda calculus. Now let’s try to encode this format in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">String</span>
          <span class="fu">|</span> <span class="dt">Abst</span> [<span class="fu">??</span>] <span class="dt">Term</span>
          <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Term</span> <span class="dt">Term</span></code></pre>
<p>What should we write in place of <code>??</code> ? Writing <code>Term</code> is obviously wrong, since then we could be ill-formed data(for instance, think about a syntax like that: <code>(λ ((λ (a) ..)) ...)</code> we used lambda abstraction in place of lambda parameter names).</p>
<p>If the term <code>var</code> just consists of a String, then we can directly use String as a first member of <code>Abst</code> constructor, but think term <code>var</code> as a really complex constructor. I’m trying to make examples as clear and simple as possible.</p>
<p>One way to fix that is to use “smart constructors”. What this really means is that we can hide some data constructors in our module(ie. write exported names in module explicitly) and export some constructor function in place of them. With the help of a trick we can give users a more controlled way of creating data(in our case this means that we can prevent caller from creating ill-formed syntax tree).</p>
<p>First, let’s see the data type trick:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T1</span>
<span class="kw">data</span> <span class="dt">T2</span>
<span class="kw">data</span> <span class="dt">SomeData</span> a <span class="fu">=</span> <span class="dt">Data1</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Data2</span> <span class="dt">Int</span>
  <span class="kw">deriving</span> <span class="kw">Show</span></code></pre>
<p>This is interesting because data types T1 and T2 don’t have any constructors. So there is literally no way to create data in that types. Second interesting point in <code>SomeData a</code> is, the <code>a</code> variable is not used by data constructors(<code>Data1</code> and <code>Data2</code>). This code still works:</p>
<pre><code>ghci&gt; :t Data1 &quot;ok&quot;
Data1 &quot;ok&quot; :: SomeData a
ghci&gt; :t Data2 123
Data2 123 :: SomeData a
ghci&gt; Data1 &quot;ok&quot; :: SomeData Int
Data1 &quot;ok&quot;
ghci&gt; Data1 &quot;ok&quot; :: SomeData Char
Data1 &quot;ok&quot;</code></pre>
<p>If we could find a way to distinguish types of data created with <code>Data1</code> and <code>Data2</code>, we’re done. This is where smart constructors take place:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">data1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeData</span> <span class="dt">T1</span>
data1 <span class="fu">=</span> <span class="dt">Data1</span>
<span class="ot">data2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeData</span> <span class="dt">T2</span>
data2 <span class="fu">=</span> <span class="dt">Data2</span></code></pre>
<p>We’re telling to compiler that data created with <code>data1</code> constructor will be the type of <code>SomeData T1</code>. Now if we hide <code>Data1</code> and <code>Data2</code> data constructors and export <code>data1</code> and <code>data2</code> functions, there is no way for user create ill-formed data types like <code>Data1 &quot;ok&quot; :: SomeData SomeUnrelatedType</code> like we done in past example.</p>
<pre><code>ghci&gt; data1 &quot;ok&quot; :: SomeData Int

&lt;interactive&gt;:48:1:
    Couldn&#39;t match expected type `Int&#39; with actual type `T1&#39;
    Expected type: SomeData Int
      Actual type: SomeData T1
    In the return type of a call of `data1&#39;
    In the expression: data1 &quot;ok&quot; :: SomeData Int</code></pre>
<p>Now we can encode our syntax in Haskell like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Var</span>
<span class="kw">data</span> <span class="dt">Abst</span>
<span class="kw">data</span> <span class="dt">App</span>
<span class="kw">data</span> <span class="dt">AnyTerm</span>
<span class="kw">data</span> <span class="dt">Term</span> a <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">String</span>
            <span class="fu">|</span> <span class="dt">Abst</span> [<span class="dt">Term</span> <span class="dt">Var</span>] (<span class="dt">Term</span> <span class="dt">AnyTerm</span>)
            <span class="fu">|</span> <span class="dt">App</span> (<span class="dt">Term</span> <span class="dt">AnyTerm</span>) (<span class="dt">Term</span> <span class="dt">AnyTerm</span>)
<span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Var</span>
var <span class="fu">=</span> <span class="dt">Var</span>
<span class="ot">abst ::</span> [<span class="dt">Term</span> <span class="dt">Var</span>] <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Abst</span>
abst <span class="fu">=</span> <span class="dt">Abst</span>
<span class="ot">app ::</span> <span class="dt">Term</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">App</span>
app <span class="fu">=</span> <span class="dt">App</span>
anyTerm <span class="fu">=</span> <span class="fu">id</span></code></pre>
<p>Now I’m omitting some parts without explaining since this post is already long enough. But the point should be clear by now. Let’s see this in action:</p>
<pre><code>ghci&gt; abst [(abst [var &quot;p1&quot;] (anyTerm (var &quot;p1&quot;)))] (anyTerm (var &quot;somevar&quot;))

&lt;interactive&gt;:63:8:
    Couldn&#39;t match expected type `Var&#39; with actual type `Abst&#39;
    Expected type: Term Var
      Actual type: Term Abst
    In the return type of a call of `abst&#39;
    In the expression: (abst [var &quot;p1&quot;] (anyTerm (var &quot;p1&quot;)))</code></pre>
<p>Nice! Just like what we wanted. GADTs help for creating smart “data constructors” so that we don’t have to hide data constructors and export some smart constructor functions. Here’s the same code with GADTs:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Var</span>
<span class="kw">data</span> <span class="dt">Abst</span>
<span class="kw">data</span> <span class="dt">App</span>
<span class="kw">data</span> <span class="dt">Term</span> a <span class="kw">where</span>
    <span class="dt">Var</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Var</span>
    <span class="dt">Abst</span><span class="ot"> ::</span> [<span class="dt">Term</span> <span class="dt">Var</span>] <span class="ot">-&gt;</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Abst</span>
    <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">App</span>
<span class="kw">data</span> <span class="dt">AnyTerm</span> <span class="kw">where</span>
    <span class="dt">AnyTerm</span><span class="ot"> ::</span><span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">AnyTerm</span></code></pre>
<p>This code should be clear. All we do is to specify constructor’s return type.</p>
<p>This is really great improvement. Think of a more complex syntax tree, with a lot more constructors. The parser already checks for invalid syntax, so actually there’s no way to create ill-formed syntax tree since parser rejects the code.</p>
<p>If you don’t use GADTs or phantom types, you have to check for ill-formed syntax in your evaluator(or reducer or compiler or whatever) even if there’s no way for parser to generate ill-formed syntax tree. For instance, you’d have to check for <code>Var [(App ..)] ...</code> in your <code>eval :: Env -&gt; Term -&gt; Val</code> function.</p>
<p>The worst part of GADTs is that you can’t use <code>deriving</code> clause in data type declaration(can anyone explain why?). In my case, that means I have to write some big amounts of code just to be able to print out the data for debugging purposes. For instance, I had to write some repetitive code like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Show</span> (<span class="dt">Expr</span> a) <span class="kw">where</span>
    <span class="fu">...</span>
    <span class="fu">show</span> (<span class="dt">Lambda</span> params ret body) <span class="fu">=</span> <span class="st">&quot;(lambda (&quot;</span> <span class="fu">++</span> <span class="fu">unwords</span> (<span class="fu">map</span> <span class="fu">show</span> params) <span class="fu">++</span> <span class="st">&quot;) : &quot;</span> <span class="fu">++</span> <span class="fu">show</span> ret <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> <span class="fu">unwords</span> (<span class="fu">map</span> <span class="fu">show</span> body) <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    <span class="fu">show</span> (<span class="dt">If</span> ifE thenE elseE) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> intercalate <span class="st">&quot;,&quot;</span> [<span class="fu">show</span> ifE, <span class="fu">show</span> thenE, <span class="fu">show</span> elseE] <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    <span class="co">-- same repetitive code for each data constructor, it&#39;s really pain when the syntax grows bigger and when you frequently make some changes on it.</span></code></pre>
<p>I also had to write same amount of code just to be able to run tests on my parser(ie. I need to compare hand-written syntax tree with parser generated syntax tree).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Eq</span> (<span class="dt">Expr</span> a) <span class="kw">where</span>
    <span class="fu">...</span>
    <span class="dt">Lambda</span> p1 b1 <span class="fu">==</span> <span class="dt">Lambda</span> p2 b2 <span class="fu">=</span> p1 <span class="fu">==</span> p2 <span class="fu">&amp;&amp;</span> b1 <span class="fu">==</span> b2
    <span class="dt">If</span> i1 t1 e1 <span class="fu">==</span> <span class="dt">If</span> i2 t2 e2 <span class="fu">=</span> i1 <span class="fu">==</span> i2 <span class="fu">&amp;&amp;</span> t1 <span class="fu">==</span> t2 <span class="fu">&amp;&amp;</span> e1 <span class="fu">==</span> e2
    <span class="fu">...</span>
    _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="kw">False</span></code></pre>
<h3 id="further-reading">Further reading:</h3>
<ul>
<li><a href="http://www.haskell.org/haskellwiki/Phantom_type">Phantom type on Haskell wiki</a>. Phantom types are data types without constructors, like we’ve used in examples. I first met with this concept in <a href="http://vimeo.com/14313378">Yaron Minsky’s great talk on effective ML</a>. I highly recommend it.</li>
<li><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt">GHC user’s guide on GADTs</a>.</li>
<li><a href="http://www.haskell.org/haskellwiki/GADT">GADTs on Haskell wiki</a>.</li>
</ul>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>To list all extensions, I run GHCi, type <code>:set -X</code> and then run auto-complete, it says “Display all 167 possibilities?” on GHC 7.4.1, 82 of them are starting with <code>-XNo</code>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Lazy lists in Lua and eliminating tail-calls with continuations</title>
    <link href="http://osa1.net/posts/2012-05-20-lazy-lists-in-lua-and-eliminating-tail-calls-with-continuations.html" />
    <id>http://osa1.net/posts/2012-05-20-lazy-lists-in-lua-and-eliminating-tail-calls-with-continuations.html</id>
    <published>2012-05-20T00:00:00Z</published>
    <updated>2012-05-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I was reading some papers about parsing with continuations and I realized that I had never implemented continuations in any language. Since I’m interested in Lua nowadays, I want to implement it in Lua.</p>
<p>After a while, I realized that you could use continuations to eliminate recursive calls to prevent stack overflows. Now, in a language like Lua, we have tail-call optimization(TCO) and recursive calls in tail positoins are not problem, but even in languages that don’t have TCO, you can easily convert tail calls to loops with help of continuations. And I found the underlying idea of this is pretty similar to lazy-lists. Now I’m going to try to explain how.</p>
<p>For those who want to see the code, here’s the <a href="https://gist.github.com/2757232">gist</a>.</p>
<p>Nowadays most of modern languages(functional ones or not), have some primitives for lazy evaluation(like Python’s generators), and I’m not an expert on Lua but AFAIK, Lua’s coroutines can be used for lazy evaluation. But even if you use a language that doesn’t have any non-strict primitives, you can have some lazy structures(ie. in JavaScript).</p>
<p>The main idea of this is that you can always pass functions in a form that holds the function itself and a list of arguments that will be passed to function. And when you want to evaluate the result of the function call, you just call the function in that form with the arguments. Note that by “function itself”, I mean the function callback. Most modern languages nowadays have functions as first-class values or at least some kind of function pointers/referances, so this is not a problem.</p>
<p>I’ll give the code in Lua. We’ll call the structure that holds a function callback(or whatever your language call it) and a list of parameters, <code>thunk</code><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> In Lua, this will be a table with two keys: <code>f</code> and <code>args</code>. Here’s an example thunk.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">t</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">f</span> <span class="ot">=</span> <span class="fu">print</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="ot">{</span><span class="st">&quot;first arg&quot;</span><span class="ot">,</span> <span class="st">&quot; second arg&quot;</span><span class="ot">}</span> <span class="ot">}</span></code></pre>
<p>So when we want to run the function in the thunk, we just call <code>evalThunk</code>, which is pretty straightforward to implement:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="kw">t</span><span class="ot">.</span>f<span class="ot">(</span><span class="fu">unpack</span><span class="ot">(</span><span class="kw">t</span><span class="ot">.</span><span class="kw">args</span><span class="ot">))</span>
<span class="kw">end</span>
<span class="ot">&gt;</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
<span class="kw">first</span> <span class="kw">arg</span>        <span class="kw">second</span> <span class="kw">arg</span></code></pre>
<p>Basically, when we want to make a function non-strict, we just create a thunk of it, with <code>f</code> = function itself, and the <code>args</code> = the args we want to pass to the function when we run it. Here’s a helper for it:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> makeThunk<span class="ot">(</span><span class="kw">f</span><span class="ot">,</span> <span class="kw">args</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="ot">{</span> <span class="fu">tag</span> <span class="ot">=</span> <span class="st">&quot;thunk&quot;</span><span class="ot">,</span> <span class="kw">f</span> <span class="ot">=</span> <span class="kw">f</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="kw">args</span> <span class="ot">}</span>
<span class="kw">end</span></code></pre>
<p>Now, with the help of this two functions, we can create a infinite-length lazy linked-lists. Each node in our linked-lists will have two keys: <code>first</code> and <code>rest</code>. <code>first</code> will have the value of that node, and <code>rest</code> will have the next node connected to that node. Here’s a helper to create linked-list nodes.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> cons<span class="ot">(</span><span class="kw">first</span><span class="ot">,</span> <span class="kw">rest</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="ot">{</span> <span class="kw">first</span> <span class="ot">=</span> <span class="kw">first</span><span class="ot">,</span>
             <span class="kw">rest</span>  <span class="ot">=</span> <span class="kw">rest</span> <span class="ot">}</span>
<span class="kw">end</span></code></pre>
<p>In lazy-lists, we always have the <code>rest</code> part of the list as unevaluated thunks. To traverse the list to some point, we need to evaluate the nodes we passed, and when we evaluate this nodes, we just replace the thunks with evaluated values. Because we don’t want to evaluate the same node again and again for eact iteration.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="kw">p</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">t</span> <span class="ot">==</span> <span class="kw">nil</span> <span class="kw">then</span>
        <span class="kw">return</span> <span class="kw">nil</span>
    <span class="kw">elseif</span> <span class="fu">type</span><span class="ot">(</span><span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">])</span> <span class="ot">==</span> <span class="st">&quot;table&quot;</span> <span class="kw">and</span> <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">].</span><span class="kw">tag</span> <span class="ot">==</span> <span class="st">&quot;thunk&quot;</span> <span class="kw">then</span>
        <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">]</span> <span class="ot">=</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">])</span>
    <span class="kw">end</span>
    <span class="kw">return</span> <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">]</span>
<span class="kw">end</span>
<span class="kw">function</span> first<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="st">&quot;first&quot;</span><span class="ot">)</span>
<span class="kw">end</span>
<span class="kw">function</span> rest<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="st">&quot;rest&quot;</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p><code>first</code> and <code>rest</code> functions are returning the <code>first</code> and <code>rest</code> parts of our linked-list nodes. We’re expecting this parts to be unevaluated thunks. So if they’re thunks, we just evaluate them and replace the return value with thunks so that we don’t need to re-evaluate everytime we get a node.</p>
<p>And with the last helper, we can start creating infinite lazy-lists in Lua:</p>
<pre><code>function nth(t, n)
    if n == 0 then
        return first(t)
    end
    return nth(rest(t), n-1)
end</code></pre>
<p>This function is just getting the n. node in a linked list. And while getting this node, it’s evaluating all the thunk on the way with help of <code>rest</code> function. This is important because as you’ll see, we will be creating the rest of the lists while we’re traversing it.</p>
<p>Let’s see an example of infinite lazy-list that creates a list of factorials, starting from 1!:</p>
<pre><code>function fact(n, f)
    n = n or 1
    f = f or 1
    return cons(n, makeThunk(fact, {n*f, f+1}))
end</code></pre>
<p>This function returns a linked-list that contains factorial of 1, and then a thunk of the same factorial function, but with different parameters. The function call in the <code>rest</code> part of the thunk will return the next factorial, and then the same function as a thunk in <code>rest</code> part of the thunk, in a recursive fashion. Note that our <code>nth</code> function is tail-recursive so we’ll never have stack overflows while traversing the list(it’s also trivial to implement an iterative loop version of it).</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="ot">&gt;</span> <span class="kw">a</span> <span class="ot">=</span> fact<span class="ot">()</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">))</span>
<span class="dv">1</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">))</span>
<span class="dv">2</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">10</span><span class="ot">))</span>
<span class="dv">3628800</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">20</span><span class="ot">))</span>
<span class="dv">2.4329020081766e+18</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">30</span><span class="ot">))</span>
<span class="dv">2.6525285981219e+32</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">40</span><span class="ot">))</span>
<span class="dv">8.159152832479e+47</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">50</span><span class="ot">))</span>
<span class="dv">3.0414093201713e+64</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">250</span><span class="ot">))</span>
<span class="kw">inf</span></code></pre>
<p>So it’s obviously generating all the factorials while we traverse the list. You can also try to see that every thunk is evaluated only once by adding some <code>print</code> functions to thunks.</p>
<p>Here’s a lazy-list that contains all fibonacci numbers:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> fib<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="kw">b</span><span class="ot">)</span>
    <span class="kw">a</span> <span class="ot">=</span> <span class="kw">a</span> <span class="kw">or</span> <span class="dv">0</span>
    <span class="kw">b</span> <span class="ot">=</span> <span class="kw">b</span> <span class="kw">or</span> <span class="dv">1</span>
    <span class="kw">return</span> cons<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> makeThunk<span class="ot">(</span><span class="kw">fib</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">b</span><span class="ot">,</span> <span class="kw">a</span><span class="ot">+</span><span class="kw">b</span><span class="ot">}))</span>
<span class="kw">end</span></code></pre>
<p>You can also easily define functions that take linked-lists and map/filter and return the result as lazy-lists. I added them the to the gist.</p>
<p>Now, how’s that related with continuations that eliminate tail-calls? Let’s work on an exmple:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">n</span> <span class="ot">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span>
        <span class="kw">return</span> cont<span class="ot">(</span><span class="dv">1</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> newCont<span class="ot">(</span><span class="kw">v</span><span class="ot">)</span>
        <span class="kw">return</span> cont<span class="ot">(</span><span class="kw">v</span><span class="ot">+</span><span class="kw">n</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="kw">return</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">-</span><span class="dv">1</span><span class="ot">,</span> <span class="kw">newCont</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>I found JavaScript version of this example in <a href="http://nathansuniversity.com/cont3.html">Nathan’s University</a> and I think it’s a typical usage of continuations. Instead of returning the result, we’re passing the result to the continuation function. And when we hit the buttom(ie. when n &lt;= 1) we pass the last result to continuation function and return it.</p>
<p>I don’t explain why one would do that, you can read it from Nathan’s University.</p>
<p>If you run a function like this in JavaScript, you get a stack overflow after a while since this function is recursive. But with the help of thunks, you can eliminate the recursive call entirely, even in JavaScript. Let’s change it to:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">n</span> <span class="ot">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span>
        <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="dv">1</span><span class="ot">})</span>
    <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> newCont<span class="ot">(</span><span class="kw">v</span><span class="ot">)</span>
        <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">v</span><span class="ot">+</span><span class="kw">n</span><span class="ot">})</span>
    <span class="kw">end</span>
    <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">sum</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">n</span><span class="ot">-</span><span class="dv">1</span><span class="ot">,</span> <span class="kw">newCont</span><span class="ot">})</span>
<span class="kw">end</span></code></pre>
<p>We replaced every function call with thunks. Now you can realize that <code>makeThunk</code> calls are just linking function calls together. For example, after calling <code>sum(10, function(n) print(&quot;result: &quot;, n) end)</code>, we get this thunk:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="ot">{</span> <span class="fu">tag</span> <span class="ot">=</span> <span class="st">&quot;thunk&quot;</span><span class="ot">,</span> <span class="kw">f</span> <span class="ot">=</span> <span class="kw">sum</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="ot">{</span><span class="dv">9</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">v</span><span class="ot">)</span> <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">v</span><span class="ot">+</span><span class="dv">10</span><span class="ot">})</span> <span class="kw">end</span><span class="ot">}}</span></code></pre>
<p>When we evaluate this thunk, we just get another thunk unless the first arg is not &lt;= 1. Now we need a helper to evaluate the thunk, and then evaluate the thunk returned by the first thunk, until we evaluate all the thunks. This is what’s called “trampoline”:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> trampoline<span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span>
    <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
        <span class="kw">if</span> <span class="fu">type</span><span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span> <span class="ot">~=</span> <span class="st">&quot;table&quot;</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">thunk</span>
        <span class="kw">elseif</span> <span class="kw">thunk</span><span class="ot">.</span><span class="kw">tag</span> <span class="ot">==</span> <span class="st">&quot;thunk&quot;</span> <span class="kw">then</span>
            <span class="kw">thunk</span> <span class="ot">=</span> evalThunk<span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">end</span>
<span class="ot">&gt;</span> <span class="kw">a</span> <span class="ot">=</span> sum<span class="ot">(</span><span class="dv">10</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">n</span><span class="ot">)</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;result: &quot;</span><span class="ot">,</span> <span class="kw">n</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">tag</span><span class="ot">)</span>
<span class="kw">thunk</span>
<span class="ot">&gt;</span> trampoline<span class="ot">(</span><span class="kw">a</span><span class="ot">)</span>
<span class="kw">result</span>:         <span class="dv">55</span></code></pre>
<p>We’re evaluating the thunks in a <code>while</code> loop. This is how you can eliminate tail calls. Now, this exactly looks like the lazy-list method I mentioned in this post. And we already used the same thunk structure for both of them.</p>
<p>The only difference is, in continuations we don’t save old thunks anywhere and just replace them with new continuations, and we only return a value other than new thunks when we finished the calculation(ie. when we reach the base case).</p>
<p>So essentially, both continuations and lazy-lists have the same idea. And these are very easy to implement even in langauges that doesn’t support any non-strict primitives.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For a better explanation of <code>thunk</code>s, see <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#footnote_Temp_580">SICP</a>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Ramblings on monads</title>
    <link href="http://osa1.net/posts/2012-04-09-ramblings-monads.html" />
    <id>http://osa1.net/posts/2012-04-09-ramblings-monads.html</id>
    <published>2012-04-09T00:00:00Z</published>
    <updated>2012-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had written a short post about Haskell and monads to <a href="http://nathansuniversity.com/">Nathan’s University</a> forum as a first homework, and I wanted to add it to my blog too:</p>
<hr />
<p>I know lots of people here have already given Haskell as an example, but I want to mention to a different point of Haskell. Monads and DSL capabilities.</p>
<p>Every monad in Haskell is potentially a DSL. You can define commands(ie. functions) in a syntax that looks almost like syntax in imperative languages even if you’re doing a purely functional computation(for imperative computations, see IO monad). When you write a monad and some functions working with this monad, you basically write operations of a kind of computations, and a way to combine this computations(with <code>&gt;&gt;=</code> function, read as bind).</p>
<p>This gives you two great advantages. First, monads give you an elegant way to separate combination and calculation logic, and second, it gives you an opportunity to create syntactic abstractions.</p>
<p>For example, you don’t have to pass some states around functions thank to monads. You can just create a monad with functions getting a state and returning some values and the new state. Then you can define your combination logic(bind functions) and with the help of <code>do</code> notation, you can write almost imperative looking code, passing states automatically. See example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Control.Monad.State
<span class="kw">import</span> Control.Monad
<span class="kw">type</span> <span class="dt">AvgState</span> <span class="fu">=</span> <span class="dt">State</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Int</span>
state0 <span class="fu">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)
 
<span class="ot">addAvg ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AvgState</span>
addAvg x <span class="fu">=</span> <span class="kw">do</span>
    (count, total) <span class="ot">&lt;-</span> get
    put (count<span class="fu">+</span><span class="dv">1</span>, total<span class="fu">+</span>x)
    <span class="fu">return</span> <span class="fu">$</span> (total<span class="fu">+</span>x) <span class="ot">`div`</span> (count<span class="fu">+</span><span class="dv">1</span>)
 
<span class="ot">test ::</span> <span class="dt">AvgState</span>
test <span class="fu">=</span> <span class="kw">do</span>
    addAvg <span class="dv">10</span>
    addAvg <span class="dv">20</span>
    addAvg <span class="dv">30</span>
 
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">print</span> <span class="fu">$</span> evalState test state0</code></pre>
<p>Here I’m calculating arithmetic average of some integers. <code>type AvgState</code> is my data type representing the sum of the numbers I give and the total count of numbers. Here I don’t write a new monad, instead I use Haskell’s State monad, contained in <code>Control.Monad.State</code> package.</p>
<p><code>addAvg</code> functions is the main logic. If you look at it, it almost looks like an imperative program, I’m reading some values and changing them by adding them one, and returning a new value(note that I’m not returning any new states, it’s being handled my the monad itself), but still it’s purely functional.</p>
<p>Now how’s that a DSL? Look at <code>test</code> function and hopefully you’ll see :) .</p>
<p>I want to give another example about DSL-like monads: <code>Parsec</code>.</p>
<p>I’ve been working on a Websocket based chat protocol written in Haskell lately and this code is directly from my project:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chanName ::</span> <span class="dt">Parser</span> <span class="dt">ChanName</span>
chanName <span class="fu">=</span> many1 (letter <span class="fu">&lt;|&gt;</span> oneOf <span class="st">&quot;-&quot;</span> <span class="fu">&lt;|&gt;</span> digit)
 
<span class="ot">msgCmd ::</span> <span class="dt">Parser</span> <span class="dt">Cmd</span>
msgCmd <span class="fu">=</span> <span class="kw">do</span>
    string <span class="st">&quot;msg&quot;</span>
    spaces
    chan <span class="ot">&lt;-</span> chanName
    spaces
    msg <span class="ot">&lt;-</span> many1 anyChar
    eof
    <span class="fu">return</span> <span class="fu">$</span> <span class="dt">MsgCmd</span> chan msg</code></pre>
<p>I’m using Parsec’s <code>Parser</code> monads with <code>do</code> notation and it looks almost like Backus–Naur Form. chanName mathes list of letters, ‘-’ character, or digits with at least one element. This is a parser. And then I’m using this parser in my <code>msgCmd</code> parser. It matches a string “msg”, then arbitrary number of spaces, then <code>chanName</code>, then spaces again, and at last any characters.</p>]]></summary>
</entry>
<entry>
    <title>Finger Tree I</title>
    <link href="http://osa1.net/posts/2012-03-14-finger-tree-i.html" />
    <id>http://osa1.net/posts/2012-03-14-finger-tree-i.html</id>
    <published>2012-03-14T00:00:00Z</published>
    <updated>2012-03-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>As a part of my journey of understanding functional programming and functional languages’ internals, I’m reading some classical papers about functional data structures. In this series of posts, I’ll be explaining Finger Trees, which I learned so much from.</p>
<p>At first I had tried to write about finger trees in one post but later I realized that it was too long and it contained lots of different concepts. So I decided to split it into 3-4 posts, each of them explaining a different concept. In each post, we’re going to implement a different data structure. First post is going to be about implementing a functional <em>deque</em> with Finger Trees. Second is going to be about <em>priority queues</em>, in which I also am going to explain an use of <em>monoid</em> s. Third is going to be about vectors, with efficient concatenation and slicing. And at last, I’m going to explain Clojure’s persistent vector’s internals, which I think it’s somewhat related with finger tree’s. Oh, and somewhere in between I’m going to write something about <em>Peano numbers</em>.</p>
<p>So, let’s start. AFAIK, the first paper about finger trees was <a href="http://www.soi.city.ac.uk/~ross/papers/FingerTree.html">Finger Trees: A Simple General-purpose Data Structure</a>. I read the paper a couple of times and I found it too .. complex. So I’ll explain most of the stuff in my own words. Some part of the code will be different from code in the paper.</p>
<p>The problem finger trees are trying to solve is, since in functional setting we can’t mutate any structures, to form our structures in a way that making some specific changes on them should cost us minimum number of copying operations. This idea is similar to zippers. With zippers, we convert our structures to a form that make changes in some specific places cost us less copying operations, which means we can make changes more efficiently. And with finger trees, we have a structure that make modifications on two(or maybe more, depending on your implementation) places are really efficient. For instance, we can create <em>deque</em> with finger trees with efficient <code>push_back</code>, <code>push_front</code>, <code>pop_back</code> and <code>pop_front</code> operations.</p>
<p>Let’s assume a 2-3 tree, which we use as a <em>deque</em>. In order to make modifications on ends of the tree, we need to copy all nodes on it’s way to end. So we change the structure, like in zippers, create a new structure which looks like this:</p>
<div class="figure">
<img src="/images/fingertree/finger.png" />
</div>
<p>For those who have already read the original paper, this example is the same with the paper. But I change the look of it. I found drawing of this example in paper confusing. It shows different nodes with same shapes, then gives a definition of the structure, which I found completely unrelated with the drawing.</p>
<p>This is a deque contains characters of “thisisnotatree”. To make some changes in front or back of the deque, all we need to change is the nodes containing “th” and “ree”, which are just ordinary arrays, and the root node. When arrays get bigger, we shift some elements from arrays to our tree structures. Let’s make some definitions(most of my ADTs are deriving from <code>Show</code>, I found it better to see internals of structures that I’m working on):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Node</span> s <span class="fu">=</span> <span class="dt">Node2</span> s s <span class="fu">|</span> <span class="dt">Node3</span> s s s
  <span class="kw">deriving</span> (<span class="kw">Show</span>)
<span class="kw">data</span> <span class="dt">FingerTree</span> a <span class="fu">=</span> <span class="dt">Empty</span>
                  <span class="fu">|</span> <span class="dt">Single</span> a
                  <span class="fu">|</span> <span class="dt">Deep</span> (<span class="dt">Digit</span> a) (<span class="dt">FingerTree</span> (<span class="dt">Node</span> a)) (<span class="dt">Digit</span> a)
  <span class="kw">deriving</span> (<span class="kw">Show</span>)
<span class="kw">type</span> <span class="dt">Digit</span> a <span class="fu">=</span> [a]</code></pre>
<p>In my drawing, blue nodes are FingerTrees, black nodes which characters inside are Digits<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup></p>
<p>So let’s see how we can add new Digits to the structure. In my examples, Digits will be <code>[Char]</code>, which are the same with <code>String</code>. Later we’ll see we can use any types that provide some operations.</p>
<p>Let’s define <code>addl</code> and <code>addr</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addl ::</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</code></pre>
<p>We have 4 cases, if we add to an empty finger tree, it’s obvious:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addl a <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Single</span> a</code></pre>
<p>If we add to a finger tree with only one element(<code>Single a</code>), we just shift old element to right part of the structure and put new element to left:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addl a (<span class="dt">Single</span> b) <span class="fu">=</span> <span class="dt">Deep</span> [a] <span class="dt">Empty</span> [b]</code></pre>
<p>When we add to a tree with left side contains 4 elements, we push two of this elements to subtree part, and push new element to new left part:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addl a (<span class="dt">Deep</span> [b,c,d,e] m sf) <span class="fu">=</span> <span class="dt">Deep</span> [a, b] (addl (<span class="dt">Node3</span> c d e) m) sf</code></pre>
<p>And lastly, if our left part contains less than 4 elements, we just add a new element to the left part:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addl a (<span class="dt">Deep</span> pr m sf) <span class="fu">=</span> <span class="dt">Deep</span> ([a] <span class="fu">++</span> pr) m sf</code></pre>
<p>The number of maximum elements in our left and right part of trees are arbitrary. When we come to Clojure’s persistent vector implementation, we’ll see that it could be 32, depending on your needs.</p>
<p>We can easily track our structure when creating a tree of “thisisnotatree”:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Empty</span>
<span class="dt">Single</span> <span class="ch">&#39;e&#39;</span>
<span class="dt">Deep</span> [<span class="ch">&#39;e&#39;</span>] <span class="dt">Empty</span> [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;r&#39;</span>, <span class="ch">&#39;e&#39;</span>] <span class="dt">Empty</span> [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;t&#39;</span>, <span class="ch">&#39;r&#39;</span>, <span class="ch">&#39;e&#39;</span>] <span class="dt">Empty</span> [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;t&#39;</span>, <span class="ch">&#39;r&#39;</span>, <span class="ch">&#39;e&#39;</span>] <span class="dt">Empty</span> [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;t&#39;</span>, <span class="ch">&#39;a&#39;</span>] (<span class="dt">Single</span> (<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;o&#39;</span>, <span class="ch">&#39;t&#39;</span>, <span class="ch">&#39;a&#39;</span>] (<span class="dt">Single</span> (<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;n&#39;</span>, <span class="ch">&#39;o&#39;</span>, <span class="ch">&#39;t&#39;</span>, <span class="ch">&#39;a&#39;</span>] (<span class="dt">Single</span> (<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;s&#39;</span>, <span class="ch">&#39;n&#39;</span>] (<span class="dt">Deep</span> [(<span class="dt">Node3</span> <span class="ch">&#39;o&#39;</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;a&#39;</span>)] <span class="dt">Empty</span> [(<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)]) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;i&#39;</span> ,<span class="ch">&#39;s&#39;</span>, <span class="ch">&#39;n&#39;</span>] (<span class="dt">Deep</span> [(<span class="dt">Node3</span> <span class="ch">&#39;o&#39;</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;a&#39;</span>)] <span class="dt">Empty</span> [(<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)]) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;s&#39;</span>, <span class="ch">&#39;i&#39;</span> ,<span class="ch">&#39;s&#39;</span>, <span class="ch">&#39;n&#39;</span>] (<span class="dt">Deep</span> [(<span class="dt">Node3</span> <span class="ch">&#39;o&#39;</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;a&#39;</span>)] <span class="dt">Empty</span> [(<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)]) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;i&#39;</span>, <span class="ch">&#39;s&#39;</span>] (<span class="dt">Deep</span> [(<span class="dt">Node3</span> <span class="ch">&#39;i&#39;</span> <span class="ch">&#39;s&#39;</span> <span class="ch">&#39;n&#39;</span>), (<span class="dt">Node3</span> <span class="ch">&#39;o&#39;</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;a&#39;</span>)] <span class="dt">Empty</span> [(<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)]) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;h&#39;</span>, <span class="ch">&#39;i&#39;</span>, <span class="ch">&#39;s&#39;</span>] (<span class="dt">Deep</span> [(<span class="dt">Node3</span> <span class="ch">&#39;i&#39;</span> <span class="ch">&#39;s&#39;</span> <span class="ch">&#39;n&#39;</span>), (<span class="dt">Node3</span> <span class="ch">&#39;o&#39;</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;a&#39;</span>)] <span class="dt">Empty</span> [(<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)]) [<span class="ch">&#39;e&#39;</span>]
<span class="dt">Deep</span> [<span class="ch">&#39;t&#39;</span>, <span class="ch">&#39;h&#39;</span>, <span class="ch">&#39;i&#39;</span>, <span class="ch">&#39;s&#39;</span>] (<span class="dt">Deep</span> [(<span class="dt">Node3</span> <span class="ch">&#39;i&#39;</span> <span class="ch">&#39;s&#39;</span> <span class="ch">&#39;n&#39;</span>), (<span class="dt">Node3</span> <span class="ch">&#39;o&#39;</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;a&#39;</span>)] <span class="dt">Empty</span> [(<span class="dt">Node3</span> <span class="ch">&#39;t&#39;</span> <span class="ch">&#39;r&#39;</span> <span class="ch">&#39;e&#39;</span>)]) [<span class="ch">&#39;e&#39;</span>]</code></pre>
<p>When I first saw the definition of <code>FingerTree</code> in the paper, I had no idea what was this all about, and tracing the structure while adding characters one by one helped me a lot. Notice that we have only one element in the right part. This is because we made all changes to the left part of the structure so right part remained unchanged.</p>
<p><code>push_right</code> is just the mirror of <code>push_left</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addr ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a
addr <span class="dt">Empty</span> a                 <span class="fu">=</span> <span class="dt">Single</span> a
addr (<span class="dt">Single</span> b) a            <span class="fu">=</span> <span class="dt">Deep</span> [b] <span class="dt">Empty</span> [a]
addr (<span class="dt">Deep</span> pr m [e,b,c,d]) a <span class="fu">=</span> <span class="dt">Deep</span> pr (addr m (<span class="dt">Node3</span> e d c)) [b,a]
addr (<span class="dt">Deep</span> pr m sf) a        <span class="fu">=</span> <span class="dt">Deep</span> pr m (sf <span class="fu">++</span> [a])</code></pre>
<p>So, the structure of FingerTree’s and add operations should be clear now. To create FingerTrees from other collections, we need <code>fold</code> operations:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Foldable</span> <span class="dt">Node</span> <span class="kw">where</span>
  <span class="fu">foldr</span> f z (<span class="dt">Node2</span> a b) <span class="fu">=</span> a <span class="ot">`f`</span> (b <span class="ot">`f`</span> z)
  <span class="fu">foldr</span> f z (<span class="dt">Node3</span> a b c) <span class="fu">=</span> a <span class="ot">`f`</span> (b <span class="ot">`f`</span> (c <span class="ot">`f`</span> z))
  <span class="fu">foldl</span> f z (<span class="dt">Node2</span> a b) <span class="fu">=</span> (z <span class="ot">`f`</span> a) <span class="ot">`f`</span> b
  <span class="fu">foldl</span> f z (<span class="dt">Node3</span> a b c) <span class="fu">=</span> ((z <span class="ot">`f`</span> a) <span class="ot">`f`</span> b) <span class="ot">`f`</span> c
<span class="kw">instance</span> <span class="kw">Foldable</span> <span class="dt">FingerTree</span> <span class="kw">where</span>
  <span class="fu">foldr</span> _ z <span class="dt">Empty</span> <span class="fu">=</span> z
  <span class="fu">foldr</span> f z (<span class="dt">Single</span> x) <span class="fu">=</span> x <span class="ot">`f`</span> z
  <span class="fu">foldr</span> f z (<span class="dt">Deep</span> pr m sf) <span class="fu">=</span>
    <span class="fu">foldr</span> f (<span class="fu">foldr</span> (<span class="fu">flip</span> (<span class="fu">foldr</span> f)) (<span class="fu">foldr</span> f z sf) m) pr
  <span class="fu">foldl</span> _ z <span class="dt">Empty</span> <span class="fu">=</span> z
  <span class="fu">foldl</span> f z (<span class="dt">Single</span> x) <span class="fu">=</span> z <span class="ot">`f`</span> x
  <span class="fu">foldl</span> f z (<span class="dt">Deep</span> pr m sf) <span class="fu">=</span>
    <span class="fu">foldl</span> f (<span class="fu">foldl</span> (<span class="fu">foldl</span> f) (<span class="fu">foldl</span> f z pr) m) sf</code></pre>
<p><code>Foldable</code> typeclass is in <code>Data.Foldable</code> package. Only part that is not so trivial in this definitions is folding over a <code>Deep</code> structure. When we <code>foldr</code> over a <code>Deep</code> structure, we first <code>foldr</code> over it’s right part(<code>sf</code>), then <code>foldr</code> it over it’s subtree part, and then <code>foldr</code> it to right part. I don’t know how can I explain it more but if you inspect functions a little bit you’ll see that it’s just a recursive fold operation, and it really makes sense.</p>
<p>With help of this fold functions, we define some helpers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addl&#39; ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a
addl&#39; <span class="fu">=</span> <span class="fu">flip</span> <span class="fu">$</span> <span class="fu">foldr</span> addl
<span class="ot">addr&#39; ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a
addr&#39; <span class="fu">=</span> <span class="fu">flip</span> <span class="fu">$</span> <span class="fu">foldl</span> addr</code></pre>
<p>Those are not really necessary, just helpers. Now we can define a function to create FingerTrees from lists:</p>
<pre><code>toTree :: [a] -&gt; FingerTree a
toTree s = addl&#39; s Empty</code></pre>
<p>So now we can create FingerTree from a String with just <code>toTree &quot;thisisnotatree&quot; Empty</code>. From now on, we need some operations to pop each side of the <em>deque</em> . For this, authors of the original paper use a structure called <code>view</code>. I’m not sure if I’d do it the same way, but I’ll stick with the authors’ idea.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LeftView</span> s a <span class="fu">=</span> <span class="dt">LeftNil</span> <span class="fu">|</span> <span class="dt">LeftCons</span> a (s a)
  <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p>With this structure, we can easily create <code>first</code> and <code>tail</code> operations of FingerTree. But first we need to convert our FingerTrees to LeftView:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftView ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">LeftView</span> <span class="dt">FingerTree</span> a
leftView <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">LeftNil</span>
leftView (<span class="dt">Single</span> x) <span class="fu">=</span> <span class="dt">LeftCons</span> x <span class="dt">Empty</span>
leftView (<span class="dt">Deep</span> pr m sf) <span class="fu">=</span> <span class="dt">LeftCons</span> (<span class="fu">head</span> pr) (leftDeep (<span class="fu">tail</span> pr) m sf)</code></pre>
<p>This code is trivial other than the last part. It just splits our structure to <code>head</code> and <code>tail</code>. With this, we can work on finger trees just like we work on any list. In the last case, we are calling <code>leftDeep</code> on tail of the left part, this is because we don’t want our <code>tail</code> tree’s left part to be empty. So if we call <code>tail</code> with the tree with one element in it’s left part, we get a new tree, with a left part not empty:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftDeep ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> (<span class="dt">Node</span> a) <span class="ot">-&gt;</span> <span class="dt">Digit</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a
leftDeep [] m sf <span class="fu">=</span> <span class="kw">case</span> leftView m <span class="kw">of</span>
                     <span class="dt">LeftNil</span>       <span class="ot">-&gt;</span> toTree sf
                     <span class="dt">LeftCons</span> a m&#39; <span class="ot">-&gt;</span> <span class="dt">Deep</span> (toList a) m&#39; sf
leftDeep pr m sf <span class="fu">=</span> <span class="dt">Deep</span> pr m sf</code></pre>
<p>With the help of this view functions, we can easily define <code>head</code>, <code>tail</code> and <code>isEmpty</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isEmpty ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEmpty x <span class="fu">=</span> <span class="kw">case</span> leftView x <span class="kw">of</span>
              <span class="dt">LeftNil</span>      <span class="ot">-&gt;</span> <span class="kw">True</span>
              <span class="dt">LeftCons</span> _ _ <span class="ot">-&gt;</span> <span class="kw">False</span>
<span class="ot">leftHead ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> a
leftHead x <span class="fu">=</span> <span class="kw">case</span> leftView x <span class="kw">of</span> <span class="dt">LeftCons</span> a _ <span class="ot">-&gt;</span> a
<span class="ot">leftTail ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a
leftTail x <span class="fu">=</span> <span class="kw">case</span> leftView x <span class="kw">of</span> <span class="dt">LeftCons</span> _ x&#39; <span class="ot">-&gt;</span> x&#39;</code></pre>
<p>And that’s it. I’m omitting definitions of <code>rightHead</code>, <code>rightTail</code> and right view functions because they’re just mirrors of lefts. Now let’s talk about efficiency. I’m not experienced in that stuff so don’t expect a detailed explanation :) .</p>
<p>Since Haskell is a lazy language, when we call head function on left or right views, we only create head part of the view structures. <em>Deque</em> operations take more than constant time only when we have 4 elements in the left/right part of the tree. Also, changes affect next level of the tree only when we have 4 elements in the subtree’s left/right part. Which means, at most half of the operations descend to second level, and at most quarter of the operations descent to the third level. All of this gives us a great <em>deque</em> structure implemented as a FingerTree. You can refer to the paper for some detailed analysis :) .</p>
<p>BTW, Haskell’s <code>Data.Sequence</code> is just a FingerTree, implemented by the paper’s authors. Next, we’ll implement a priority queue based on ideas explained in this post. I’ll also talk about monoids.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Digit name here used for compatibility with the paper.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
