<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2015-05-17T00:00:00Z</updated>
    <entry>
    <title>Staging is not just code generation</title>
    <link href="http://osa1.net/posts/2015-05-17-staging-is-not-just-codegen.html" />
    <id>http://osa1.net/posts/2015-05-17-staging-is-not-just-codegen.html</id>
    <published>2015-05-17T00:00:00Z</published>
    <updated>2015-05-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="section"></h1>
<p>It feels weird to see that even <a href="http://okmij.org/ftp/">Oleg</a> seems to <a href="http://lambda-the-ultimate.org/node/5146#comment-85570">think about it that way</a>.</p>
<p>Sure, we don’t have a definition of the term that’s supposed to be accepted by everyone, and one can use it in different meanings. My minimal definition for the term is “a technique for runtime code generation and linking”. If it’s missing “linking” part, then to me it’s just another AST definition + printer library(sometimes it’s embedded into the language to add some convenience syntactic sugar and/or quasiquotation to the language).</p>
<p>To me the whole point is “runtime specialization”. For that you should be able to use the runtime data that’s available when you’re generating the code in the generated code<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. This is called “cross-stage persistence”. In a simple multi-stage language, this may be supported simply by serializing data as code, but this is not as flexible as one might need for runtime optimized code generation. For example, you can’t serialize a socket or file handle this way, but it’s safe and possible to use a socket or file handle that’s available while generating the code in the generated code. You can’t easily do that if the staging library/language doesn’t provide this as a feature.</p>
<p>In the case of <a href="http://okmij.org/ftp/ML/MetaOCaml.html">BER-MetaOCaml</a>, I think this is one of the major limitations without any workarounds: It only supports OCaml bytecode. Printing the code and compiling manually is not a solution for the reason I just described.</p>
<p>One more thing about printing the code: In my opinion, a multi-stage language should provide a way to print generated code <em>only for debugging purposes</em>. (e.g. To see if I’m really generating the code I want)<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>I should make this clear that it’s completely fine to use it for code generation, what I’m trying to say is that if all it can do is code generation then it’s missing the point.</p>
<p>As an example, I used staging for code generation <a href="http://osa1.net/posts/2015-05-13-comp-through-interp.html">in my last project</a>, and it seems like <a href="http://scala-lms.github.io/">Scala LMS</a> people do this a lot too<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In a sense this is like a closure, generated code should be able to refer to names in enclosing environment of code generator.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>I’m wondering if <a href="http://terralang.org/">Terra</a> has a way to print generated code. Any ideas?<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>I didn’t read the paper very carefully, but I think one example is <a href="http://dl.acm.org/citation.cfm?id=2429128">Optimizing Data Structures in High-Level Programs</a> paper which is published in POPL ’13.<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Simplest pathological program for supercompilers</title>
    <link href="http://osa1.net/posts/2015-05-16-simplest-pathological-pgm-for-supercompilers.html" />
    <id>http://osa1.net/posts/2015-05-16-simplest-pathological-pgm-for-supercompilers.html</id>
    <published>2015-05-16T00:00:00Z</published>
    <updated>2015-05-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working on one of my program transformation ideas, I’ve found a very simple program that is apparently pathological for most supercompilers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">loop x <span class="fu">=</span> loop (x <span class="fu">+</span> <span class="dv">1</span>)</code></pre>
<p>I tried this program on several supercompilers:</p>
<ul>
<li><p><a href="https://github.com/ilya-klyuchnikov/sc-mini">sc-mini</a><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>: It unfolds arbitrarily and generates this program:</p>
<pre><code>f1(v1) = f1(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(
              S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(
                S(S(S(S(S(v1))))))))))))))))))))))))))))))))))))))));</code></pre></li>
<li><p><a href="https://github.com/ndmitchell/supero">supero</a>: It just loops:</p>
<pre><code>➜  supero4 git:(master) ✗ ../.cabal-sandbox/bin/supero --compile ../example/Example1.hs
files: [&quot;../example/Example1.hs&quot;]
Converting ../example/Example1.hs
{-# LANGUAGE UnboxedTuples, NoMonomorphismRestriction #-}
module ...example.Example1_gen(test) where
define: _1 = (:) (loop 1) []
peel: (:) (loop 1) []
define: _2 = loop 1
^C
➜  supero4 git:(master) ✗</code></pre></li>
<li><p><a href="https://github.com/batterseapower/supercompilation-by-evaluation">supercompilation-by-evaluation</a>: Similar to sc-mini, it unfolds for a while and generates this:</p>
<pre><code>let
  h0 = let
         root_u15 = loop_u17 a_u51
         loop_u17 = h1
         a_u51 = h5
       in root_u15
  h1 = \i_u55 -&gt; h2 i_u55
  h2 = \i_u55 -&gt; let
                   loop_u17 = h1
                   a_u60 = h3 i_u55
                 in loop_u17 a_u60
  h3 = \i_u55 -&gt; let a_u57 = (+) i_u55 h4
                 in (+) a_u57 h4
  h4 = 1 :: Int
  h5 = 4 :: Int
in h0</code></pre></li>
</ul>
<p>In the ideal case a supercompiler would just generate same program, without making any changes.</p>
<p>There’s one supercompiler that I couldn’t try: <a href="https://github.com/batterseapower/chsc">chsc</a>(The Cambridge Haskell Supercompiler). I wasted a lot of time trying to make it working, but I failed. If you’re able to run it, please post the results in comments section below.</p>
<p>If you know any other supercompilers that I can test, please tell me about those too.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This supercompiler comes with <a href="https://themonadreader.files.wordpress.com/2014/04/super-final.pdf">this paper</a>. I highly recommend the paper if you’re interested in supercompilation.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Compilation through interpretation, a small experiment</title>
    <link href="http://osa1.net/posts/2015-05-13-comp-through-interp.html" />
    <id>http://osa1.net/posts/2015-05-13-comp-through-interp.html</id>
    <published>2015-05-13T00:00:00Z</published>
    <updated>2015-05-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been studying different program transformation techniques recently, and to me <a href="http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html">Futamura projections</a> are one of the most interesting applications of program transformations. Couple of days ago I finished a small project in which I implemented first Futamura projection(aka. interpreter specialization) using <a href="http://www.madore.org/~david/programs/unlambda/">Unlambda</a> as object language. You can see the project <a href="https://github.com/osa1/int-proj">here</a>. I tried to write some comments to the source when I get stuck because of a problem or realized something interesting, so I suggest reading the source if you’re interested.</p>
<p>I did two implementations and used a different meta language for each one. There are multiple ways to achieve first Futamura projections: We can use a partial evaluator, a supercompiler(which may actually subsume partial evaluation, depending on how sophisticated it is), or just a “sufficiently smart” compiler. The problem though, we don’t have a lot of(read: any) usable implementations of partial evaluators or supercompilers, so I had to use the only language with a partial evaluator that I could find: <a href="https://github.com/idris-lang/Idris-dev">Idris</a><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>There’s one another technique that we can use. The techniques I listed above are all completely automated. If things don’t go as expected we’re on our own to figure out why is that and hack around to make the tool transform the program the way we want. Indeed this is happened even in this project, which is deliberately kept simple and small<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<p>At the other end of the spectrum is multi-stage programming. In multi-stage programming the programmer specifies, using some annotations<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, what code to generate and how to generate it. It clearly separates code that runs in code generation time and generated code. When generated code is printed to be compiled later, multi-stage programming feels like a compiler or a partial evaluator that the programmer can guide to generate the code he/she wants.</p>
<p>My second meta language is <a href="http://okmij.org/ftp/ML/MetaOCaml.html">MetaOCaml</a>, which is basically OCaml with multi-stage programming constructs. Using these two languages as representatives of two different program generation techniques, I implemented first Futamura projections for Unlambda.</p>
<p>There’s a report file in the repository, and I refer interesting readers to that document. README file contains compilation directives and some interesting executions. One interesting thing is that I later added a simple partial evaluator to MetaOCaml implementation, and in the <code>programs/</code> directory there’s an Unlambda interpreter, written in Unlambda. Using these two programs, you can do things like partially applying(specializing) Unlambda interpreter to other programs or even itself. Before every experiment, I suggest thinking about what is the generated code you’re expecting(what does it do). What would a “sufficiently smart” partial evaluator generate? What would a simple partial evaluator generate? Similarly, try these while generating first projections.</p>
<p>Finally, if you’re interested in program transformations, stay tuned for more blog posts.</p>
<p><a href="https://github.com/osa1/int-proj">Link to the project.</a></p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is actually an <a href="https://github.com/annenkov/unmix">implementation of well-known partial evaluator unmix</a>. I knew about the project, but didn’t remember by the time I started this project. Still, I think I’d choose Idris even if I remembered.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Although some of those problems were implementation related, e.g. Idris was buggy. See the source code for comments and Github issues.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>In MetaOCaml case those annotations are term-level, but there are other cases where annotations happen in type level only. See <a href="http://scala-lms.github.io/">LMS</a> as an example. (I think it’s the only example for now)<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Some benchmarks for meta-tracing BF JIT and traditional BF implementations</title>
    <link href="http://osa1.net/posts/2015-04-11-some-bf-benchmarks.html" />
    <id>http://osa1.net/posts/2015-04-11-some-bf-benchmarks.html</id>
    <published>2015-01-29T00:00:00Z</published>
    <updated>2015-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I found RPython very interesting for several reasons which I may be talking about later, and I need to use it for a project, so I started running some tutorials. However, I had some concerns about the idea(I still have, and I’ll defer the discussion to some other post for now), and I wanted to experiment with different implementations of same interpreter and compare results.</p>
<p>What I wanted to see is, given a very good and mature JIT compiler(LuaJIT in this case), how hard would it be to have similar optimizations without annotating code manually to give hints to the JIT compiler.</p>
<p>So I implemented a simple BF interpreter in Lua, and started experimenting with different optimizations. As for benchmarking, I used <code>bench</code> program from this <a href="https://bitbucket.org/brownan/pypy-tutorial/">RPython tutorial repository</a>.</p>
<p>Before diving into Lua implementation, here results of running them with RPython compiled interpreter, Python and PyPy:</p>
<pre><code>./example5-rpython bench.b    0.94s user 0.00s system 99% cpu 0.947 total
pypy example5.py   bench.b   15.57s user 0.01s system 99% cpu 15.597 total
python example5.py bench.b  597.34s user 0.04s system 99% cpu 9:57.87 total</code></pre>
<p>The Lua implementation started with this:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> mainloop<span class="ot">(</span>program<span class="ot">,</span> bracket_map<span class="ot">,</span> dispatch_fn<span class="ot">)</span>
    <span class="kw">local</span> pc <span class="ot">=</span> <span class="dv">1</span>
    <span class="kw">local</span> tape <span class="ot">=</span> <span class="ot">{</span><span class="dv">0</span><span class="ot">}</span>
    <span class="kw">local</span> tape_pos <span class="ot">=</span> <span class="dv">1</span>

    <span class="kw">local</span> code
    <span class="kw">while</span> pc <span class="ot">&lt;=</span> <span class="ot">#</span>program <span class="kw">do</span>
        code <span class="ot">=</span> program<span class="ot">[</span>pc<span class="ot">]</span>
        <span class="kw">if</span> code <span class="ot">==</span> <span class="st">&quot;&gt;&quot;</span> <span class="kw">then</span>
            tape_pos <span class="ot">=</span> tape_pos <span class="ot">+</span> <span class="dv">1</span>
            <span class="kw">if</span> <span class="ot">#</span>tape <span class="ot">&lt;</span> tape_pos <span class="kw">then</span>
                <span class="fu">table.insert</span><span class="ot">(</span>tape<span class="ot">,</span> <span class="dv">0</span><span class="ot">)</span>
            <span class="kw">end</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;&lt;&quot;</span> <span class="kw">then</span>
            tape_pos <span class="ot">=</span> tape_pos <span class="ot">-</span> <span class="dv">1</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;+&quot;</span> <span class="kw">then</span>
            tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">=</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;-&quot;</span> <span class="kw">then</span>
            tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">=</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">-</span> <span class="dv">1</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;.&quot;</span> <span class="kw">then</span>
            <span class="fu">io.write</span><span class="ot">(</span><span class="fu">string.char</span><span class="ot">(</span>tape<span class="ot">[</span>tape_pos<span class="ot">]))</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;[&quot;</span> <span class="kw">and</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">==</span> <span class="dv">0</span> <span class="kw">then</span>
            pc <span class="ot">=</span> bracket_map<span class="ot">[</span>pc<span class="ot">]</span>
        <span class="kw">elseif</span> code <span class="ot">==</span> <span class="st">&quot;]&quot;</span> <span class="kw">and</span> tape<span class="ot">[</span>tape_pos<span class="ot">]</span> <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">then</span>
            pc <span class="ot">=</span> bracket_map<span class="ot">[</span>pc<span class="ot">]</span>
        <span class="kw">end</span>
        pc <span class="ot">=</span> pc <span class="ot">+</span> <span class="dv">1</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>I’m not sure how many reasonable different implementations one can come up with, given that the language is this small. Still, there are some optimizations that we can do and I’ve tried some of them. Here are some things I tried:</p>
<ul>
<li>I tried replacing one character strings with ASCII code equivalents. Since Lua doesn’t have character constants, I thought this may give us a few instructions per branch. But results were just the same.</li>
<li>I tried replacing table getters and setters with <code>rawget</code> and <code>rawset</code>s. Nothing changed. Apparently it’s not worth the effort unless you have a metatable for your table.</li>
<li><p>I tried generating a huge “if-then-else” statement for <code>bracket_map</code>, and used it as a jump table kind of thing. Here’s the code:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> gen_dispatch_fn<span class="ot">(</span>bracket_map<span class="ot">,</span> fun_name<span class="ot">)</span>
    <span class="kw">local</span> first <span class="ot">=</span> <span class="kw">true</span>
    <span class="kw">local</span> acc <span class="ot">=</span> <span class="ot">{}</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;function &quot;</span> <span class="ot">..</span> fun_name <span class="ot">..</span> <span class="st">&quot;(arg)</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="kw">for</span> k<span class="ot">,</span>v <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">(</span>bracket_map<span class="ot">)</span> <span class="kw">do</span>
        <span class="kw">if</span> first <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    if arg == &quot;</span> <span class="ot">..</span> k <span class="ot">..</span> <span class="st">&quot; then</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
            first <span class="ot">=</span> <span class="kw">false</span>
        <span class="kw">else</span>
            <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    elseif arg == &quot;</span> <span class="ot">..</span> k <span class="ot">..</span> <span class="st">&quot; then</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
        <span class="kw">end</span>
        <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;        return &quot;</span> <span class="ot">..</span> v <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    else</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;        error(</span><span class="ot">\&quot;</span><span class="st">invalid arg: </span><span class="ot">\&quot;</span><span class="st"> .. arg)</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;    end</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="fu">table.insert</span><span class="ot">(</span>acc<span class="ot">,</span> <span class="st">&quot;end</span><span class="ot">\n</span><span class="st">&quot;</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="fu">table.concat</span><span class="ot">(</span>acc<span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>I loaded this code using standard <code>load()</code> function. This also didn’t work. The reason is that, even if this is faster(which is probably not always the case), profiling showed that interpreter spents only 4% of the time for <code>bracket_map</code> lookups. So if this implementation only slightly faster, it just can’t make a big difference.</p></li>
</ul>
<p>Profiling output revealed that, 85% of the time spent on fetching the next instruction:</p>
<pre><code>@@ 69 @@
      |
      |     local code
      |     while pc &lt;= #program do
  85% |         code = program[pc]
      |         if code == 62 then
      |             tape_pos = tape_pos + 1
      |             if #tape &lt; tape_pos then
@@ 89 @@
      |             pc = bracket_map[pc]
      |         elseif code == 93 and tape[tape_pos] ~= 0 then
   4% |             pc = bracket_map[pc]
      |         end
      |         pc = pc + 1</code></pre>
<p>Which really means that you can’t optimize anything, because there’s nothing optimizable in <code>code = program[pc]</code>, since this is one of the most primitive operations that you can do in this language. (note that we don’t have metamethod assigned to this table, so <code>rawget</code> is not an optimization)</p>
<p>At this point the Lua results were like this:</p>
<pre><code>luajit example_lua.lua bench.b  34.41s user 0.00s system 99% cpu 34.442 total</code></pre>
<p>The fact that PyPy did better job than LuaJIT here is surprising and impressive. It seems like RPython and PyPy is doing a very good job here.</p>
<p>Since I already started gradually compiling things, I thought why not go further and compile everything. Here’s a simple BF to Lua compiler:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> compile<span class="ot">(</span>str<span class="ot">)</span>
    <span class="kw">local</span> pgm <span class="ot">=</span> <span class="ot">{}</span>
    <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> <span class="st">[[</span>
<span class="st">function pgm()</span>
<span class="st">    local tape = {0}</span>
<span class="st">    local tape_pos = 1</span>
<span class="st">]]</span><span class="ot">)</span>

    <span class="kw">local</span> adv <span class="ot">=</span> <span class="st">[[</span>
<span class="st">    tape_pos = tape_pos + 1</span>
<span class="st">    if #tape &lt; tape_pos then</span>
<span class="st">        table.insert(tape, 0)</span>
<span class="st">    end</span>
<span class="st">]]</span>
    <span class="kw">local</span> <span class="kw">function</span> dev<span class="ot">(</span>i<span class="ot">)</span> <span class="kw">return</span> <span class="st">&quot;    tape_pos = tape_pos - &quot;</span> <span class="ot">..</span> i <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span> <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> inc<span class="ot">(</span>i<span class="ot">)</span> <span class="kw">return</span> <span class="st">&quot;    tape[tape_pos] = tape[tape_pos] + &quot;</span> <span class="ot">..</span> i <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span> <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> dec<span class="ot">(</span>i<span class="ot">)</span> <span class="kw">return</span> <span class="st">&quot;    tape[tape_pos] = tape[tape_pos] - &quot;</span> <span class="ot">..</span> i <span class="ot">..</span> <span class="st">&quot;</span><span class="ot">\n</span><span class="st">&quot;</span> <span class="kw">end</span>
    <span class="kw">local</span> out  <span class="ot">=</span> <span class="st">&quot;    io.write(string.char(tape[tape_pos]))</span><span class="ot">\n</span><span class="st">&quot;</span>
    <span class="kw">local</span> inp  <span class="ot">=</span> <span class="st">&quot;&quot;</span> <span class="co">-- no need for this</span>
    <span class="kw">local</span> jmpF <span class="ot">=</span> <span class="st">&quot;    while tape[tape_pos] ~= 0 do</span><span class="ot">\n</span><span class="st">&quot;</span>
    <span class="kw">local</span> jmpB <span class="ot">=</span> <span class="st">&quot;    if tape[tape_pos] == 0 then break end end</span><span class="ot">\n</span><span class="st">&quot;</span>

    <span class="co">-- these are used to combine consecutive same instructions</span>
    <span class="kw">local</span> devs <span class="ot">=</span> <span class="dv">0</span>
    <span class="kw">local</span> incs <span class="ot">=</span> <span class="dv">0</span>
    <span class="kw">local</span> decs <span class="ot">=</span> <span class="dv">0</span>

    <span class="kw">local</span> indent <span class="ot">=</span> <span class="dv">0</span><span class="ot">;</span>

    <span class="kw">for</span> i<span class="ot">=</span><span class="dv">1</span><span class="ot">,</span> <span class="ot">#</span>str <span class="kw">do</span>
        <span class="kw">local</span> char <span class="ot">=</span> <span class="fu">string.char</span><span class="ot">(</span><span class="fu">string.byte</span><span class="ot">(</span>str<span class="ot">,</span> i<span class="ot">))</span>

        <span class="kw">if</span> devs <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">and</span> char <span class="ot">~=</span> <span class="st">&quot;&lt;&quot;</span> <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> dev<span class="ot">(</span>devs<span class="ot">)))</span>
            devs <span class="ot">=</span> <span class="dv">0</span>
        <span class="kw">elseif</span> incs <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">and</span> char <span class="ot">~=</span> <span class="st">&quot;+&quot;</span> <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> inc<span class="ot">(</span>incs<span class="ot">)))</span>
            incs <span class="ot">=</span> <span class="dv">0</span>
        <span class="kw">elseif</span> decs <span class="ot">~=</span> <span class="dv">0</span> <span class="kw">and</span> char <span class="ot">~=</span> <span class="st">&quot;-&quot;</span> <span class="kw">then</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> dec<span class="ot">(</span>decs<span class="ot">)))</span>
            decs <span class="ot">=</span> <span class="dv">0</span>
        <span class="kw">end</span>

        <span class="kw">if</span> char <span class="ot">==</span> <span class="st">&quot;&gt;&quot;</span> <span class="kw">then</span> <span class="co">-- 62</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> adv<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;&lt;&quot;</span> <span class="kw">then</span> <span class="co">-- 60</span>
            devs <span class="ot">=</span> devs <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;+&quot;</span> <span class="kw">then</span> <span class="co">-- 43</span>
            incs <span class="ot">=</span> incs <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;-&quot;</span> <span class="kw">then</span> <span class="co">-- 45</span>
            decs <span class="ot">=</span> decs <span class="ot">+</span> <span class="dv">1</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;.&quot;</span> <span class="kw">then</span> <span class="co">-- 46</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> out<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;,&quot;</span> <span class="kw">then</span> <span class="co">-- 44</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> inp<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;[&quot;</span> <span class="kw">then</span> <span class="co">-- 91</span>
            indent <span class="ot">=</span> indent <span class="ot">+</span> <span class="dv">4</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> jmpF<span class="ot">))</span>
        <span class="kw">elseif</span> char <span class="ot">==</span> <span class="st">&quot;]&quot;</span> <span class="kw">then</span> <span class="co">-- 93</span>
            indent <span class="ot">=</span> indent <span class="ot">-</span> <span class="dv">4</span>
            <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> indent_lines<span class="ot">(</span>indent<span class="ot">,</span> jmpB<span class="ot">))</span>
        <span class="kw">end</span>
    <span class="kw">end</span>

    <span class="fu">table.insert</span><span class="ot">(</span>pgm<span class="ot">,</span> <span class="st">&quot;end&quot;</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="fu">table.concat</span><span class="ot">(</span>pgm<span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>One thing to note here is that loops in BF programs correspond to loops in generated Lua. There’s another way to implement this compiler and it might turn out to be more efficient, but I didn’t try it. (see BF-to-C compiler below) Also, I’m merging some instructions together. This has significant performance impact, but it’s also necessary because if the generated code is too big, both PUC-Lua and LuaJIT is rejecting to load it. (this is documented, but the limit is not specified)</p>
<p>Results:</p>
<pre><code>luajit example_lua.lua bench.b  0.53s user 0.00s system 99% cpu 0.532 total</code></pre>
<p>Note that runtime code generation and loading is NOT included in this number, but code generation takes less than 0.01s, so I might just include that.</p>
<p>Just for completeness, I also tried a <a href="https://github.com/kgabis/brainfuck-c/blob/master/brainfuck.c">C interpreter</a>, and <a href="http://awk.info/?doc/bfc.html">BF-to-C</a> compiler:</p>
<pre><code>./c-int bench.b  2.44s user 0.00s system 99% cpu 2.443 total
./c-compiled     0.00s user 0.00s system 82% cpu 0.004 total</code></pre>
<p>A fun thing about C compiler is that compiling generated C programs takes long time:</p>
<pre><code>gcc -O3 awk_output.c  14.07s user 0.14s system 99% cpu 14.219 total</code></pre>
<p>RPython once again does an impressive job here, because it’s even faster than C interpreter. I didn’t bother profiling C code and optimizing it, because it looks like a reasonable implementation: A simple “fetch instruction and run it in a case statement” loop.</p>
<p>So I think the conclusion is that RPython and PyPy are doing really good job.</p>]]></summary>
</entry>
<entry>
    <title>Top-down expression parsing is easy</title>
    <link href="http://osa1.net/posts/2015-01-29-top-down-expr-parsing-easy.html" />
    <id>http://osa1.net/posts/2015-01-29-top-down-expr-parsing-easy.html</id>
    <published>2015-01-29T00:00:00Z</published>
    <updated>2015-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently fixed <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>’s 2-years-old expression parsing bug. Previously it was using <a href="http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Expr.html">Parsec’s expression parser</a>, which is actually horrible because it can’t handle chained unary operators.</p>
<p>Two weeks ago I decided to take a look into Lua’s original implementation, and in about an hour or so the algorithm was crystal clear to me. I immediately <a href="https://github.com/osa1/language-lua/commit/b4bebe36e927dcc671dbe6dd19572b83073dc556#diff-630bbd2d118baf109da6ad79d3f168bfR257">implemented it</a> and closed the <a href="https://github.com/osa1/language-lua/issues/2">2-years-old bug report</a>.</p>
<p>This implementation is essentially a port of Lua’s expression parser. Recently I thought about the algorithm and I was wondering if this has a name – the algorithm looked pretty obvious to me once I understand and given how much we know about parsing I thought this should have a name.</p>
<p>I found <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing">this algorithm named “precedence climbing”</a>. This is almost the same algorithm, only difference is that instead of using <code>lookahead</code> I’m just consuming the binary operator and returning it to the caller(which is parsing an expression with lower precedence than current parser) if precedence is lower. Associativity handling is also different(I use different left and right precedences to handle associativity) but the idea is really the same.</p>
<p>Now, there is also another algorithm called Pratt, and I can’t read the original paper(paywall), but according to <a href="http://lambda-the-ultimate.org/node/3682">this LtU discussion</a> it should also be similar. Indeed, <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">this explanation of it</a> looks pretty similar, and <a href="http://stackoverflow.com/a/13637731/691032">this StackOverflow answer</a> says that Lua’s implementation is “Pratt style parsing”.</p>
<p>So it seems like we have two, or maybe one since they’re actually very similar, solution(s) to solve top-down expression parsing problem and Haskell implementation using Parsec is possible in only 12 lines of code.</p>
<h1 id="a-challenge">A challenge</h1>
<p>One challenge might be to modify Parsec’s expression parser so that internally it generates a Pratt/precedence climbing parser. I’m hoping to spare some time to work on this.</p>]]></summary>
</entry>
<entry>
    <title>Loading dynamic Haskell libs in Lua</title>
    <link href="http://osa1.net/posts/2015-01-16-haskell-so-lua.html" />
    <id>http://osa1.net/posts/2015-01-16-haskell-so-lua.html</id>
    <published>2015-01-16T00:00:00Z</published>
    <updated>2015-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Last year I wrote <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">a blog post</a> in which I explained how to call Lua from Haskell and Haskell from Lua using <a href="http://hackage.haskell.org/package/hslua">hslua</a> library. At the end of that blog post I mentioned that it should be possible to compile Haskell code to shared library and load that in Lua.</p>
<p>Today a friend in our research group <a href="https://github.com/iu-parfunc">parfunc</a> asked a question about compiling Haskell to shared libraries and loading generated libraries in other programs and I thought while I’m at it I can just update my blog post as well. So in this post I’m going to explain how to compile Haskell functions to shared libraries and load them in Lua.</p>
<p>Before diving into the code, a few remarks:</p>
<ul>
<li>All the code in this blog post is tried on Linux, with Lua 5.1 and latest LuaJIT.</li>
<li>To be able to load our function in Lua and register it, our functions should have C linkage and <a href="http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><code>lua_CFunction</code></a> type. We can either write Haskell functions directly using this type, or write C wrapper functions around our Haskell functions to be able to use them in Lua. In this post I’m going to do first one.</li>
<li>We’ll need some intermediate C code to expose some Haskell RTS functions to Lua, like <code>hs_init</code> to start Haskell runtime and <code>hs_exit</code> to stop it.</li>
<li>To be able to <code>require</code> our shared library in Lua, we need to implement a <code>int luaopen_&lt;ourlibrary&gt;(lua_State *L)</code> function. While in theory it should be possible to implement that function in Haskell, I’ll implement it in C in this post, because I’m not sure how to write Lua wrappers for <code>hs_init</code> and <code>hs_exit</code> in Haskell.</li>
<li>To keep the code as simple as possible, our Haskell function will be a very dumb addition function.</li>
</ul>
<p>Let’s start.</p>
<h1 id="defining-lua-function-in-haskell">Defining Lua function in Haskell</h1>
<p>This is exactly the same as before: We just define a function with type: <code>LuaState -&gt; IO Int</code>. To keep the code simple, we don’t do error handling at all.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">LibArith</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Scripting.Lua</span> <span class="co">-- this one from hslua</span>

foreign export ccall
<span class="ot">  add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="ot">add ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
add l <span class="fu">=</span> <span class="kw">do</span>
  i1 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">1</span>
  i2 <span class="ot">&lt;-</span> fromJust <span class="ot">`fmap`</span> peek l <span class="dv">2</span>
  pop l <span class="dv">2</span>
  push l (i1 <span class="fu">+</span><span class="ot"> i2 ::</span> <span class="dt">Int</span>)
  return <span class="dv">1</span></code></pre>
<h1 id="implementing-intermediate-c">Implementing intermediate C</h1>
<p>In our C glue code, we do two things:</p>
<ol style="list-style-type: decimal">
<li>Wrap <code>hs_init</code> and <code>hs_exit</code> Haskell runtime functions.</li>
<li>Implement Lua C module interface in which we register our functions to Lua. (see <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders">related docs</a> for details)</li>
</ol>
<p>Here’s the code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;LibArith_stub.h&quot;</span>
<span class="ot">#include &quot;lua.h&quot;</span>

<span class="dt">int</span> hs_init_lua(lua_State *L)
{
  hs_init(NULL, NULL);
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> hs_exit_lua(lua_State *L)
{
  hs_exit();
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> luaopen_lualibhelper(lua_State *L)
{
  lua_pushcfunction(L, add);
  lua_setglobal(L, <span class="st">&quot;add_in_haskell&quot;</span>);
  lua_pushcfunction(L, hs_init_lua);
  lua_setglobal(L, <span class="st">&quot;hs_init&quot;</span>);
  lua_pushcfunction(L, hs_exit_lua);
  lua_setglobal(L, <span class="st">&quot;hs_exit&quot;</span>);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Some things to note:</p>
<ul>
<li><code>LibArith_stub.h</code> is generated by GHC. I’ll explain how to compile and link next.</li>
<li>Our Haskell function actually has type <code>HsInt (*)(void *)</code>. While this is not what Lua API expected(it expects <code>int (*)(lua_State *L)</code>), in my x86_64 Linux machine this is working fine. In the worst case, you may need to wrap the Haskell function in C and convert the types using Haskell RTS C API and Lua C API.</li>
</ul>
<h1 id="compiling-and-linking">Compiling and linking</h1>
<p>This is the tricky part, I wasted a good 2 hours trying to figure how to compile to <code>.so</code> and link it with correct set of libraries.</p>
<p>First step is to compile <code>hslua</code> in a sandbox, or at least make it reachable by GHC(by installing globally, using nix environments etc.). I’ll be giving commands assuming that you’re in a sandbox that has <code>hslua</code> installed, if you’re not, then just replace <code>cabal exec ghc --</code> part with <code>ghc</code> and it should just work.</p>
<p>Step 1, compile and link the Haskell code to generate a shared library:</p>
<pre><code>$ cabal exec ghc -- LibArith.hs -shared -dynamic -fPIC -o libarith.so -lHSrts-ghc7.8.3</code></pre>
<p>Note that if you’re using a different version of GHC, you’ll need to modify the last argument to make it link it with corrent GHC RTS library.(alternatively, you can link with debug or profiling versions etc.)</p>
<p>Step 2, compile the Lua module written in C(the C code above) and link it with our shared Haskell library:</p>
<pre><code>$ cabal exec ghc -- libarithhelper.c -no-hs-main -optl -larith -o lualibhelper.so -shared -fPIC -dynamic</code></pre>
<p>Note that you may need to pass extra linker parameters if you have Lua library/headers in non-standard locations. If that’s the case, <code>-optl</code> argument of GHC is used to add linker arguments, just use standard linker arguments with that(<code>-L</code>, <code>-I</code> etc.).</p>
<p>This command should print a warning like this:</p>
<pre><code>/home/omer/opt/luajit_bin/include/luajit-2.0/lua.h:168:16:
     note: expected ‘lua_CFunction’ but argument is of type ‘HsInt (*)(void *)’
     LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);</code></pre>
<p>Like mentioned above, this doesn’t make any difference on my x86_64 Linux machine. If that’s being a problem on your system, just wrap your Haskell function in intermediate C code above using Haskell RTS API.</p>
<p>Now you should have two shared libraries, one for our Haskell code and one for the intermediate C code. One problem is that the shared library generated from C is now depending on the one generated from Haskell. So Haskell library should be in your <code>LD_LIBRARY_PATH</code>.</p>
<p>A good improvement here would be to compile Haskell code to static library, and generate one dynamic library only. (which has Haskell library statically linked to it)</p>
<h1 id="loading-the-code-in-lua">Loading the code in Lua</h1>
<p>Before loading it, make sure that the dynamic linker can really find the shared library generated from Haskell. Run this:</p>
<pre><code>$ ldd lualibhelper.so | grep &quot;not found&quot;</code></pre>
<p>Make sure it’s not printing anything.</p>
<p>Now just run Lua and enjoy the library:</p>
<pre><code>$ luajit-2.0.3
LuaJIT 2.0.3 -- Copyright (C) 2005-2014 Mike Pall. http://luajit.org/
JIT: ON CMOV SSE2 SSE3 SSE4.1 fold cse dce fwd dse narrow loop abc sink fuse
&gt; require &quot;lualibhelper&quot;
&gt; hs_init()
&gt; print(add_in_haskell(1, 2))
3
&gt; print(add_in_haskell(-10, 20))
10</code></pre>
<p>Just for the amusement, let’s crash it by running Haskell function <em>after</em> stopping the Haskell runtime:</p>
<pre><code>&gt; hs_exit()
&gt; add_in_haskell(1, 2)
newBoundTask: RTS is not initialised; call hs_init() first</code></pre>
<p>Fun :)</p>
<h1 id="conclusion">Conclusion</h1>
<p>It turns out that extending Lua using Haskell is almost as easy as the doing it using the technique I explained in my <a href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html">previous blog post on this topic</a>.</p>
<p>This post also demonstrates one other thing, namely, compiling Haskell libraries to shared libraries and dynamically loading them in different programs. I’m hoping that this post helps fellow Haskellers to extend their programs written in different languages with Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Understanding Futamura Projections</title>
    <link href="http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html" />
    <id>http://osa1.net/posts/2015-01-11-understanding-futamura-projections.html</id>
    <published>2015-01-11T00:00:00Z</published>
    <updated>2015-01-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s a way to understand Futamura projections<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<p>(Quick note: “Partial evaluator” == “specializer”. As far as I can see these words are also used interchangeably in the literature)</p>
<p>We call our specializer <code>specialize</code>. We specify languages using capital letters, <code>S</code>, <code>T</code>, <code>L</code> etc. We use Haskell syntax for applications. (e.g. <code>f a1 a2 a3</code> is a function application of <code>f</code> to three arguments, applications are left-associative in the case of currying)</p>
<p><code>specialize</code> takes two arguments, first argument is the program(function) to specialize, second argument is the input to specialize the program(function) on.</p>
<p>Note that our specializers are “correct”: For all specializer <code>s</code>, program <code>f</code> and program arguments <code>a</code> and <code>b</code>, <code>(s f a) b</code> is semantically same as <code>f a b</code>.</p>
<p>We show a specializer written in L which operates on programs written in T as <code>specialize_L_T</code>.</p>
<p>Now there are three interesting “Futamura projections”. Let’s say we have an interpreter for a language <code>L</code>, called <code>int</code>, which is written in <code>T</code>. We use <code>*</code> as a wildcard for languages. (e.g. it can be substituted with any language)</p>
<ol style="list-style-type: decimal">
<li><p><code>specialize_*_T int int_pgm</code>: We specialized the interpreter on a program <code>int_pgm</code>, resulting program is in <code>T</code>. We now have a program in <code>T</code> which just gets arguments of the interpreted program and produces output. This gives us a compiled version of <code>int_pgm</code> to <code>T</code>.</p></li>
<li><p><code>specialize_T_T specialize_T_T int</code>: We specialized the specializer on an interpreter. Generated program will be in <code>T</code>, and it’ll be expecting interpreter programs as input. The output will be specialized version of <code>int</code> for the given interpreter program. So we got a compiler for the interpreter <code>int</code>!</p>
<p>Note that specializers now need to be written in the language that they operate on. Alternatively, we could use two different specializers: One for specialize the interpreter, and one for specializing the interpreter specializer. (e.g. in most general form, we can have <code>specialize_A_B specialize_B_C int</code> where <code>int</code> is written in <code>C</code>)</p></li>
<li><p><code>specialize_T_T specialize_T_T specialize T_T</code>: This one is tricky. Let’s try to think what will be the generated program. We know from (2) is that <code>specialize_T_T specialize_T_T int</code> is a compiler for the language that <code>int</code> interprets. Now, we know from the note above that specializing doesn’t change meaning of the program, so our term from (2) <code>specialize_T_T specialize_T_T int</code> should be same with <code>(specialize_T_T specialize_T_T specialize_T_T) int</code>. What happens if we don’t apply the last <code>int</code>? Then we got a program that takes an interpreter and specializes it, resulting with a program in <code>T</code> that doesn’t expect interpreter argument. This is a compiler-compiler. Given an interpreter in <code>T</code>, it gives us a compiled version.</p></li>
</ol>
<p>Futamura projections are originally introduced in Futamura’s <a href="https://cs.au.dk/~hosc/local/HOSC-12-4-pp381-391.pdf">“Partial Evaluation of Computation Process – An Approach to a Compiler-Compiler”</a> and also described in <a href="http://www.itu.dk/people/sestoft/pebook/jonesgomardsestoft-letter.pdf">“Partial Evaluation and Automatic Program Generation”</a>.</p>
<p>Thinking about languages and interpreters are good way to have an intuition about how partial evaluation, specializing specializers etc. work, and “writing interpreters on problem domain” may be a good and general approach to solving problems<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, but I’m wondering what interesting programs and results we would get if we apply the these to different domains. Any ideas and pointers would be appreciated.</p>
<h1 id="problem-with-implementing-the-idea">Problem with implementing the idea</h1>
<p>Implementing ideas are generally a good way to learn, but in this case it’s a bit tricky. If we want to specialize specializers(like in projection (2) and (3)) we need to write one specializer in the language that it specializes, so we need a <code>specialize_T_T</code> for a <code>T</code>.</p>
<p>To be more concrete, if we want to write the specializer in Haskell, then it has to be operating on Haskell so that we could specialize it on itself. Now this is no trivial work, Haskell is a big and complicated language.</p>
<p>On the other hand, if we want to roll our own language just to try this idea, then we’ll have to write the specializer in our language. This is also not trivial, because we need implement a language that is expressive enough to write a specializer for itself.</p>
<p>Designing a minimal language that is expressive enough to implement the idea may be a good challenge.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Futamura projections are what you get when you apply partial evaluators to interpreters and to themselves. Have a look at <a href="http://en.wikipedia.org/wiki/Partial_evaluation#Futamura_projections">related Wikipedia page</a> and see bottom of the post for more resources.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>I recently stumbled upon this <a href="http://stackoverflow.com/questions/27852709/enterprise-patterns-with-functional-programming/27860072#27860072">SO answer</a> to a question about functional design patterns. It’s interesting how forcing yourself to a particular paradigm leads to different approaches and ways to solving problems. This is one of the reasons why I’m trying to learn a new paradigm using a language that is specifically crafted for that paradigm(e.g. Haskell for functional programming instead of Lisps, Scala etc.).<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Two challenges for dependently typed languages</title>
    <link href="http://osa1.net/posts/2014-09-23-two-challenges-for-dep-typed-langs.html" />
    <id>http://osa1.net/posts/2014-09-23-two-challenges-for-dep-typed-langs.html</id>
    <published>2014-09-23T00:00:00Z</published>
    <updated>2014-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

I propose two challenges that I think are very useful to see how easy to use a dependently typed language is. Different dependently typed languages use different type theories as their trusted cores and admit different axioms. In my experience, this significantly effects user experience. For example, lack of dependent pattern matching in Coq is leading to horribly verbose, hard to write, read and understand pattern matching code(see convoy and transport patterns).

<div class="paragraph"> </div>

Adding some extra axioms to Coq's trusted but sometimes too simple core can make the experience significantly better(see <a href="http://coq.inria.fr/distrib/current/stdlib/Coq.Logic.JMeq.html">JMec</a>, <a href="http://coq.inria.fr/distrib/current/stdlib/Coq.Program.Equality.html">Program</a> and <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual010.html">dependent destruction</a>). On the other hand, languages like Idris handles some of the cases that Coq can't handle by default.

<div class="paragraph"> </div>

The challenge is to solve two problems defined below in different dependently typed languages. We can then compare programs for 1) simplicity of code 2) use of extra axioms 3) giving away totality or some other useful properties.

<div class="paragraph"> </div>

Solutions of one of the challenges may also be compared for erasure of types. Problems are defined in Coq.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Challenge 1: Cardinality</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

This is a theorem proving exercise. <span class="inlinecode"><span class="id" type="var">Cardinality</span></span> of a type is defined as bijection of the type with <span class="inlinecode"><span class="id" type="var">Fin.t</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> for some <span class="inlinecode"><span class="id" type="var">n</span></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="cardinality"><span class="id" type="inductive">cardinality</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <span class="id" type="keyword">Prop</span> :=<br />
| <a name="cardinality_intro"><span class="id" type="constructor">cardinality_intro</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">to_fin</span>    : <span class="id" type="var">A</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Vectors.Fin.html#t"><span class="id" type="inductive">Fin.t</span></a> <span class="id" type="var">n</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">from_fin</span>  : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Vectors.Fin.html#t"><span class="id" type="inductive">Fin.t</span></a> <span class="id" type="var">n</span> → <span class="id" type="var">A</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">bijection</span> :<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#from_fin"><span class="id" type="variable">from_fin</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#to_fin"><span class="id" type="variable">to_fin</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">y</span>, <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#to_fin"><span class="id" type="variable">to_fin</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#from_fin"><span class="id" type="variable">from_fin</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#y"><span class="id" type="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>).<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

You may want to solve this simple exercise just to warm-up:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="cardinality_bool"><span class="id" type="lemma">cardinality_bool</span></a> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#cardinality"><span class="id" type="inductive">cardinality</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> 2.<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Now the challenge is to prove that cardinality of

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Inductive</span> <a name="T"><span class="id" type="inductive">T</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br />
| <a name="T1"><span class="id" type="constructor">T1</span></a> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <span class="id" type="var">A</span><br />
| <a name="T2"><span class="id" type="constructor">T2</span></a> : <span class="id" type="var">A</span> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <span class="id" type="var">A</span><br />
| <a name="T3"><span class="id" type="constructor">T3</span></a> : <span class="id" type="var">A</span> → <span class="id" type="var">A</span> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <span class="id" type="var">A</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

.. is <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">N</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">N</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" type="var">N</span></span> where <span class="inlinecode"><span class="id" type="var">N</span></span> is cardinality of <span class="inlinecode"><span class="id" type="var">A</span></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="cardinality_T"><span class="id" type="lemma">cardinality_T</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">N</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#cardinality"><span class="id" type="inductive">cardinality</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#cardinality"><span class="id" type="inductive">cardinality</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#T"><span class="id" type="inductive">T</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#A"><span class="id" type="variable">A</span></a>) (1 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#N"><span class="id" type="variable">N</span></a>).<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

UPDATE: First solution for this challange came from <a href="http://homes.cs.washington.edu/~jrw12/">jrw</a>, in Coq: <a href="http://lpaste.net/111568">http://lpaste.net/111568</a>. UPDATE: He wrote an awesome blog post: <a href="http://homes.cs.washington.edu/~jrw12/more-cardinality.html">Reasoning about Cardinalities of Sums and Products</a>.

<div class="paragraph"> </div>

UPDATE 2: See comments for more solutions.

<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">Challenge 2: Verified, CoInductive definition of Pascal's Triangle</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

This should be easier. What's good about this one is that we can compare languages for performance and/or erasure properties. Basically we expect type arguments to be absent in extracted/executed code.

<div class="paragraph"> </div>

Here's one way to define the problem:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">CoInductive</span> <a name="triangle_t"><span class="id" type="inductive">triangle_t</span></a> (<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Type</span> :=<br />
| <a name="triangle"><span class="id" type="constructor">triangle</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Vectors.Vector.html#t"><span class="id" type="inductive">Vector.t</span></a> <span class="id" type="var">T</span> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#triangle_t"><span class="id" type="inductive">triangle_t</span></a> <span class="id" type="var">T</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a>) → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#triangle_t"><span class="id" type="inductive">triangle_t</span></a> <span class="id" type="var">T</span> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="pascal"><span class="id" type="definition">pascal</span></a> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#triangle_t"><span class="id" type="inductive">triangle_t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> 0. <span class="id" type="var">Admitted</span>.<br />

<br />
<span class="id" type="keyword">Definition</span> <a name="pascal_nth"><span class="id" type="definition">pascal_nth</span></a> (<span class="id" type="var">row</span> <span class="id" type="var">col</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>. <span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Extracted/executed version of <span class="inlinecode"><span class="id" type="var">pascal_nth</span></span> and any auxiliary function should be clean from type arguments.

<div class="paragraph"> </div>

Now the verification part:

<div class="paragraph"> </div>


</div>
<div class="code">

<br />
<span class="id" type="keyword">Theorem</span> <a name="pascal_first_col_is_1"><span class="id" type="lemma">pascal_first_col_is_1</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> 0 (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Le.html#le_0_n"><span class="id" type="lemma">le_0_n</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1.<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
<span class="id" type="keyword">Theorem</span> <a name="pascal_last_col_is_1"><span class="id" type="lemma">pascal_last_col_is_1</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#le_n"><span class="id" type="constructor">le_n</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1.<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
<span class="id" type="keyword">Lemma</span> <a name="pascal_correct_aux"><span class="id" type="lemma">pascal_correct_aux</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span> <span class="id" type="var">col</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1.<br />
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">omega</span>. <span class="id" type="keyword">Qed</span>.<br />

<br />
<span class="id" type="keyword">Lemma</span> <a name="lt_le"><span class="id" type="lemma">lt_le</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#b"><span class="id" type="variable">b</span></a> → <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#b"><span class="id" type="variable">b</span></a>.<br />
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">omega</span>. <span class="id" type="keyword">Qed</span>.<br />

<br />
<span class="id" type="keyword">Lemma</span> <a name="pascal_correct_aux'"><span class="id" type="lemma">pascal_correct_aux'</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span> <span class="id" type="var">col</span>,<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1 →<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1.<br />
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">omega</span>. <span class="id" type="keyword">Qed</span>.<br />

<br />
<span class="id" type="keyword">Theorem</span> <a name="pascal_correct"><span class="id" type="lemma">pascal_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">row</span> <span class="id" type="var">col</span><br />
&nbsp;&nbsp;(<span class="id" type="var">pf</span> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<'_x"><span class="id" type="notation">&lt;</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a>)<br />
&nbsp;&nbsp;(<span class="id" type="var">pf_row</span> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1)<br />
&nbsp;&nbsp;(<span class="id" type="var">pf_col</span> : <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'>='_x"><span class="id" type="notation">≥</span></a> 1),<br />
&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#lt_le"><span class="id" type="lemma">lt_le</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf"><span class="id" type="variable">pf</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1) (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1) (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_correct_aux"><span class="id" type="lemma">pascal_correct_aux</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf"><span class="id" type="variable">pf</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_row"><span class="id" type="variable">pf_row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_col"><span class="id" type="variable">pf_col</span></a>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_nth"><span class="id" type="axiom">pascal_nth</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1) <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> (<a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pascal_correct_aux'"><span class="id" type="lemma">pascal_correct_aux'</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#row"><span class="id" type="variable">row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#col"><span class="id" type="variable">col</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf"><span class="id" type="variable">pf</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_row"><span class="id" type="variable">pf_row</span></a> <a class="idref" href="/posts/2014-09-23-two-challenges-for-dep-typed-langs.html#pf_col"><span class="id" type="variable">pf_col</span></a>).<br />
<span class="id" type="var">Admitted</span>.<br />

<br />
</div>

<div class="doc">

<div class="paragraph"> </div>

Feel free to change the definitions. The point is to 1) have strict <span class="inlinecode"><span class="id" type="var">nth</span></span> function that fail 2) prove that the data structure has property of <a href="http://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's triangle</a>.

<div class="paragraph"> </div>

I'm hoping to come up with some solutions given in Coq over the next couple of weeks.

<div class="paragraph"> </div>


</div>
<div class="code">
</div>
]]></summary>
</entry>
<entry>
    <title>Problems with tactic generated programs</title>
    <link href="http://osa1.net/posts/2014-09-13-problems-with-tactics.html" />
    <id>http://osa1.net/posts/2014-09-13-problems-with-tactics.html</id>
    <published>2014-09-13T00:00:00Z</published>
    <updated>2014-09-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I never managed to write anything with dependent types in Coq, without using tactics. Pattern matching is never giving enough information in cases to allow me to generate the term I want. <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> book describes “Convoy pattern”, which is a way to write dependently typed terms in Coq without using tactics. I later learned that standard <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual010.html#hevea_tactic87">inversion</a> tactic also uses something like a convoy pattern, except it’s not as fine grained as what a user would write by hand.</p>
<p>Unfortunately, even after learning about convoy pattern, I’m still not satisfied with what I get when I write dependently typed definitions without using tactics. The reason is that convoy pattern is incredibly ugly and hard to read and understand. Even if I embrace the ugliness, most of the time I have no idea how to use the pattern so that 1) it’s not horribly verbose 2) does what I want.</p>
<p>I had a small verification idea: I was going to implement <a href="http://en.wikipedia.org/wiki/Pascals_triangle">Pascal’s triangle</a> as a co-inductive type and implement operations on it. Later I was hoping to prove that <code>p(n, k) = p(n-1, k-1) + p(n-1, k)</code> where <code>k</code> is column and <code>p</code> is row.</p>
<p>I struggled for this for a long time. The problem was that I was not comfortable with tactics and I couldn’t define dependently typed terms using fixpoints or definitions. Now that I’m comfortable enough with tactics, I finally managed to <a href="https://gist.github.com/osa1/47ed1dd4267fa379259d">implement what I want</a>.</p>
<p>Here are a few things that I also mentioned in <a href="https://sympa.inria.fr/sympa/arc/coq-club/2014-09/msg00088.html">my mail to Coq-club</a>:</p>
<ul>
<li>The whole thing looks a bit complex but actually implementing it was very easy. Definitely a lot easier than how it’d be if I wanted to implement it without tactics.</li>
<li>Even though generated Coq terms are huge, generated OCaml is actually very good. It still has some problems though. <code>snoc</code> has a redundant argument which could be eliminated by using OCaml lists for vectors. First argument of <code>sum-pairs</code> is redundant because it’s just vector’s length so we could use <code>Vector.t</code>’s field instead. Similarly, I think <code>pascal_aux</code>’s first argument may also be removed etc. (see generated OCaml from the Github link above)</li>
</ul>
<p>If you look at the Coq code, you’ll realize that I couldn’t prove even the simplest fact about my definition. This is the problem with tactic-generated terms. The reason I can’t prove anything is that <code>simpl</code> just doesn’t work anymore, and there are no workarounds. The terms are so huge and complex, nothing is provable anymore.</p>
<p>I got very good responses about alternatives and problems in Coq-club mailing list. One of them was the suggestion of giving functions types that 1) show the properties I’m trying to show in separate theorems 2) still subject to erasure.</p>
<p>This approach has an obvious problem. There won’t be a program/proof distinction anymore. As a programmer I don’t like this at all. Also, making sure that proof terms will be erased is hard.(see rest of the discussion from the mailing list link above) I don’t think I’ll follow this idea.</p>
<p>Another alternative is just using Agda. I have my problems with Agda which I’m deferring to another post for now. Some of my excuses may actually not be Agda’s problem but rather they may be Coq’s advantage. In any case, I probably won’t be using Agda.</p>
<p>So now I’m stuck with Coq – I can’t define anything without using tactics, but when I use tactics for definitions(instead of proofs) then I can’t prove anything.</p>]]></summary>
</entry>
<entry>
    <title>GHC + Cabal installation guide for starters</title>
    <link href="http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html" />
    <id>http://osa1.net/posts/2014-12-09-ghc-cabal-installation-guide.html</id>
    <published>2014-09-12T00:00:00Z</published>
    <updated>2014-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I see a lot of starters having problems with installing latest GHC and Cabal, and then keeping their package repository in a sane state(e.g. no thousands of broken packages because of one re-install, no installation problems because of conflicts). I came up with a simple method several years ago, and today when combined with sandboxes, that works really well. I suggest every new Haskeller to do the same. Here’s how I do my GHC/Cabal installation up-to-date and sane:</p>
<p>NEVER USE HASKELL PALTFORM. When I first started, it caused just too much pain. I don’t know how it is today, but I presume same problems should still apply. (globally installing packages)</p>
<p>Most important thing is to keep Cabal and cabal-install up-to-date. You can easily remove a GHC, or install other versions and keep them togerher once you have a working and relatively new(so that it supports sandboxes) Cabal. In fact, I currently have 3 versions of GHC installed, for different projects, and I have no problems at all. Starting from a system with no GHC/Cabal is installed, here’s the way to install latest Cabal and cabal-install:</p>
<ol style="list-style-type: decimal">
<li>Install whatever GHC and Cabal you have in your package manager.</li>
<li>If the GHC you installed from package manager is not latest one, install latest pre-compiled binary from <a href="http://www.haskell.org/ghc/">GHC webpage</a>. Set your <code>$PATH</code>(or move executables to <code>$PATH</code>) and remove the GHC you installed using the package manager.</li>
<li>Run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, then remove Cabal and cabal-install installed using the package manager, and add <code>~/.cabal/bin</code> to $PATH. After doing that, you’ll have latest GHC and Cabal installed. Also, Cabal will be installed locally, so you can update it very easily using <code>cabal udpate &amp;&amp; cabal install Cabal cabal-install</code> whenever you want. Updating for newer GHC is similarly easy, just installed pre-compiled binary from the link above and move it wherever you want. You can use multiple GHC installations at the same time without any problems, Cabal just keeps separate repositories for different GHC versions.</li>
</ol>
<p>The worst thing that can happen is that your package manager may not have Cabal at all. In that case you may need Haskell Platform temporarily, for booting GHC and Cabal. Once you have Haskell Platform(which includes Cabal) and run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code>, just remove Haskell Platform and download latest GHC as mentioned above and go from there.</p>
<p>Occasionally you may want to remove some directories in <code>~/.cabal/lib</code>. Here’s what I have right now:</p>
<pre><code>➜  lib  pwd
/home/omer/.cabal/lib
➜  lib  ls | xargs du -hs
107M    x86_64-linux-ghc-7.6.3
341M    x86_64-linux-ghc-7.8.3
170M    x86_64-linux-ghcjs-0.1.0_ghc-7.8.2
34M     x86_64-linux-ghcjs-0.1.0_ghc-7.8.3</code></pre>
<p>I have 170M of libraries installed in GHCJS compiled with GHC 7.8.2, but I updated my GHCJS installation and I won’t be using that version anymore, so it’s safe to remove that directory. Similarly you may want to remove versions you won’t be using anymore.</p>
<p>Once you have GHC and Cabal installed, you should be very careful with global installations. Basically all you need to do is to use sandboxes as much as possible. You may want or need to have some programs installed globally, like <code>alex</code> and <code>happy</code> and those are fine since they have almost no dependencies at all.</p>
<p>In all other cases, just create a <code>~/bin</code> directory and add it to your <code>$PATH</code>. Now whenever you need a Haskell program in your path, install it in a sandbox, and symlink it to <code>~/bin</code>.</p>
<p>Another very useful tip: You may still have some installation problems because of dependency conflicts. In that cases always try to install with <code>cabal install --allow-newer</code>. Most of the time this sandbox approach + <code>--allow-newer</code> should solve all your problems.</p>
<p>As a last thing, if you still have problems because you installed some libs globally for some reason, you may want to reset your whole Cabal state. In that case, just copy <code>~/.cabal/bin/cabal</code> to somewhere else and remove <code>~/.cabal</code>. Then using copied <code>cabal</code> executable, run <code>cabal update &amp;&amp; cabal install Cabal cabal-install</code> again. Now you have a fresh Cabal state and you can remove copied <code>cabal</code> executable and go with the one just installed at <code>~/.cabal/bin</code>.</p>
<p>I hope this helps.</p>]]></summary>
</entry>

</feed>
