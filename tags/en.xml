<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2020-02-21T00:00:00Z</updated>
    <entry>
    <title>Knot-tying: why and how (and my opinions on it)</title>
    <link href="http://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html" />
    <id>http://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html</id>
    <published>2020-02-21T00:00:00Z</published>
    <updated>2020-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Suppose I have this simple language:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a></code></pre></div>
<p>When generating code, for an identifier that stands for a lambda, I want to know the arity of the lambda, so that I can generate more efficient code. While in this language a lambda takes only one argument, if I have something like</p>
<pre><code>let f = \x . \y . \z . ...
 in ...</code></pre>
<p>I consider <code>f</code> as having arity 3.</p>
<p>One way to implement this is having this information attached to every <code>Id</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  {<span class="ot"> idName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="co">-- ^ Unique name of the identifier</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  }</a></code></pre></div>
<p>This way of associating information to <code>Id</code>s makes some things very simple. For example, if I’m generating code for this application:</p>
<pre><code>f 1 2</code></pre>
<p>In AST:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="fu">=</span> <span class="dv">3</span> })) (<span class="dt">IntE</span> <span class="dv">1</span>)) (<span class="dt">IntE</span> <span class="dv">2</span>)</a></code></pre></div>
<p>I can simply use the <code>idArity</code> field to see the arity of the function being applied. It doesn’t get any simpler than this.</p>
<h1 id="problem-1-redundant-allocations">Problem 1: redundant allocations</h1>
<p>In a program we usually have many references to a single Id, whether it’s for a top-level function or an argument. If we allocate an Id for every occurance that’s a lot of redundant allocations that make the AST representation larger, and affects compiler performance.</p>
<p>For example, if I have this expression:</p>
<pre><code>f x + f y</code></pre>
<p>A naive representation of this would be</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="dt">App</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="fu">=</span> <span class="dv">2</span> })</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> }))</a></code></pre></div>
<p>Here for every occurance of <code>f</code> we have a new <code>Id</code>, and these <code>Id</code>s all have the same arity. This is two <code>Id</code> heap objects used for the same identifier.</p>
<p>A more efficient representation would be</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">let</span> f <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="fu">=</span> <span class="dv">0</span> } <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="dt">App</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="fu">=</span> <span class="dv">2</span> })</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        (<span class="dt">IdE</span> f)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">     (<span class="dt">IdE</span> f)</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">     (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> }))</a></code></pre></div>
<p>Here we only have one heap object for <code>f</code>, and all uses refer to that one object.</p>
<p>This is actually not hard to fix: we maintain a map from <code>Id</code> names to the actual <code>Id</code>s. When we see a <code>let</code> we add the LHS to the map. When we see an identifier we lookup. Easy.</p>
<h1 id="problem-2-invalidating-the-information-during-transformations">Problem 2: invalidating the information during transformations</h1>
<p>Suppose I want to implement a pass that drops unused bindings. For example:</p>
<pre><code>let f = let a = e1
         in \x . e2
 in f z + f t</code></pre>
<p>Here if <code>e2</code> doesn’t use <code>a</code> I want to drop the binding:</p>
<pre><code>let f = \x . e2
 in f z + f t</code></pre>
<p>The AST for the original program is:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="dt">Let</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  (<span class="dt">Let</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;a&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     <span class="fu">&lt;</span>e1<span class="fu">&gt;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">     (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> } <span class="fu">&lt;</span>e2<span class="fu">&gt;</span>))</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="fu">=</span> <span class="dv">2</span> })</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">        (<span class="dt">App</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a></code></pre></div>
<p>Here’s a naive implementation of this pass:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">dropUnusedBindings <span class="fu">=</span> snd <span class="fu">.</span> go Set.empty</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    go free_vars e0 <span class="fu">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="dt">IdE</span> id <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">        (Set.insert (idName id) free_vars, e0)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        (free_vars, e0)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">        bimap (Set.delete (idName arg)) (<span class="dt">Lam</span> arg)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">              (go free_vars body)</a>
<a class="sourceLine" id="cb12-15" data-line-number="15"></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">          (free1, e1&#39;) <span class="fu">=</span> go free_vars e1</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">          (free2, e2&#39;) <span class="fu">=</span> go free_vars e2</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">          (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</a>
<a class="sourceLine" id="cb12-22" data-line-number="22"></a>
<a class="sourceLine" id="cb12-23" data-line-number="23">      <span class="dt">IfE</span> e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25">          (free1, e1&#39;) <span class="fu">=</span> go free_vars e1</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">          (free2, e2&#39;) <span class="fu">=</span> go free_vars e2</a>
<a class="sourceLine" id="cb12-27" data-line-number="27">          (free3, e3&#39;) <span class="fu">=</span> go free_vars e3</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29">          (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</a>
<a class="sourceLine" id="cb12-30" data-line-number="30"></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">      <span class="dt">Let</span> bndr e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">          (free1, e1&#39;) <span class="fu">=</span> first (Set.delete (idName bndr)) (go free_vars e1)</a>
<a class="sourceLine" id="cb12-34" data-line-number="34">          (free2, e2&#39;) <span class="fu">=</span> go free_vars e2</a>
<a class="sourceLine" id="cb12-35" data-line-number="35">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36">          <span class="kw">if</span> Set.member (idName bndr) free2</a>
<a class="sourceLine" id="cb12-37" data-line-number="37">            <span class="kw">then</span> (Set.delete (idName bndr) (Set.union free1 free2),</a>
<a class="sourceLine" id="cb12-38" data-line-number="38">                  <span class="dt">Let</span> (updateIdArity bndr e1&#39;) e1&#39; e2&#39;)</a>
<a class="sourceLine" id="cb12-39" data-line-number="39">            <span class="kw">else</span> (free2, e2&#39;)</a>
<a class="sourceLine" id="cb12-40" data-line-number="40"></a>
<a class="sourceLine" id="cb12-41" data-line-number="41"><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb12-42" data-line-number="42">updateIdArity id rhs <span class="fu">=</span> id{ idArity <span class="fu">=</span> countLambdas rhs }</a>
<a class="sourceLine" id="cb12-43" data-line-number="43"></a>
<a class="sourceLine" id="cb12-44" data-line-number="44"><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-45" data-line-number="45">countLambdas (<span class="dt">Lam</span> _ rhs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> countLambdas rhs</a>
<a class="sourceLine" id="cb12-46" data-line-number="46">countLambdas _ <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>The problem with this pass is that it changes arity of binders, but doesn’t update the <code>idArity</code>s of occurances. Here’s what I get if I run this over the original AST:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="dt">Let</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> } <span class="fu">&lt;</span>e2<span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="fu">=</span> <span class="dv">2</span> })</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        (<span class="dt">App</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a></code></pre></div>
<p>Note how <code>f</code>, which was not a lambda binder previously, became a lambda binder with arity 1. The pass correctly updated <code>f</code>’s <code>idArity</code> in the binder position, but it did not update it in the occurances! Indeed, in this representation it’s not easy to do this efficiently.</p>
<p>Even if we solved the first problem and had only one closure for <code>f</code>, the <code>updateIdArity</code> step in this pass allocates a new <code>Id</code> and loses sharing. So we would end up with something like:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">let</span> f <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span>, idArity <span class="fu">=</span> <span class="dv">0</span> } <span class="kw">in</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="dt">Let</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;f&quot;</span> , idArity <span class="fu">=</span> <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  (<span class="dt">Lam</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;x&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> } <span class="fu">&lt;</span>e2<span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  (<span class="dt">App</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span> , idArity <span class="fu">=</span> <span class="dv">2</span> })</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">        (<span class="dt">App</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">           (<span class="dt">IdE</span> f)</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">           (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;z&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">     (<span class="dt">App</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12">        (<span class="dt">IdE</span> f)</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">        (<span class="dt">IdE</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;t&quot;</span> , idArity <span class="fu">=</span> <span class="dv">0</span> })))</a></code></pre></div>
<p>The arity of <code>f</code> in the use sites are still wrong, and we lost sharing.</p>
<h1 id="knot-tying">Knot-tying</h1>
<p>Knot-tying is a way of solving both of these in one step. I find it quite hard to explain in words so I’ll show the code (only the interesting bits):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">dropUnusedBindings <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    snd <span class="fu">.</span> go Map.empty Set.empty</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    go binders free_vars e0 <span class="fu">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">      <span class="dt">IdE</span> id <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">        (Set.insert (idName id) free_vars, <span class="dt">IdE</span> (fromMaybe id (Map.lookup (idName id) binders)))</a>
<a class="sourceLine" id="cb15-10" data-line-number="10"></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">      <span class="dt">Let</span> bndr<span class="fu">@</span><span class="dt">Id</span>{ idName <span class="fu">=</span> bndr_name } e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">          bndr&#39; <span class="fu">=</span> updateIdArity bndr e1&#39;</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">          binders&#39; <span class="fu">=</span> Map.insert bndr_name bndr&#39; binders</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">          (free1, e1&#39;) <span class="fu">=</span> first (Set.delete bndr_name) (go binders&#39; free_vars e1)</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">          (free2, e2&#39;) <span class="fu">=</span> go binders&#39; free_vars e2</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb15-18" data-line-number="18">          <span class="kw">if</span> Set.member bndr_name free2</a>
<a class="sourceLine" id="cb15-19" data-line-number="19">            <span class="kw">then</span> (Set.delete bndr_name (Set.union free1 free2),</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">                  <span class="dt">Let</span> bndr&#39; e1&#39; e2&#39;)</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">            <span class="kw">else</span> (free2, e2&#39;)</a>
<a class="sourceLine" id="cb15-22" data-line-number="22"></a>
<a class="sourceLine" id="cb15-23" data-line-number="23">      <span class="fu">...</span></a></code></pre></div>
<p>The differences from the original version:</p>
<ul>
<li><p>We now pass around a “binders” map that maps identifier names to actual <code>Id</code>s. This is used to common-up uses of identifiers with one shared heap object with correct arity info.</p></li>
<li><p>In <code>IdE</code> case we now do lookup on this map, and replace the <code>Id</code> with the shared <code>Id</code> with correct arity info from the map.</p></li>
<li><p>The tricky bit is the <code>Let</code> case where we have a cyclic group of let bindings. <code>binders'</code> is the binder map with <code>bndr</code> with correct arity information. However to be able to generate that map we first need to process <code>e1</code>, and while processing <code>e1</code> we want to replace any occurances of <code>bndr</code> with correct <code>Id</code> too! This gives us the cyclic bindings:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">bndr&#39; <span class="fu">=</span> updateIdArity bndr e1&#39;</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">binders&#39; <span class="fu">=</span> Map.insert bndr_name bndr&#39; binders</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">(<span class="fu">...</span>, e1&#39;) <span class="fu">=</span> <span class="fu">...</span> (go binders&#39; free_vars e1)</a></code></pre></div></li>
</ul>
<p>This technique relies heavily on lazy evaluation. In the original example the AST is not recursive, but suppose we also want to record RHSs of let binders in <code>Id</code>s, to be used for inlining:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  { <span class="fu">...</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    <span class="co">-- ^ RHS of a let binding, used for inlining</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  }</a></code></pre></div>
<p>Now once we implement sharing (solving problem 1) ASTs with recursive definitions will become cyclic. A simple example:</p>
<pre><code>let fac = \x . if x then x * fac (x - 1) else 1 in fac 5</code></pre>
<p>This will be represented as something like</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">pgm <span class="fu">=</span> <span class="dt">Let</span> fac_id rhs body</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    fac_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;fac&quot;</span>, idArity <span class="fu">=</span> <span class="dv">0</span>, idUnfolding <span class="fu">=</span> <span class="dt">Just</span> rhs }</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    rhs <span class="fu">=</span> <span class="dt">Lam</span> x_id (<span class="dt">IfE</span> (<span class="dt">IdE</span> x_id)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">                        (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> star_id) (<span class="dt">IdE</span> x_id))</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                             (<span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> minus_id) (<span class="dt">IdE</span> x_id))</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                                                    (<span class="dt">IntE</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">                                  (<span class="dt">IntE</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    body <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">IntE</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">    x_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;x&quot;</span>, idArity <span class="fu">=</span> <span class="dv">0</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    plus_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span>, idArity <span class="fu">=</span> <span class="dv">2</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">    star_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;*&quot;</span>, idArity <span class="fu">=</span> <span class="dv">2</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    minus_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;-&quot;</span>, idArity <span class="fu">=</span> <span class="dv">2</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a></code></pre></div>
<p>Here <code>fac_id</code> refers to <code>rhs</code>, which refers to <code>fac_id</code>, forming a cycle.</p>
<p>The knot-tying implementation of <code>dropUnusedBindings</code> works even in cases like this. We just need to update <code>updateIdArity</code> to update the unfolding, when it’s available:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">updateIdArity id rhs <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    id{ idArity <span class="fu">=</span> countLambdas rhs</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">      , idUnfolding <span class="fu">=</span> idUnfolding id <span class="fu">$&gt;</span> rhs }</a></code></pre></div>
<p>This is a bit hard to try, but if I implement a <code>Show</code> instance for <code>Id</code> that doesn’t print the unfolding (to avoid looping), make <code>fac_id</code>’s arity <code>0</code>, and call <code>dropUnusedBindings</code> this is the AST I get:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="dt">Let</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  (<span class="dt">Lam</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">     (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">     (<span class="dt">IfE</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">        (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">        (<span class="dt">App</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">           (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;*&quot;</span> <span class="dv">2</span>)) (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>)))</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">           (<span class="dt">App</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">              (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">              (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;-&quot;</span> <span class="dv">2</span>)) (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;x&quot;</span> <span class="dv">0</span>))) (<span class="dt">IntE</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">        (<span class="dt">IntE</span> <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">  (<span class="dt">App</span> (<span class="dt">IdE</span> (<span class="dt">Id</span> <span class="st">&quot;fac&quot;</span> <span class="dv">1</span>)) (<span class="dt">IntE</span> <span class="dv">5</span>))</a></code></pre></div>
<p>All uses of <code>fac</code> have correct arity! Similarly I can do something hacky like this in GHCi to check that the unfolding has correct arity for uses of <code>fac</code> too:</p>
<pre><code>ghci&gt; let Let lhs _ _ = dropUnusedBindings pgm
ghci&gt; putStrLn (ppShow (idUnfolding lhs))
Just
  (Lam
     (Id &quot;x&quot; 0)
     (IfE
        (IdE (Id &quot;x&quot; 0))
        (App
           (App (IdE (Id &quot;*&quot; 2)) (IdE (Id &quot;x&quot; 0)))
           (App
              (IdE (Id &quot;fac&quot; 1))
              (App (App (IdE (Id &quot;-&quot; 2)) (IdE (Id &quot;x&quot; 0))) (IntE 1))))
        (IntE 1)))</code></pre>
<p>Nice!</p>
<h1 id="or-is-it">… or is it?</h1>
<p>The main problem with this technique is that it’s very difficult to understand. Even after working on different knot-tying code in GHC and implementing my own knot-tying passes, the recursive let bindings in the <code>Let</code> case above is still mind-boggling to me.</p>
<p>Secondly, it’s really hard to reason about the evaluation order of things in knot-tying code. You might think that this shouldn’t be an issue in a purely functional implementation, but in my experience any non-trivial compiler pass, even when implemented in a purely functional style, still needs debugging. Even if it’s not buggy, you may want to trace the evaluation and print a few things to understand how the code works.</p>
<p>Knot-tying code makes this, which should be absolutely trivial in any reasonable code base, very difficult. If you end up evaluating just the right places with your print statements you end looping. For example, here’s our AST with a few bang patterns:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">IdE</span> <span class="fu">!</span><span class="dt">Id</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">App</span> <span class="fu">!</span><span class="dt">Expr</span> <span class="fu">!</span><span class="dt">Expr</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="fu">!</span><span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  {<span class="ot"> idName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb23-11" data-line-number="11">  ,<span class="ot"> idArity ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  }</a></code></pre></div>
<p>If you run the same program above using this AST definition you’ll see that the pass now loops. Note that I’ve removed the <code>idUnfolding</code> field just to demonstrate that this doesn’t happen because we have a loop in the AST.</p>
<p>It’s even more frustrating when what you’re debugging is a loop. You add a few prints, and scratch your head thinking why none of your prints are working even though the algorithm is clearly looping. What’s really happening is that the code is indeed looping, but for a different reason…</p>
<p>Finally, because making things more strict potentially breaks things, knot-tying makes fixing some memory leaks very hard. For example, we may have many passes on our AST, one of them being our knot-tying pass. Some of these passes may be very leaky, and instead of adding strict applications or bang patterns to dozens of places, we may want to add bangs to only a few places in the AST. But that, as demonstrated above, causes our knot-tying pass to loop.</p>
<h1 id="opinions">Opinions</h1>
<p>GHC makes use of knot-tying extensively, which has always been one of the pain points for me since my first days contributing to GHC. I vaguely remember, I was a graduate student at Indiana University at the time, making my first contributions to GHC. I remember finding it refreshing to be able to simply do <code>idType</code> and get type of an identifier in GHC, as opposed to using a symbol table, which I’d been doing in some of the other compilers I worked on in the past.</p>
<p>At the same time, I was constantly confused that my simple print statements added in some front-end pass makes the compiler loop. I had no idea what could be the reason. I had no idea that the thing I found so refreshing is also the reason why debugging and tracing were so much harder.</p>
<p>Suffice it to say, I don’t like knot-tying. If I had to use knot-tying in my project I’d probably reconsider how I represent my data instead. For example, if we simply used an unique number for our identifiers and maintained a symbol table to map the unique numbers to actual <code>Id</code>s then we wouldn’t have cycles for recursive functions in the AST and wouldn’t need knot-tying. Updating something about an <code>Id</code> would be a simple update in the symbol table.</p>
<details>
<p><summary>Full code</summary></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4"></a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Control.DeepSeq</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Bifunctor</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Functor</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Debug.Trace</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"></a>
<a class="sourceLine" id="cb24-15" data-line-number="15"><span class="co">{-</span></a>
<a class="sourceLine" id="cb24-16" data-line-number="16"><span class="co">data Expr</span></a>
<a class="sourceLine" id="cb24-17" data-line-number="17"><span class="co">  = IdE !Id</span></a>
<a class="sourceLine" id="cb24-18" data-line-number="18"><span class="co">  | IntE Int</span></a>
<a class="sourceLine" id="cb24-19" data-line-number="19"><span class="co">  | Lam Id Expr</span></a>
<a class="sourceLine" id="cb24-20" data-line-number="20"><span class="co">  | App !Expr !Expr</span></a>
<a class="sourceLine" id="cb24-21" data-line-number="21"><span class="co">  | IfE Expr !Expr Expr</span></a>
<a class="sourceLine" id="cb24-22" data-line-number="22"><span class="co">  | Let Id Expr Expr</span></a>
<a class="sourceLine" id="cb24-23" data-line-number="23"><span class="co">  | Placeholder String</span></a>
<a class="sourceLine" id="cb24-24" data-line-number="24"><span class="co">  deriving (Show)</span></a>
<a class="sourceLine" id="cb24-25" data-line-number="25"></a>
<a class="sourceLine" id="cb24-26" data-line-number="26"><span class="co">data Id = Id</span></a>
<a class="sourceLine" id="cb24-27" data-line-number="27"><span class="co">  { idName :: String</span></a>
<a class="sourceLine" id="cb24-28" data-line-number="28"><span class="co">    -- ^ Unique name of the identifier</span></a>
<a class="sourceLine" id="cb24-29" data-line-number="29"><span class="co">  , idArity :: !Int</span></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"><span class="co">    -- ^ Arity of a lambda. 0 for non-lambdas.</span></a>
<a class="sourceLine" id="cb24-31" data-line-number="31"><span class="co">  }</span></a>
<a class="sourceLine" id="cb24-32" data-line-number="32"><span class="co">-}</span></a>
<a class="sourceLine" id="cb24-33" data-line-number="33"></a>
<a class="sourceLine" id="cb24-34" data-line-number="34"><span class="kw">data</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-35" data-line-number="35">  <span class="fu">=</span> <span class="dt">IdE</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb24-36" data-line-number="36">  <span class="fu">|</span> <span class="dt">IntE</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-37" data-line-number="37">  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-38" data-line-number="38">  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-39" data-line-number="39">  <span class="fu">|</span> <span class="dt">IfE</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-40" data-line-number="40">  <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">Id</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-41" data-line-number="41">  <span class="fu">|</span> <span class="dt">Placeholder</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb24-42" data-line-number="42">  <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb24-43" data-line-number="43"></a>
<a class="sourceLine" id="cb24-44" data-line-number="44"><span class="kw">data</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb24-45" data-line-number="45">  {<span class="ot"> idName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb24-46" data-line-number="46">    <span class="co">-- ^ Unique name of the identifier</span></a>
<a class="sourceLine" id="cb24-47" data-line-number="47">  ,<span class="ot"> idArity ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-48" data-line-number="48">    <span class="co">-- ^ Arity of a lambda. 0 for non-lambdas.</span></a>
<a class="sourceLine" id="cb24-49" data-line-number="49">  ,<span class="ot"> idUnfolding ::</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-50" data-line-number="50">    <span class="co">-- ^ RHS of a binder, used for inlining</span></a>
<a class="sourceLine" id="cb24-51" data-line-number="51">  }</a>
<a class="sourceLine" id="cb24-52" data-line-number="52"></a>
<a class="sourceLine" id="cb24-53" data-line-number="53"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Id</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-54" data-line-number="54"></a>
<a class="sourceLine" id="cb24-55" data-line-number="55">  show (<span class="dt">Id</span> name arity _) <span class="fu">=</span> <span class="st">&quot;(Id &quot;</span> <span class="fu">++</span> show name <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> show arity <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb24-56" data-line-number="56"></a>
<a class="sourceLine" id="cb24-57" data-line-number="57"><span class="co">{-</span></a>
<a class="sourceLine" id="cb24-58" data-line-number="58"><span class="co">f_id = Id { idName = &quot;f&quot;, idArity = 0 }</span></a>
<a class="sourceLine" id="cb24-59" data-line-number="59"><span class="co">a_id = Id { idName = &quot;a&quot;, idArity = 0 }</span></a>
<a class="sourceLine" id="cb24-60" data-line-number="60"><span class="co">x_id = Id { idName = &quot;x&quot;, idArity = 0 }</span></a>
<a class="sourceLine" id="cb24-61" data-line-number="61"><span class="co">z_id = Id { idName = &quot;z&quot;, idArity = 0 }</span></a>
<a class="sourceLine" id="cb24-62" data-line-number="62"><span class="co">t_id = Id { idName = &quot;t&quot;, idArity = 0 }</span></a>
<a class="sourceLine" id="cb24-63" data-line-number="63"><span class="co">plus_id = Id { idName = &quot;+&quot;, idArity = 2 }</span></a>
<a class="sourceLine" id="cb24-64" data-line-number="64"></a>
<a class="sourceLine" id="cb24-65" data-line-number="65"></a>
<a class="sourceLine" id="cb24-66" data-line-number="66"><span class="co">f_x_plus_f_y = (App (App (IdE plus_id) (App (IdE f_id) (IdE z_id)))</span></a>
<a class="sourceLine" id="cb24-67" data-line-number="67"><span class="co">                     (App (IdE f_id) (IdE t_id)))</span></a>
<a class="sourceLine" id="cb24-68" data-line-number="68"></a>
<a class="sourceLine" id="cb24-69" data-line-number="69"><span class="co">ast1 = Let f_id (Let a_id (Placeholder &quot;e1&quot;) (Lam x_id (Placeholder &quot;e2&quot;))) f_x_plus_f_y</span></a>
<a class="sourceLine" id="cb24-70" data-line-number="70"></a>
<a class="sourceLine" id="cb24-71" data-line-number="71"><span class="co">ast2 = Let a_id (Placeholder &quot;e1&quot;)</span></a>
<a class="sourceLine" id="cb24-72" data-line-number="72"><span class="co">           (Let f_id (Lam x_id (Placeholder &quot;e2&quot;))</span></a>
<a class="sourceLine" id="cb24-73" data-line-number="73"><span class="co">                     f_x_plus_f_y)</span></a>
<a class="sourceLine" id="cb24-74" data-line-number="74"><span class="co">-}</span></a>
<a class="sourceLine" id="cb24-75" data-line-number="75"></a>
<a class="sourceLine" id="cb24-76" data-line-number="76"><span class="ot">updateIdArity ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb24-77" data-line-number="77">updateIdArity id rhs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-78" data-line-number="78">  id{ idArity <span class="fu">=</span> countLambdas rhs,</a>
<a class="sourceLine" id="cb24-79" data-line-number="79">      idUnfolding <span class="fu">=</span> idUnfolding id <span class="fu">$&gt;</span> rhs }</a>
<a class="sourceLine" id="cb24-80" data-line-number="80"></a>
<a class="sourceLine" id="cb24-81" data-line-number="81"><span class="ot">countLambdas ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-82" data-line-number="82">countLambdas (<span class="dt">Lam</span> _ rhs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> countLambdas rhs</a>
<a class="sourceLine" id="cb24-83" data-line-number="83">countLambdas _ <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb24-84" data-line-number="84"></a>
<a class="sourceLine" id="cb24-85" data-line-number="85"><span class="ot">dropUnusedBindings ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-86" data-line-number="86">dropUnusedBindings <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-87" data-line-number="87">    snd <span class="fu">.</span> go Map.empty Set.empty</a>
<a class="sourceLine" id="cb24-88" data-line-number="88">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-89" data-line-number="89"><span class="ot">    go ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Set.Set</span> <span class="dt">String</span>, <span class="dt">Expr</span>)</a>
<a class="sourceLine" id="cb24-90" data-line-number="90">    go binders free_vars e0 <span class="fu">=</span> <span class="kw">case</span> e0 <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-91" data-line-number="91"></a>
<a class="sourceLine" id="cb24-92" data-line-number="92">      <span class="dt">IdE</span> id <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-93" data-line-number="93">        (Set.insert (idName id) free_vars, <span class="dt">IdE</span> (fromMaybe id (Map.lookup (idName id) binders)))</a>
<a class="sourceLine" id="cb24-94" data-line-number="94"></a>
<a class="sourceLine" id="cb24-95" data-line-number="95">      <span class="dt">IntE</span>{} <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-96" data-line-number="96">        (free_vars, e0)</a>
<a class="sourceLine" id="cb24-97" data-line-number="97"></a>
<a class="sourceLine" id="cb24-98" data-line-number="98">      <span class="dt">Lam</span> arg body <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-99" data-line-number="99">        bimap (Set.delete (idName arg)) (<span class="dt">Lam</span> arg)</a>
<a class="sourceLine" id="cb24-100" data-line-number="100">              (go binders free_vars body)</a>
<a class="sourceLine" id="cb24-101" data-line-number="101"></a>
<a class="sourceLine" id="cb24-102" data-line-number="102">      <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-103" data-line-number="103">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb24-104" data-line-number="104">          (free1, e1&#39;) <span class="fu">=</span> go binders free_vars e1</a>
<a class="sourceLine" id="cb24-105" data-line-number="105">          (free2, e2&#39;) <span class="fu">=</span> go binders free_vars e2</a>
<a class="sourceLine" id="cb24-106" data-line-number="106">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb24-107" data-line-number="107">          (Set.union free1 free2, <span class="dt">App</span> e1&#39; e2&#39;)</a>
<a class="sourceLine" id="cb24-108" data-line-number="108"></a>
<a class="sourceLine" id="cb24-109" data-line-number="109">      <span class="dt">IfE</span> e1 e2 e3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-110" data-line-number="110">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb24-111" data-line-number="111">          (free1, e1&#39;) <span class="fu">=</span> go binders free_vars e1</a>
<a class="sourceLine" id="cb24-112" data-line-number="112">          (free2, e2&#39;) <span class="fu">=</span> go binders free_vars e2</a>
<a class="sourceLine" id="cb24-113" data-line-number="113">          (free3, e3&#39;) <span class="fu">=</span> go binders free_vars e3</a>
<a class="sourceLine" id="cb24-114" data-line-number="114">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb24-115" data-line-number="115">          (Set.unions [free1, free2, free3], <span class="dt">IfE</span> e1&#39; e2&#39; e3&#39;)</a>
<a class="sourceLine" id="cb24-116" data-line-number="116"></a>
<a class="sourceLine" id="cb24-117" data-line-number="117">      <span class="dt">Let</span> bndr<span class="fu">@</span><span class="dt">Id</span>{ idName <span class="fu">=</span> bndr_name } e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-118" data-line-number="118">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb24-119" data-line-number="119">          bndr&#39; <span class="fu">=</span> updateIdArity bndr e1&#39;</a>
<a class="sourceLine" id="cb24-120" data-line-number="120">          binders&#39; <span class="fu">=</span> Map.insert bndr_name bndr&#39; binders</a>
<a class="sourceLine" id="cb24-121" data-line-number="121">          (free1, e1&#39;) <span class="fu">=</span> first (Set.delete bndr_name) (go binders&#39; free_vars e1)</a>
<a class="sourceLine" id="cb24-122" data-line-number="122">          (free2, e2&#39;) <span class="fu">=</span> go binders&#39; free_vars e2</a>
<a class="sourceLine" id="cb24-123" data-line-number="123">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb24-124" data-line-number="124">          <span class="kw">if</span> Set.member bndr_name free2</a>
<a class="sourceLine" id="cb24-125" data-line-number="125">            <span class="kw">then</span> (Set.delete bndr_name (Set.union free1 free2),</a>
<a class="sourceLine" id="cb24-126" data-line-number="126">                  <span class="dt">Let</span> bndr&#39; e1&#39; e2&#39;)</a>
<a class="sourceLine" id="cb24-127" data-line-number="127">            <span class="kw">else</span> (free2, e2&#39;)</a>
<a class="sourceLine" id="cb24-128" data-line-number="128"></a>
<a class="sourceLine" id="cb24-129" data-line-number="129">      <span class="dt">Placeholder</span>{} <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-130" data-line-number="130">        (free_vars, e0)</a>
<a class="sourceLine" id="cb24-131" data-line-number="131"></a>
<a class="sourceLine" id="cb24-132" data-line-number="132">pgm <span class="fu">=</span> <span class="dt">Let</span> fac_id rhs body</a>
<a class="sourceLine" id="cb24-133" data-line-number="133">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-134" data-line-number="134">    fac_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;fac&quot;</span>, idArity <span class="fu">=</span> <span class="dv">0</span>, idUnfolding <span class="fu">=</span> <span class="dt">Just</span> rhs }</a>
<a class="sourceLine" id="cb24-135" data-line-number="135">    rhs <span class="fu">=</span> <span class="dt">Lam</span> x_id (<span class="dt">IfE</span> (<span class="dt">IdE</span> x_id) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> star_id) (<span class="dt">IdE</span> x_id))</a>
<a class="sourceLine" id="cb24-136" data-line-number="136">                                        (<span class="dt">App</span> (<span class="dt">IdE</span> fac_id)</a>
<a class="sourceLine" id="cb24-137" data-line-number="137">                                             (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">IdE</span> minus_id) (<span class="dt">IdE</span> x_id)) (<span class="dt">IntE</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb24-138" data-line-number="138">                                   (<span class="dt">IntE</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb24-139" data-line-number="139">    body <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">IdE</span> fac_id) (<span class="dt">IntE</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb24-140" data-line-number="140"></a>
<a class="sourceLine" id="cb24-141" data-line-number="141">    x_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;x&quot;</span>, idArity <span class="fu">=</span> <span class="dv">0</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb24-142" data-line-number="142">    plus_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;+&quot;</span>, idArity <span class="fu">=</span> <span class="dv">2</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb24-143" data-line-number="143">    star_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;*&quot;</span>, idArity <span class="fu">=</span> <span class="dv">2</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb24-144" data-line-number="144">    minus_id <span class="fu">=</span> <span class="dt">Id</span> { idName <span class="fu">=</span> <span class="st">&quot;-&quot;</span>, idArity <span class="fu">=</span> <span class="dv">2</span>, idUnfolding <span class="fu">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb24-145" data-line-number="145"></a>
<a class="sourceLine" id="cb24-146" data-line-number="146">main <span class="fu">=</span> putStrLn (ppShow (dropUnusedBindings pgm))</a></code></pre></div>
</details>
<p>Thanks to Oleg Grenrus for reading a draft of this.</p>]]></summary>
</entry>
<entry>
    <title>Some arguments against small syntax extensions in GHC</title>
    <link href="http://osa1.net/posts/2020-01-22-no-small-syntax-extensions.html" />
    <id>http://osa1.net/posts/2020-01-22-no-small-syntax-extensions.html</id>
    <published>2020-01-22T00:00:00Z</published>
    <updated>2020-01-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently realized that I haven’t published a single post in 2019. I think that’s the longest break I ever took to blogging, and it kinda made me motivated to publish some of the draft posts that I’ve been keeping in private Github gists.</p>
<p>This post is originally written in 11 January 2019. Because it is more of an angry rant than a constructive piece, I wasn’t sure at the time that publishing it is a good idea. However reading it again now, I see that it’s not directed at a person, a group, or a specific proposal/patch, so I think it shouldn’t be offensive to anyone and I should be able to publish it on my personal blog.</p>
<p>(original post starts below)</p>
<hr />
<p>So I woke up at 5AM today and felt like writing about one of my frustrations. These are my personal opinions, and I don’t represent GHC HQ here.</p>
<hr />
<p>At this point adding new syntax to GHC/Haskell is a bad idea. Before moving on to examples, here are some facts:</p>
<ul>
<li><p>The language that GHC supports is incredibly complex. GHC 8.6.3 man page lists 115 language pragmas.</p></li>
<li><p>You just can’t have a good understanding of <em>all</em> of these features and know interactions of the proposed syntax with all combinations of these.</p></li>
<li><p>GHC is a complex and old compiler with parts that today no active contributor knows well. The compiler (ignoring all the libraries, the RTS, tools etc.) currently has 189,699 lines of code (ignoring comments and whitespace). That’s a lot of complexity to deal with.</p></li>
<li>When you propose a new syntax, what you’re actually proposing is:
<ul>
<li>At least one more pragma</li>
<li>More user manual sections</li>
<li>MVP implementation of your syntax (which is usually not bug-free)</li>
<li>A few common-case tests (which are usually not enough)</li>
<li>More headache for tool developers</li>
<li>Scaring more potential new Haskell developers away</li>
<li>Adding to the frustration of existing Haskell developers</li>
<li>Adding maintenance burden to GHC devs</li>
</ul></li>
<li><p>Because you can’t predict all the interactions of your new syntax (conceptually, or in the implementation) your syntax will cause a ton of problems.</p></li>
<li><p>Those problems will sit there unfixed for months/years.</p></li>
<li><p>GHC maintainers barely have enough time and manpower to provide stable releases. 8.6.1 and 8.6.2 are completely broken (<a href="https://gitlab.haskell.org/ghc/ghc/issues/15544">#15544</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15696">#15696</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15892">#15892</a>), and 8.6.3 doesn’t <a href="https://gitlab.haskell.org/ghc/ghc/issues/16057">work well on Windows</a>.</p></li>
</ul>
<p>You might not accept some of these, however in my experience these are facts. If you disagree with any of these let me know and I can elaborate.</p>
<p>I’ll have only two examples for now, because I don’t normally work on front-end parts of the compiler I don’t notice most of the problems.</p>
<h1 id="example-1-tiny-addition-to-ghci-syntax">Example 1: Tiny addition to GHCi syntax</h1>
<p><a href="https://gitlab.haskell.org/ghc/ghc/issues/7253">#7253</a> proposed a tiny new syntax in GHCi. A few years later a new contributor picked it up and submitted a <a href="https://phabricator.haskell.org/D1299">patch</a>. This trivial new syntax later caused <a href="https://gitlab.haskell.org/ghc/ghc/issues/11606">#11606</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/12091">#12091</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15721">#15721</a>. That’s 3 too many tickets for a trivial syntax that buys us so little. It also generated at least one <a href="https://stackoverflow.com/questions/53898220/sprint-and-seq-together-missing-evaluation">SO question</a>, and invalidated an answer to <a href="https://stackoverflow.com/questions/14052093/ghci-let-what-does-it-do/14052220#14052220">another SO question</a> by making things more complicated.</p>
<p>The implementation is finally <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/97">fixed by a frustrated maintainer</a>, but the additional complexity (both in the implementation, and as the GHCi syntax to be explained to users) it added won’t be fixed.</p>
<h1 id="example-2--xblockarguments">Example 2: -XBlockArguments</h1>
<p>This was proposed as <a href="https://github.com/ghc-proposals/ghc-proposals/pull/90">a GHC proposal</a>. It’s a trivial syntax change that in the best case can save 3 characters (including spaces). So far it generated two tickets: <a href="https://gitlab.haskell.org/ghc/ghc/issues/16137">#16137</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/16097">#16097</a>. Even worse than the previous example is none of these tickets mention <code>-XBlockArguments</code>, they don’t even use it! Yet the error messages got significantly worse because of it.</p>
<hr />
<h1 id="just-to-be-clear">Just to be clear</h1>
<p>I think some of the extensions are quite useful. However I also think that at this point new syntax extensions are doing more harm than good. Problems from a maintainer’s point of view are as listed above (arguably maintainers’ problems are also users’ problems because they lead to poor product, but let’s ignore this aspect for now). Now I want to add one more problem, this time from a software developer/engineer’s point of view:</p>
<ul>
<li>Adding a different way of doing things, especially when the difference is so small, does more harm than good.</li>
</ul>
<p>Here’s why. Now that we have two ways of using <code>do</code> syntax:</p>
<pre><code>-- (1)
atomically $ do
  ...

-- (2) with -XBlockArguments
atomically do
  ...</code></pre>
<p>with my team I have to do one of these</p>
<ol type="1">
<li>Decide which one to use, and somehow manually make sure to use it consistently (this can’t be done automatically as we lack the tooling)</li>
<li>Let everyone use whatever they want.</li>
</ol>
<p>(1) means wasting the team’s time and energy on endless bikeshedding. (2) means being inconsistent in the source code. Either way we lose.</p>
<p>You might argue that with good tooling (1) is not a problem, and I’d agree. However as we add new syntax the tooling story will only get worse. GHC Haskell syntax is already so complex we don’t even have a good formatter. We should first stop making it even more complex if we want the tooling story to get better.</p>
<h1 id="what-we-need">What we need</h1>
<p>In my opinion what we need is principles to guide the language and the compiler. Currently <a href="https://github.com/ghc-proposals/ghc-proposals/pull/190#issuecomment-450440245">we don’t have this</a> (last paragraph), and the result is 100+ pragmas, a buggy compiler, and frustrated users and maintainers.</p>
<h1 id="my-advice-to-users">My advice to users</h1>
<p>If you’re proposing a new syntax; don’t! If you know someone who will, point them to this blog post.</p>]]></summary>
</entry>
<entry>
    <title>A project we've been working on presented at MuniHac 2018</title>
    <link href="http://osa1.net/posts/2018-10-22-gc-work-presented.html" />
    <id>http://osa1.net/posts/2018-10-22-gc-work-presented.html</id>
    <published>2018-10-22T00:00:00Z</published>
    <updated>2018-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new low-latency garbage collector for GHC that <a href="http://bgamari.github.io/">Ben Gamari</a> and I have been working on for the last year or so has recently been presented at <a href="https://munihac.github.io/">MuniHac 2018</a>. I’d like to thank Ben for the great talk.</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7_ig6r2C-d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
<p>I’ve been answering some questions on the <a href="https://www.reddit.com/r/haskell/comments/9ygoy1/munihac_2018_keynote_a_lowlatency_garbage/">/r/haskell thread</a> (I’m /u/semanticistZombie on Reddit). If you have any questions please don’t hesitate to add a comment in the reddit thread (make sure to ping me so that I get a notification), or even better, add a comment below.</p>]]></summary>
</entry>
<entry>
    <title>New blog post published elsewhere</title>
    <link href="http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html" />
    <id>http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html</id>
    <published>2018-05-19T00:00:00Z</published>
    <updated>2018-05-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new blog post that I’ve authored has been published on <a href="http://www.well-typed.com/blog/2018/05/ghc-special-gc-objects/">Well-Typed’s blog</a>. If you’re interested in garbage collection or liked my <a href="/posts/2018-03-16-gc-optimizations.html">previous post</a> you should check it out.</p>]]></summary>
</entry>
<entry>
    <title>Debugging #15038</title>
    <link href="http://osa1.net/posts/2018-04-28-debugging-15038.html" />
    <id>http://osa1.net/posts/2018-04-28-debugging-15038.html</id>
    <published>2018-04-28T00:00:00Z</published>
    <updated>2018-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently spent some time debugging GHC bug <a href="https://ghc.haskell.org/trac/ghc/ticket/15038">#15038</a> and to help with context switching between debugging and other tasks I took notes during debugging. After successfully debugging it and reading my notes from the beginning I thought it may be an interesting read, so I’m publishing it. It may not make much sense to anyone other than me, and it’s very lightly edited, so keep your expectations low :)</p>
<hr />
<p>Crashes at this point:</p>
<pre><code>&gt;&gt;&gt; bt
#11 0x00000000008d6650 in
    barf (s=0x94fe90 &quot;evacuate(static): strange closure type %d&quot;) at rts/RtsMessages.c:47
#12 0x00000000008e7e83 in
    evacuate (p=0x981640) at rts/sm/Evac.c:574
#13 0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#14 0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#15 0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#16 0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#17 0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#18 0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#19 0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#20 0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#21 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#22 0x000000000040d7da in
    main ()</code></pre>
<p>While evacuating object at location</p>
<pre><code>p = (StgClosure **) 0x981640</code></pre>
<p>Info table of the object:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl(q)
$5 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>Untagged object:</p>
<pre><code>q = (StgClosure *) 0x981618</code></pre>
<p>Tagged:</p>
<pre><code>*p = (StgClosure *) 0x981619</code></pre>
<p>Where does this object appear? Tagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981619
(nothing)</code></pre>
<p>Untagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981618
(nothing)</code></pre>
<p>Not in the heap!</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981618
rctv_closure in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>According to STG output references should be</p>
<pre><code>lvl4_rctv referenced by
lvl5_rctw referenced by
lvl6_rctx referenced by
$wbyteParserBadOnce</code></pre>
<p>Looking at each closure:</p>
<pre><code>rctv :: ([Char], Packed.Bytes.Parser.Parser Word)

&gt;&gt;&gt; print (StgClosure)rctv_closure (0x981618)
{
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctv_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 0,
  code = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt; &quot;H\377\303\377e&quot;
}


rctw :: [([Char], Packed.Bytes.Parser.Parser Word)]

&gt;&gt;&gt; print (StgClosure)rctw_closure (0x981638)
{
  header = {
    info = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctw_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 1,
  code = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt; &quot;H\203\303\002\377e&quot;
}


rctx :: Packed.Bytes.Parser.Parser Word

&gt;&gt;&gt; print (StgClosure)rctx_closure (0x981658)
{
  header = {
    info = 0x40ca10 &lt;rctx_info&gt;
        -- Packed.Bytes.Parser.Parser GHC.Types.Word
  },
  payload = []
}
&gt;&gt;&gt; print *get_itbl(&amp;rctx_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 21, -- THUNK_STATIC
  srt_bitmap = 3,
  code = 0x40ca10 &lt;rctx_info&gt; &quot;H\215E\350L9\370r@H\203\354\bL\211\350H\211\336H\211\307\061\300\350S\314M&quot;
}

$wbyteParserBadOnce :: Int -&gt; Int#

&gt;&gt;&gt; print (StgClosure)Parser_zdwbyteParserBadOnce_closure (0x981680)
{
  header = {
    info = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;Parser_zdwbyteParserBadOnce_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 113,
  code = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt; &quot;H\215E\320L9\370\017\202\342\001&quot;
}</code></pre>
<p>Back to the backtrace. Adding watchpoints makes it run too slow, so first figure out when this happens:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 2 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 2 10000000
Will ignore next 10000000 crossings of breakpoint 2.
&gt;&gt;&gt; c
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 6 times
        ignore next 9999994 hits</code></pre>
<p>So 6th time we run GC we see this error. Let’s see if 0x981640 is a valid closure by the beginning of 6th GC:</p>
<pre><code>&gt;&gt;&gt; call LOOKS_LIKE_CLOSURE_PTR(0x981640)
$5 = true</code></pre>
<p>However at this point it already has wrong type:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl((StgClosure*)0x981640)
$4 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>In fact, this object has this type since the beginning.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981640
rctw_closure + 8 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>This object is in <code>payload[0]</code> of <code>rctw</code>?</p>
<pre><code>lvl5_rctw
  :: [(GHC.Base.String, Packed.Bytes.Parser.Parser GHC.Types.Word)]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [lvl4_rctv GHC.Types.[]];</code></pre>
<p>So it should be <code>rctv</code>. Something is wrong with first payload of <code>rctw</code>. We should focus on evacuation/scavenging of <code>rctw</code>.</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981638
&gt;&gt;&gt; c
** hits breakpoint **
&gt;&gt;&gt; call printClosure(q)
ghc-prim:GHC.Types.:(0x981619, 0xace111)
&gt;&gt;&gt; info symbol 0x981619
rctv_closure + 1 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>So indeed we have <code>rctv_closure</code> in first payload (but tagged).</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)
&gt;&gt;&gt; call printClosure(0xace111)
ghc-prim:GHC.Types.[](0x8c3450#)</code></pre>
<p>It looks OK. Let’s see if it breaks after this GC.</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981638)
ghc-prim:GHC.Types.:(0x981619, 0xace111)</code></pre>
<p>Nope. Continue until first payload of 0x981638 (<code>rctw</code>) changes.</p>
<p>It turns out the payload doesn’t change. So <code>rctv</code> itself changes!</p>
<p>On 4th <code>GarbageCollect()</code> this fails:</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
*** printClosure: unknown type 16585 ****
Main: internal error: printClosure 16585
    (GHC version 8.5.20180425 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
<p>So break at 3rd:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 1 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 1 2
Will ignore next 2 crossings of breakpoint 1.
&gt;&gt;&gt; c
&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)</code></pre>
<p>(Remember that 0x981619 is tagged 0x981618 which is <code>rctv</code>)</p>
<p>Now watch the closure:</p>
<pre><code>&gt;&gt;&gt; watch (StgClosure)rctv_closure
Watchpoint 2: (StgClosure)rctv_closure
&gt;&gt;&gt; disable breakpoint 1
&gt;&gt;&gt; c</code></pre>
<p>This takes forever, gdb starts leaking memory, fills 16G and swaps.</p>
<p>Let’s take a look at static objects again. <code>rctv</code>’s info table pointer somehow gets overwritten. What could cause this? Perhaps an object before <code>rctv</code> has an overlapping field.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981617
rctu_closure + 7 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>It seems like we have <code>rctu</code> before <code>rctv</code>.</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)

&gt;&gt;&gt; print (StgClosure)rctu_closure
{
  header = {
    info = 0x40c908 &lt;rctu_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;rctu_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 1,
  code = 0x40c908 &lt;rctu_info&gt; &quot;H\215E\370L9\370\017\202\277&quot;
}</code></pre>
<p>So locations of <code>rctu</code> and <code>rctv</code></p>
<pre><code>rctu: 0x981610
rctv: 0x981618</code></pre>
<p>There’s only 8 bytes in between. This doesn’t look right. Because <code>rctu</code> is a static object with no payload, so it needs at least two words: info table pointer and static link field. Static link field is missing in the layout, so info table pointer of <code>rctv</code> is used as static link.</p>
<p>At this point I remember different types of objects have link fields in different places so let’s check:</p>
<pre><code>#define FUN_STATIC_LINK(p)   (&amp;(p)-&gt;payload[0])</code></pre>
<p>Because I can’t add watchpoint to this location so I do this:</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981610</code></pre>
<p>Just to count which GC we’re at</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
&gt;&gt;&gt; ignore 2 10000</code></pre>
<p>First hit</p>
<pre><code>&gt;&gt;&gt; print (StgClosure)rctv_closure
$1 = {
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000008e7a73 in evacuate_static_object at rts/sm/Evac.c:340
        stop only if q == 0x981610 (target evals)
        breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 3 times
        ignore next 9997 hits</code></pre>
<p>Let’s see if this breaks it:</p>
<pre><code>&gt;&gt;&gt; fin
&gt;&gt;&gt; print (StgClosure)rctv_closure
$2 = {
  header = {
    info = 0x981561
  },
  payload = 0x8
}</code></pre>
<p>Yep! So this function call breaks rctv:</p>
<pre><code>&gt;&gt;&gt; bt
#0  evacuate_static_object (link_field=0x981618, q=0x981610 (rctu)) at rts/sm/Evac.c:340
#1  0x00000000008e7e20 in
    evacuate (p=0x981628) at rts/sm/Evac.c:546
#2  0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#3  0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#4  0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#5  0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#6  0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#7  0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#8  0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#9  0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#10 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#11 0x000000000040d7da in
    main ()</code></pre>
<p>I’m convinced that layout of <code>rctu</code> is wrong. I’ll add some debug prints to GHC to see why the layout is generated this way, but before that I’m saving all the binaries and dump files of this session.</p>
<p>The bug should be in <code>cgTopRhsClosure</code>, the Cmm code generator for top-level closures.</p>
<p>Good thing GHC is deterministic enough these days so I get the same symbols when I recompile (later I realized that top-level symbols are deterministic enough but local ids usually change).</p>
<pre><code>gen_code
  closure_label: lvl3_rctu_closure
  descr: &lt;Parser.lvl3_rctu&gt;
  info_tbl: label: lvl3_rctu_info
            rep:HeapRep static {
                  Fun {arity: 6 fun_type: ArgGen [True, False, False, True, True]} }
  fv_details: []</code></pre>
<p>This looks fine. Let’s check <code>mkStaticClosureFields</code>:</p>
<pre><code>mkStaticClosureFields
  caf_refs: NoCafRefs
  info_lbl: lvl3_rctu_info
  is_caf: False
  padding: []
  static_link_field: []
  saved_info_field: []
  static_link_value: 3</code></pre>
<p>So this object doesn’t get a static link field. This is because the condition</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">staticClosureNeedsLink (mayHaveCafRefs caf_refs) info_tbl</a></code></pre></div>
<p>doesn’t hold.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">staticClosureNeedsLink ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">CmmInfoTable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="co">-- A static closure needs a link field to aid the GC when traversing</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="co">-- the static closure graph.  But it only needs such a field if either</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="co">--        a) it has an SRT</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="co">--        b) it&#39;s a constructor with one or more pointer fields</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6"><span class="co">-- In case (b), the constructor&#39;s fields themselves play the role</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="co">-- of the SRT.</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">staticClosureNeedsLink has_srt <span class="dt">CmmInfoTable</span>{ cit_rep <span class="fu">=</span> smrep }</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">  <span class="fu">|</span> isConRep smrep         <span class="fu">=</span> not (isStaticNoCafCon smrep)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">  <span class="fu">|</span> otherwise              <span class="fu">=</span> has_srt <span class="co">-- needsSRT (cit_srt info_tbl)</span></a></code></pre></div>
<p>So <code>has_srt</code> is <code>False</code> for this object and <code>idCafInfo</code> of this closure says it’s not caffy.</p>
<p>Just to make sure this is the problem, I modify the code to treat all top-level closures as caffy. Indeed that fixes the bug.</p>
<p>CAFness of bindings are decided in <code>hasCafRefs</code> in <code>TidyPgm</code>. Two conditions for CAFness are</p>
<ul>
<li>Top level and no arguments</li>
<li>Mentions CAFs</li>
</ul>
<p>First one obviously doesn’t hold becasue <code>rctu</code> is a function. I don’t know why the second condition doesn’t hold yet.</p>
<p><code>TidyPgm</code> operates on Core so let’s look at Core of <code>rctu</code>:</p>
<pre><code>-- RHS size: {terms: 80, types: 1,207, coercions: 0, joins: 0/0}
lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s, Packed.Bytes.Parser.Result# s Word #)
[GblId, Arity=2, Caf=NoCafRefs, Str=&lt;S,1*U&gt;&lt;S,U&gt;, Unf=OtherCon []]
lvl3_rctu
  = \ (@ s_a6Ca)
      (leftovers0_a691
         :: Packed.Bytes.Parser.Maybe#
              (Packed.Bytes.Parser.Leftovers# s_a6Ca))
      (s0_a692 :: GHC.Prim.State# s_a6Ca) -&gt;
      case leftovers0_a691 of {
        (#_|#) ds_d6Km -&gt;
          (# s0_a692,
             (# GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ (&#39;GHC.Types.TupleRep
                       &#39;[&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                         &#39;GHC.Types.LiftedRep])
                  @ (# #)
                  @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                  GHC.Prim.(##),
                GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ &#39;GHC.Types.LiftedRep
                  @ (# #)
                  @ Word
                  GHC.Prim.(##) #) #);
        (#|_#) ds_d6Kn -&gt;
          case ds_d6Kn of { (# bytes0_scqD, stream0_scqE #) -&gt;
          case bytes0_scqD of { (# arr0_scqH, off0_scqI, len0_scqJ #) -&gt;
          case GHC.Prim.&gt;# len0_scqJ 0# of {
            __DEFAULT -&gt;
              case Packed.Bytes.Parser.nextNonEmpty @ s_a6Ca stream0_scqE s0_a692
              of
              { (# ipv_s6NZ, ipv1_s6O0 #) -&gt;
              case ipv1_s6O0 of {
                (#_|#) ds3_d6JW -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          GHC.Prim.(##),
                        GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          GHC.Prim.(##) #) #);
                (#|_#) ds3_d6JX -&gt;
                  case ds3_d6JX of { (# bytes1_scqM, stream1_scqN #) -&gt;
                  case bytes1_scqM of { (# arr1_scqQ, off1_scqR, ds4_scqS #) -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          (# (# arr1_scqQ, GHC.Prim.+# off1_scqR 1#,
                                GHC.Prim.-# ds4_scqS 1# #),
                             stream1_scqN #),
                        GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          a1_rcbR #) #)
                  }
                  }
              }
              };
            1# -&gt;
              (# s0_a692,
                 (# GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ (&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                             &#39;GHC.Types.LiftedRep])
                      @ (# #)
                      @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                      (# (# arr0_scqH, GHC.Prim.+# off0_scqI 1#,
                            GHC.Prim.-# len0_scqJ 1# #),
                         stream0_scqE #),
                    GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ &#39;GHC.Types.LiftedRep
                      @ (# #)
                      @ Word
                      a1_rcbR #) #)
          }
          }
          }
      }</code></pre>
<p>This is huge and I’m not going to check this by hand. However at this point I realize that the condition for evacuating a <code>FUN_STATIC</code> is</p>
<pre><code>case FUN_STATIC:
    if (info-&gt;srt_bitmap != 0) {
        evacuate_static_object(FUN_STATIC_LINK((StgClosure *)q), q);
    }
    return;</code></pre>
<p>So this is not marked as CAF, but its SRT bitmap is not empty. Perhaps the bug is in the SRT bitmap.</p>
<p>I also try this in gdb:</p>
<pre><code>&gt;&gt;&gt; set get_itbl(&amp;rctu_closure)-&gt;srt_bitmap = 0</code></pre>
<p>This also fixes it. Now let’s figure out why SRT bitmap of <code>rctu</code> (which is supposed to be a non-CAF) is 1.</p>
<p>I look again at the definition of <code>rctu</code> and it seems like <code>a1_rcbR</code> is a free variable.</p>
<pre><code>a1_rcbR :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [5##];</code></pre>
<p>However because this is not a CAF it shouldn’t make <code>rctu</code> CAF.</p>
<p>I stare at the code aimlessly for a while until I realize something interesting. This is the STG for <code>rctu</code> after unarisation:</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=&lt;S,1*U&gt;&lt;S,U&gt;,
 Unf=OtherCon []] =
    [] \r [us_gcwc us_gcwd us_gcwe us_gcwf us_gcwg void_0E]
        case us_gcwc of tag_gcwh {
          __DEFAULT -&gt;
              (#,,,,,,#) [1#
                          Control.Exception.Base.absentError
                          Control.Exception.Base.absentError
                          0##
                          0##
                          1#
                          Control.Exception.Base.absentError];
          2# -&gt;
              case &gt;# [us_gcwg 0#] of {
                __DEFAULT -&gt;
                    case Packed.Bytes.Parser.nextNonEmpty us_gcwe GHC.Prim.void# of {
                      (#,,,,#) us_gcwi us_gcwj us_gcwk us_gcwl us_gcwm -&gt;
                          case us_gcwi of tag_gcwn {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [1#
                                            Control.Exception.Base.absentError
                                            Control.Exception.Base.absentError
                                            0##
                                            0##
                                            1#
                                            Control.Exception.Base.absentError];
                            2# -&gt;
                                case -# [us_gcwm 1#] of sat_scuk {
                                  __DEFAULT -&gt;
                                      case +# [us_gcwl 1#] of sat_scuj {
                                        __DEFAULT -&gt;
                                            (#,,,,,,#) [2#
                                                        us_gcwj
                                                        us_gcwk
                                                        sat_scuj
                                                        sat_scuk
                                                        2#
                                                        a1_rcbR];
                                      };
                                };
                          };
                    };
                1# -&gt;
                    case -# [us_gcwg 1#] of sat_scur {
                      __DEFAULT -&gt;
                          case +# [us_gcwf 1#] of sat_scuq {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [2# us_gcwd us_gcwe sat_scuq sat_scur 2# a1_rcbR];
                          };
                    };
              };
        };</code></pre>
<p>This has two free variables: <code>a1_rcbR</code> and <code>Control.Exception.Base.absentError</code>. <code>a1_rcbR</code> is clearly not a CAF, but maybe <code>absentError</code> is? Because <code>absentError</code> references are generated in unarise, which happens much later than <code>TidyPgm</code> (right before generating Cmm), <code>TidyPgm</code> can’t take those into account.</p>
<p><code>Id</code> for <code>absentError</code> is generated using <code>vanillaIdInfo</code> which sets the CAF-ness field as <code>MayHaveCafRefs</code>. So clearly <code>absentError</code> is a CAFFY.</p>
<p>So in summary, we introduce references to CAFs in <code>UnariseStg</code> which happens later than <code>TidyPgm</code>. The code generator is somehow handles this correctly by generating a SRT for this function and setting the info table bitmap correctly. However object layout generator (in <code>cgTopRhsClosure</code>) only uses the information generated in <code>TidyPgm</code>, so we get this mismatch of SRT information of this function.</p>
<p>Some ways to fix this:</p>
<ul>
<li>Update binder ids in unarise if we introduced an <code>absentError</code></li>
<li>Conservatively treat unboxed sums as CAFFY in <code>TidyPgm</code></li>
<li>Mark <code>absentError</code> as non-CAF (I don’t know if it has to be a CAF, I think error ids are conservatively marked as CAFs)</li>
</ul>
<p>The whole thing took 4:47 hours.</p>]]></summary>
</entry>
<entry>
    <title>On malloc and brk/sbrk</title>
    <link href="http://osa1.net/posts/2018-04-08-malloc-brk-sbrk.html" />
    <id>http://osa1.net/posts/2018-04-08-malloc-brk-sbrk.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Read about <code>malloc()</code> on Linux in lecture notes and even non-ancient books like The Linux Programming Interface (published on 2010) and you’ll see a lot of mentions to <code>brk()</code> and <code>sbrk()</code> system calls. They then move on to talk about <code>mmap()</code>, and at that point you probably start wondering how they interact.</p>
<p>The problem is, because <code>mmap()</code> lets you map stuff in your program’s address space, it seems like you can easily break <code>brk</code>/<code>sbrk</code> by mapping stuff right after the current program break. Here’s a program that does exactly that:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">// mmap() something right after program break, then increase it by malloc-ing stuff</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="dt">long</span> page_size = sysconf(_SC_PAGESIZE);</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    printf(<span class="st">&quot;Page size:             %ld</span><span class="sc">\n</span><span class="st">&quot;</span>, page_size);</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="dt">void</span>* brk = sbrk(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    printf(<span class="st">&quot;Current program break: %p</span><span class="sc">\n</span><span class="st">&quot;</span>, brk);</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="co">// mmap() right after program break</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    <span class="dt">void</span>* mmap_ret = mmap(</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">            brk, page_size, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, <span class="dv">-1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    printf(<span class="st">&quot;mmap() returned:       %p</span><span class="sc">\n</span><span class="st">&quot;</span>, mmap_ret);</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">    assert(mmap_ret == brk);</a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    <span class="co">// Allocate until brk changes</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    <span class="dt">void</span>* new_brk = sbrk(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">    <span class="dt">void</span>* ret = malloc(page_size);</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">    <span class="cf">for</span> (;;)</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">    {</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">        <span class="cf">if</span> (!ret)</a>
<a class="sourceLine" id="cb1-31" data-line-number="31">        {</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">            printf(<span class="st">&quot;malloc() failed</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-33" data-line-number="33">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">        }</a>
<a class="sourceLine" id="cb1-35" data-line-number="35"></a>
<a class="sourceLine" id="cb1-36" data-line-number="36">        <span class="cf">if</span> (new_brk != brk)</a>
<a class="sourceLine" id="cb1-37" data-line-number="37">        {</a>
<a class="sourceLine" id="cb1-38" data-line-number="38">            printf(<span class="st">&quot;brk changed</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-39" data-line-number="39">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb1-40" data-line-number="40">        }</a>
<a class="sourceLine" id="cb1-41" data-line-number="41"></a>
<a class="sourceLine" id="cb1-42" data-line-number="42">        <span class="cf">if</span> (ret &gt; brk)</a>
<a class="sourceLine" id="cb1-43" data-line-number="43">        {</a>
<a class="sourceLine" id="cb1-44" data-line-number="44">            printf(<span class="st">&quot;ret &gt; brk</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-45" data-line-number="45">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb1-46" data-line-number="46">        }</a>
<a class="sourceLine" id="cb1-47" data-line-number="47"></a>
<a class="sourceLine" id="cb1-48" data-line-number="48">        ret = malloc(page_size);</a>
<a class="sourceLine" id="cb1-49" data-line-number="49">        new_brk = sbrk(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-50" data-line-number="50">    }</a>
<a class="sourceLine" id="cb1-51" data-line-number="51"></a>
<a class="sourceLine" id="cb1-52" data-line-number="52">    printf(<span class="st">&quot;New brk:               %p</span><span class="sc">\n</span><span class="st">&quot;</span>, new_brk);</a>
<a class="sourceLine" id="cb1-53" data-line-number="53">    printf(<span class="st">&quot;ret:                   %p</span><span class="sc">\n</span><span class="st">&quot;</span>, ret);</a>
<a class="sourceLine" id="cb1-54" data-line-number="54"></a>
<a class="sourceLine" id="cb1-55" data-line-number="55">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-56" data-line-number="56">}</a></code></pre></div>
<p>So we read the program break, <code>mmap()</code> stuff right after it, then <code>malloc()</code> page-sized space until the program break changes. The idea is if we actually increment the program break, we’ll end up re-using <code>mmap()</code>d area.</p>
<p>Of course this does not happen. If you run this, you’ll see something like:</p>
<pre><code>Page size:             4096
Current program break: 0x1efb000
mmap() returned:       0x1efb000
ret &gt; brk
New brk:               0x1efb000
ret:                   0x7fdb72d8f010</code></pre>
<p>So the <code>malloc()</code> implementation doesn’t care about program break at all, instead it uses <code>mmap()</code>, probably with <code>NULL</code> as the <code>addr</code> parameter, to get a fresh location in the address space.</p>
<p>Of course this is all obvious if you’re already familiar with this stuff. <code>sbrk()</code> just can’t work with <code>mmap()</code>. Try adding these lines to the program above, right before the return statement:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" data-line-number="1">    <span class="co">// Try to increment program break manually</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="dt">void</span>* sbrk_ret = sbrk(page_size);</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    printf(<span class="st">&quot;sbrk_ret:              %p</span><span class="sc">\n</span><span class="st">&quot;</span>, sbrk_ret);</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    printf(<span class="st">&quot;New brk:               %p</span><span class="sc">\n</span><span class="st">&quot;</span>, sbrk(<span class="dv">0</span>));</a></code></pre></div>
<p>You’ll see that <code>sbrk()</code> returns something like <code>0xffffffffffffffff</code> ( <code>(void*)-1</code> ) and the program break does not change.</p>
<p>Really what confused me is all these over-simplified lecture notes and book chapters.</p>]]></summary>
</entry>
<entry>
    <title>Three runtime optimizations done by GHC's GC</title>
    <link href="http://osa1.net/posts/2018-03-16-gc-optimizations.html" />
    <id>http://osa1.net/posts/2018-03-16-gc-optimizations.html</id>
    <published>2018-03-16T00:00:00Z</published>
    <updated>2018-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working on GHC’s GC code I realized that it does some runtime optimizations. One of those I already knew from another language, but the other two were quite interesting to me because they’re related with laziness. I wouldn’t think consequences of laziness reach this far into the runtime system. It turns out it does; disabling those optimizations make programs run significantly slower.</p>
<p>Because I almost read the whole code line by line, I believe this list is exhaustive. The code is taken from the source code but significantly simplified.</p>
<p>If you’re not familiar with GHC’s heap object layout and info tables etc., I suggest reading <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">the wiki page</a> before moving on the rest of the post.</p>
<h1 id="replacing-small-int-and-char-closures-with-statically-initialized-shared-closures">1. Replacing small Int and Char closures with statically initialized, shared closures</h1>
<p><code>Int</code> and <code>Char</code> closures have one non-pointer field for the actual integer and character values, as can be seen in GHCi:</p>
<pre><code>λ&gt; :info Int
data Int = GHC.Types.I# GHC.Prim.Int#     -- Defined in ‘GHC.Types’
λ&gt; :info Char
data Char = GHC.Types.C# GHC.Prim.Char#   -- Defined in ‘GHC.Types’</code></pre>
<p>The corresponding closure type for closures with one non-pointer and no pointers is <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/includes/rts/storage/ClosureTypes.h#L25"><code>CONSTR_0_1</code></a>. The garbage collector <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L656">needs to check closure type before copying an object</a> to decide how many bytes to copy (and also to decide what pointers to follow and copy the pointed object, but this happens in a later stage). When it finds a <code>CONSTR_0_1</code> it checks if it’s actually an <code>Int</code> or <code>Char</code> closure, if it is, it checks if the payload (the actual <code>Int</code> and <code>Char</code> values) is within a range. If it is then we know that we have statically-allocated <code>Int</code> or <code>Char</code> closure what is identical to the one we’re copying, so we return address to the statically allocated one rather than copying the closure and returning the new address of the copied closure. This way we avoid having multiple closures for <code>1 :: Int</code>, for example. The code (simplified, some comments by me):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="cf">case</span> CONSTR_0_1:</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="co">// Constructor with one non-pointer field. Read the field.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    StgWord w = (StgWord)q-&gt;payload[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="cf">if</span> (<span class="co">// is it a Char?</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        info == Czh_con_info &amp;&amp;</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="co">// is the value in range?</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        (StgChar)w &lt;= MAX_CHARLIKE)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="co">// return address to statically allocated Char closure</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        *p =  TAG_CLOSURE(tag, (StgClosure *)CHARLIKE_CLOSURE((StgChar)w));</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="cf">else</span> <span class="cf">if</span> (<span class="co">// is it an Int?</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">             info == Izh_con_info &amp;&amp;</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">             <span class="co">// is the value in range?</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">             (StgInt)w &gt;= MIN_INTLIKE &amp;&amp; (StgInt)w &lt;= MAX_INTLIKE)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    {</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">        <span class="co">// return address to statically allocated Int closure</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        *p = TAG_CLOSURE(tag, (StgClosure *)INTLIKE_CLOSURE((StgInt)w));</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">    <span class="co">// otherwise copy the object</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24">    {</a>
<a class="sourceLine" id="cb2-25" data-line-number="25">        copy_tag_nolock(p,info,q,sizeofW(StgHeader)+<span class="dv">1</span>,gen_no,tag);</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">}</a></code></pre></div>
<p>What are the ranges here? Looking at the <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/StgMiscClosures.cmm#L679-L974">definition</a>, we see that integers in range [-16, 16] and the whole ASCII character set is covered.</p>
<p>Here’s a small program that shows the effect of this optimization:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">GHC.Stats</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Mem</span> (performMajorGC)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">seqIntList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">seqIntList []       a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">seqIntList (i <span class="fu">:</span> is) a <span class="fu">=</span> i <span class="ot">`seq`</span> is <span class="ot">`seqIntList`</span> a</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">let</span> lst <span class="fu">=</span> [ <span class="dv">0</span> <span class="fu">..</span> <span class="dv">15</span> ]</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="co">-- let lst = [ 17 .. 32 ] -- enable this on the second run</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="co">-- evaluate the list</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    lst <span class="ot">`seqIntList`</span> return ()</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="co">-- collect any thunks, do the optimization if possible, update stats</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    performMajorGC</a>
<a class="sourceLine" id="cb3-20" data-line-number="20"></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    rts_stats <span class="ot">&lt;-</span> getRTSStats</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    putStrLn (<span class="st">&quot;Live data: &quot;</span> <span class="fu">++</span> show (gcdetails_live_bytes (gc rts_stats)) <span class="fu">++</span> <span class="st">&quot; bytes&quot;</span>)</a>
<a class="sourceLine" id="cb3-23" data-line-number="23"></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    <span class="co">-- to make sure our list won&#39;t be collected</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">    lst <span class="ot">`seqIntList`</span> return ()</a></code></pre></div>
<p>Run it with:</p>
<pre><code>ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T</code></pre>
<p>On the second run, disable the first list and enable the second one. You’ll see this output:</p>
<pre><code>$ ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T
[1 of 1] Compiling Main             ( eq.hs, eq.o )
Linking eq ...
Live data: 2224 bytes

$ ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T
[1 of 1] Compiling Main             ( eq.hs, eq.o )
Linking eq ...
Live data: 2480 bytes</code></pre>
<p>So second program has 256 bytes more live data. Let’s check if that makes sense. The first program doesn’t have any heap-allocated <code>Int</code> closures, because all of the <code>Int</code> in the program are within the range of statically allocated <code>Int</code> closures. Second one has 16 <code>Int</code> closures. An <code>Int</code> closure is two words: a pointer to the <code>I#</code> info table, and an actual integer value in the payload, so that’s 16 bytes. 16 (number of <code>Int</code> closures) * 16 (<code>Int</code> closure size) = 256.</p>
<p>I know at least one another language, Python, does this as well:</p>
<pre><code>Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 1
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; x = 100000000000
&gt;&gt;&gt; y = 100000000000
&gt;&gt;&gt; x is y
False</code></pre>
<p>Although I’m not sure if it does this during garbage collection.</p>
<h1 id="shorting-out-indirections">2. Shorting out indirections</h1>
<p>This is related with how lazy evaluation is implemented so we’ll first take a look at the generated code for a simple thunk update. When we compile the following program: (to keep things simple we disable optimizations)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    i <span class="ot">&lt;-</span> readLn</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    print (fib i)</a></code></pre></div>
<p>in STG level we get this function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sat_s31Q <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    \r [i_s31O]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="kw">let</span> { sat_s31P <span class="fu">=</span> \u [] fib_rqh i_s31O;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        } <span class="kw">in</span>  print <span class="fu">$</span>fShowInt sat_s31P;</a></code></pre></div>
<p>Here <code>fib_rqh</code> is the <code>fib</code> function, and <code>sat_s31P</code> is the thunk for <code>fib i</code>. First let’s take a look at how this thunk is evaluated in the use site: (Cmm syntax)</p>
<pre><code>I64[Sp - 16] = stg_upd_frame_info;
P64[Sp - 8] = _s31P::P64;
_s31O::P64 = P64[_s31P::P64 + 16];
R2 = _s31O::P64;
Sp = Sp - 16;
call fib_rqh_info(R2) args: 24, res: 0, upd: 24;</code></pre>
<p>So we push the thunk (<code>_s31P</code>), then <code>stg_upd_frame_info</code> to the stack, and jump to the code for the <code>fib</code> function, passing the argument in <code>R2</code>.</p>
<p>I won’t show the code (because it’s large and complex), but the code for <code>fib</code> puts the return value in <code>R1</code>, pops the stack, and jump to the code for the popped stack frame, which is <code>stg_upd_frame_info</code>.</p>
<p>At this point we have the return value of <code>fib</code> in <code>R1</code>, and thunk to update at the bottom of the stack.</p>
<p>The code for <code>stg_upd_frame_info</code> is as follows: (simplified, see the original version <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/Updates.cmm#L28-L38">here</a>)</p>
<pre><code>INFO_TABLE_RET ( stg_upd_frame, // label
                 UPDATE_FRAME,  // frame type
                 w_ info_ptr,   // info ptr
                 p_ updatee )   // thunk to update at the bottom of the stack
    return (P_ ret) // in R1 we expect the value to update the thunk with
{
    StgInd_indirectee(updatee) = ret;       // (1)
    SET_INFO(updatee, stg_BLACKHOLE_info);  // (2)
    ...
    return (ret);
}</code></pre>
<p>This basically replaces the thunk’s (<code>_s31P</code>) info table pointer with <code>stg_BLACKHOLE_info</code> in line (2) (effectively making the thunk an indirection), and writes pointer to the evaluated object to the payload in line (1).</p>
<p>Now any code that uses this value needs to follow the pointer written to what was originally a thunk in line (1). This is done by the <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/StgMiscClosures.cmm#L295">entry code of <code>stg_BLACKHOLE_info</code></a>.</p>
<p>Now, because the GC copies objects from one heap to another, and updates any references to these moved objects in thread stacks (and in other roots), we can follow any indirections when copying blackhole objects, and replace references in thread stacks to the blackhole object with a reference to the object pointed to by the blackhole object. <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L732-L755">The code</a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="cf">case</span> BLACKHOLE:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    StgClosure *r;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">const</span> StgInfoTable *i;</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    r = ((StgInd*)q)-&gt;indirectee;</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="cf">if</span> (GET_CLOSURE_TAG(r) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        i = r-&gt;header.info;</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="cf">if</span> (IS_FORWARDING_PTR(i)) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">            r = (StgClosure *)UN_FORWARDING_PTR(i);</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">            i = r-&gt;header.info;</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        }</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        <span class="cf">if</span> (i == &amp;stg_TSO_info</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">            || i == &amp;stg_WHITEHOLE_info</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">            || i == &amp;stg_BLOCKING_QUEUE_CLEAN_info</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">            || i == &amp;stg_BLOCKING_QUEUE_DIRTY_info) {</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">            copy(p,info,q,sizeofW(StgInd),gen_no);</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">            <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">        ASSERT(i != &amp;stg_IND_info);</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    q = r;</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">    *p = r;</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">    <span class="cf">goto</span> loop;</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">}</a></code></pre></div>
<p>I don’t understand all the details in this code, but I think the important bits are the <code>q-&gt;indirectee</code> line which follows the pointer written in line (1) above, and <code>goto loop</code> which makes the garbage collector copy and return the object pointed by the blackhole.</p>
<p>After this we no longer have to follow a pointer to our evaluated thunk. Instead references to the thunk become references to the evaluated object.</p>
<h1 id="selector-thunk-evaluation">3. Selector thunk evaluation</h1>
<p>A selector thunk is a thunk of this form: (<a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/compiler/codeGen/StgCmmBind.hs#L267-L297">code</a>)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="dt">C</span> x1 <span class="fu">...</span> xn <span class="ot">-&gt;</span> xm</a></code></pre></div>
<p>where <code>1 &lt;= m &lt;= n</code>, and <code>x</code> is a variable. The problem with such a thunk is that it keeps all of the fields of <code>x</code> live until the selector thunk is evaluated, even when <code>x</code> is evaluated by some other code. As an example where this happens, suppose we have this record:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">R</span> <span class="fu">=</span> <span class="dt">R</span> {<span class="ot"> _i1 ::</span> <span class="dt">Int</span>,<span class="ot"> _i2 ::</span> <span class="dt">Int</span>, <span class="fu">...</span> other fields <span class="fu">...</span> }</a></code></pre></div>
<p>then in a function we take <code>R</code> as parameter, and use the fields:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f r <span class="fu">=</span> _i1 r <span class="fu">+</span> _i2 r</a></code></pre></div>
<p>Here <code>_i1 r</code> and <code>_i2 r</code> are selector thunks. Now suppose that the parameter to this function was already evaluated before the function is called. In this case the thunk that holds the this function application will keep all of <code>r</code> live even though only <code>_i1</code> and <code>_i2</code> are needed.</p>
<p>It turns out this problem was known since around <del>1985</del> 1981. <del>To my knowledge, Wadler was the first one to suggest solving these kind of “leaks” in the garbage collector</del> <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> (see <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> for correction). The idea is that while the GC copies these thunks it checks if the “selectee” is already evaluated. If so the GC evaluates the selector thunk during copying, and copies the evaluated form. Because selectors thunks are so simple (the exact shape of a selector thunk is well specified and it can’t do anything other than accessing a field) evaluation of these are just a matter of indexing the selectee’s payload. The function that does this is <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L1002">here</a>. The whole story is complicated because of concurrency concerns (e.g. another GC thread can also evaluate the thunk at the same time), but the actual optimization starts around line 1104 by looking at info table at the selectee. If it’s a constructor, then we access to the field and return it. Otherwise it’s a thunk and we copy it as usual.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In each cycle a copying garbage collector copies live data in a heap to another heap and abandons the old heap. It turns out this kind of garbage collection is really convenient for implementing optimizations described above. The code that traverses all live data, copies it, and updates the roots is already there. Doing updates on objects while copying is just a matter of adding a few more lines in the copying function.</p>
<p>In a non-copying collector this is much trickier, because the collector doesn’t actually need to update roots or the data. For example, to implement optimizations (2) in a mark-sweep collector we have to somehow keep track of the location where we found the pointer to the object we’re currently marking. Then, if the object became an indirection, we have to update the source location and should not mark the indirection object, because some other object may have a reference to it, and we have to update that reference too. In short, it’s certainly possible, but much trickier. Mark phase gets more complicated.</p>
<p>In summary,</p>
<ul>
<li><p>Generational copying collectors are known to be a good fit for functional languages. It turns out if your language is also lazy they’re even better fit.</p></li>
<li><p>Laziness have far-reaching consequences. The optimizations (2) and (3) are really essential to get good performance out of lazy programs (try commenting out those lines in the GC!), and they require support from the GC.</p></li>
</ul>
<hr />
<p>This post is submitted to <a href="https://www.reddit.com/r/haskell/comments/852jfc/three_runtime_optimizations_done_by_ghcs_gc/">/r/haskell</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>“Fixing some space leaks with a garbage collector”, Wadler, 1987.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Correction: Wadler was the first one to write about it in 1987, but Lennart Augustsson came up with this solution around 1981, and <a href="https://www.reddit.com/r/haskell/comments/852jfc/three_runtime_optimizations_done_by_ghcs_gc/dvuwtl0/">according him him</a> David Turner came up with the solution even before him.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Fuzzy module loading in GHCi</title>
    <link href="http://osa1.net/posts/2017-10-26-ghc-fuzzy-module-loading.html" />
    <id>http://osa1.net/posts/2017-10-26-ghc-fuzzy-module-loading.html</id>
    <published>2017-10-26T00:00:00Z</published>
    <updated>2017-10-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/ghci.html#ghci-cmd-:def">A GHCi macro</a> is just a function of type <code>String -&gt; IO String</code>. The argument is parameter of the macro, and return value is evaluated by GHCi as a command.</p>
<p>Using this and the <a href="http://hackage.haskell.org/package/process"><code>process</code></a> library we can implement a fuzzy module loader that works inside ghci:</p>
<p><img src="/images/fuzzy_ghci_load.gif" /></p>
<p>(sorry for the gif quality)</p>
<p>Here I’m using <a href="https://github.com/junegunn/fzf">fzf</a> as the fuzzy file finder. Code for defining the macro:</p>
<pre><code>import System.IO (withFile, IOMode (WriteMode))
import System.Process (runProcess, waitForProcess)

:{
let loadFuzzy _ = do
      let f = &quot;/tmp/fzf_out&quot;
      withFile f WriteMode $ \h -&gt; do
        p &lt;- runProcess &quot;fzf&quot; [] Nothing Nothing Nothing (Just h) Nothing
        _ &lt;- waitForProcess p
        out &lt;- readFile f
        return (&quot;:load &quot; ++ init out)
:}

:def l loadFuzzy</code></pre>
<p>Add this code to your global ghci config file (<code>~/.ghci</code>) or your project-wide <code>.ghci</code> (at the project root).</p>
<p>Only problem here is the <code>process</code> dependency: when you use <code>stack repl</code> or <code>cabal repl</code>, <code>process</code> won’t be importable in GHCi unless the project you’re loading into GHCi already has it as a dependency. One solution is to pass <code>-package process</code> to <code>cabal repl</code> or <code>--ghci-options=&quot;-package process&quot;</code> to <code>stack repl</code>. Because <code>process</code> is distributed with GHC this will always work.</p>]]></summary>
</entry>
<entry>
    <title>A parallel scheduler in 50 lines of Haskell</title>
    <link href="http://osa1.net/posts/2017-10-16-a-parallel-scheduler.html" />
    <id>http://osa1.net/posts/2017-10-16-a-parallel-scheduler.html</id>
    <published>2017-10-16T00:00:00Z</published>
    <updated>2017-10-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s a problem:</p>
<ul>
<li>You have N resources.</li>
<li>You have M tasks.</li>
<li>Each task requires exclusive access to a subset of the resources.</li>
<li>Tasks can be run in parallel.</li>
</ul>
<p>Implement a scheduler that runs these tasks in parallel, utilizing available resources as much as possible.</p>
<p>The code I’ll show here piggybacks on GHC RTS for scheduling. But for that we first have to implement our resources and tasks in a way that exposes necessary information to GHC’s scheduler. The idea is simple and fun to implement, but I can’t recommended using it in production :-) Scheduling is a hard problem, with many variations, and I’ve only recently started reading about it. This solution is a fun one than anything else.</p>
<hr />
<p>The idea is simple; we implement resources as <code>MVar</code>s and tasks as threads. Threads (tasks) take the <code>MVar</code>s before performing the operation. Because threads are scheduled by GHC RTS, GHC handles scheduling of our tasks. Because of fairness properties of <code>MVar</code>s, our threads are scheduled “fairly”, e.g. all tasks eventually finish even when we have infinitely many tasks.</p>
<p>A resource is an abstract object with a lock and unique identifier:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Resource</span> <span class="fu">=</span> <span class="dt">Resource</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  {<span class="ot"> _resourceName ::</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> _resourceId   ::</span> <span class="dt">Unique</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ,<span class="ot"> _resourceLock ::</span> <span class="dt">MVar</span> ()</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Resource</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  show <span class="fu">=</span> T.unpack <span class="fu">.</span> _resourceName</a></code></pre></div>
<p><code>_resourceName</code> is just a string to be used for tracing program execution.</p>
<p>A <code>Unique</code> is an integer that can be used in at most one resource:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Unique</span> <span class="fu">=</span> <span class="dt">Unique</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>Using <code>Unique</code> we can define a total order for <code>Resource</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Resource</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  (<span class="fu">==</span>) <span class="fu">=</span> (<span class="fu">==</span>) <span class="ot">`on`</span> _resourceId</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Resource</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  compare <span class="fu">=</span> comparing _resourceId</a></code></pre></div>
<p>A task that requires exclusive access to a subset of all resources can be implemented using <code>withResources</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">withResources ::</span> (<span class="dt">MonadLogger</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m) <span class="ot">=&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">withResources locks a <span class="fu">=</span> acquire_locks (S.toList locks)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    acquire_locks ls <span class="fu">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">      [] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        a</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">      l <span class="fu">:</span> ls&#39; <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        logDebug (<span class="st">&quot;taking lock &quot;</span> <span class="fu">&lt;&gt;</span> (_resourceName l))</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">        withMVar (_resourceLock l) <span class="fu">$</span> \() <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">          acquire_locks ls&#39;</a></code></pre></div>
<p>Note that when all tasks are implemented using this function a deadlock won’t occur: resources are ordered, and <code>S.toList</code> generates a sorted list, which in turn causes <code>acquire_locks</code> to take locks in order, effectively implementing <a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">Dijkstra’s resource hierarchy solution to the dining philosophers problem</a>.</p>
<p>Here are three task generators:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Task</span> <span class="fu">=</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  {<span class="ot"> runTask ::</span> forall m <span class="fu">.</span> (<span class="dt">MonadLogger</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m) <span class="ot">=&gt;</span> m () }</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">mkFastTask ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">mkFastTask i res <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="dt">Task</span> <span class="fu">$</span> withResources res <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">      logDebug (<span class="st">&quot;Performing &quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">      threadDelay (<span class="dv">500</span><span class="ot"> ::</span> <span class="dt">Milliseconds</span>)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">      logDebug (<span class="st">&quot;Fast task done (&quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i) <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">mkSlowTask ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">mkSlowTask i res <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="dt">Task</span> <span class="fu">$</span> withResources res <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      logDebug (<span class="st">&quot;Performing &quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i))</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">      threadDelay (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Seconds</span>)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">      logDebug (<span class="st">&quot;Slow task done (&quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i) <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="ot">mkCrashingTask ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Resource</span> <span class="ot">-&gt;</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">mkCrashingTask i res <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="dt">Task</span> <span class="fu">$</span> withResources res <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">      logDebug (<span class="st">&quot;Performing &quot;</span> <span class="fu">&lt;&gt;</span> T.pack (show i))</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">      error <span class="st">&quot;task failed&quot;</span></a></code></pre></div>
<p>Integer arguments are just for tracing task execution in program output. <code>mkFastTask</code> generates a task that takes 500 milliseconds to run. <code>mkSlowTask</code> generates a task that takes 3 seconds. <code>mkCrashingTask</code> makes a task that throws an exception, demonstrating that we release resources properly on exceptions.</p>
<p>Finally, the scheduler just spawns tasks using <code>forkIO</code> or <code>async</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">schedule ::</span> (<span class="dt">MonadLogger</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m, <span class="dt">Forall</span> (<span class="dt">Pure</span> m)) <span class="ot">=&gt;</span> [<span class="dt">Task</span>] <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">schedule tasks <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    thrs <span class="ot">&lt;-</span> forM tasks <span class="fu">$</span> \(<span class="dt">Task</span> task) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">              async (task <span class="ot">`catch`</span> (\(<span class="ot">e ::</span> <span class="dt">SomeException</span>) <span class="ot">-&gt;</span> logDebug <span class="st">&quot;Task failed&quot;</span>))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    forM_ thrs wait</a></code></pre></div>
<p>Here’s an example run</p>
<pre><code>taking lock resource5
Performing 0
taking lock resource0
Performing 1
taking lock resource2
taking lock resource6
taking lock resource7
Performing 2
Task failed
taking lock resource6
Performing 3
taking lock resource8
Performing 4
taking lock resource1
taking lock resource2
Performing 5
Task failed
taking lock resource2
taking lock resource3
taking lock resource8
taking lock resource0
taking lock resource3
taking lock resource4
Performing 9
Fast task done (3)
Fast task done (9)
Fast task done (0)
Slow task done (1)
taking lock resource4
taking lock resource8
Slow task done (4)
Performing 6
Fast task done (6)
taking lock resource7
Performing 8
Task failed
Performing 7
Slow task done (7)</code></pre>
<p>The whole code that randomly generates resources and tasks and then runs them is <a href="https://gist.github.com/osa1/e7416f6a0f299f88f275bb8d56a31da3">here</a>. It uses quite a lot of dependencies because it was extracted from a larger program, and I’m too lazy to make it smaller and simpler. I provided a <code>stack.yaml</code> so hopefully it’s still not too hard to run.</p>]]></summary>
</entry>
<entry>
    <title>More Rust woes</title>
    <link href="http://osa1.net/posts/2017-10-08-more-rust-woes.html" />
    <id>http://osa1.net/posts/2017-10-08-more-rust-woes.html</id>
    <published>2017-10-08T00:00:00Z</published>
    <updated>2017-10-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the third part of the series (<a href="http://osa1.net/posts/2016-03-28-rust-brwchk-woes.html">1</a>, <a href="http://osa1.net/posts/2016-09-11-more-rust-problems.html">2</a>) we’re going to look at two curious cases, first one related with “drop checker” and the second one with “borrow checker”.</p>
<p>(examples below are tested with <code>rustc 1.22.0-nightly (05f8ddc46 2017-10-07)</code>)</p>
<h1 id="redundant-semicolon-fixes-borrow-or-drop-checker">1. Redundant semicolon fixes borrow (or drop) checker</h1>
<p>It turns out if you’re getting a weird borrow checker error about something not living long enough to be dropped you can sometimes fix it by adding more semicolons.</p>
<p>The error message itself is weird because intuitively you’d think that for something to be dropped it should first become dead, but the error message says something like “<code>x</code> dropped here while still borrowed”. Because the variable is not dropped explicitly by the user, this error message is actually complaining about compiler’s behavior not being consistent in itself.</p>
<p>Here’s an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">use</span> std::sync::Arc;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">use</span> std::sync::Mutex;</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="kw">let</span> s: Arc&lt;Mutex&lt;<span class="dt">i32</span>&gt;&gt; = Arc::new(Mutex::new(<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="kw">match</span> s.lock().unwrap() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        _ =&gt; <span class="op">{}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="op">}</span></a></code></pre></div>
<p>This fails to compile with:</p>
<pre><code>error[E0597]: `s` does not live long enough
 --&gt; src/main.rs:9:1
  |
6 |     match s.lock().unwrap() {
  |           - borrow occurs here
...
9 | }
  | ^ `s` dropped here while still borrowed
  |
  = note: values in a scope are dropped in the opposite order they are created</code></pre>
<p>Solution? Add more semicolons! In this example, just put a semicolon after the match expression and it compiles fine.</p>
<p>Here’s <a href="https://github.com/rust-lang/rust/issues/21114#issuecomment-312447832">one more example</a>. It turns out questions about this error message are regularly asked on the IRC channel.</p>
<p><a href="https://github.com/rust-lang/rust/issues/21114">#21114</a> reported this issue on Jan 14, 2015, but no progress has been made towards a solution so far. It’s not clear if non-lexical lifetimes will help solving this.</p>
<h1 id="match-expression-keeps-values-alive-longer-than-necessary">2. <code>match</code> expression keeps values alive longer than necessary</h1>
<p>This problem is kind of special. All other problems mentioned in this series were about borrow checker being too strict. This one is different: it causes runtime bugs.</p>
<p><code>match</code> expression keeps the value to be examined (sometimes called <code>scrutinee</code> in Haskell land) alive longer than necessary. Because alive values are not dropped, if you rely on dynamic borrow checks in the scrutinee and in the branches, your checks fail. Here’s an example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">use</span> std::sync::Arc;</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">use</span> std::sync::Mutex;</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">struct</span> S(<span class="dt">i32</span>);</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">impl</span> S <span class="op">{</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">pub</span> <span class="kw">fn</span> get_int(&amp;<span class="kw">self</span>) -&gt; <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        <span class="kw">self</span>.<span class="dv">0</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    <span class="kw">pub</span> <span class="kw">fn</span> set_int(&amp;<span class="kw">mut</span> <span class="kw">self</span>, i: <span class="dt">i32</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">        <span class="kw">self</span>.<span class="dv">0</span> = i;</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    <span class="kw">let</span> s = Arc::new(Mutex::new(S(<span class="dv">0</span>)));</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="kw">match</span> s.lock().unwrap().get_int() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">        i =&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">            s.lock().unwrap().set_int(i);</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">        <span class="op">}</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    <span class="op">}</span>;</a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="op">}</span></a></code></pre></div>
<p>(notice how I use a redundant semicolon after the match expression, to fix #1)</p>
<p>Even though <code>get_int()</code> returns in <code>i32</code> as a value, not a reference, the <code>MutexGuard</code> returned by <code>Mutex::lock()</code> is kept alive in the branches of this <code>match</code> expression, so the second <code>Mutex::lock()</code> call causes a deadlock. Solution? Use a <code>let</code> expression:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">let</span> x = s.lock().unwrap().get_x();</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">match</span> x <span class="op">{</span> ... <span class="op">}</span></a></code></pre></div>
<p>This problem makes <code>match &lt;expr&gt; { ... }</code> less useful than <code>let x = &lt;expr&gt;; match x { ... }</code>.</p>
<p><a href="https://github.com/rust-lang/rust/issues/38355">#38355</a> reported this issue on Dec 14, 2016, but no progress towards a solution has been made so far.</p>]]></summary>
</entry>

</feed>
