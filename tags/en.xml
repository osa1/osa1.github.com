<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged en</title>
    <link href="http://osa1.net/tags/en.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/en.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-07-12T00:00:00Z</updated>
    <entry>
    <title>Coq exercises for beginners</title>
    <link href="http://osa1.net/posts/2014-07-12-fun-coq-exercises.html" />
    <id>http://osa1.net/posts/2014-07-12-fun-coq-exercises.html</id>
    <published>2014-07-12T00:00:00Z</published>
    <updated>2014-07-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<style>
.solution {
  background-color: rgb(245, 245, 245);
  padding-left: 1em;
}
</style>


<p>Formalizing abstractions/data structures and proving theorems about them in Coq is so much fun. I made up some simple exercises that consist of encoding some abstractions and laws we know from algebra and functional programming and then proving that some particular set + some operations on that set obeys the laws.</p>
<p>Using my amazing(!) JavaScript skills, I set up some “show/hide answer” buttons after each exercise. Exercises are easy, but the latter ones are relatively harder. Some abstractions/laws are inspired by Haskell.</p>
<p>Please note that I’m a beginner so my solutions probably have some flaws if you want to use them in large-scale verified programs :) I’m currently learning about typeclasses and records of Coq and I’m open to suggestions for improvements.</p>
<p>In exercises, when we talk that an abstraction should obey some laws, you need to enforce it in construction. e.g. You need to make constructors in a way that user would have to prove that the data structure + operations obey the laws.</p>
<pre class="coq"><code>Require Import List.
Import ListNotations.

Open Scope list_scope.</code></pre>
<h1 id="exercise-1">Exercise 1</h1>
<p>A <a href="http://en.wikipedia.org/wiki/Semigroup">semigroup</a> is a set together with an associative binary function. For example, natural numbers and addition function form a semigroup, because we know/can prove that addition function is associative. More precisely: (in Coq syntax)</p>
<pre class="coq"><code>forall (n1 n2 n3 : nat), n1 + (n2 + 3) = (n1 + n2) + n3.</code></pre>
<p>Encode semigroups in Coq.</p>
<div id="ex-div-1.1" class="solution">
<pre class="coq"><code>Inductive semigroup (A : Type) (Op : A -&gt; A -&gt; A) : Prop :=
| Semigroup_intro :
    (forall (a1 a2 a3 : A), Op a1 (Op a2 a3) = Op (Op a1 a2) a3) -&gt; semigroup A Op.</code></pre>
</div>
<button id="ex-btn-1.1"></button>

<p>Now prove that lists together with append operation form a semigroup. Use standard Coq lists and <code>app</code> function.</p>
<div id="ex-div-1.2" class="solution">
<pre class="coq"><code>Theorem list_semigroup : forall A, semigroup (list A) (@app A).
Proof.
  intro. apply Semigroup_intro. intros.
  induction a1.
  + reflexivity.
  + simpl. f_equal. induction a2; auto.
Qed.</code></pre>
</div>
<button id="ex-btn-1.2"></button>


<h1 id="exercise-2">Exercise 2</h1>
<p>A <a href="http://en.wikipedia.org/wiki/Monoid">monoid</a> is a semigroup with an identity element. In our addition example, identity element is 0, because when applied to the monoid function(addition) as first or second argument, results is the other argument:</p>
<pre class="coq"><code>forall (n : nat), 0 + n = n /\ n + 0 = n.</code></pre>
<p>Encode monoids in Coq.</p>
<div id="ex-div-2.1" class="solution">
<pre class="coq"><code>Inductive monoid A Op (sg : semigroup A Op) (U : A) : Prop :=
| Monoid_intro :
    semigroup A Op -&gt; (forall (a : A), Op U a = Op a U /\ Op U a = a) -&gt; monoid A Op sg U.</code></pre>
</div>
<button id="ex-btn-2.1"></button>

<p>Now prove that lists with empty list as unit element together with the proof that lists are monoids as we proved in previous exercise, form a monoid.</p>
<div id="ex-div-2.2" class="solution">
<pre class="coq"><code>Theorem list_monoid : forall A, monoid (list A) (@app A) (@list_semigroup A) [].
Proof.
  intro. apply Monoid_intro. apply list_semigroup.
  intro. split.
  + rewrite app_nil_r. reflexivity.
  + reflexivity.
Qed.</code></pre>
</div>
<button id="ex-btn-2.2"></button>

<h1 id="exercise-3">Exercise 3</h1>
<p>In this exercise and exercise 4, we’ll be talking about Haskell definitions of abstractions, instead of algebra definitions. (although they may coincide)</p>
<p>A functor is a type with one argument(in Haskell terms, a type with kind <code>* -&gt; *</code>) and a function, together with some laws. If you’re unfamiliar with functors of Haskell, you may want to skip this, or read <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#Functor">Typeclassopedia</a>.</p>
<p>A Coq definition would use these to encode functors:</p>
<ul>
<li>Functor type: <code>F : Type -&gt; Type</code></li>
<li>Functor operation: <code>forall t1 t2, (t1 -&gt; t2) -&gt; f t1 -&gt; f t2</code> (let’s call it fmap)</li>
</ul>
<p>A functor should obey these laws:</p>
<ul>
<li><code>fmap id = id</code></li>
<li><code>fmap (fun x =&gt; g (h x)) = fun x =&gt; (fmap g (fmap h x))</code></li>
</ul>
<p>Encode functors in Coq.</p>
<div id="ex-div-3.1" class="solution">
<pre class="coq"><code>Inductive functor (F : Type -&gt; Type) : (forall t1 t2, (t1 -&gt; t2) -&gt; f t1 -&gt; f t2) -&gt; Prop :=
| Functor_intro
    (fmap : forall t1 t2, (t1 -&gt; t2) -&gt; F t1 -&gt; F t2)
    (l1   : forall t f, fmap t t id f = f)
    (l2   : forall t1 t2 t3, forall (f : F t1) (p : t2 -&gt; t3) (q : t1 -&gt; t2),
              fmap t1 t3 (fun a =&gt; p (q a)) f = fmap t2 t3 p (fmap t1 t2 q f)) :
    functor F fmap.</code></pre>
</div>
<button id="ex-btn-3.1"></button>

<p>Now prove that lists with standard map function form a functor.</p>
<div id="ex-div-3.2" class="solution">
<pre class="coq"><code>Theorem list_functor : functor list map.
Proof.
  apply Functor_intro.
  + intros. induction f. reflexivity. simpl. rewrite IHf. reflexivity.
  + intros. induction f. reflexivity. simpl. f_equal. apply IHf.
Qed.</code></pre>
</div>
<button id="ex-btn-3.2"></button>

<h1 id="exercise-4">Exercise 4</h1>
<p>A monad is a functor with two more operations; let’s call <code>bind</code> and <code>lift</code> and some more laws. In Coq syntax: (<code>F</code> is our functor type)</p>
<ul>
<li>bind: <code>forall t1 t2, F t1 -&gt; (t1 -&gt; F t2) -&gt; F t2</code></li>
<li>lift: <code>forall t, t -&gt; F t</code></li>
</ul>
<p>Laws:</p>
<ul>
<li>Left identity: <code>forall t1 t2 a f, bind t1 t2 (lift t1 a) f = f a</code></li>
<li>Right identity: <code>right_id : forall t m, bind t t m (lift t) = m</code></li>
<li>Associativity: <code>forall t1 t2 t3 m f g, bind t2 t3 (bind t1 t2 m f) g = bind t1 t3 m (fun x =&gt; bind t2 t3 (f x) g)</code></li>
</ul>
<p>Encode monads in Coq.</p>
<div id="ex-div-4.1" class="solution">
<pre class="coq"><code>Inductive monad : (Type -&gt; Type) -&gt; Prop :=
| Monad_intro
    (F        : Type -&gt; Type)
    (fmap     : forall t1 t2, (t1 -&gt; t2) -&gt; F t1 -&gt; F t2)
    (Fp       : functor F fmap)
    (lift     : forall t, t -&gt; F t)
    (bind     : forall t1 t2, F t1 -&gt; (t1 -&gt; F t2) -&gt; F t2)
    (left_id  : forall t1 t2 a f, bind t1 t2 (lift t1 a) f = f a)
    (right_id : forall t m, bind t t m (lift t) = m)
    (assoc    : forall t1 t2 t3 m f g,
                  bind t2 t3 (bind t1 t2 m f) g = bind t1 t3 m (fun x =&gt; bind t2 t3 (f x) g)) :
    monad F.</code></pre>
</div>
<button id="ex-btn-4.1"></button>

<p>Now prove that lists form a monad. You need to figure out what functions to use for <code>lift</code> and <code>bind</code>.</p>
<div id="ex-div-4.2" class="solution">
<p><code>lift</code> function:</p>
<pre class="coq"><code>(* I couldn&#39;t find this in stdlib so let&#39;s define *)
Definition singleton (A : Type) (x : A) := [x].</code></pre>
<p>For <code>bind</code>, you can use standard <code>flat_map</code> function, but it’s argument order is reversed. So instead I rolled my own version:</p>
<pre class="coq"><code>Fixpoint concat {A : Type} (l : list (list A)) : list A :=
  match l with
  | []     =&gt; []
  | h :: t =&gt; app h (concat t)
  end.

(* I don&#39;t like argument order of flat_map in stdlib ... *)
Definition concatMap (A : Type) (B : Type) (l : list A) (f : A -&gt; list B) : list B :=
  concat (map f l).</code></pre>
<p>Now most involved proof in this exercises: (still very easy)</p>
<pre class="coq"><code>Theorem list_monad : monad list.
Proof.
  apply Monad_intro with (fmap := map) (lift := singleton) (bind := concatMap).
  + apply list_functor.
  + intros. unfold concatMap. simpl. rewrite app_nil_r. reflexivity.
  + intros. unfold concatMap. induction m.
    - reflexivity.
    - simpl. f_equal. apply IHm.
  + intros. induction m as [|h t].
    - reflexivity.
    - unfold concatMap in *. simpl. rewrite &lt;- IHt. 
      assert (forall A (l1 : list (list A)) (l2 : list (list A)),
                concat l1 ++ concat l2 = concat (l1 ++ l2)) as H.
        intros. induction l1; auto.
          simpl. rewrite &lt;- app_assoc. rewrite IHl1. auto.
      rewrite H. f_equal. rewrite map_app. reflexivity.
Qed.</code></pre>
</div>
<button id="ex-btn-4.2"></button>

<h1 id="exercise-5">Exercise 5</h1>
<p>Prove that standard <code>option</code> type with some operations form a semigroup, monoid, functor and monad. You need to find relevant operations.</p>
<div id="ex-div-5.1" class="solution">
<pre class="coq"><code>Definition map_option (A B : Type) (f : A -&gt; B) (opt : option A) :=
  match opt with
  | None =&gt; None
  | Some t =&gt; Some (f t)
  end.

Definition append_option A OpA (sg : semigroup A OpA) (a b : option A) : option A :=
  match a, b with
  | None, None =&gt; None
  | None, Some b&#39; =&gt; Some b&#39;
  | Some a&#39;, None =&gt; Some a&#39;
  | Some a&#39;, Some b&#39; =&gt; Some (OpA a&#39; b&#39;)
  end.

Theorem option_semigroup : forall A OpA (sg : semigroup A OpA),
  semigroup (option A) (append_option A OpA sg).
Proof.
  intros. apply Semigroup_intro. intros. destruct a1.
  + destruct a2.
    - destruct a3.
      * simpl. f_equal. inversion sg. apply H.
      * simpl. reflexivity.
    - destruct a3; simpl; reflexivity.
  + destruct a2; destruct a3; auto.
Qed.

Theorem option_monoid : forall A OpA (sg : semigroup A OpA),
  monoid (option A) (append_option A OpA sg) (option_semigroup A OpA sg) None.
Proof.
  intros. apply Monoid_intro. apply option_semigroup.
  intros. split. auto. destruct a; auto.
Qed.

Definition option_map A B (f : A -&gt; B) (o : option A) : option B :=
  match o with
  | None =&gt; None
  | Some a =&gt; Some (f a)
  end.

Theorem option_functor : functor option option_map.
Proof.
  apply Functor_intro; intros; destruct f; auto.
Qed.

Definition option_bind A B (o1 : option A) (f : A -&gt; option B) : option B :=
  match o1 with
  | None =&gt; None
  | Some a =&gt; f a
  end.

Theorem option_monad : monad option.
Proof.
  apply Monad_intro with (fmap := option_map) (lift := Some) (bind := option_bind).
  + apply option_functor.
  + intros. auto.
  + intros. destruct m; auto.
  + intros. destruct m; auto.
Qed.</code></pre>
</div>
<button id="ex-btn-5.1"></button>


<h1 id="exercise-6">Exercise 6</h1>
<p>I only have a partial solution to this one and it’s not strictly a Coq exercise, but it’s still fun :)</p>
<p>A <a href="http://en.wikipedia.org/wiki/Group_(mathematics)">group</a> is a monoid with inverse element of every element. In Coq syntax:</p>
<pre class="coq"><code>forall e, exists e_i -&gt; op e e_1 = U</code></pre>
<p>where <code>op</code> is monoid operation and <code>U</code> is unit of monoid.</p>
<p>Can you come up with a data structure that forms a group?</p>
<div id="ex-div-6.1" class="solution">

<p>Someone at Coq IRC channel suggested diffs. Do you think a diff could form a group? What would associative operation, unit element, and inverse elements be?</p>
<div id="ex-div-6.2" class="solution">
<p>Diffs don’t form a group. Composing two diffs is the merge operation, which is partial function. We can’t always merge two diffs. (merge conflicts)</p>
So I don’t have an answer to this exercise, If you know examples to this one, please write at comments :)
</div>
<button id="ex-btn-6.2"></button>

</div>
<button id="ex-btn-6.1"></button>



<script>
function showMsg(exNum) {
  return "Show solution (ex. " + exNum + ")";
}

function hideMsg(exNum) {
  return "Hide solution (ex. " + exNum + ")";
}

function setUpShowHide(exNum) {
  var div = document.getElementById("ex-div-" + exNum);
  var btn = document.getElementById("ex-btn-" + exNum);
  btn.innerHTML = showMsg(exNum);
  btn.onclick = function() {
    if (div.style.display !== 'none') {
      div.style.display = 'none';
      btn.innerHTML = showMsg(exNum);
    } else {
      div.style.display = 'block';
      btn.innerHTML = hideMsg(exNum);
    }
  }
  div.style.display = 'none';
}

setUpShowHide(1.1);
setUpShowHide(1.2);
setUpShowHide(2.1);
setUpShowHide(2.2);
setUpShowHide(3.1);
setUpShowHide(3.2);
setUpShowHide(4.1);
setUpShowHide(4.2);
setUpShowHide(5.1);
setUpShowHide(6.2);
setUpShowHide(6.1);
</script>

]]></summary>
</entry>
<entry>
    <title>A complicated proof of a simple theorem</title>
    <link href="http://osa1.net/posts/2014-07-10-complicated-proof-simple-thm.html" />
    <id>http://osa1.net/posts/2014-07-10-complicated-proof-simple-thm.html</id>
    <published>2014-07-10T00:00:00Z</published>
    <updated>2014-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s that time of the year again in which I’m suddenly very interested about verification and interactive theorem proving. I’m currently working on proving properties of some well-known algorithms.</p>
<p>At least in the beginning even the simplest properties may turn out to be very hard to prove. In this post I’m going to give an example of a very simple theorem which turns out to be hard to prove for beginners like me.</p>
<p>Let’s say I want to divide peano nats by 10. I can define <code>div10</code> in two ways: 1) I can implement a function that directly divides by 10 2) I can implement <code>div2</code> and <code>div5</code> and use those two to implement <code>div10</code>:</p>
<pre class="coq"><code>(* first definition *)
Fixpoint div10 (n : nat) : nat :=
  match n with
  | S (S (S (S (S (S (S (S (S (S n&#39;))))))))) =&gt; S (div10 n&#39;)
  | _ =&gt; 0
  end.

(* second definition *)
Fixpoint div5 (n : nat) : nat :=
  match n with
  | S (S (S (S (S n&#39;)))) =&gt; S (div5 n&#39;)
  | _ =&gt; 0
  end.

Fixpoint div2 (n : nat) : nat :=
  match n with
  | S (S n&#39;) =&gt; S (div2 n&#39;)
  | _ =&gt; 0
  end.

Definition div10&#39; (n : nat) : nat := div5 (div2 n).</code></pre>
<p>It may be obvious enough that those two definitions are equal(in the sense that they always terminate and given same arguments they return same values) but as an exercise let’s try to prove it:</p>
<pre class="coq"><code>Theorem divs_eq : forall n, div10 n = div10&#39; n.</code></pre>
<p>It’s obvious that we need to do induction on n, but unfortunately that leads to very complicated induction hypothesis and I can’t make any use of them:</p>
<pre class="coq"><code>Proof.
  unfold div10&#39;. intro.
  do 10 (induction n; auto). simpl. f_equal. 
Abort.</code></pre>
<p>At this point goal is same as our original goal, but induction hypothesis are about a hundred lines long so I can’t make any use of it. (and I don’t understand why induction hypothesis getting that big)</p>
<p>It turns out that by using a different induction scheme we can easily prove this. Instead of using standard induction scheme of nats “prove P 0, assume P n and prove P (S n)” we can use “prove P 0, P 1, … P 9, assume P n and prove P (10 + n)”:</p>
<pre class="coq"><code>Definition nat10ind : forall (P : nat -&gt; Prop),
  P 0 -&gt; P 1 -&gt; P 2 -&gt; P 3 -&gt; P 4 -&gt; P 5 -&gt; P 6 -&gt; P 7 -&gt; P 8 -&gt; P 9 -&gt;
  (forall n, P n -&gt; P (10 + n)) -&gt; forall n, P n.

  intros.
  assert (P n /\ P (1 + n) /\ P (2 + n) /\ P (3 + n) /\ P (4 + n) /\ P (5 + n) /\
          P (6 + n) /\ P (7 + n) /\ P (8 + n) /\ P (9 + n)).
  + induction n.
    - simpl. repeat split; assumption.
    - repeat (match goal with H : _ /\ _ |- _ =&gt; destruct H end).
      repeat split; try assumption.
      apply H9. assumption.
  + destruct H10. assumption.
Defined.</code></pre>
<p>Now our main theorem is very easy to prove:</p>
<pre class="coq"><code>Theorem divs_eq : forall n, div10 n = div10&#39; n.
Proof.
  unfold div10&#39;. intro.
  induction n using nat10ind; auto.
  simpl. f_equal. assumption.
Qed.</code></pre>
<p>One thing that I found weird in <code>nat10ind</code> definition is that the expression <code>match goal with ...</code> is kind of special in that <code>goal</code> is not an identifier that represents some part of the context. Rather, <code>match goal with ...</code> is a special syntax to pattern match against the whole context, with hypothesis and goals<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. <code>H : _ /\ _ |- _</code> part is then matching for any hypothesis with form <code>_ /\ _</code> and binding it to <code>H</code>, ignoring the current goal(RHS of turnstile shown as <code>|-</code>).</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>See <a href="http://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#sec447">tacexpr_1 production</a> of Coq expression syntax in reference manual for details.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Stack traces in GHCJS</title>
    <link href="http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html" />
    <id>http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html</id>
    <published>2014-06-20T00:00:00Z</published>
    <updated>2014-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m about to finish the first part of my GSoC project and as a part of my project I have implemented stack traces for GHCJS. Currently <code>GHC.Stack</code> functions should work in GHCJS, except for some cases I explain below.</p>
<p>As a demo, I set up <a href="http://osa1.net/files/stacktrace.jsexe/index.html">this page</a>, it runs the Haskell program rendered on the page (some part of the code is copied from Simon Marlow’s <a href="http://www.youtube.com/watch?v=J0c4L-AURDQ">“Why can’t I get stack traces?” presentation</a>). Output is printed to the console. You should be seeing something like this:</p>
<div class="figure">
<img src="http://osa1.net/images/ghcjs-stacktrace.png" />
</div>
<p>My main goal is to implement profiling features of GHC (cost-centres, SCC annotations, reporting allocations/ticks etc.) for GHCJS. It turns out that cost-centre stacks and call stacks are same thing. <code>GHC.Stack.currentCallStack</code> returns the current cost-centre stack, and cost attribution is done to current call-stack(or current cost-centre stack, since they’re exactly the same thing). Similarly, <code>GHC.Stack.whoCreated</code> returns the cost centre stack that was active when the heap object was created.</p>
<p><a href="https://github.com/osa1/ghcjs/compare/ghcjs:master...work3">20 changed files with 810 additions and 527 deletions</a> later, I had <code>GHC.Stack</code> working. You won’t need to do anything different once it’s merged into GHCJS, but for now it requires some effort to install. It also still has some bugs and differences from GHC version. Rest of the post explains how to test it, bugs, and differences from GHC.</p>
<h1 id="how-to-use">How to use</h1>
<p>Because of a horrible bug(see bugs section), you need a 32bit system to use profiling features of GHCJS. You should clone my fork of <a href="https://github.com/osa1/ghcjs">GHCJS</a> and <a href="https://github.com/osa1/shims">shims</a>. For GHCJS, switch to <code>work3</code> branch(that 3 represents how many times I started from scratch :) and for shims switch to <code>work2</code> branch. You need to install <a href="https://github.com/ghcjs/Cabal">modified Cabal for GHCJS</a>. After installing Cabal, install GHCJS and run <code>ghcjs-boot --init -q --prof</code>. This takes about 20 minutes on my system and compiles <code>base</code> and some other libraries. <code>--prof</code> is used to generate profiled versions of libraries.</p>
<p>After GHCJS has been booted, replace ~/.ghcjs/&lt;your platform&gt;/shims folder with my fork of shims(make sure you switched to work2 branch). Now you should be able to compile and run programs with profiling options of GHC. For example, to compile and run the example program given above, run <code>ghcjs stacktrace.hs -prof -fprof-auto</code> and then run generated <code>stacktrace.jsexe/all.js</code> using nodejs. Enabling profiling gives you a debug executable, with more metadata (object names) and longer (non-renamed) variable names.</p>
<h1 id="differences">Differences</h1>
<p>Because GHCJS represents some objects as unboxed numbers and currently we don’t associate any cost-centres with this type of objects, <code>whoCreated</code> returns an empty list. If there’s demand, we can disable unboxing with a command line switch and <code>whoCreated</code> on these values would work. In the example program, second and third lines are printing empty lists because of this.</p>
<h1 id="bugs">Bugs</h1>
<p>Currently we discovered two bugs:</p>
<ol style="list-style-type: decimal">
<li><p>There’s a horrible bug happening outside of GHCJS code, see my <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">blog post</a> and <a href="http://www.haskell.org/pipermail/ghc-devs/2014-May/005059.html">ghc-devs mail</a>. Because of this bug, booting GHCJS with profiling enabled is resulting with a segfault on 64bit systems. I’m developing this project on a 32bit VM, running on a VPS :) I need to make some more progress before tracking this bug.</p></li>
<li><p>We’re having a bug that makes stack traces sometimes a bit different than the ones generated by GHC compiled programs. For example, the example program should have printed this stack trace:</p>
<pre><code>Main.errorM.\ (stacktrace.hs:13:22-54)
Main.errorM (stacktrace.hs:13:1-54)
Main.foo.\.\ (stacktrace.hs:27:23-30)
Main.foo.\ (stacktrace.hs:27:16-33)
Main.foo (stacktrace.hs:27:1-36)
Main.bar (stacktrace.hs:24:1-20)
Main.runM.(...) (stacktrace.hs:16:20-31)
Main.runM (stacktrace.hs:16:1-36)
Main.main (stacktrace.hs:(29,1)-(38,36))
Main.CAF (&lt;entire-module&gt;)</code></pre>
<p>.. but <code>runM</code> calls are missing in GHCJS output. I have no idea what could be the reason for this and I’m currently working to fix this. After fixing this, I think we’ll have exactly same stack traces as the ones produced by GHC compiled programs.</p></li>
</ol>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>I’d like to thank my mentor Luite Stegeman for answering my endless questions, helping me understanding GHC and GHCJS internals and reviewing this blog post.</p>]]></summary>
</entry>
<entry>
    <title>Dependency boundaries and orphan instances</title>
    <link href="http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html" />
    <id>http://osa1.net/posts/2014-06-13-dependencies-and-orphan-instances.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>According to the <a href="http://www.haskell.org/haskellwiki/Package_versioning_policy">PVP</a>(Package Versioning Policy), adding a non-orphan instance is not a breaking change and a minor version number should be bumped(<code>C</code> in <code>A.B.C</code>) in case of a non-orphan instance implementation.</p>
<p>This means that if you’re implementing an orphan instance, you should specify minor upper bound of the package that defines the typeclass. Otherwise if the package implements the typeclass for the type in the future, you’re package will be broken.</p>
<p>I want to add <code>StackValue a =&gt; StackValue [a]</code> instance in hslua, but that breaks Pandoc because it implements that instance without using a newtype(an orphan instance) and hslua dependency upper bound is specified as <code>&lt; 0.4</code>.</p>
<p>Good news is that bergmark at Freenode #haskell told me that now it’s possible to change dependency ranges on Hackage without pushing a new version, so there’s an easy fix that’ll keep package working.</p>]]></summary>
</entry>
<entry>
    <title>Calling Haskell from Lua and Lua from Haskell</title>
    <link href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html" />
    <id>http://osa1.net/posts/2014-04-27-calling-haskell-lua.html</id>
    <published>2014-04-27T00:00:00Z</published>
    <updated>2014-04-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>TL;DR: It’s possible to call Haskell functions from Lua and Lua function from Haskell using <a href="https://github.com/osa1/hslua">hslua</a>. <a href="https://github.com/osa1/hslua/tree/master/examples/callbacks">“Callbacks” example</a> in hslua repository shows how to do this.</p>
<hr />
<p><a href="https://github.com/osa1/hslua"><code>hslua</code></a> provides Lua 5.1 C API to the programmer, and using it we can call Lua functions from Haskell and Haskell functions from Lua. In this post, I’m going to give two example Lua function implementations in Haskell. This functions will be mapped to a global name in Lua and one of them will be getting Lua functions as it’s arguments.</p>
<h1 id="two-ways-of-writing-lua-functions-in-haskell">Two ways of writing Lua functions in Haskell</h1>
<p>There are two ways of writing Lua functions in Haskell using hslua. First is the high-level method, where the Haskell function is just any function, provided that it’s type is an instance of <code>LuaImport</code>(we’ll come to this later). Second method is what I’d like to call the <em>raw</em> Haskell function method. <em>Raw</em> Haskell functions should have the type <code>LuaState -&gt; IO CInt</code>, where <code>LuaState</code> is Lua interpreter state provided by <code>hslua</code> and return type <code>CInt</code> represents the amount of return values(e.g. values that are left on the stack by this function). In <em>raw</em> functions, you need to do Lua stack manipulation using standard <a href="http://www.lua.org/manual/5.1/manual.html#3">Lua 5.1 API</a>.</p>
<p>While first method gives you a nice, abstracted way of writing Lua functions in Haskell, <em>raw</em> function method gives you the maximum amount of flexibility that Lua can provide. First method has lots of limitations when compared with <em>raw</em> method.</p>
<h1 id="higher-level-haskell-functions-in-lua">Higher-level Haskell functions in Lua</h1>
<p>In first method all you have to do is to write a Haskell function with it’s type is an instance of <code>LuaImport</code>. So let’s see what types are instances:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">StackValue</span> a) <span class="ot">=&gt;</span> <span class="dt">LuaImport</span> (<span class="dt">IO</span> a) <span class="kw">where</span>
<span class="kw">instance</span> (<span class="dt">StackValue</span> a, <span class="dt">LuaImport</span> b) <span class="ot">=&gt;</span> <span class="dt">LuaImport</span> (a <span class="ot">-&gt;</span> b)</code></pre>
<p>So basically every function type where it’s argument types are instances of <code>StackValue</code> and return type is <code>IO a</code> where <code>a</code> is also an instance of <code>StackValue</code> is an instance of <code>LuaImport</code> and thus can be used in this higher-level method of writing Lua functions in Haskell. Let’s see which types are <code>StackValue</code>s:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaInteger</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaNumber</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Int</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Double</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">String</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Bool</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> (<span class="dt">FunPtr</span> <span class="dt">LuaCFunction</span>)
<span class="kw">instance</span> <span class="dt">StackValue</span> (<span class="dt">Ptr</span> a)
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaState</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> ()</code></pre>
<p>We have basic Haskell types <code>Int</code>, <code>Double</code>, <code>String</code>, and <code>Bool</code> as instances. Other types are for more advanced use, for example, <code>Ptr a</code> is used for <code>userdata</code>(basically any binary data that you want to pass to Lua stack and later get back, see <a href="http://www.lua.org/manual/5.1/manual.html#2.2">reference manual</a> for more details).</p>
<p>This two functions are instances of <code>LuaImport</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">concat&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
concat&#39; s1 s2 <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> s1 <span class="fu">++</span> s2

<span class="ot">pow ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span>
pow d1 d2 <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> d1 <span class="fu">**</span> d2</code></pre>
<p>And we can push this functions to Lua stack using <code>pushhsfunction</code> or directly assign them to a global variable using <code>registerhsfunction</code>. In this post I’ll use register functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Scripting.Lua <span class="kw">as</span> Lua

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> newstate
    openlibs l
    registerhsfunction l <span class="st">&quot;concat&quot;</span> concat&#39;
    registerhsfunction l <span class="st">&quot;pow&quot;</span> pow
    loadfile l <span class="st">&quot;haskellfun.lua&quot;</span>
    call l <span class="dv">0</span> <span class="dv">0</span>
    close l</code></pre>
<p>With 11 lines of code, we can create a Lua state and map this Haskell functions to some names and call them from Lua. This program runs Lua file <code>haskellfun.lua</code>, which you can see in examples folder of <a href="https://github.com/osa1/hslua/tree/master/examples/haskellfun"><code>hslua</code> repository</a>.</p>
<p>Apart from the simplicity, another good thing about this method is that it handles type checking of Lua values automatically. Internally, this functions are wrapped with another function which gets <code>LuaState</code> as parameter and collects Lua values from stack, checks their types(and throws error in case of a type mismatch), and push return value of the function to the Lua stack again. Here’s an example call with wrong type of values:</p>
<pre><code>print(pow(&quot;wrong&quot;))
...
bad argument #1 to &#39;?&#39; (number expected, got string)</code></pre>
<p>Major limitation of this method is that you can only get basic Lua types from the Lua stack. For example, you can’t get a Lua table automatically like you get a Lua string. This because Lua needs to keep track of tables and some other values for garbage collection.</p>
<h1 id="working-on-more-complex-lua-types-and-the-registry">Working on more complex Lua types and the registry</h1>
<p>The Lua way of using Lua tables, Lua functions etc. in Lua API is to register that values to the Lua table called <em>registry</em>, and refer to that values using their index at <em>registry</em>. Using <em>registry</em>, Lua keeps tracks of references to Lua values that are available for garbage collection. See <a href="http://www.lua.org/manual/5.1/manual.html#3.5">reference manual section 3.5</a> for more details.</p>
<h1 id="raw-haskell-function-method">Raw Haskell function method</h1>
<p>We can do this writing <em>raw</em> Haskell functions. Raw functions have type <code>LuaState -&gt; IO CInt</code> and <code>LuaState</code> allows us to run any C API function. <em>raw</em> functions are pushed to Lua stack using <code>pushrawhsfunction</code> and registered as global variable using <code>registerrawhsfunction</code>.</p>
<p><a href="https://github.com/osa1/hslua/tree/master/examples/callbacks"><code>callbacks</code> example</a> in the <code>hslua</code> repository takes Lua callbacks in Haskell functions and later call them in FIFO order and return their return values as a Lua array(table with int keys). You can see the complete program in the repository and here I’ll give only the tricky parts.</p>
<p><em>Raw</em> Haskell functions should return number of values left on the Lua stack as return values. As an example, <code>addLuaCallbacks</code> function uses this for simple error reporting, it puts the error string to the Lua stack and return <code>1</code> in case of an error, and return <code>0</code> otherwise:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addLuaCallbacks l <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
    <span class="kw">case</span> as <span class="kw">of</span>
      <span class="kw">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="co">-- arguments are functions, add them to callback queue and return</span>
        <span class="co">-- nothing</span>
        addCallbacks <span class="dv">1</span> args
        <span class="fu">return</span> <span class="dv">0</span>
      <span class="kw">Just</span> errArg <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="co">-- error: argument at `errArg` is not a function, return error</span>
        <span class="co">-- string</span>
        pushstring l <span class="fu">$</span> <span class="st">&quot;argument &quot;</span> <span class="fu">++</span> <span class="fu">show</span> errArg <span class="fu">++</span> <span class="st">&quot; is not a function&quot;</span>
        <span class="fu">return</span> <span class="dv">1</span></code></pre>
<p>This example program keeps track of passed Lua callbacks in an <code>IORef</code>. Here’s the part that handles getting Lua callbacks from Lua stack:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addCallbacks n <span class="fu">max</span>
  <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="fu">max</span> <span class="fu">=</span> <span class="fu">return</span> ()
  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">do</span>
      <span class="co">-- move nth argument to top of the stack</span>
      pushvalue l n
      <span class="co">-- add function reference to registry</span>
      refId <span class="ot">&lt;-</span> ref l registryindex
      <span class="co">-- add registry index to IORef</span>
      modifyIORef cs (<span class="fu">++</span> [refId])
      <span class="co">-- continue adding other arguments</span>
      addCallbacks (n<span class="fu">+</span><span class="dv">1</span>) <span class="fu">max</span></code></pre>
<p>Note how we’re adding the function to the <em>registry</em> and getting it’s index at the <em>registry</em> in Haskell. We can now refer to this functions(e.g. push this function to Lua stack) using this index. Here’s the relevant code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Call Lua callbacks collected with `addLuaCallbacks`.</span>
<span class="ot">callLuaCallbacks ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CInt</span>
callLuaCallbacks l <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
  <span class="kw">where</span>
    iter [] <span class="fu">=</span> <span class="fu">return</span> ()
    iter (c <span class="fu">:</span> rest) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">...</span>
      pushinteger l (<span class="fu">fromIntegral</span> c)
      gettable l registryindex
      <span class="co">-- call the callback</span>
      call l <span class="dv">0</span> <span class="dv">1</span>
      <span class="fu">...</span>
      iter rest</code></pre>
<p>We’re pushing the index to the Lua stack, and calling <code>gettable</code> to push actual function to the stack using the index. Complete program is longish, so I’m omitting it here, you can see it in <a href="https://github.com/osa1/hslua/tree/master/examples/callbacks"><code>hslua</code>s Github repository</a> with an example Lua program that uses defined Haskell functions to pass Lua callbacks to Haskell.</p>
<h1 id="a-note-about-safety">A note about safety</h1>
<p>Lua tolerates some incorrect stack operations and if you do that while writing <em>raw</em> Haskell functions, you can have hard times debugging your programs. Fortunately, Lua also provides a compile time flag to enable checking API usage for safety. If you install <code>hslua</code> using <code>-fapicheck</code> Cabal flag, it compiled Lua with API checking enabled and Lua gives you errors instead of silently doing something not intended. For example, if you refer to a Lua value at stack index <code>-4</code> while your stack has only <code>3</code> elements, you get something like:</p>
<pre><code>callbacks: src/lapi.c:57: index2adr: Assertion `idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base&#39; failed.</code></pre>
<p>This helps making sure that your API usage is correct.</p>
<h1 id="using-hslua-for-reading-configuration-files-written-in-lua">Using hslua for reading configuration files written in Lua</h1>
<p>hslua also provides a module for reading configuration files. As an example, using <code>Scripting.Lua.ConfigFile.getNestedAssocLists</code>, you can execute the Lua file given below and get resulting nested table as Haskell <code>[(String, [(String, String)])]</code>:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"> <span class="kw">someVal</span> <span class="ot">=</span> <span class="ot">{</span>
    <span class="kw">something</span> <span class="ot">=</span> <span class="ot">{</span>
       <span class="kw">foo</span> <span class="ot">=</span> <span class="st">&quot;aaa&quot;</span><span class="ot">,</span>
       <span class="kw">bar</span> <span class="ot">=</span> <span class="st">&quot;bbb&quot;</span><span class="ot">,</span>
       <span class="kw">baz</span> <span class="ot">=</span> <span class="st">&quot;ccc&quot;</span>
    <span class="ot">},</span>
    <span class="kw">somethingElse</span> <span class="ot">=</span> <span class="ot">{</span>
       <span class="ot">...</span>
    <span class="ot">}</span>
 <span class="ot">}</span></code></pre>
<h1 id="running-lua-programs-using-lua-interpreters">Running Lua programs using Lua interpreters</h1>
<p>In all hslua examples, we needed to create Lua state in Haskell, register Haskell functions inside Haskell and then run Lua files using Lua C API again in Haskell. I think in theory it is also possible to run Lua programs using standard Lua interpreter executables(instead of running the interpreter using Lua C API inside Haskell) and load Haskell functions compiled to <code>*.so</code> shared library files.</p>
<p>About one year ago, I did something similar using C instead of Haskell. You can see the code <a href="https://github.com/osa1/lcl">here</a>. The library compiled to a <code>.so</code> file and by using Lua’s <code>package.loadlib</code>, you can load functions defined in the <code>.so</code>.</p>
<p>Compiling raw Haskell <code>hslua</code> functions to a <code>.so</code> should not be tricky. <code>LuaState</code> type is just a wrapper around <code>Ptr ()</code>, and <code>CInt</code> is just a C integer, so it’s signature is already compatible. We probably need to use <code>foreign export ...</code> of GHC FFI and find GHC parameters to compile to <code>.so</code>. I’ll investigate this further and post updates.</p>]]></summary>
</entry>
<entry>
    <title>I'm accepted into GSoC and I'll be hacking on GHCJS this summer</title>
    <link href="http://osa1.net/posts/2014-04-24-accepted-to-gsoc.html" />
    <id>http://osa1.net/posts/2014-04-24-accepted-to-gsoc.html</id>
    <published>2014-04-24T00:00:00Z</published>
    <updated>2014-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m accepted into Google Summer of Code 2014 and I’ll be working on adding profiling support to GHCJS. This is very exciting for me, I’ll be hacking on JavaScript backend of my favorite compiler(GHC) all summer and get paid :)</p>
<p>I can’t wait to start hacking, but unfortunately I still have one last and very important exam before my graduation from undergraduate school on 26th April and I have to study hard for that. After that, I’ll be hacking on GHCJS all summer long.</p>
<p>Stay tuned for updates about my work and live demos that you can run from within your browser, thanks to GHCJS.</p>
<p>You can see all accepted proposals of Haskell organization <a href="http://www.google-melange.com/gsoc/org2/google/gsoc2014/haskell">here</a>.</p>]]></summary>
</entry>
<entry>
    <title>An idea to handle left-recursion in Parsec</title>
    <link href="http://osa1.net/posts/2014-03-07-parsec-left-recursion.html" />
    <id>http://osa1.net/posts/2014-03-07-parsec-left-recursion.html</id>
    <published>2014-03-07T00:00:00Z</published>
    <updated>2014-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently realized that it may be possible to handle left-recursion in Parsec style parser combinator libraries. I quickly wrote a simple prototype implementation that demonstrates the idea.</p>
<p>The idea is to keep track of parser functions that are called without consuming any tokens from input stream. You should be able to run failure procedures when same parser function is encountered more than one time without consuming any tokens. When a token is consumed, state that is used to keep track of parser functions should be reset.</p>
<p>One assumption here is that I’m assuming parser functions do not alter any states. Otherwise when you come across a same parser, you can have different state and parser may behave differently.</p>
<p>Implementing the idea is easy even without having any extra support from Parsec. Here’s a demonstration on my favorite ambiguous grammar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Exp ::= Int</span>
<span class="co">--      |  Exp `+` Exp</span>

<span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p>Parsers for non-terminals are easy:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">plus <span class="fu">=</span> char <span class="ch">&#39;+&#39;</span> <span class="fu">&gt;&gt;</span> spaces
int  <span class="fu">=</span> <span class="fu">fmap</span> (<span class="dt">Int</span> <span class="fu">.</span> <span class="fu">read</span>) <span class="fu">$</span> many1 digit <span class="fu">&lt;*</span> spaces</code></pre>
<p>I’m using a set to keep track of already visited parsers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MarksSeen</span> <span class="fu">=</span> <span class="dt">S.Set</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">RecParser</span> s m a <span class="fu">=</span> <span class="dt">ParsecT</span> s <span class="dt">MarksSeen</span> m a</code></pre>
<p>Auxiliary functions to alter the state that keeps track of visited parsers:</p>
<pre><code>putMark i = do
    is &lt;- getState
    if S.member i is
      then fail &quot;recursion&quot;
      else putState $ S.insert i is

resetMarks = putState S.empty</code></pre>
<p>Now the interesting part, <code>add</code> parser marks itself as first thing to do, and calls <code>exp</code> parser. Since <code>exp</code> parser is entry point, this means an indirect recursive call. When same <code>putMark</code> call is made, Parsec runs failure actions instead of going into infinte loop:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">add <span class="fu">=</span> <span class="kw">do</span>
    putMark <span class="dv">1</span>
    e1 <span class="ot">&lt;-</span> <span class="fu">exp</span>
    resetMarks
    plus
    e2 <span class="ot">&lt;-</span> <span class="fu">exp</span>
    spaces
    <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Add</span> e1 e2

<span class="fu">exp</span> <span class="fu">=</span> choice [try add, int]</code></pre>
<p><code>resetMarks</code> call is also important, <code>exp</code> has to consume some tokens, so after parsing <code>e1</code>, I’m calling <code>resetMarks</code>.</p>
<p>Here’s an example call of this parser:</p>
<pre><code>ghci&gt; runParser exp S.empty &quot;&quot; &quot;1 + 2 + 3 + 4&quot;
Right (Add (Int 1) (Add (Int 2) (Add (Int 3) (Int 4))))</code></pre>
<p>You can observe that parser gets into an infinite loop when marks are removed. Here’s an example demonstrating the error message:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rec <span class="fu">=</span> putMark <span class="dv">0</span> <span class="fu">&gt;&gt;</span> rec <span class="fu">&gt;&gt;</span> resetMarks

ghci<span class="fu">&gt;</span> runParser rec S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>
<span class="kw">Left</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)<span class="fu">:</span>
recursion</code></pre>
<p>One problem with this approach is that it requires more typing, and you should be careful too. Marks can be placed using TemplateHaskell to ensure unique numbers are given to each <code>putMark</code> call. As a second improvement, I think with some modifications on Parsec we can make Parsec to reset marks when a token is consumed(using <em>consumed-ok</em> continuation of <code>ParsecT</code>).</p>
<p>You can see the complete program <a href="https://gist.github.com/osa1/9414577">here</a>.</p>
<hr />
<p>Removing left-recursions in your grammar may not be a huge problem – except when you’re working on functional languages with ML-like syntax. Then you’re out of luck because being functional means you’re <code>Exp</code> non-terminal contains several dozen of productions and function applications is a part of that too, and it’s left-recursive:</p>
<pre><code>Exp ::= ...
     |  Exp Exp_1 ... Exp_N [left-associative]
     ... a hundred more productions ...</code></pre>
<p>Whenever I need to write a parser for a grammar like this, I’m thinking for an easier way to parse it. I still couldn’t come up with a solution. Idea I just explained does not solve it, because it parses right-associatively. There is one workaround, but I’m not sure if that results with a parser for same grammar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">app <span class="fu">=</span> <span class="kw">do</span>
    putMark <span class="dv">2</span>
    fn <span class="ot">&lt;-</span> <span class="fu">exp</span>
    resetMarks

    putMark <span class="dv">2</span>
    as <span class="ot">&lt;-</span> many1 <span class="fu">exp</span>
    resetMarks

    <span class="fu">return</span> <span class="fu">$</span> <span class="fu">foldl</span> <span class="dt">App</span> fn as


ghci<span class="fu">&gt;</span> runParser pgm S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;1 2 3 4 + 5 + 6 7&quot;</span>
<span class="kw">Right</span> (<span class="dt">Add</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">1</span>) (<span class="dt">Int</span> <span class="dv">2</span>)) (<span class="dt">Int</span> <span class="dv">3</span>)) (<span class="dt">Int</span> <span class="dv">4</span>)) (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">5</span>) (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">6</span>) (<span class="dt">Int</span> <span class="dv">7</span>))))

ghci<span class="fu">&gt;</span> runParser pgm S.empty <span class="st">&quot;&quot;</span> <span class="st">&quot;1 + 2 + 3 4&quot;</span>
<span class="kw">Right</span> (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">1</span>) (<span class="dt">Add</span> (<span class="dt">Int</span> <span class="dv">2</span>) (<span class="dt">App</span> (<span class="dt">Int</span> <span class="dv">3</span>) (<span class="dt">Int</span> <span class="dv">4</span>))))</code></pre>]]></summary>
</entry>
<entry>
    <title>Proving soundness of simply typed multi-staged lambda-calculus</title>
    <link href="http://osa1.net/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html" />
    <id>http://osa1.net/posts/2014-03-06-proving-simply-typed-multi-staged-lc.html</id>
    <published>2014-03-06T00:00:00Z</published>
    <updated>2014-03-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>First part of my first non-trivial(e.g. something other than a Software Foundations exercise) Coq program is finally done. I learned Coq from Software Foundations, but I didn’t finish to book. I still know only very basic tactics, which I think one of the reasons why my proofs are so long. You can see the source <a href="https://github.com/osa1/StagedLambda/blob/master/Lc.v">here</a>.</p>
<p>Some random notes about implementation:</p>
<ul>
<li>I’m looking to improve proofs. I have a lot more to implement for the rest of the program until deadline, so I may not be able to refactor current proofs very much, but at one point I want to simplify the proofs and use more advanced tactics.</li>
<li>Currently only <code>inversion</code>, <code>destruct</code>, <code>induction</code>, <code>rewrite</code>, <code>assumption</code>, <code>assert</code>, <code>constructor</code>, <code>auro</code>, <code>simpl</code>, <code>intro</code>/<code>intros</code>, <code>apply</code>, <code>right</code>/<code>left</code>, <code>exists</code>, <code>unfold</code>, <code>subst</code>, <code>reflexivity</code>, <code>remember</code> and <code>generalize</code> tactics are used.</li>
<li>Language definition is almost the same as in papers. There is one difference, we implemented substitutions as a function. In reality, substitution in multi-staged lambda-calculus is not a function. I believe this doesn’t effect correctness of theorems. At one point I’ll refactor the code and define substitution as a relation.</li>
<li>I used <code>Case</code>, <code>SCase</code>, <code>SSCase</code> … constructs from SFlib extensively.</li>
</ul>
<p>Now I’m going to implement lambda-calculus with row-polymorphic records. I expect this to be at least 2x harder, since polymorphism is involved. Let’s see how it goes …</p>]]></summary>
</entry>
<entry>
    <title>Combining digestive-functors and heist with Snap (continued from last tutorial)</title>
    <link href="http://osa1.net/posts/2014-01-04-combining-df-heist-snap-cont.html" />
    <id>http://osa1.net/posts/2014-01-04-combining-df-heist-snap-cont.html</id>
    <published>2014-01-04T00:00:00Z</published>
    <updated>2014-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here’s an high-level overview of last post:</p>
<ul>
<li>We used digestive-functors for handling form validation and digestive-functors-heist for rendering Heist templates with digestive-funtors forms.</li>
<li>A digestive-functor form has type <code>Form v m a</code> where <code>v</code> is type of error messages, <code>m</code> is the monad type that are used in validation functions, <code>a</code> is return type of a valid form. In our example, <code>a</code> was <code>User</code> since our form was to create a <code>User</code> object. In order to render HTML from a <code>Form</code>, we had to generate a <code>View v</code> object, using <code>getForm</code> or <code>postForm</code> functions from digestive-functors package(<code>Text.Digestive.View</code> module). Once we had a our <code>View</code>, we can use <code>digestiveSplices</code> function from digestive-functors-heist package to get Heist splices of our form. (note: for some type mismatch problem, we had to use <code>bindDigestiveSplices</code> to bind our splices to a Heist state directly, instead of getting splices using <code>digestiveSplices</code> and then binding using some Heist functions) The rest is related with Hesit template rendering.</li>
<li>In Heist site, we had to create a HeistState object which keeps track of compiled and interpreted splices, template paths and some other things.</li>
<li>We then rendered our forms using <code>renderTemplate</code>, binding our form splices to HeistState using <code>bindDigestiveSplices</code>.</li>
</ul>
<p>In this post, I’m going to add some functionalities from Snap to serve HTML pages from a server and handle routing and POST request processing. Our forms will be served at root and when we submit our form, we will be informed whether user creating was successful or what was the problem.</p>
<p>Recommended way fo starting a Snap applcation is by using <code>snap init</code> command. It creates a cabal project structure with <code>Application.hs</code>, <code>Site.hs</code> and <code>Main.hs</code>. According to Snap docs, we only rarely need to touch <code>Main.hs</code>. The other two files are used to create a new Snaplet, and only function we need to provide to <code>Main</code> module is <code>app :: SnapletInit App App</code> for some <code>App</code> type.</p>
<p>In this post I’m assuming you created a Snap project using <code>snap init</code> command and have <code>Main.hs</code> file. You don’t need <code>Application.hs</code> file and in this post we’ll be writing <code>Site.hs</code> file.</p>
<p>Required for some Snap features</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell     #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Tut2</span> (app) <span class="kw">where</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Applicative        (Applicative (..), (&lt;$&gt;))
<span class="ot">&gt;</span> <span class="kw">import</span>           Data.Maybe                 (isJust)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Text                  <span class="kw">as</span> T</code></pre>
<p>from `digestive-functors’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive</code></pre>
<p>from `digestive-functors-heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Heist       (bindDigestiveSplices)</code></pre>
<p>from <code>lens</code> package, required for Snaplets</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Lens</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Snap.Snaplet
<span class="ot">&gt;</span> <span class="kw">import</span>           Snap.Snaplet.Heist</code></pre>
<p>from <code>bytestring</code> package, required for some Snap functions</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString            <span class="kw">as</span> B</code></pre>
<p>from <code>digestive-functors-snap</code> package, required for form rendering, we had handled that using <code>getForm</code> and <code>postForm</code> from <code>Text.Digestive.Heist</code> before.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Snap        (runForm)</code></pre>
<p><code>snap init</code> creates a project with only this code in <code>Application.hs</code>:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span>
<span class="ot">&gt;</span>     { _<span class="ot">heist ::</span> <span class="dt">Snaplet</span> (<span class="dt">Heist</span> <span class="dt">App</span>)
<span class="ot">&gt;</span>     }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> makeLenses <span class="ch">&#39;&#39;</span><span class="dt">App</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">HasHeist</span> <span class="dt">App</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     heistLens <span class="fu">=</span> subSnaplet heist</code></pre>
<p>In this post I’m copying this code to <code>Site.hs</code> and removing <code>Application.hs</code> file. Here, I only changed the definition of <code>App</code>. Since our application is minimal, we only need Heist Snaplet nested in our App. When we need other functionalities in the future(like database access), we will extend this definition for new Snaplets.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; app ::</span> <span class="dt">SnapletInit</span> <span class="dt">App</span> <span class="dt">App</span></code></pre>
<p>First type parameter of SnapletInit is for type of parent Snaplet. In our case, we don’t have a parent Snaplet but I guess this is what you do in that case. Second type is currently initialized Snaplet’s type.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> app <span class="fu">=</span> makeSnaplet <span class="st">&quot;app&quot;</span> <span class="st">&quot;An snaplet example application&quot;</span> <span class="kw">Nothing</span> <span class="fu">$</span> <span class="kw">do</span></code></pre>
<p>Type of <code>makeSnaplet</code> is really helpful to understand what’s going on at the level of types:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">makeSnaplet
<span class="ot">  ::</span> <span class="dt">T.Text</span>                  <span class="co">-- ^ Default ID of the Snaplet, I have no idea where is this used.</span>
     <span class="ot">-&gt;</span> <span class="dt">T.Text</span>               <span class="co">-- ^ Description of the Snaplet, again, no idea where is this used.</span>
     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">IO</span> <span class="fu">FilePath</span>)  <span class="co">-- ^ Root folder for Snaplet&#39;s filesystem content. In case your Snaplet works on files.</span>
     <span class="ot">-&gt;</span> <span class="dt">Initializer</span> b v v    <span class="co">-- ^ Initializer for the Snaplet.</span>
     <span class="ot">-&gt;</span> <span class="dt">SnapletInit</span> b v      <span class="co">-- ^ SnapletInit is an opaque type for internal use. It&#39;s needed for embedding our snaplet to other snaplets.</span></code></pre>
<p>We’re nesting Heist snaplet provided by <code>Snap.Snaplet.Heist</code> from <code>snap</code> package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    h <span class="ot">&lt;-</span> nestSnaplet <span class="st">&quot;&quot;</span> heist <span class="fu">$</span> heistInit <span class="st">&quot;templates&quot;</span></code></pre>
<p>self explanatory, see definition below</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    addRoutes routes
<span class="ot">&gt;</span>    <span class="fu">return</span> <span class="fu">$</span> <span class="dt">App</span> h
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;    routes ::</span> [(<span class="dt">B.ByteString</span>, <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ())]</code></pre>
<p>routes are how we handle requests. <code>Handler</code> type takes 3 arguments, but I’m yet to figure out what do these arguments mean. I guess these are same as arguments in <code>SnapletInit</code> type, except the last one is for return values of Handler functions.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>    routes <span class="fu">=</span> [ (<span class="st">&quot;/&quot;</span>, mainHandler) ]</code></pre>
<p><code>mainHandler</code> is our handler function. Thanks to <code>runForm</code> function provided by <code>Text.Digestive.Snap</code>, we don’t need to anything because it handles POST/GET requests and renders form templates depending on request data. <code>heistLocal</code> function is provided by <code>Snap.Snaplet.Heist</code> and runs a handler action(in our case, this is <code>render &quot;user_form&quot;</code>) on a modified Heist state. We’re modifying Heist state by binding our user form splices using <code>bindDigestiveSplices</code> as we did in previous post.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mainHandler ::</span> <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ()
<span class="ot">&gt;</span> mainHandler <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     (formView, maybeUser) <span class="ot">&lt;-</span> runForm <span class="st">&quot;userform&quot;</span> userForm
<span class="ot">&gt;</span>     heistLocal (bindDigestiveSplices formView) <span class="fu">$</span> render <span class="st">&quot;user_form&quot;</span></code></pre>
<p>This is some code from previous post.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     {<span class="ot"> uUsername ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uEmail    ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uKarma    ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     } <span class="kw">deriving</span> (<span class="kw">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; userForm ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">T.Text</span> m <span class="dt">User</span>
<span class="ot">&gt;</span> userForm <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;$&gt;</span> <span class="st">&quot;username&quot;</span>  <span class="fu">.:</span> text <span class="kw">Nothing</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span>     <span class="fu">.:</span> check <span class="st">&quot;invalid email&quot;</span> validateEmail (text <span class="kw">Nothing</span>)
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> pure <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     validateEmail ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>     validateEmail <span class="fu">=</span> isJust <span class="fu">.</span> T.find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)</code></pre>
<p>As last thing, we need to copy our template file to <code>snaplets/heist/templates</code>. This is because of the way Snap handles Snaplets. I think what happens is for every Snaplet nested in a Snap application, Snap creates a folder in <code>snaplets/snaplet_name</code> and later when that Snaplet requires some filesystem operations, all paths are handled relative to this directory.</p>
<p>After that, if you compile and run the application, you can see our form at http://0.0.0.0:8000 and you can test error messages.</p>]]></summary>
</entry>
<entry>
    <title>Quick digestive-functors and heist tutorial</title>
    <link href="http://osa1.net/posts/2014-01-03-quick-digestive-f-heist-tut.html" />
    <id>http://osa1.net/posts/2014-01-03-quick-digestive-f-heist-tut.html</id>
    <published>2014-01-03T00:00:00Z</published>
    <updated>2014-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>EDIT: I just found this awesome <a href="http://softwaresimply.blogspot.com/2011/04/heist-in-60-seconds.html">“Heist in 60 seconds”</a> post in Hesit’s author’s blog, strongly recommended.</p>
<p>I’m currently learning some web programming related libraries for Haskell and I’m very, very confused because of the need for using more than 20 libraries for even the simplest CRUD webapp. In the end I’ll be using Snap, Heist, Digestive-functors, Persistent, Esqueleto and glue libraries to combine all of this together. After wasting several hours trying to learn all of them at once, I decided to move gradually from simplest parts. In this short tutorial, I’ll explain how to create forms using digestive-functors, render them in HTML and run some validation procedures.</p>
<p>This post is written in Literate Haskell, except for the last part, which contains a Heist template for rendering our forms in HTML.</p>
<p>In my opinition, there are two problems for starters of Haskell web programming in Snap. First, Snap lacks some important web development functionalities and for that you need to use separate libraries. This includes form generation and rendering, database operations and probably many others. (on the other hand, we have very high quality libraries so this part may not be a problem, depending on your point of view)</p>
<p>Second, while using other libraries you realize that most of the time documentation is not very good and some important details for starters are missing, when that happens you end up diving into the source code and open source examples.</p>
<p>Anyway, I hope this post serves as an example for using Digestive-functors and Heist together for handling user inputs.</p>
<p>A note before starting: I don’t understand how compiled splices of Heist works, I tried using them but for some reason I couldn’t make it working. So in this post I’ll be using interpreted splices only.</p>
<p>Let’s start with some langauge extensions. You’ll see why this extension is needed below</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></code></pre>
<p>This one is required for pattern matching against Text values</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings   #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></code></pre>
<p>Even though our program doesn’t do anything interesting, we still need to use about 10 libraries. I’m showing the package name when a non-standard(e.g. the ones distributed with Haskell Platform) module is imported.</p>
<p>from `blaze-builder’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Blaze.ByteString.Builder   (toByteString)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Applicative        (Applicative (..), (&lt;$&gt;), (&lt;*&gt;))
<span class="ot">&gt;</span> <span class="kw">import</span>           Control.Monad.IO.Class     (MonadIO)</code></pre>
<p>from `either’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Control.Monad.Trans.Either (EitherT, runEitherT)</code></pre>
<p>from `bytestring’ package, needed for putStrLn function on bytestrings</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString.Char8      <span class="kw">as</span> BS (putStrLn)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Data.Maybe                 (isJust)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Text                  <span class="kw">as</span> T</code></pre>
<p>from `heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Heist
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Heist.Interpreted          <span class="kw">as</span> HI</code></pre>
<p>from `digestive-functors’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive</code></pre>
<p>from `digestive-functors-heist’ package</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Text.Digestive.Heist       (bindDigestiveSplices)</code></pre>
<p>In this program, we’ll have one data type that represents a User in our app. I’m planning to extend this post later on to add CRUD database operations on same data type.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     {<span class="ot"> uUsername ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uEmail    ::</span> <span class="dt">T.Text</span>
<span class="ot">&gt;</span>     ,<span class="ot"> uKarma    ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     } <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p><code>userForm</code> is a digestive-functors form for User type, which is used for creating new User and modifying existing User.</p>
<p>In the return type:</p>
<ul>
<li>First argument of Form(Text) is type of textual information printed to user. This is used for error messages and probably some other stuff</li>
<li>Second argument is the Monad type that validator of this form operates on.</li>
<li>Third argument is return type of this form. Form return types are used when combining forms using applicative instance. For example, a form that asks user for a text can be used to get a text value.</li>
</ul>
<p><code>.:</code> operator is used to assign a name to form fields. This names are later used in templates, POST request environments and probably in some other places.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; userForm ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">T.Text</span> m <span class="dt">User</span>
<span class="ot">&gt;</span> userForm <span class="fu">=</span> <span class="dt">User</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;$&gt;</span> <span class="st">&quot;username&quot;</span>  <span class="fu">.:</span> text <span class="kw">Nothing</span>
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span>     <span class="fu">.:</span> check <span class="st">&quot;invalid email&quot;</span> validateEmail (text <span class="kw">Nothing</span>)
<span class="ot">&gt;</span>     <span class="fu">&lt;*&gt;</span> pure <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     <span class="co">-- in our example, we don&#39;t need to use `m` monad for validation. if we</span>
<span class="ot">&gt;</span>     <span class="co">-- were to need that, we could use `checkM` instead of `check`, and</span>
<span class="ot">&gt;</span>     <span class="co">-- then use a validation function with type `T.Text -&gt; m Bool` for same m.</span>
<span class="ot">&gt;     validateEmail ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>     validateEmail <span class="fu">=</span> isJust <span class="fu">.</span> T.find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)</code></pre>
<p>For generating HTML using Heist, we need to maintain <code>HeistState</code> type, which keeps track of information that is needed for rendering templates.</p>
<p>In the code below, `m’ is called “runtime monad” and represents the monad type that rendering functions operate on. We will see an example use later.</p>
<p>I’m using <code>ScopedTypeVariables</code> extension to share type parameter <code>m</code> with type declarations in <code>where</code> part. This is only optional, since I could always use <code>let</code> or just inline the <code>heistConfig</code> definition.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; initHeistState ::</span> forall m<span class="fu">.</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> (<span class="dt">HeistState</span> m)
<span class="ot">&gt;</span> initHeistState <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     st <span class="ot">&lt;-</span> runEitherT <span class="fu">$</span> initHeist heistConfig
<span class="ot">&gt;</span>     <span class="kw">case</span> st <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Left</span> errors <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="fu">$</span> <span class="fu">unlines</span> errors
<span class="ot">&gt;</span>       <span class="kw">Right</span> state <span class="ot">-&gt;</span> <span class="fu">return</span> state
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     heistConfig ::</span> <span class="dt">HeistConfig</span> m
<span class="ot">&gt;</span>     <span class="co">-- In HeistConfig, we need to specify what load-time, compile-time and</span>
<span class="ot">&gt;</span>     <span class="co">-- run-time splices will be available. We also have options for</span>
<span class="ot">&gt;</span>     <span class="co">-- attibute splices(QUESTION: why we don&#39;t have time distinction in</span>
<span class="ot">&gt;</span>     <span class="co">-- attribute splices?) and locations of template files.</span>
<span class="ot">&gt;</span>     heistConfig <span class="fu">=</span> <span class="dt">HeistConfig</span>
<span class="ot">&gt;</span>       {
<span class="ot">&gt;</span>       <span class="co">-- default interpreted splices consists of</span>
<span class="ot">&gt;</span>       <span class="co">-- `apply`, `bind`, `ignore` and `markdown` splices</span>
<span class="ot">&gt;</span>         hcInterpretedSplices <span class="fu">=</span> defaultInterpretedSplices
<span class="ot">&gt;</span>       <span class="co">-- this is same as default interpreted splices</span>
<span class="ot">&gt;</span>       , hcLoadTimeSplices <span class="fu">=</span> defaultLoadTimeSplices
<span class="ot">&gt;</span>       <span class="co">-- I&#39;m not using compiled splices because of the reason explained</span>
<span class="ot">&gt;</span>       <span class="co">-- in first paragraphs</span>
<span class="ot">&gt;</span>       , hcCompiledSplices <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="co">-- .. also here.</span>
<span class="ot">&gt;</span>       , hcAttributeSplices <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="co">-- list of template locations. A template location is an</span>
<span class="ot">&gt;</span>       <span class="co">-- IO action that either returns a list of error strings,</span>
<span class="ot">&gt;</span>       <span class="co">-- or a map from template locations to template files.</span>
<span class="ot">&gt;</span>       <span class="co">-- We&#39;re using `loadTemplates` from Heist package for loading</span>
<span class="ot">&gt;</span>       <span class="co">-- templates from a folder. Subfolders are also traversed.</span>
<span class="ot">&gt;</span>       , hcTemplateLocations <span class="fu">=</span> [loadTemplates <span class="st">&quot;templates&quot;</span>]
<span class="ot">&gt;</span>       }</code></pre>
<p>This is our function to render form templates written in Heist template format using digestive-functors forms. Digestive-functors forms are not directly renderable, instead we need a <code>View</code> object generated from <code>Form</code> using <code>getForm</code> or <code>postForm</code> from <code>Text.Digestive.View</code> (<code>digestive-functors</code> package).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; renderForm ::</span> <span class="dt">HeistState</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">View</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> renderForm hs formView <span class="fu">=</span> <span class="kw">do</span></code></pre>
<p>Because of a problem, we can’t use <code>digestiveSplices form</code> to get splices and then bind them manually using <code>bindSplices</code>. I think this is because of a type mismatch caused by current versions of digestive-functors-heist and heist libraries. So we need to use <code>bindDigestiveSplices</code> from <code>Text.Digestive.Heist</code> (<code>digestive-functors-heist</code> package).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     maybeBuilder <span class="ot">&lt;-</span> HI.renderTemplate (bindDigestiveSplices formView hs) <span class="st">&quot;user_form&quot;</span>
<span class="ot">&gt;</span>     <span class="kw">case</span> maybeBuilder <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Nothing</span> <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>         <span class="co">-- This happens when wrong template name is given to `renderTemplate`.</span>
<span class="ot">&gt;</span>         <span class="fu">error</span> <span class="st">&quot;template is not rendered&quot;</span>
<span class="ot">&gt;</span>       <span class="kw">Just</span> (builder, mimeType) <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         <span class="co">-- here `builder` has type `Blaze.ByteString.Builder.Builder` from</span>
<span class="ot">&gt;</span>         <span class="co">-- `blaze-builder` package. It&#39;s used to efficiently build</span>
<span class="ot">&gt;</span>         <span class="co">-- ByteStrings.</span>
<span class="ot">&gt;</span>         BS.putStrLn (toByteString builder)
<span class="ot">&gt;</span>         <span class="fu">print</span> mimeType</code></pre>
<p>I’m just printing stuff, since this app is mostly for learning purposes.</p>
<p>In main function, I do three things:</p>
<ol style="list-style-type: decimal">
<li>Just render the form on empty POST request environment. This just renders the form without filling HTML fields with values.</li>
<li>Render form with invalid email address. This fills HTML fields with values form POST request environment, and renders an error message after email field saying that email is invalid. This validation part was handled in <code>validateEmail</code> function above, and error message was specified in <code>userForm</code> function.</li>
<li>Render the form with valid values.</li>
</ol>
<p>After rendering the HTML code, I’m just printing it. Also, form rendering function(<code>postForm</code>) returns an optional User object depending on the validness of information from POST request. I’m also printing that User object.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     hs <span class="ot">&lt;-</span> initHeistState
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- we need to dynamically bind splices related with form generation</span>
<span class="ot">&gt;</span>     <span class="co">-- while rendering `user_form` heist template. for that we need to use</span>
<span class="ot">&gt;</span>     <span class="co">-- `Heist.Interpreter` functions to modify interpereted splices of our</span>
<span class="ot">&gt;</span>     <span class="co">-- heist state.</span>
<span class="ot">&gt;</span>     <span class="fu">--</span>
<span class="ot">&gt;</span>     <span class="co">-- To get form splices, we need to pass some POST or GET request as</span>
<span class="ot">&gt;</span>     <span class="co">-- ByteString to `Text.Digestive.View.getForm` or `postForm`. Then we</span>
<span class="ot">&gt;</span>     <span class="co">-- can use `Text.Digestive.Heist.digestiveSplices` to get required</span>
<span class="ot">&gt;</span>     <span class="co">-- splices to render form.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Here the type T.Text comes from first argument of userForm&#39;s return</span>
<span class="ot">&gt;</span>     <span class="co">-- type</span>
<span class="ot">&gt;</span>     (formView, maybeUser) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm (<span class="fu">const</span> <span class="fu">$</span> <span class="fu">return</span> [])
<span class="ot">&gt;                                ::</span> <span class="dt">IO</span> (<span class="dt">View</span> <span class="dt">T.Text</span>, <span class="dt">Maybe</span> <span class="dt">User</span>)
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser
<span class="ot">&gt;</span>     renderForm hs formView
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Case 2, POST request with invalid email address</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> env path <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> path <span class="kw">of</span>
<span class="ot">&gt;</span>                               [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;username&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;testuser&quot;</span>]
<span class="ot">&gt;</span>                               [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;email&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;invalidemail&quot;</span>]
<span class="ot">&gt;</span>                               _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span>     (formView&#39;, maybeUser&#39;) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm env
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser&#39;
<span class="ot">&gt;</span>     renderForm hs formView&#39;
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="co">-- Case 3, POST request with valid email address and username</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> env&#39; path <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> path <span class="kw">of</span>
<span class="ot">&gt;</span>                                [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;username&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;testuser&quot;</span>]
<span class="ot">&gt;</span>                                [<span class="st">&quot;userform&quot;</span>, <span class="st">&quot;email&quot;</span>] <span class="ot">-&gt;</span> [<span class="dt">TextInput</span> <span class="st">&quot;valid@email.com&quot;</span>]
<span class="ot">&gt;</span>                                _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span>     (formView&#39;&#39;, maybeUser&#39;&#39;) <span class="ot">&lt;-</span> postForm <span class="st">&quot;userform&quot;</span> userForm env&#39;
<span class="ot">&gt;</span>     <span class="fu">print</span> maybeUser&#39;&#39;
<span class="ot">&gt;</span>     renderForm hs formView&#39;&#39;</code></pre>
<p>Now our program is almost complete, only detail left is the Heist template file. We specified the template path in <code>initHeistState</code> as <code>templates</code> folder, and we’re rendering Heist template named <code>user_form</code> in <code>renderForm</code>. So the template file we need should be <code>templates/user_form.tpl</code>.</p>
<p>Here’s the template file:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;dfForm&gt;</span>
    <span class="kw">&lt;dfLabel</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/dfLabel&gt;</span>
    <span class="kw">&lt;dfInputText</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;dfErrorList</span><span class="ot"> ref=</span><span class="st">&quot;username&quot;</span> <span class="kw">/&gt;</span>

    <span class="kw">&lt;dfLabel</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/dfLabel&gt;</span>
    <span class="kw">&lt;dfInputText</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;dfErrorList</span><span class="ot"> ref=</span><span class="st">&quot;email&quot;</span> <span class="kw">/&gt;</span>

    <span class="kw">&lt;dfInputSubmit</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/dfForm&gt;</span></code></pre>
<p>One problem here is that there’s no way to know which tags to put in template file. I wrote this file mostly by looking to source code of <code>bindDigestiveSplices</code>, trial-and-error, and some open source examples.</p>
<p>Output should be something like: (after creating the template file, see below)</p>
<p>Case 1:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Nothing</span></code></pre>
<p>because POST request environment is not valid, so it’s not possible to create a User object.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> method=</span><span class="st">&#39;POST&#39;</span><span class="ot"> enctype=</span><span class="st">&#39;application/x-www-form-urlencoded&#39;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.username&#39;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> value</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.email&#39;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> value</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;ul&gt;&lt;li&gt;</span>invalid email<span class="kw">&lt;/li&gt;&lt;/ul&gt;</span>

    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;submit&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre>
<p>User form is generated without filling any values and no error messages.</p>
<p>Case 2:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Nothing</span></code></pre>
<p>because email information in POST request environment is invalid.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> method=</span><span class="st">&#39;POST&#39;</span><span class="ot"> enctype=</span><span class="st">&#39;application/x-www-form-urlencoded&#39;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.username&#39;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> value=</span><span class="st">&#39;testuser&#39;</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.email&#39;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> value=</span><span class="st">&#39;invalidemail&#39;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;ul&gt;&lt;li&gt;</span>invalid email<span class="kw">&lt;/li&gt;&lt;/ul&gt;</span>

    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;submit&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre>
<p>User form is generated with fields filled and an error message is rendered.</p>
<p>Case 3:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Just</span> (<span class="dt">User</span> {uUsername <span class="fu">=</span> <span class="st">&quot;testuser&quot;</span>, uEmail <span class="fu">=</span> <span class="st">&quot;valid@email.com&quot;</span>, uKarma <span class="fu">=</span> <span class="dv">0</span>})</code></pre>
<p>Since form data is valid, a User object is created.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> method=</span><span class="st">&#39;POST&#39;</span><span class="ot"> enctype=</span><span class="st">&#39;application/x-www-form-urlencoded&#39;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.username&#39;</span><span class="kw">&gt;</span>Username: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.username&#39;</span><span class="ot"> value=</span><span class="st">&#39;testuser&#39;</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&#39;userform.email&#39;</span><span class="kw">&gt;</span>Email: <span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;text&#39;</span><span class="ot"> id=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> name=</span><span class="st">&#39;userform.email&#39;</span><span class="ot"> value=</span><span class="st">&#39;valid@email.com&#39;</span> <span class="kw">/&gt;</span>


    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&#39;submit&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre>
<p>.. and for is created with values filled, no error messages is rendered.</p>
<p>Note the form and input ids and names. The name passed to <code>postForm</code> is used as prefix of generated HTML elements, and thus also used in POST request environments.</p>
<p>I hope this post helps starters with digestive-functors and heist.</p>]]></summary>
</entry>

</feed>
