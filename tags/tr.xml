<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged tr</title>
    <link href="http://osa1.net/tags/tr.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/tr.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-02-28T00:00:00Z</updated>
    <entry>
    <title>ADTler ve sınıflar: bir örnek</title>
    <link href="http://osa1.net/posts/2013-02-31-adtler-siniflar.html" />
    <id>http://osa1.net/posts/2013-02-31-adtler-siniflar.html</id>
    <published>2013-02-28T00:00:00Z</published>
    <updated>2013-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı, <a href="/rowlar-kindlar/">bir önceki yazım</a> gibi, yine bir mail için yazıldı. Birkaç düzenleme ve eklemeden sonra blog yazısı olarak yayınlıyorum.</p>
<hr />
<p>Bir programlama dili meraklısı olarak sık sık yorumlayıcılar ve nadiren derleyiciler yazıyorum. Derleyici/yorumlayıcı yazarken çok sık yapılan işlemlerden biri şudur:</p>
<p>Programda(derleyici/yorumlayıcıda) kod üzerinde çalışabilmek için son kullanıcı tarafından metin olarak girilmiş kodun üzerinde çalışılabilinecek bir veri yapısına dönüştürülmesi gerekir. Buna “parsing” işlemi diyoruz ve yaptığı iş kısaca metni alıp, abstract syntax tree(AST) dediğimiz bir çeşit ağaç yapısına dönüştürmektir.</p>
<p>Bu aşamadan sonra elimizde bir ağaç yapısı olmuş olur. Fakat burdaki ağaç yapısını veri yapıların dersinde gösterilen “binary tree” vs. yapılarla karıştırmamak lazım, burda çok çeşitli nodelar oluyor ve her bir node farklı özelliklere sahip, her birine ayrı muameleler yapılacak oluyor. (kod örnekleri vereceğim)</p>
<p>Bir yorumlayıcı/derleyicinin bu ağaç yapısı üzerinde defalarca gezinmesi gerekir ve genelde her bir gezinmede farklı işlemler yapılır. Bir tur sonrası ağaç üzerinde değişiklikleri yapılabilir ve bir sonraki turda bu yeni ağaç üzerinden devam edilir vs.</p>
<p>Örnek: Statically typed bir dil için yorumlayıcı yazdığımızda, ilk başta type checker ağaç üzerinde gezerek programın type-safe olduğundan emin olur. Program type-safe ise, ağacın biraz değiştirilmiş hali üzerinde(örneğin type annotationları silinmiş, veya ağacın tagless bir hali) yorumlayıcı çalışır.</p>
<p>Derleyicilerde ise ağaç çok daha fazla sayıda adımlanır. Her bir adımlamada ağaç yapısı değiştirilebilir.<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup></p>
<p>Yani kısaca problem şu: Elimde farklı tiplerde ağaçlar var(örnek: tip bilgilerini içeren, type checking/inference için oluşturulmuş bir ağaç ve tip bilgilerinin büyük oranda silindiği, yorumlama/derleme için kullanılan bir ağaç vs.), bu ağaçlar üzerinde turlar atacağım fakat tur atarken farklı işler yapacağım.</p>
<p>Katkı yaptığım bir derleyici kodundan birkaç örnek vereceğim: Fay, bir Haskell alt kümesinden JavaScript’e derleyici.</p>
<p><a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Compiler/Exp.hs#L21"><code>compileExp</code></a> fonksiyonu, <a href="http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html#g:8"><code>Exp</code></a> ağacı üzerinde gezinir çıktı olarak <a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Types.hs#L242"><code>JsExp</code></a> (yine başka bir ağaç) üretir. Bu bir ağaç üzerinde gezinip farklı işlemler yapıp farklı bir ağaçlar üreten fonksiyonlara bir örnek.</p>
<p><a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Compiler/Optimizer.hs"><code>Optimizer</code></a> modulü çeşitli ağaçlar üzerinde gezinip başka ağaçlar üreten 13 tane fonksiyondan oluşur ve bunların 5-6 tanesi <a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Types.hs#L227"><code>JsStmt</code></a> ağacını dolaşır. Bu da aynı ağaç üzerinde gezinip farklı işlemler yapan fonksiyonlara örnek.</p>
<p>Algebraic data typelara ve pattern matchinge sahip olan fonksiyonel dillerde(yani belki de tüm statically typed fonksiyonel dillerde) bunu yapmanın bir yolunu göstermek için hemen hiçbir işlevi olmayan çok basit bir aritmetik ifade dili oluşturalım:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span>
    <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Float</span></code></pre>
<p>Bu kadar işlevsiz bir dil olamaz. Şimdi bu ağaç üzerinde iki farklı işlem yapan iki fonksiyon:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
run (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> run e1 <span class="fu">+</span> run e2
run (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> run e1 <span class="fu">*</span> run e2
run (<span class="dt">Number</span> f)  <span class="fu">=</span> f</code></pre>
<p><code>run</code> programı çalıştırıp sonucu dönüyor.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringOfExp ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stringOfExp (<span class="dt">Add</span> e1 e2) <span class="fu">=</span>
    <span class="fu">concat</span> [ <span class="st">&quot;(&quot;</span>, stringOfExp e1, <span class="st">&quot; + &quot;</span>, stringOfExp e2, <span class="st">&quot;)&quot;</span> ]
stringOfExp (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span>
    <span class="fu">concat</span> [ <span class="st">&quot;(&quot;</span>, stringOfExp e1, <span class="st">&quot; * &quot;</span>, stringOfExp e2, <span class="st">&quot;)&quot;</span> ]
stringOfExp (<span class="dt">Number</span> f) <span class="fu">=</span> <span class="fu">show</span> f</code></pre>
<p><code>stringOfExp</code> ise programın string halini dönüyor. Örnek:</p>
<pre><code>ghci&gt; let prog1 = Add (Number 10) (Mul (Number 20) (Add (Number 30) (Number 40)))
ghci&gt; run prog1
1410.0
ghci&gt; stringOfExp prog1
&quot;(10.0 + (20.0 * (30.0 + 40.0)))&quot;</code></pre>
<p>Yarın ağaca yeni bir node eklediğimde ağaç üzerinde çalışan tüm fonksiyonları güncellemem gerekecek.</p>
<p>Herkes için son derece basittir sanıyorum. Şimdi aynısını ADT’lara sahip olmayan, OO bir dil ile yazalım.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Exp { <span class="co">// base class for expressions</span>
<span class="kw">public</span>:
  <span class="kw">virtual</span> ~Exp() {}
};

<span class="kw">class</span> AddExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  AddExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
};

<span class="kw">class</span> MulExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  MulExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
};

<span class="kw">class</span> Number : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> <span class="dt">float</span> f;
  Number(<span class="dt">const</span> <span class="dt">float</span> f) : f(f) {}
};</code></pre>
<p>Örnek programımız da şu şekilde yazılabilir:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Exp *prog1 = <span class="kw">new</span> AddExp(
    <span class="kw">new</span> Number(<span class="dv">10</span>), <span class="kw">new</span> MulExp(
      <span class="kw">new</span> Number(<span class="dv">20</span>), <span class="kw">new</span> AddExp(
        <span class="kw">new</span> Number(<span class="dv">30</span>), <span class="kw">new</span> Number(<span class="dv">40</span>))));</code></pre>
<p>Peki bu ağaç üzerinde gezinmek nasıl mümkün olabilir ? Bir kere, tüm nodelar alt node olarak <code>Exp</code> tipinde bir nesne tutuyor, kesin tip bilgisine sahip değiliz ve bu tip bilgisine sahip olmadan da yorumlamak mümkün değil mi, yorumladığımız node <code>Number</code> mı, <code>MulExp</code> mi vs. bilmemiz gerekir.</p>
<p>Bunu yapmanın çeşitli yolları var, ama güzel bir çözümü yok. Örneğin <code>Exp</code> sınıfında nodeların tipini tutan bir enum tutabiliriz ve <code>Exp *</code>leri gerekli tiplere cast ederiz. Veya Java gibi bir dilde <code>instanceof</code> kontrolü yapılıp cast edilebilir. Başka çözümler de bulunabilir.</p>
<p>Bu gibi durumlarda kabul edilen en yaygın çözüm visitor design patternı. Biraz aradığınızda onlarca tutorial bulabilirsiniz ki tutoriala ihtiyaç duyması bile aslında fonksiyonel dildeki çözümümüzden ne kadar kötü olduğunun bir göstergesi sayılabilir(8 satır son derece basit ve açık bir Haskell koduna denk bir iş yapmaya çalışıyoruz şu anda)</p>
<p>Bu probleme <em>double dispatch</em> problemi de deniyor. Sebebi yapacağımız işleme hem yorumlayıcıya, hem de ağaca göre karar vermek istiyoruz fakat bir yandan da ağaçlara ve yorumlayıcılara aynı muameleyi yapabilmeliyiz. C++ örneğinde her bir node’un bir ağaç oluşturduğuna dikkat.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> AddExp;
<span class="kw">class</span> MulExp;
<span class="kw">class</span> Number;

<span class="kw">class</span> ExpVisitor {
<span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) = <span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) = <span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) = <span class="dv">0</span>;

  <span class="kw">virtual</span> ~ExpVisitor() {};
};

<span class="kw">class</span> Exp { <span class="co">// base class for expressions</span>
<span class="kw">public</span>:
  <span class="kw">virtual</span> ~Exp() {}
  <span class="kw">virtual</span> <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> = <span class="dv">0</span>;
};

<span class="kw">class</span> AddExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  AddExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};

<span class="kw">class</span> MulExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  MulExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};

<span class="kw">class</span> Number : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> <span class="dt">float</span> f;
  Number(<span class="dt">const</span> <span class="dt">float</span> f) : f(f) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};</code></pre>
<p>Detaylara çok fazla girmek istemiyorum, kısaca, virtual methodların yardımıyla artık bir nesneyi <code>Exp</code> tipine cast etsek de doğru <code>visit</code> methodları çağırılacak. Buna göre ilk yorumlayıcımızı şu şekilde yazabiliyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Run : <span class="kw">public</span> ExpVisitor {
<span class="kw">public</span>:
  <span class="dt">float</span> result;
  Run() : result(<span class="dv">0</span>) {}

  <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) {
    Run v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    Run v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = v1.result + v2.result;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) {
    Run v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    Run v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = v1.result * v2.result;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) {
    result = exp-&gt;f;
  }
};</code></pre>
<p>Bu arada nesnesel çözümümüzün fonksiyonel çözümümüzden bir başka farkı da burda belli oluyor. Visitorlar arası değer dönmenin bir yolu yok ve bu yüzden buradaki <code>result</code> member değişkeni gibi bir mutable değişken kullanmak zorunda kalıyoruz.</p>
<p>İkinci yorumlayıcımız:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> StringOfExp : <span class="kw">public</span> ExpVisitor {
<span class="kw">public</span>:
  std::string result;
  StringOfExp() : result(<span class="kw">new</span> std::string()) {}

  <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) {
    StringOfExp v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    StringOfExp v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = <span class="st">&quot;(&quot;</span> + v1.result + <span class="st">&quot; + &quot;</span> +  v2.result + <span class="st">&quot;)&quot;</span>;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) {
    StringOfExp v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    StringOfExp v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = <span class="st">&quot;(&quot;</span> + v1.result + <span class="st">&quot; * &quot;</span> +  v2.result + <span class="st">&quot;)&quot;</span>;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) {
    std::ostringstream ss;
    ss &lt;&lt; exp-&gt;f;
    result = ss.str();
  }
};</code></pre>
<p><code>result</code> member değişkeninin tipinin farklı olduğuna dikkat. Buradaki farklılık Haskell fonksiyonlarındaki dönüş tiplerinin farklılığı ile aynı.</p>
<p>Son olarak programı şu şekilde çalıştırabiliyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Run r;
prog1-&gt;accept(&amp;r);
std::cout &lt;&lt; <span class="st">&quot;return value Run: &quot;</span> &lt;&lt; r.result &lt;&lt; std::endl;

StringOfExp s;
prog1-&gt;accept(&amp;s);
std::cout &lt;&lt; <span class="st">&quot;return value of StringOfExp: &quot;</span> &lt;&lt; s.result &lt;&lt; std::endl;</code></pre>
<p>Çıktı:</p>
<pre><code>➜  cpp  clang++ arith.cpp -g
➜  cpp  ./a.out
return value Run: 1410
return value of StringOfExp: (10 + (20 * (30 + 40)))</code></pre>
<p>Burda 14 satır Haskell kodu ile aynı işi yapan 125 satır C++ kodundan bahsediyoruz. Tabii kodun aynı özelliğe sahip olduğunu sadece aynı sonuca ulaşmasına bakarak karar vermiyoruz. Yapı olarak da oldukça benzerler.</p>
<p>Haskell programında ağaca yeni bir node eklemek için ilk başta <code>Exp</code> tipine yeni bir constructor eklememiz gerekecek ve daha sonra tüm yorumlayıcılarda match edilecek bir pattern daha eklenecek.</p>
<p>C++ programında, <code>Exp</code> sınıfından yeni bir sınıf türeteceğiz ve tamamen aynı <code>accept</code> methoduna sahip olacak. <code>ExpVisitor</code> sınıfına da bir <code>visit</code> methodu daha eklememiz gerek. Daha sonra yorumlayıcılara teker teker alakalı <code>visit</code> methodunun eklenmesi gerek.</p>
<p>Haskell fonksiyonlarının dönüş değerleri, Visitor sınıflarının <code>result</code> değişkeni ile eşleşiyor.</p>
<p>Aslında aynı şeylerden bahsediyoruz yani.</p>
<p>C++ kodunun çalışan bir haline <a href="https://gist.github.com/osa1/5005037">şuradan</a> ulaşabilirsiniz.</p>
<p>Alıştırma: Hem Haskell hem C++ programı için, ağaç üzerinde gezinerek “x + 0” ifadesini “x” haline, “x * 1” ifadesini “x” haline, “x * 0” ifadesini “0” haline getirecek yorumlayıcılar yazın. Anlamı koruyacak şekilde daha küçük bir ağaç elde etmiş olacağız. (bu optimizasyonlar gerçek derleyiciler tarafından yapılıyor)</p>
<h1 id="ifade-problemi">İfade problemi</h1>
<p>Yukarıda anlattıklarımın ifade problemi diye tercüme ettiğim <a href="http://en.wikipedia.org/wiki/Expression_problem">expression problem</a> ile de alakalı.</p>
<p>Problemimiz şu, program iki boyutta gelişebiliyor, 1.si veri yapısı boyutunda, yani ağaca yeni nodelar eklemek, 2.si operasyonlar boyutunda, yani yeni yorumlayıcılar eklemek.</p>
<p>Yukarıdaki çözümler aslında birbirlerine denk: İkisinde de veri yapısını değiştirdiğimizde kodu yeniden derlememiz gerekiyor(dolayısıyla kodun elimizde olması gerekiyor), fakat koda sahip olmadan ve yeniden derleme yapmadan yeni operasyon(yani yorumlayıcı ekleyebiliyoruz).</p>
<p>Bu yazının amacı ifade problemi değil, o yüzden en azından şimdilik bahsetmeyeceğim(yazının orjinalinde bu kısım hiç yoktu), fakat aslında oldukça ilginç bir konu ve Haskell’ın ve Lisp dillerinin getirdiği ilginç çözümler var. OO dillerin çözümleri hakkında pek bir bilgim yok.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Aslında tabii yorumlayıcı bir çeşit byte-code üzerinden değil de, AST üzerinden yorumlama yapıyorsa, program çalıştığı sürece AST’yi geziyor demektir ve bu durumda bir derleyiciden çok daha fazla sayıda tur atmış olur. Benim burada kastettiğim çalıştırılmadan önce ön işlem anlamında yapılan gezinmeler.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Haskell örneğinde yorumlayıcıların tipleri farklı olduğundan ikisine aynı muameleyi yapamıyoruz, farkındayım. Tamamen aynı tipte yorumlayıcılar için Fay için verdiğim linklere göz atabilirsiniz.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Rowlar, kindlar ve tip çıkarımı hakkında öylesine bir yazı</title>
    <link href="http://osa1.net/posts/2013-02-15-rowlar-kindlar.html" />
    <id>http://osa1.net/posts/2013-02-15-rowlar-kindlar.html</id>
    <published>2013-02-15T00:00:00Z</published>
    <updated>2013-02-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı birkaç gün önce attığım bir mail aslında. Acele ile yazılmış bir yazı olmasına rağmen epey uzun oldu ve maili yazmaya başlamadan önce kafamda karmaşık bir şekilde duran bazı fikirleri toparlamamda yardımcı oldu. Pek kimsenin işine yarayacağını tahmin etmesem de, yine de buraya koyuyorum. Küçük bazı düzenlemeler yaptım. Eklemeler ise yazının en altına yazıldı. Kodlar OCaml dilinde yazıldı.</p>
<hr />
<p>Üzerinde çalıştığım dilin tip sistemi hakkında<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ty =
  | ...
  | <span class="dt">TRow</span> <span class="kw">of</span> tyrow
  | ...

<span class="kw">type</span> fieldty =
  | <span class="dt">Pre</span> ty
  | <span class="dt">Btm</span> <span class="co">(* Abs ismi lambda abstractionlarda kullanildi *)</span>

<span class="kw">type</span> tyrow =
  | <span class="dt">EmptyRow</span>
  | <span class="dt">Row</span> (id * ty * ..1..)
  | ..2..</code></pre>
<p>1 ve 2 boşluklarını doldurmamız gerekiyor. Sorunlar şunlar:</p>
<p>1 kısmına yazdığımız tip, sadece yine kendi tipiyle(yani <code>TRow</code> ile) unify etmek zorunda(ilk bakışta <code>tyrow</code> yazmak mantıklı gibi geliyor ama bu yüzden değil).</p>
<p>2 kısmına yazdığımız constructor polymorphic row’u temsil edecek. Burada ben ilk başta aslında row değişkenlerini tamamen yok sayıp, recordlar extensible mı değil mi diye bir boolean flag tutayım demiştim. Fakat sorun, recordlar rowları paylaşabiliyorlar, örneğin şöyle bir fonksiyonda <code>\r -&gt; r.x = 10</code> tip <code>{r/x} -&gt; {x:int|r/x}</code> oluyor, başka bir yerde bu <code>r</code> kullanılabilir(parametre olarak verilen record başka yerlerde kullanıldığında fonksiyonun dönüş değeri olan recordın row değişkeni ile aynı row değişkenine sahip birden fazla record oluyor). Dolayısıyla bir değişken olmak zorunda.</p>
<p>Fakat bu <code>typevar</code> tipinde olamaz, çünkü <code>typevar</code> bir <code>ty</code> ile unify edilebiliyor. Rowlarda ise <code>tyrow</code> ile unify etmek istiyoruz. Ayrı bir tip gerekiyor yani.</p>
<p>Temel olarak row variable ile normal variable tamamen aynı olmalı, tek farkla, row değişkenler sadece row değişkenlerle/değerler ile unify edecek, variablelar da aynı şekilde.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<h2 id="neden-tip-seviyesinde-kindlara-ihtiyaç-var">Neden tip seviyesinde kindlara ihtiyaç var ?</h2>
<p>Type schemeler row değişkenler de tutabilir. <code>let</code> ile bir fonksiyon tanımladım, fonksiyon tipindeki free type variableları generalize ederek(terimler teminoloji ile uyumlu olsun diye ingilizce kullanıldı) bu fonksiyon polymorphic hale getiriliyor ve tipi <code>TypeScheme</code> olarak tutuluyor, quantified değişkenler belirtiliyor.<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup></p>
<p>Daha sonra bu fonksiyon kullanıldığında instantiate ediliyor. Burada instantiate edilen quantified değişkenler yerine ancak kendi kindlarında tiplerin konulması bir şekilde sağlanmalı.</p>
<p>Yani şunu demeye çalışıyorum, elimde bir row variable varsa, bu ancak bir row tipi ile yer değiştirebilir(yerine ancak row tipi yazılabilir). Bunu implementasyon sırasında tip sistemi ile garanti etmek gerçekten zor. İnsanlar bu yüzden kind sistemi kullanıyorlar sanırım.</p>
<p>Kind kullanırsam şöyle oluyor, her tipe bir kind veriyorum. Özet geçmek gerekirse, mesela TVar bir type değişkeni tutuyordu, şimdi bir de kind tutacak. Kindlar ise dilimde kaç tip -birbirlerinden farklı- type varsa, o kadar olacak. Örneğin <code>Star</code> int, bool gibi tipler için kullanılırken, <code>Row</code> row tipleri için kullanılır. Bu sayede bir değişkenim Row kindında ise, quantified edilse de instantiate edilse de bu bilgi taşınır ve en son yerine yazılacağında kind kontrol edilir. Tüm yerine yazmalar <code>kind-preserving</code> olmalıdır.<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup></p>
<p>Bu sayede farklı kindlarda type variablelar için aynı fonksiyonları kullanabilirim, sürekli kind bilgisini de taşırım. En son substitution veya unification yaparken, kindların korunup korunmadığını kontrol ederim ve normal type değişkeni yerine row type yazılmamasını sağlarım veya unification sırasında hata alırım.</p>
<p>–</p>
<p>Kindlarla beraber tipleri şu şekilde tanımlayabiliyoruz(yaklaşık olarak, henüz programı yazmadım)</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> kind =
  | <span class="dt">KStar</span>                 <span class="co">(* kind of term types *)</span>
  | <span class="dt">KRow</span>                  <span class="co">(* kind of row types *)</span>
  | <span class="dt">KArr</span> <span class="kw">of</span> (kind * kind) <span class="co">(* kind of type constructors *)</span>

<span class="kw">type</span> ty =
  | <span class="dt">TCon</span> <span class="kw">of</span> tycon     <span class="co">(* constant *)</span>
  | <span class="dt">TVar</span> <span class="kw">of</span> tyvar     <span class="co">(* type variable *)</span>
  | <span class="dt">TApp</span> <span class="kw">of</span> (ty * ty)
      <span class="co">(* type application, to be well-typed</span>
<span class="co">         kind of first ty should be KArr (k2, k)</span>
<span class="co">         and second ty should be k2 *)</span>
<span class="kw">and</span> tyvar = (tyvarlink <span class="dt">ref</span> * kind)
<span class="kw">and</span> tyvarlink =
  | <span class="dt">NoLink</span> <span class="kw">of</span> id <span class="co">(* just a type variable *)</span>
  | <span class="dt">LinkTo</span> <span class="kw">of</span> ty <span class="co">(* equated to a ty *)</span>
<span class="kw">and</span> tycon = (id * kind) <span class="co">(* kind should be always KStar *)</span>

<span class="kw">let</span> t_int        = <span class="dt">TCon</span> (<span class="st">&quot;int&quot;</span>,  <span class="dt">KStar</span>)
<span class="kw">let</span> t_bool       = <span class="dt">TCon</span> (<span class="st">&quot;bool&quot;</span>, <span class="dt">KStar</span>)
<span class="kw">let</span> t_unit       = <span class="dt">TCon</span> (<span class="st">&quot;unit&quot;</span>, <span class="dt">KStar</span>)
<span class="kw">let</span> t_list       = <span class="dt">TCon</span> (<span class="st">&quot;[]&quot;</span>,   <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>))
<span class="kw">let</span> t_ref        = <span class="dt">TCon</span> (<span class="st">&quot;ref&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>))
<span class="kw">let</span> t_arr        = <span class="dt">TCon</span> (<span class="st">&quot;-&gt;&quot;</span>,   <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>)))
<span class="kw">let</span> t_empty_row  = <span class="dt">TCon</span> (<span class="st">&quot;&lt;|&gt;&quot;</span>,  <span class="dt">KRow</span>)
<span class="kw">let</span> t_row_ext    = <span class="dt">TCon</span> (<span class="st">&quot;&lt;+&gt;&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KArr</span> (<span class="dt">KRow</span>, <span class="dt">KRow</span>)))
<span class="kw">let</span> t_rec_const  = <span class="dt">TCon</span> (<span class="st">&quot;{_}&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KRow</span>, <span class="dt">KStar</span>))

<span class="co">(* type of {r1} *)</span>
<span class="kw">let</span> rp1 = <span class="dt">TApp</span> (t_rec_const, <span class="dt">TVar</span> (<span class="dt">ref</span> (<span class="dt">NoLink</span> <span class="st">&quot;r1&quot;</span>), <span class="dt">KRow</span>))

<span class="co">(* type of {r1} -&gt; {_:int|r1} *)</span>
<span class="kw">let</span> f   = <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_arr, rp1), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_row_ext, t_int), rp1))</code></pre>
<p>En sonraki iki tanım örnek olsun diyeydi.</p>
<p>Karmaşık olduğunun farkındayım ama 1) bu tip sistemi implementasyonları için standard yol gibi geldi bana(çok fazla makalede kind sistemlerinden bahsediliyor) 2) diğer türlü de daha az karmaşık değil gibi.<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup></p>
<p>Burda mesela <code>TApp</code> oluşturan bir yardımcı fonksiyon oluştururuz ve kindları kontrol eder, uyumlu mu diye, bir miktar daha kolaylaşır. Yardımcı fonksiyonlarla işi kolaylaştırabiliriz diye düşünüyorum yani.</p>
<p>Bu örnekde <code>rp1</code> yerine mesela <code>{a:bool}</code> (yani <code>TApp (TApp (t_rec_ext, bool_ty), t_empty_row)</code>) yazarsak:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">TApp</span> (<span class="dt">TApp</span> (t_arr, rp1), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_row_ext, t_int), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_rec_ext, bool_ty), t_empty_row)))</code></pre>
<p>Bana gayet temiz bir şekilde <code>{x:int, a:bool}</code> elde ettik gibi geliyor ve tek yaptığımız yerine yazmak oldu. ( bu sunumda labelların atlandığının farkındayım, tam olarak labelları nasıl bu sisteme entegre ederim düşünmedim )</p>
<p>Diğer türlü yapılamaz mı, tabii ki yapılabilir ve ben zaten çok yaklaşmıştım. Fakat çirkin olmayan bir yolu yok. Kod içerisinde şöyle kısımlar olmak <em>zorunda</em> gibi: “implementasyonum doğru olduğuna göre bu type variable record ile unify edilmiş olacak, exhaustive olmayan pattern matching yap”. Mesela tüm row değişkenler bir record’a unify edilimş olacak, ben pattern matching ile fieldları alacağım kendi recordıma ekleyeceğim vs.<sup><a href="#fn6" class="footnoteRef" id="fnref6">6</a></sup></p>
<p>Ama kindler ile yaptığımda bu gibi durumlar olmayacak, ben <code>TApp</code>’lar ile typelar oluşturacağım, kind preserving substitutionlar, generalizationlar, instantiationlar yapılacağından, her zaman row tiplerim well-formed olmuş olacak ben hiçbir kontrol yapmadan <code>TApp</code>’ler oluşturmaya başlayacağım.</p>
<p>Ben bugün akşam birkaç makale daha inceleyeceğim: Type Inference for Records in a Natural Extension of ML (Didier Rémy) ve A Polymorphic Type System for Extensible Records and Variants (Mark P. Jones, Benedict R. Gaster). Bir de Typing Haskell in Haskell (Mark P. Jones)’a baktım, Haskell’da burada konuştuğumuz anlamda recordlar yok, ama kind sisteminden bahsederken “row kindlar da kolayca eklenebilir” diyerek sanırım yukarıda yaptığım şeyi kastetmekte.</p>
<p>Bu nasıl olabiliyor anlayabilmiş değilim ama gerçekten internette hiç örnek implementasyon yok. Bu yüzden ben bir tane yazacağım blog yazısı olarak. Polymorphic recordlara sahip bir dil inceleyeyim dedim, bir tanesi <a href="http://elm-lang.org/">Elm</a> adlı bir dil, kaynağı Haskell ile yazılmış temel olarak “Scoped Labels” makalesini kullanmış, ama kod berbat bir durumda. Çok çok karmaşık, kod stili berbat(type annotationlarını atlamış, Haskell’da bunu hiçbir zaman yapmayız, derleyici uyarı verir, annotationlar OCaml’daki gibi kodun içine yazılmaz, ayrı bir satıra yazılır ve anlaşılabilmeye çok katkı sağlarlar) vs. Yine de okunacak olursa en mantıklısı bu.</p>
<p>İkincisi <a href="http://www.pllab.riec.tohoku.ac.jp/smlsharp/">SML#</a>. Bu da ne yazık ki SML üzerine implement edilmiş ve kaynak kodu devasa. Tüm SML kodunu incelemek gerekecek yani(aradım bulamadım alakalı kısımları).<sup><a href="#fn7" class="footnoteRef" id="fnref7">7</a></sup></p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Özetle, row polymorphism’e sahip, multi-staged bir dil. Buradaki veri yapısı dilin tip sistemini ifade ediyor. Row tiplerine dikkat. Row polymorphism’de fieldlar üzerinde bazı kısıtlar tanımlamanın birkaç yolu var. Bir yol, benim burada yaptığım ve <a href="http://gallium.inria.fr/~remy/publications.html">D. Rémy</a>’nin “Type inference for records in a natural extension of ML” ve başka makalelerinde gösterdiği gibi, field tiplerinde bir çeşit “flag” tutmak. Makalelerde Abs/Pre diye geçer, benim kodumda Pre/Btm. Bu yolun bu işi yapmak en bariz yol olduğunu söyleyebiliriz belki. Fakat kesinlikle en kolay/güzel yötem değil. Alternatif olarak kısıtlar constraint seviyesinde, kind seviyesinde veya başka bazı seviyelerde tanımlanabiliyor.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Burada anlatmaya çalıştığım problem bana çok vakit kaybettirdi ve aslında pek çok kişiye tanıdık gelebilir. Kısaca yapmaya çalıştığım şey, bazı şeyleri statik olarak garanti etmek için tip sistemini kullanmaya çalışmak. Örneğin bir programlama dilinde syntax ağacını well-formed olmayan programları ifade edebilmesini engelleyecek şekilde oluşturmak gibi. Bu gibi durumlarda eğer yeterince güçlü tip sisteminiz yoksa(örnek: GADTler yardımcı olabiliyor) işiniz çok zorlaşabiliyor. Daha kolay bir yöntemi runtime’da bunu garantilemek. Hemen sonrasında anlattığım şey tam olarak bu aslında. Statik garantiler verebilmek süper birşey aslında. Hiçbir şart altında programınızın yanlış çalışmayacağını garanti altına alıyorsunuz. Ama bazı durumlarda bu mümkün ama çok zor olabiliyor. Diğer yandan, zor da olsa bir kere implement ettikten sonra kesin olarak doğru çalışacağından emin olabiliyorsunuz. Veya test etmesi çok kolay oluyor vs.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Anlattığım şey Damas-Hindley-Milner tip sisteminin temellerinden aslında.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Kindları kendi kendime keşfettiğim an. Aslında Haskell programcısı olduğumdan kind konspetine aşinaydım, ama bu şekilde kullanımı bir bakıma kendi kendime keşfettim diyebilirim. Kind adını da ben vermedim tabii, daha sonra hakkında okudukça farkettim.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>“diğer türlü daha az karmaşık değil gibi” derken kastettiğim, Rémy usulü, field tiplerine bir flag koyarak Abs/Pre özelliğini belirtmekti.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Burda aslında biraz programımın implementasyonu ile alakalı detaylardan bahsediyorum. Belki bir ara biraz daha açarım.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Daha sonradan farkettim ki bir alternatif daha varmış: “Extensible records with scoped labels” makalesinde bahsedilenlerin implement edildiği <a href="http://www.equational.org/morrow/">Morrow</a> programlama dili. En iyi implementasyon şimdilik bu. Tek problemi, kurulmak için <a href="http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem">UUAG attribute grammar system</a>a ihtiyaç duyması. Bir de eğer sadece type inference yapmasın, bir de çalıştırsın derseniz, OCaml’a ihtiyaç duyuyor. Evet çok fantastik. Haskell ile statik analiz kısımları yapılıyor ve OCaml’a derleniyor. Tabii programın asıl olayı tip sistemi olduğundan, deneme için yazdığınız programları çalıştırmak istemeyebilirsiniz, o zaman OCaml’a gerek yok.<a href="#fnref7">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Okudukarım, okunacaklar</title>
    <link href="http://osa1.net/posts/2013-02-12-okuduklarim-okunacaklar.html" />
    <id>http://osa1.net/posts/2013-02-12-okuduklarim-okunacaklar.html</id>
    <published>2013-02-12T00:00:00Z</published>
    <updated>2013-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Son ciddi yazımdan beri epey vakit geçmiş. Henüz buradan duyuramadım ama, bir süredir 2. 14 haftalık stajımı yapıyorum. Detaylar için ayrı bir yazı yazmayı planlıyorum ama şimdilik türkiyedeki tek PLT işinde çalıştığımı söyleyebilirim sanırım(abartmış olabilirim, PLT üzerine çalışan insanlar varsa söyleyin, ben de merak ediyorum). Birkaç ay önce imkansız gibi gözüken bazı şeylerin bu kadar çabuk normalleşmesi ne garip.</p>
<p>Neyse, kısaca şu anda üzerinde çalıştığım proje için okuduğum ve okumakta olduğum makalelerden bahsedeceğim biraz.</p>
<h2 id="okuduklarım">Okuduklarım</h2>
<pre><code>* A polymorphic modal type system for lisp-like multi-staged languages.

Multi-staged programming ile tanıştığım makale bu oldu. Aslında giriş için hiç iyi bir makale değil, kullandığı dil çok büyük, bir tam kolon big-step [operational semantics](http://en.wikipedia.org/wiki/Operational_semantics) verilmiş. Tip ve çıkarım kuralları da buna bağlı olarak kompleks.

Multi-staged programming&#39;i kısaca Lisp macroları benzeri bir meta-programming araçları gibi düşünebiliriz. Daha detaylı bilgiyi üzerinde çalıştığım yorumlayıcı bittiğinde, kendisi ile örneklerle vermek istiyorum. Şimdilik şöyle özet geçebilirim: Programların çalıştırılması birden fazla stage&#39;e ayrılmış oluyor ve her iki stage arası bir miktar evaluation yapılıyor. Örnek olarak bir matris çarpımı yapacaksanız, matrislerin uzunluğu belli olduğunda bir miktar evaluation yaparak matris uzunluk kontrolü ve iterasyon içermeyen, girdi olarak verdiğiniz iki matris boyutundaki matrisler için çarpma yapan bir kod üretebilirsiniz. Daha sonra çarpma işlemi nispeten daha hızlı olacaktır.

Bir miktar [partial evaluation](http://en.wikipedia.org/wiki/Partial_evaluation) ile de alakalı. Partial evaluation çok fantastik bir konu, bu yazıyı okuyan herkesin en azından wikipedia sayfasına bakmasını tavsiye ederim(özellikle Futamura projections kısmı fantastik).

* Static analysis of multi-staged programs via unstaging translation.

Multi-staged programların statik analizlerinin daha zor olduğu gözlemlendikten sonra, multi-staged bir programın anlam korunarak unstaged bir hale tercüme edilebileceğinin farkedilmesi üzerine, multi-staged programların bu tercüme ile statik olarak analiz edilebileceğini söylüyor. Staged expressionlar bir çeşit record-calculus(lambda calculus + recordlar)a tercüme ediliyor ve statik tip sistemi verilmiş.

Bir önceki makaledekine göre çok küçük bir multi-staged dil tanımlıyor ve bu yüzden okuması/anlaması daha kolay. Tip sistemi de daha az farklı olduğundan(hatta makalede tip sistemi anlamında yeni birşey yok) onun da anlaşılması daha kolay olabilir. (benim için farketmedi, benzer bir tip sistemi üzerinde hiç çalışmamıştım)

Tercüme sonrası analizler, tercüme öncesindeki hal ile eşleştiriliyor.


* A modern eye on ML type inference.

Damas-Hindley-Milner tip sisteminin bir özeti niteliğinde. Pek çok detay bilindiği varsayılarak atlanmış, ve 2. ve 3. bölümleri &quot;gelecek&quot; denmesine rağmen, 2005&#39;den beri, gelmemiş.

Tip çıkarımından bahsedildikten sonra, constraint solving ile alakasından bahsediyor. W ve J algoritmaları ve parametrik HM(X) algoritmasından bahsediliyor. Tip çıkarımı ile constraint oluşturma/çözme arasındaki ilişkiyi anlamak için çok iyi.

Hatırladığım bir başka güzel yanı da constraint oluşturma ve çözme kısımlarının nasıl birbirlerinden ayrılabileceği ve bunun getirdiklerinden bahsetmesiydi. Ayrıca constraintler yardımıyla çıkarımı polymorphism&#39;i anlatmadan önce anlatması da ayrı bir güzellik bence.

* Record polymorphism yazıları

Refined subtyping and row variables for record types(Didier Remy), Type inference for records in a natural extension of ML(Didier Remy), Extensible records with scoped labels(Daan Leijen), A polymorphic type system for extensible records and variants(Gaster, Jones)

Hepsini tamamen okumasam da, bir göz gezdirdim. Leijen makalesi özellikle çok hoş ve okuması kolay. [Elm](http://elm-lang.org/) dilinin [recordları](http://elm-lang.org/blog/announce/version-0.7.elm) temel olarak bu makalede anlatılanların bir implementasyonu. Ben de başka bir projem için benzer bir record yapısı planlıyorum.

Bu makalelerden benim çıkardığım en önemli şey şu oldu: Derleme zorluğu önemsenmediğinde, çok güzel record tipleri elde etmek mümkün.

İkinci olarak, aynı kısıtları tanımlamanın farklı yolları var ve çoğu zaman &quot;en iyi&quot; diyebileceğimiz bir yola sahip değiliz. Duruma göre alternatifleri değerlendirmek zorundayız.

Polymorphic recordlar söz konusu olduğunda, bir recordda bir t tipinde bir labelın bulunduğunu veya bulunmadığını belirtmenin birden fazla yolu var. Kind seviyesinde tanımlayabilirsiniz ki kompleks bir kind tipi gerektirir(daha sonra bir de kindların well-formed olduğunu kontrol etmek gerekebiliyor, kind-inference algoritmaları falan var). Ohori&#39;nin makalelerinde bu kullanıyor sanırım. Direkt olarak row field tiplerine gerekli bilgiği yerleştirebilirsiniz ki Remy&#39;nin makalelerinde yapılan bu. Veya constraint oluşturabilirsiniz ki bu benim en sevdiğim yöntem, Jones&#39;un makalesinde kullanılmış(aslında _constraint_ değil de _predicate_ denmiş).

Yani recordlar gibi elinizde nispeten kompleks bir tip olduğunda(en basitinden, label-type ikililerinden oluşan bir kümeden bahsediyoruz ve bazı makalelerdeki sistemlerde birden fazla label olabiliyor), teorik kısıtları ifade etmek için çeşitli yollar var ve elinizdeki mevcut sisteme hangisi daha iyi gidiyorsa onu seçme şansınız var. </code></pre>]]></summary>
</entry>
<entry>
    <title>Alıntılar [1]</title>
    <link href="http://osa1.net/posts/2012-11-20-alintilar-1.html" />
    <id>http://osa1.net/posts/2012-11-20-alintilar-1.html</id>
    <published>2012-11-20T00:00:00Z</published>
    <updated>2012-11-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Paul Feyerabend’in “Özgür bir toplumda bilim” adıyla tercüme edilmiş kitabından bir kısım paylaşacağım. Aslında kitap genel olarak çok ilginç bulduğum pek çok fikirden bahsetmekte, fakat özellikle bu kısımı <a href="http://osa1.net/mathematicianslament/">bir önceki yazımla</a> da alakalı olduğunu düşündüğümden ve başka konular hakkında da hiç düşünmediğim fakat aslında bariz olabilecek fikirlerden bahsettiğinden paylaşmak istedim.</p>
<p><em>Sıradan insanlar bilimi denetleyebilirler ve denetlemelidirler</em> bölümünden:</p>
<blockquote>
<p>Tipik olmaktan hiç de uzak olmayan bu örnekler, bilim adamlarının ve fizikçilerin yargılarını incelemeden kabul etmenin yalnızca aptallık değil, <em>düpedüz sorumsuzluk</em> olduğunu da gösteriyor. Söz konusu olan mesele, ister küçük bir grup için ister tüm bir toplum için, eğer önem taşıyorsa, <em>o zaman bu yargıların en sıkı biçimde incelenmeleri gerekir</em> . Sıradan insanlar arasında konuyla ilgili seçilmiş komiteler, evrim teorisinin gerçekten de biyologların inanmamızı istedikleri kadar sağlam temellere sahip olup olmadığını, onların anladığı anlamda sağlam temellere sahip olmasının meseleyi halledip halletmediğini ve bu teorinin okullarda öğretilen diğer görüşlerin yerini almasının gerekip gerekmediğini incelemelidirler.</p>
</blockquote>
<p>Bu bakış açısı bana epey mantıklı geldi. Devamında şöyle söylüyor:</p>
<blockquote>
<p>Her olayda son sözü, uzmanlar değil, konuyla doğrudan ilgili insanlar söylemelidir. Jürilerin bulunduğu mahkemelerce yapılan her yargılama, sıradan insanların “biraz çaba gösterdiklerinde” uzmanların hatalarını açığa çıkarabilecekleri temel varsayımına dayanır. Yasa, uzamanların sorguları sırasında verdikleri ifadelerin jürinin değerlendirmesine sunulmasını öngörür. Bunu isterken, uzmanların da eninde sonunda insan olduklarını, tümüyle uzmanlık alanları içinde kalan konularda bile hata yaptıklarını, kendi fikirlerinin güvenilirliğini sarsabilecek her türden belirsizliği örtbas etmeye çalıştılarını, uzmanlıklarının hiç de öyle sık sık ima edildiği gibi ulaşılmaz olmadığını varsayar. Yasa ayrıca, sıradan bir insanın, uzmanların kullandıkları usullerin anlaşılması ve hatalarının ortaya çıkarılması için gerekli bilgiyi edinebileceğini de varsayar. Bu vaysayımın doğruluğu bütün davalarda defalarca kanıtlanmıştır.</p>
</blockquote>
<p>Katılıp katılmadığım hakkında bir karara varamamış olsam da, bu bakış açısı hoşuma gidiyor. Yine aynı kısımda, bilim adamlarının da diğer pek çok meslek gruplarına yapıldığı gibi, denetlenmesi gerektiğinden bahsedildikten sonra, konuyu eğitimcilere getirir:</p>
<blockquote>
<p>Eğitimciler olayında durum daha da kötüdür. Zira fiziksel bir tedavinin başarılı olup olmadığını belirlemek olanaklıyken, eğitim denilen zihinsel tedavinin başarısını belirleyecek bir araca sahip değiliz. Okuma, yazma, aritmetik ve temel olgulara ilişkin bilgi hakkında bir yargıya varılabilir. Ama insanları ikinci el varoluşçular ya da bilim felsefecileri haline getiren bir eğitim için ne diyeceğiz? İnsanlar nasıl ki kendi doktorlarını denetlemeye başladılarsa, öğrenciler de kendi öğretmenlerini denetlemeye başlamadıkça, dokunulmazlık zırhı ardıkdaki öğretmen kendi fikirlerini bizlere yutturabilir. Bütün durumlarda tavsiye olunan şey, <em>uzmanlara başvurmak</em> , ama onlara hiç bir zaman <em>güvenmemek</em> ve kesinlikle hiç bir aman <em>onlara</em> tümüyle <em>bel bağlamamaktır</em> .</p>
</blockquote>
<p>Daha pek çok ilginç gözlem ve fikirle dolu. Belki ileride daha da paylaşırım.</p>]]></summary>
</entry>
<entry>
    <title>A Mathematician's Lament</title>
    <link href="http://osa1.net/posts/2012-11-19-mathematicianslament.html" />
    <id>http://osa1.net/posts/2012-11-19-mathematicianslament.html</id>
    <published>2012-11-19T00:00:00Z</published>
    <updated>2012-11-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Geçenlerde Paul Lockhart’ın <a href="http://www.maa.org/devlin/lockhartslament.pdf">A Mathematician’s Lament</a> adlı yazısını okudum. Genel olarak matematik eğitimine ve toplumlarda matematiğe bakışa bir eleştiri niteliğinde olsa da, öğretim, öğrenim ve eğitim sistemleri ile alakalı pek çok süper tespit var. Sadece sorunlar değil, çözümleriyle de alakalı bir yazı olmuş(her ne kadar ben yazar tarafından sunulmuş pek çok çözümü pek de gerçekçi bulmasam da).</p>
<p>Matematikçiler haricindeki insanlar tarafından matematiğe olan görüşü, bunun neden yanlış olduğunu ve daha doğru bir görüşün ne olabileceğini anlamak için okumanızı tavsiye ederim. Her ne kadar ben matematikçi olmasam ve matematik konusunda temellerimin yeterince iyi olmadığını düşünsem de, anlattığı pek çok meseleyi anlayabiliyorum ve açıkçası bazı durumlarda yazarın neler hissetiğini anladığımı ve bazı başka konularda benzerlerini hissettiğimi iddia edebilirim.</p>
<p>Aslında konu hakkında çok fazla şey yazmıştım, ama bir yerden sonra kafamdakileri toplarlayamadım ve ortalık karıştı. Kısaca, yazıda benim en çok dikkatimi çeken ve kendi hayatımdan onlarca örnek bulabildiğim bir kısımdan bahsedeceğim:</p>
<blockquote>
<p>Mathematics is an art, and art should be taught by working artists, or if not, at least by people who appreciate the art form and can recognize it when they see it. It is not necessary that you learn music from a professional composer, but would you want yourself or your child to be taught by someone who doesn’t even play an instrument, and has never listened to a piece of music in their lives? Would you accept as an art teacher someone who has never picked up a pencil or stepped foot in a museum? Why is it that we accept math teachers who have never produced an original piece of mathematics, know nothing of the history and philosophy of the subject, nothing about recent developments, nothing in fact beyond what they are expected to present to their unfortunate students? What kind of a teacher is that? How can someone teach something that they themselves don’t do?</p>
</blockquote>
<p>Burada <em>matematik</em> kelimesini çıkarıp, başka kelimeler koyup, etrafınıza bakın. Ben etrafıma baktığımda bu durum çok bariz.</p>
<p>Bazı şeylere(programlama) küçük yaşta başlayan bir hobici olarak bunu daha kolay farkedebiliyor olabilirim. Bana programlama dilleri anlatmaya çalışan insanın aslında konuyla alakalı herhangi bir ilgisinin olmadığını ve bilgi olarak da yeterli olmadığını anlamak ne kadar kolay, muhtemelen söylesem abarttığımı sanırsınız. Hatta konuyla alakası olmayan başka arkadaşlar bile bizzat bana durumu farkettiklerini söylemişlerdi.</p>
<p>Lise ortamında da hocalarım hakkında aynı şeyleri o dönemlerde tuttuğum blogumda hep yazdım ve bu yüzden pek çok problem yaşadım(gerçi çok sonralardan farkettim ki problem yaşamamın sebebi biraz da üslubummuş).</p>
<p>Peki bu şartlar altında öğrencilerin bundan faydalanmasını nasıl bekleyebilirsiniz? Dersi anlatanın anlattığı ders hakkında yeterince fikri yok ki.</p>
<p>Dikkatimi çeken ikinci bir kısım da şu oldu:</p>
<blockquote>
<p>There is surely no more reliable way to kill enthusiasm and interest in a subject than to make it a mandatory part of the school curriculum. Include it as a major component of standardized testing and you virtually guarantee that the education establishment will suck the life out of it. School boards do not understand what math is, neither do educators, textbook authors, publishing companies, and sadly, neither do most of our math teachers. The scope of the problem is so enormous, I hardly know where to begin.</p>
</blockquote>
<p>Ben de olaya benzer bir açıdan bakıyorum.</p>
<p>Birincisi, öğretilenlerin karşılığında öğrenciden birşeyler beklemek, bana göre, olayın tüm anlamını, faydasını, heyecanını ve zevkini kaçırıyor, ki yukarıdaki paragrafta da bahsedilen temel olarak bu. Özellikle eğitim sistemi yeterince saçmaysa, 2 saat içerisinde maksimum miktarda soru çözme gibi komik kriterler ile birşeyler ölçmeye çabalıyorsanız, herhangi birşey öğretebiliyor olmayı beklemek bana göre son derece saçma(komik diyecektim, sonra artık tadının kaçtığını ve komik olmadığını farkettim).</p>
<p>Bir sene sonra bilgisayar mühendisi olarak mezun olacak arkadaşların benim nasıl hobi olarak programlamayla ilgilendiğimi anlamamalarını bence bu açıklıyor.</p>
<p>Belki bu sefer ben biraz abartmış olacağım ama(bu yazıyı okurken birkaç yerde yazarın çok abarttığını düşümüşümdür mesela, bence bu yazarın olayı ne kadar sahiplendiğini ve önemsediğini gösteriyor), hep şöyle birşey hayal etmişimdir; X okulu(alanı siz belirleyin, örneğin <em>bilgisayar bilimleri</em> olabilir), katılan kimseye hiçbir şekilde ödev verilmiyor, kimse sınavlara girmiyor, bir diploma yok. Herkes başlangıçta neden orada olmak istediğinin farkında(bu kısım bence çok önemli). Günümüzdeki anlamıyla bir müfredat olmasa da, dersler var. Katılımcılardan bazı yeterliliklere sahip olmaları istense de, bu yeterlilikler diplomalar veya testlerle ölçülmüyor, mülakat formatında, veya kağıt üzerinde konunun gerekliliğini de gösteren birkaç <em>gerçek</em> problem ile ölçülebilir(veya başka yöntemler bulunabilir). Yaş ve sınıf konsepti yok. Bu da benim fantezim işte hahah.</p>
<p>İkinci olarak, birşeyi yapmaya mecbur kalmak da benzer bir etki oluşturuyor ki bunu çoğu kişi gözlemlemiştir(özellikle mesleklerini hobilerinden seçenler, mesela ben ;-( ).</p>
<hr />
<p>Bu gibi konulara merak duyuyorsanız okumanızı tavsiye ettiğim keyifli bir yazı olmuş.</p>]]></summary>
</entry>
<entry>
    <title>Assembly programları için kod organizasyonu hakkında</title>
    <link href="http://osa1.net/posts/2012-11-12-assembly-kod-organizasyonu.html" />
    <id>http://osa1.net/posts/2012-11-12-assembly-kod-organizasyonu.html</id>
    <published>2012-11-12T00:00:00Z</published>
    <updated>2012-11-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Düzenlenip yayınlanmayı bekleyen süper yazılar olmasına rağmen şu anda mikroişlemciler sınavı çıkışı bunu yazıyor olamam epey garip.</p>
<p>Her ne kadar 2. vizeden çıkmış olsak da, henüz umudu kesmeyenlerin ve gelecek dönemlerin işine yarayabileceğini düşündüğüm, derste -bana göre yanlış olarak- hiç bahsedilmeyen birkaç şeyden bahsedeceğim.</p>
<p>Ana fikir şu, bu ders kapsamında veya genel olarak x86 ASM kodlarken, bazı <em>convention</em>lar takip etmek program organizasyonu açısından çok faydalı oluyor ve ben birazdan bahsedeceğim conventionlar olmadan ben programlayamazdım.</p>
<p>Bunlardan ilk bahsedeceğim tamamen kozmetik, kodun okunaklığını arttıran ve aslında tamamen programcının yorumlaması gereken basit bir düzenleme.</p>
<p>Etiketleri yerleştirirken, kendi uydurduğum <em>scope</em> kuralları uyguluyorum. Yazdığım kod şu şartları sağlıyor:</p>
<ul>
<li>Zıplama yapılırken, zıplamayı yapan kod ile zıplaya yapılan etikete sahip kod aynı miktarda girintilenmiş olmalı.</li>
<li>Bu iki kısım kod arasında daha az girintilenmiş başka kod olmamalı.</li>
</ul>
<p>Örnek olarak aşağıdaki kod, henüz deadline’ı gelmemiş bir ödevin çözümünün bir parçası. Programın tamamını koyamıyorum o yüzden, sadece etiketleri yerleştireceğim:</p>
<pre><code>...

kopyala:
    ...
    
    kopyala_dongu:
        ...
    
    ...

sirala:
    ...

    sirala_dongu:  
        ...
   
    sirala_son:     
        ...

kaydir:
    ...
    
    kaydir_dongu:
        ...
            
    kaydir_son:
        ...</code></pre>
<p>Yukarıdaki maddeleri açıklamak için birkaç örnek: <code>sirala_dongu</code>den <code>sirala_son</code>a atlanabilir, ama <code>kaydir_dongu</code>ye atlanamaz, çünkü arada daha az girintilenmiş kod var(<code>kaydir</code> prosedürüne ait). Her yerden <code>kaydir</code>, <code>sirala</code> ve <code>kopyala</code> <em>çağırılabilir</em>(<code>call</code>), ancak hiçbir yerden zıplanamaz. Bunun gibi. Bunları takip ettiğinizde, kod çok daha okunaklı bir hale geliyor diye düşünmekteyim.</p>
<p>İkinci kısım aslında daha önemli, prosedür oluşturma ve çağırma hakkında.</p>
<p>Anlatacağım convention, <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a> olarak bilinen, x86-32 sistemlerde C fonksiyonlarının derlenme şekli.</p>
<p>Yapılan şey şu, fonksiyon parametreleri, sondan başlanarak(örneğin 3 parametre varsa, ilk önce 3. parametre) stacke pushlanır. Daha sonra <code>call</code> yapılır. Fonksiyon, önce bp’yi stacke atarak yedekler(<code>push bp</code>), daha sonra parametrelere ve local değişkenlere erişmek için, <code>bp</code>(base pointer)ye <code>sp</code>(stack pointer)ı atar(<code>mov bp, sp</code>). Bu aşamadan sonra, artık <code>[bp+2]</code> bp’nin eski değerini, <code>[bp+4]</code> birinci parametreyi, <code>[bp+6]</code> 2. parametreyi verir.</p>
<p>Bir sonraki aşama olarak, fonksiyon içerisinde kullanılacak local değişken kadar stackde yer açılır. Örneğin 1 değişken varsa, <code>sub sp, 2</code>, 2 değişken varsa <code>sub sp, 4</code> ile stack’de yer açılır. Bu sayede fonksiyon içerisinden başka bir fonksiyon çağırdığımızda, local değişkenlerin üzerine birşey yazılmaz. Aslında <code>bp</code>yi de benzer bir sebeple yedeklemiştik. Başka bir fonksiyon çağırıldığında, bp’yi kendi değişklenlerine ve parametrelerine erişmek için değiştirecek. Birazdan göreceğimiz gibi fonksiyon dönüş yaparken <code>bp</code>yi eski haline getirecek.</p>
<p>stack’de yer açtıkdan sonra da local değişkenlere, 1. değişken için <code>[bp-2]</code>, 2. değişken için <code>[bp-4]</code> ile erişebiliyoruz.</p>
<p>NOT: Bu arada eğer farkedilmediyse belirteyim, 16bit 8086 işlemcilerden bahsediyorum. 32 bit sistemlerde stack pointerını 1 değer için 2 değil 4 azaltmanız gerekecek. Bir diğer farkedilmesi gereken şey de, stack pointer’ın pushlandığında <em>azaldığı</em>.</p>
<p>Fonksiyon işini bitirdiğinde, <code>sp</code>ye local değişkenleri silmek için <code>bp</code>yi atamalı(<code>mov sp, bp</code>, hatırlarsanız fonksiyon çağırıldığında <code>mov bp, sp</code> yapmıştık, ve daha sonra local değişkenler için <code>sp</code>yi kaydırmıştık). Bu aşamada stack’in tepesinde bp’nin eski değeri var. <code>pop bp</code> ile bunu <code>bp</code>ye yükledikten sonra <code>ret</code> ile dönüş yapabiliriz.</p>
<p>Bu arada fonksiyon dönüş değerini <code>ax</code>e koyuyor.</p>
<p>Bundan sonra son olarak yapılması gereken şey, fonksiyonu çağıran kod parametreleri stacke atmıştı, ama temizleyen olmadı. 2 parametre için <code>add sp, 4</code> gibi bir kod ile stack temizlenebilir.</p>
<p>Anlaşılması için bir üs alma fonksiyonu yazacağım. Fonksiyonun adı <code>power</code> olsun. Çağırılışı şu şekilde:</p>
<pre><code>push 2          ; ikinci parametre
push 5          ; birinci parametre
call power
add sp, 4</code></pre>
<p>En sonunda stackin temizlendiğine dikkat. Bu koddan sonra <code>ax</code>de fonksiyonun dönüş değeri olmuş olacak.</p>
<p>Fonksiyon ise şöyle:</p>
<pre><code>power:
    push bp             ; bp&#39;nin eski değerini yedekle
    mov bp, sp          ; bp := sp.
    sub sp, 2           ; 1 local değişken için stackde yer aç
    
    mov bx, [bp+4]      ; birinci parametreyi bx&#39;e yükle
    mov cx, [bp+6]      ; ikinci parametreyi cx&#39;e yükle
    
    mov [bp-2], bx      ; bx&#39;i birinci local değişkene ata

    power_loop_start:
        cmp cx, 1
        je power_end
        
        mov ax, [bp-2]
        mul bx
        
        mov [bp-2], ax
        dec cx
        jmp power_loop_start        
        
    power_end:
        ; birinci local değişkenimiz fonksiyonun dönüş değeri
        ; bu değeri ax&#39;e yükle
        mov ax, [bp-2]
        mov sp, bp        ; sp&#39;yi eski haline getir
        pop bp            ; bp&#39;yi eski haline getir
        ret               ; dön</code></pre>
<p>İşte x86-32’de C fonksiyonları buna benzer bir şekilde derleniyor. 64bit sistemlerde ekstradan 8 yazmaç olduğundan, parametreler direkt olarak stacke atılmaktansa yazmaçlara yazılıyormuş. Başka dillerde de, dilin ihtiyaçlarına göre farklı yollar izleniyor. Örneğin C++ dilindeki <code>this</code> pointerları her seferinde stacke atılmaktansa, sürekli sabit bir yazmaça yükleniyor olabilir.</p>
<p>Bazı calling conventionlar için özet bilgiye Wikipedia sayfalarından ulaşabilirsiniz: <a href="http://en.wikipedia.org/wiki/X86_calling_conventions">X86 calling conventions</a>, <a href="http://en.wikipedia.org/wiki/Calling_convention">bazı farklı mimariler için conventionlar</a>, <a href="http://refspecs.linuxfoundation.org/lsb.shtml">Linux ortamında kullanılan çeşitli conventionlar</a>. Onun dışında AMD64 için <a href="http://www.x86-64.org/">ABI</a>. Intel <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">IA manualları</a>nda da ABIlardan bahsediliyordu yanlış hatırlamıyorsam.</p>
<p>Bu arada her fonksiyon çağırılışında stacki temizlemek, fonksiyonların kaç parametre aldığının fonksiyonun kendisinin her zaman bilmesi durumunda, gereksiz. Yukarıda C conventionlarından bahsettiğimden, ve C’de örneğin <a href="http://en.cppreference.com/w/c/io/fscanf"><code>sscanf</code></a> gibi fonksiyonlar değişik sayılarda parametre alabildiğinden, temizleme işlemini parametreleri gönderen taraf yapıyor.</p>]]></summary>
</entry>
<entry>
    <title>Etkinlik fikri</title>
    <link href="http://osa1.net/posts/2012-10-06-etkinlik-fikri.html" />
    <id>http://osa1.net/posts/2012-10-06-etkinlik-fikri.html</id>
    <published>2012-10-06T00:00:00Z</published>
    <updated>2012-10-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Hep ilgilenen insanların bir araya toplanıp, zorlu bazı problemleri bazı limitler altında çözdükleri etkinliklere özenmişimdir. Aslında çok farklı bir konsept değil, oyun geliştiricileri uzun süredir benzer etkinlikler yapıyorlar(<a href="http://www.ludumdare.com/compo/">1</a>, <a href="http://globalgamejam.org/">2</a>, <a href="http://igda.dk/category/nordic-game-jam/">3</a>, ve pek çok başka yerel etkinlikler).</p>
<p>Bir keresinde bir <a href="http://osa1.net/finaldeyiz/">programlama yarışmasında</a> finale kalmıştım, bir de LudumDare tecrübem var. Bunlardan ikisini de saymıyorum çünkü birincisi aslında benim ilgi alanıma giren birşey değildi ve sırf challange olsun diye girmiştim, ikincisinde de aslında bir “toplanma” yok. Yani dünyanın her yerinden yarışıyorsunuz. Ben daha çok bir araya toplanılıp, daha kısa süre içerisinde(LD 48 saat sürüyor mesela), daha küçük birşeyler yapılıp günün sonunda dağılınan birşeyler hayal etmişimdir. İşin biraz da sosyalleşme ve kafa dengi insanlarla tanışma yönü olmasını istiyorum yani ben.</p>
<p>Mesela şöyle bir fikir var kafamda: Mainstream dillerle katılınamayan bir programlama etkinliği. Örneğin Java, Python, Ruby, JavaScript, C++, C# gibi dillerle katılamazsınız ama Lisp dilleri, Go, Rust, Erlang, Haskell, Smalltalk, Factor, Scala, F#, D vs. kabul. Amaç 10 saat gibi bir süre içerisinde <a href="http://0x10c.com/doc/dcpu-16.txt">DCPU-16</a> assembler/disassembler ve debuggerı yazmak.</p>
<p>Specification’a bakarsanız, ne kadar küçük olduğunu görebilirsiniz. 10 saat içerisinde gelmeden önce birkaç döküman okunup biraz aşina hale gelinmiş farklı bir dil ile yazılabilir. Bu sayede sadece, muhtemelen daha önce karşılaşılmamış bir konuda bazı problemleri çözmüş değil, aynı zamanda bu yeni dili de daha iyi öğrenmiş ve anlamış olur katılanlar.</p>
<p>Gerçi bu problemde birden fazla kişinin iş bölümü yapması pek mümkün olmayabilir(proje zaten yeterince küçük olacaktır), bu durumda da “pair programming” benzeri birşey yapılabilir. 2 kere, her biri birkaç gün süren pair programming tecrübem oldu. Birisinde klavyede hep ben vardım ve yanımdaki arkadaş programcı bile değildi ve ikisinde de çok eğlendiğimi söyleyebilirim(gerçi biraz yorucu oluyor).</p>
<p>Burada üretilen programların pratikte çok bir işe yaramayacak olması ve herhangi bir ödülün olmaması önemli. Bu katılımcıların öğrenme ve eğlenmeye odaklanmalarını sağlar ve sadece bu amaçla katılanları bir araya toplar diye düşünüyorum.</p>
<p>Olamayacak bir fikir mi, engeller neler olabilir, neler değiştirilebilir? İlgilenen varsa, yorum bölümüne birşeyler karalarsa sevinirim :) Belki hayata geçirebiliriz.</p>
<hr />
<p>DÜZENLEME: 2. bir fikir de, yine farklı dillerde, bir C kütüphanesinin <a href="http://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>ının yazılması olabilir. Hem çok zor bir işlem değil (10 saatte epey bir yol katedilir, kullanılır hale getirilebilir), hem de son bir haftamı yoğun bir şekilde FFI bindingleri/wrapperları yazarak geçiren biri olarak, FFI’ı anlamanın inanılmaz önemli ve faydalı bir şey olduğunu düşünüyorum. Burada FFI’ı yazılacak kütüphaneyi iyi belirlemek gerekir.</p>
<p>DÜZENLEME 2: 3 arkadaşımdan olumsuz cevap aldım bile. Bu yazıyı bu blogun en başarısız yazısı ilan ediyor ve ibret olsun diye burada bırakıyorum :P .</p>]]></summary>
</entry>
<entry>
    <title>Kompleks meseleleri anlatmak ve formal diller</title>
    <link href="http://osa1.net/posts/2012-08-28-formal-diller.html" />
    <id>http://osa1.net/posts/2012-08-28-formal-diller.html</id>
    <published>2012-08-28T00:00:00Z</published>
    <updated>2012-08-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün ortamlarda rastgele gezinirken şöyle bir metine denk geldim:</p>
<blockquote>
<p>From William Thurston: <a href="http://arxiv.org/pdf/math/9404236v1.pdf">On proof and progress in mathematics</a></p>
<p>When a significant theorem is proved, it often (but not always) happens that the solution can be communicated in a matter of minutes from one person to another within the subfield. The same proof would be communicated and generally understood in an hour talk to members of the subfield. It would be the subject of a 15- or 20-page paper, which could be read and understood in a few hours or perhaps days by members of the subfield.</p>
<p>Why is there such a big expansion from the informal discussion to the talk to the paper? One-on-one, people use wide channels of communication that go far beyond formal mathematical language. They use gestures, they draw pictures and diagrams, they make sound effects and use body language. Communication is more likely to be two-way, so that people can concentrate on what needs the most attention. With these channels of communication, they are in a much better position to convey what’s going on, not just in their logical and linguistic facilities, but in their other mental facilities as well.</p>
<p>In talks, people are more inhibited and more formal. Mathematical audiences are often not very good at asking the questions that are on most people’s minds, and speakers often have an unrealistic preset outline that inhibits them from addressing questions even when they are asked.</p>
<p>In papers, people are still more formal. Writers translate their ideas into symbols and logic, and readers try to translate back.</p>
</blockquote>
<p>Birkaç aydır neredeyse her gün akademik makaleler vb. okuyan ama hala formal anlatımları anlamayı inanılmaz zor bulan(ama yine de en azından sabırla uğraşıp, anlayabilen) biri olarak, bundan daha iyi bir özet görmemiştim.</p>
<p>Zaten birinin tahtaya çıkıp ders anlatmasına da bu yüzden ihtiyacımız yok mu? Kağıt üzerinde, hiçbir konuda farklı yorumlamaya fırsat bırakmayacak ve bir yandan da özlü bir şekilde meseleyi anlatabilecek formal bir dille öğrenmeye kalktığımıza, yeterli sabrı gösteremeyip, yeterli emeği veremeyiz. Sebebi de, yazıda bahsedildiği gibi, yazar tarafından formal bir dil ile ifade edilmiş meseleleri kendi anlayışımıza göre tercüme etmek zorunda olmamız.</p>
<p>Okul ortamı benim için biraz da bu yüzden moral bozucu aslında. Bir hafta boyunca bir makaleyi anlamaya çalışıp, anladıktan sonra sözlü olarak başka birine ne kadar kolay bir şekilde anlatılabileceğini farkettiğimde, “keşke biri bana anlatıyor olsaymış” diye düşünüyorum. Bir haftamı değil birkaç saatimi vermem yetebilirdi o zaman.</p>]]></summary>
</entry>
<entry>
    <title>call/cc [2]</title>
    <link href="http://osa1.net/posts/2012-08-09-callcc-2.html" />
    <id>http://osa1.net/posts/2012-08-09-callcc-2.html</id>
    <published>2012-08-09T00:00:00Z</published>
    <updated>2012-08-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Scheme çok ilginç bir dil. Çok küçük olmasına rağmen(R5RS 50 sayfa, R6RS 90 sayfa, aradaki fark büyük oranda kütüphanelerden kaynaklanıyor) programlama dilleri camiasından sürekli tartışma konusu, ve bir sonraki standard konusundaki tartışmalar neredeyse hiçbir zaman bitmiyor. Çok fazla tartışmalı özelliği var. Kendisine göre devasa boyutlardaki dillerde bile Scheme’inkiler kadar tartışılan özellikler yoktur büyük ihtimalle(gerçi bu biraz da Scheme camiasının çok sayıda programlama dili meraklısı içermesi ile alakalı olabilir).</p>
<p><code>call/cc</code> bu özelliklerden biri, hakkında buralarda birşeyler yazmıştım. <code>call/cc</code> benim gözümde, birazdan bahsedeceğim yazıdaki tabiriyle, “ultimate abstraction of control” idi. Kendi dilime de call/cc’yi programın kontrol akışı üzerinde değişiklikler gerektiren yapıları implement etmek için kullnacaktım.</p>
<p>Bugün internetteki favori sayfalarımdan <a href="http://okmij.org/ftp/">okmij</a>de <a href="http://okmij.org/ftp/continuations/against-callcc.html">“An argument against call/cc”</a> adlı yazıya denk geldim. Meraklısı olan varsa kaçırmasın.</p>
<p>call/cc’nin neden kötü bir soyutlama olduğunu 7 madde halinde incelemiş. Benim anladığım, tüm bu problemleri delimited continuationlarla çözebiliriz. Delimited continuationlara giriş için <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf">Introduction to Programming with Shift and Reset</a>e bakabilirsiniz. Ben epey anlaşılır buldum(OchaCaml’ı yükleyip denemedim gerçi, içinde yama uygulamayı da içeren birkaç maddelik kurulum komutu var, şaka gibi). Bir maddede <code>dynamic-wind</code>den bahsetmiş. <code>dynamic-wind</code> ile ilk kez bu yazıda karşılaştım, ve anladığım kadarıyla delimited continuationlar buna olan ihtiyacı ortadan kaldırmıyor. Sonuçta örneğin bir dosyaya erişim yapıldığı durumda, continuation dosyanın referansını içerecektir ve daha sonradan bu continuation kullnıldığında, delimited olsa da olmasa da, aynı kaynakların alınıp(dosyanın açılması, sunucuya bağlanılması vs.), işlem sonrasında kapatılması gerekir.</p>
<p>Static bir tip sistemi ve lexical scope ile call/cc implementasyonu benim için zaten yeterince zor bir problem. Belki de tamamen kaldırıp, Lua usulü biraz daha genelleştirilmiş generatorlar<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>ile yola devam etmeliyim.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://dl.acm.org/citation.cfm?id=1462167&amp;CFID=125136476&amp;CFTOKEN=41020401">Revisiting coroutines</a><a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Bir dönemin daha sonu</title>
    <link href="http://osa1.net/posts/2012-08-05-bir-donemin-daha-sonu.html" />
    <id>http://osa1.net/posts/2012-08-05-bir-donemin-daha-sonu.html</id>
    <published>2012-08-05T00:00:00Z</published>
    <updated>2012-08-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün son finalimden çıktım, bir dönem daha bitmiş oldu. Nasıl inanılmaz derecede saçma ve sıkıcı bir dönem olduğundan bahsetmeyeceğim. Okulda dönemler geçtikçe işlerin daha iyiye gidiyor olması gerekirken, daha kötüye gidiyor olması epey ilginç.</p>
<p>4 haftalık çok değerli(!) tatilim için bir yapılacak listesi hazırladım. Aslında yaz dönemleri, ne kadar önemli işim olursa olsun, zaten tatil dönemi gibi geçiyor benim için. Dolayısıyla dinlenmek için ayrıca bir vakit ayırmama gerek yok. Bir de Ramazan’la birleşince, destansı uyuyuşlar, vakit geçirmek için yazılan programlar vs. epey dinlendirici oluyor hahah.</p>
<p>Buna göre <code>TODO</code> dosyamın içeriği şöyle:</p>
<ul>
<li>Oku: Types and Programming Languages. İlk yarısını final haftası falan tanımadan okudum. Bazı önemli kısımları atladım(bazı teoremler ve ispatlar, alıştırmalar). Diyebilirim ki SICP’den sonra okuduğum en iyi kitap. Konusu epey farklı tabii (tip sistemleri).</li>
<li>Oku: <a href="www.cs.cmu.edu/~rwh/papers/callcc/jfp.ps">Typing First-Class Continuations in ML</a>: Kendi dilimde önce first-class continuationları implement edip, sonra tip sistemi yazmaya çalışınca böyle bir problemle karşılaştım tabii.</li>
<li>Bir daha oku: <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.120.5931">Basic Polymorphic Typechecking</a>. Bu sefer çok daha fazla şey anlayacağımı umuyorum :P .</li>
<li>Oku: <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.138.5038">Uniprocessor Garbage Collection Techniques</a>.</li>
<li>Yaz: Kafamda bir oyun fikri var. 19 gün sonraki LD24’de başlamayı planlıyorum. Lua ile yazacağım.</li>
<li>Yaz: OCaml’a derlenen bir dil var kafamda.</li>
<li>Yaz: “Tosbağa” adlı yarım bıraktığım bir yorumlayıcı(veya aslında daha çok sanal makinaya yakın) var, Haskell ile yazıyorum. Turtle graphics. Hiçbir esprisi yok. Basit komutlar hazırlamış, onlarla fonksiyonlar vs. implement etmeye çalışıyordum en son bıraktığımda.</li>
<li>İncele: <a href="http://klisp.org/">klisp</a>, bir Kernel Lisp implementasyonu. First class macrolar, continuationlar ve fexprlar var. Karşılaştığım bazı problemleri çözmüşler.</li>
<li>Oyna: Metal Gear Solid 4: Guns of the Patriots. İlk 3 oyun gözümde efsanedir. Şu anda bunun için önümdeki en büyük engel, oyunu alabilmek :P .</li>
<li>Oyna: Jade Empire. Bioware’ın iyi dönemlerinden kalan son oyunlardan. Oynayamamıştım.</li>
<li>Araştır: Derleyici detaylarını öğrenmek için kaynak ve hedef diller. Kaynak dili kendim oluşturabilirim aslında, problemleri bir bir yerden okumak yerine, onlarla karşılaşmak daha heyecanlı oluyor hehe. Hem okumak genel olarak çok daha sıkıcı. Hedef dil bir assembly dili(MIPS uygun mudur? çalıştırmak için emulator kullanak zorunda kalacak olmam kötü) veya en azından byte-code (Java, Lua) olmalı.</li>
<li>Arkadaşlarla tatile git. Böyle bir plan yapmıştık, 3-4 günlük birşey. Ben zaten son 15 gündür yeterince yattığımdan gitmek için pek bir istek yok içimde, fakat bir yandan da gitmem gerektiğini biliyorum.</li>
<li>Blogu güncelle. Komple statik sayfalara geçireceğim. Octopress’i inceledim, epey rahat gözüküyor ve hazır temalar da var. Benim için uygun gibi. Problem, yazılarımı markdown formatında saklıyorum ama syntax olarak biraz farklı(kod kısımları özellikle). Bunları düzeltecek bir program yazmam gerekecek(Python bilgime başvurabilirim, epeydir yazmamıştım, regexleri de güzeldir :P ).</li>
</ul>
<p>4 hafta için biraz uzun oldu sanırım, artık ne kadar olursa.</p>
<h2 id="bundan-sonrası">Bundan sonrası</h2>
<p>Bundan sonrası hakkında kafam epey karışık. İnsan üstü bir çaba gösterip(kendime göre), ikinci bir yabancı dil öğrenemezsem, mezun olamıyorum. Ve bu çabayı ikinci bir yabancı dil öğrenmek için göstereceğime, örneğin derleyici yazmak için göstersem, zaten mezun olmama gerek kalmaz. Bunun yanında ikinci yabancı dil öğrenmenin bana sağlayacağı herhangi bir fayda yok. Saçma bir yatırım yani. Dolayısıyla mezun olmak istiyorsam, ikinci yabancı dil dersini vermeden mezun olmanın bir yolunu bulmam gerek.</p>
<p>Şu anda iki sonraki dönemden itibaren bir şekilde okul ile alakalı işlerde minimum miktarda vakit harcayıp, her ne ile ilgileneceksem uğraşmaya başlamam lazım(önümde çok güzel bir staj imkanı var, bir dönem sonra, 14 hafta sürecek). Mezun olmama yaklaşık 1.5 sene var, vakit sıkıntım yok gibi yani. Bu 1.5 senede de toplamda 28 hafta staj yapacağım, çok faydalı olabilir(dediğim gibi çok güzel bir staj ayarladım zaten ilk 14 hafta için, iki taraf da memnun kalırsa, diğer stajımı da aynı yerde yapabilirim, okul açısından bir engel yok).</p>
<p>Sonuçta bu okuldan mezun olmak bana sembolik bir diplomadan başka hiçbir şey sağlamayacak ve karşılığında göstermem gereken çabaya değeceğini düşünmüyorum.</p>
<p>Diğer yandan, Türkiye’de Haskell ile, veya derleyiciler ve programlama dilleri üzerine çalışan yerler olmadığından, yurt dışına çıkmanın bir yolunu bulamazsam, Türkiye’de Java yazmak zorunda kalacağım kesin gibi. Neyse ki bir aydan daha uzak bir geleceği kafama takmama gibi garip bir adetim var. Mezun olmama 1 ay kala düşünürüm :P .</p>]]></summary>
</entry>

</feed>
