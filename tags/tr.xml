<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged tr</title>
    <link href="http://osa1.net/tags/tr.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/tr.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-07-29T00:00:00Z</updated>
    <entry>
    <title>Tartışma</title>
    <link href="http://osa1.net/posts/2014-07-29-tartisma.html" />
    <id>http://osa1.net/posts/2014-07-29-tartisma.html</id>
    <published>2014-07-29T00:00:00Z</published>
    <updated>2014-07-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Birkaç tip insanla ne pahasına olursa olsun tartışmak istemiyorum. Ne iddia ediyorlarsa haklılar.</p>
<ol style="list-style-type: decimal">
<li>Heyecanlananlar, sesini yükseltenler, sinirlenenler, gaza gelenler. Hatta gaza gelen kesim ölene kadar benden uzak dursa keşke.</li>
<li><a href="http://staffhome.ecm.uwa.edu.au/~00043886/humour/invalid.proofs.html#1.1Proofbyexample">“Proof by example”</a> ispat tekniğini benimseyenler. Özellikle bunu insanlara uyguladığında gerzekliğin sınırları zorlanmış oluyor. “Ankaralı iki arkadaşım var ikisi de şöyleydi, o zaman büyün Ankaralılar öyledir”. Her geçen gün bunun ne kadar fazla uygulandığına hayret etmekteyim. (günlük hayatta karşılaştıklarımız bu kadar bariz olmadığından çoğu zaman iki taraf da argümanın geçersizliğini hiçbir zaman farkedemiyor)</li>
<li>Pire için yorgan yakanlar. Kimsenin kusursuz olmasını bekleyemezsin, yiğidi öldür hakkını yeme demişler.</li>
<li>Dedikodu, desteksiz atanlar. Duyduğun işine gelen şeyleri doğru kabul edenler.</li>
<li>Haksız olmayı göze alamayanlar. Tartışmanın amacı orta yolu bulmak, hatalı olanların hatalarının farkında olması değil midir? Bir spor olarak tartışanlar.</li>
</ol>
<p>Umarım bu hatalara ben de yapmıyorumdur, gerçekten çok uğraşıyorum bunun için.</p>
<p>Bu sebeplerden, Türkiye’de mutlu, üretken, sağlıklı olmanın sırrını siyasetten uzak durmak olarak görüyorum. Üniversitede sınıf arkadaşlarım bana “apolitik” derlerdi, ne anlama geldiği hakkında halen daha pek fikrim yok, ama o zamanlar “vaktini öldürmemek için çaba sarfeden” olarak yorumlardım :)</p>]]></summary>
</entry>
<entry>
    <title>Tercüme</title>
    <link href="http://osa1.net/posts/2014-06-03-tercume.html" />
    <id>http://osa1.net/posts/2014-06-03-tercume.html</id>
    <published>2014-06-03T00:00:00Z</published>
    <updated>2014-06-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A. Einstein ve L. Infeld’in “Fiziğin Evrimi” kitabının Öner Ünalan tarafından tercüme edilmiş halinin çok eski bir baskısını(baskı yılı yazmıyor, fakat kitabın arkasında “30 lira” yazmakta) okuyorum ve yabancı kelimelerin tercümesi hakkında çok güzel bir “çevirmen notuna” denk geldim.</p>
<p>Çevirmen “inertia” kelimesinin Türkçe karşılığı olarak neden “eylemsizlik” değil de “süredurum” kullandığını şu şekilde açıklıyor:<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Inert: Eylemsiz - süreduran</li>
<li>Inertia: Eylemsizlik - süredurum</li>
<li>Noninert: Eylemli (?) - süredurmayan</li>
<li>Inertial: ? - süredurumlu, süredurumsal</li>
<li>Noninertial: ? - süredurumsuz.</li>
</ul>
<p>Dolayısıyla “süredurum” kelimesi “inertia”ya daha iyi bir karşılık gibi çünkü aynı kökten türemiş yabancı kelimelerin Türkçe karşılıkları da kelimenin kökünün Türkçe karşılığından türemiş kelimeler olmuş oluyor.</p>
<p>Değişik ortamlarda değişik insanlardan “bilgisayar” kelimesinin kötü bir tercüme olduğunu duymuştum. Hiçbir zaman neden öyle düşündüklerini sormadım belki ama hep o kadar da kötü olmadığını düşünmüşümdür. Yukarıdaki teknik ile “bilgisayar” kelimesinin ne kadar yeterli olduğuna bakalım:</p>
<ul>
<li>Computer: Bilgisayar</li>
<li>Compute: Bilgisaymak (kullanılan: hesaplamak)</li>
<li>Computing: Bilgisayma (kullanılan: hesaplama)</li>
<li>Computable: Bilgisayılabilir (kullanılan: hesaplanabilir)</li>
<li>Computability: Bilgisayılabilirlik (kullanılan: hesaplanabilirlik)</li>
<li>Non-computable: Bilgisayılamaz (kullanılan: hesaplanılamaz)</li>
</ul>
<p>“Bilgisayar” kelimesini beğenmeyenlerin aklında böyle birşey var mıydı emin değilim, fakat görünüşe göre “bilgisayar” gerçekten korkunç bir tercüme, olması gereken kelime “hesaplayıcı”ymış gibi görünüyor. Gerçi durum burada biraz daha farklı. “Bilgisay-” kökünden türemiş alternatifler her kelime için var, fakat 1) hiçbiri anlam olarak eşleşmiyor<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> 2) hiçbiri günümüzde kullanılmıyor(çok şükür).</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Bugün Türkçe fizik kitaplarında hep “eylemsizlik” diye geçer.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>“Bilgi saymak” ile bir alakamız yok ve hatta bilgi saymanın ne kadar anlamlı bir fiil olduğu da tartışmaya açık. Benim aklımda hiçbir şey canlanmıyor mesela “bilgi saymak” deyince.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Güncelleme 2</title>
    <link href="http://osa1.net/posts/2014-03-29-guncelleme-2.html" />
    <id>http://osa1.net/posts/2014-03-29-guncelleme-2.html</id>
    <published>2014-03-29T00:00:00Z</published>
    <updated>2014-03-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Çeşitli sebeplerden artık eskisi kadar uzun ve teknik yazılar yazma fırsatı bulamıyorum. Bundan sonra sık sık kısa güncellemeler girmeyi deneyeceğim. İlk güncelleme yazım <a href="/posts/2014-01-17-guncelleme.html">şuradaydı</a>.</p>
<p>17 Ocak’dan beri epey önemli olay oldu, sırasız bir şekilde şöyle özetleyebilirim:</p>
<ul>
<li>Indiana Üniversitesi’nden doktoraya kabul edildim. Bu benim için bir hayalin gerçek olması bir bakıma. Indiana Üniversitesi her ne kadar çok süper bir üniversite olmasa da 1) PL araştırmalarında Top 20’de 2) Benim ilgi alanlarıma çok uygun araştırmalar oluyor 3) 6 tane çalışabileceğim hocaya sahip 4) UIUC stajım sırasında ziyaret edip kampüsü gezdiğim, öğrencilerle ve hocalarla tanıştığım, dolayısıyla bildiğim ve sevdiğim bir yer. Başarılı bir öğrenci olmadığım da göz önünde bulundurulduğunda benim için ne kadar önemli bir imkan olduğunu farkedilebilir. Sonbahar döneminde başlayacağım bir aksilik olmazsa. Bir RA pozisyonundan yararlanacağım fakat henüz araştırma konum kesinlik kazanmadı.</li>
<li>Google Summer of Code 2014’e başvurdum. Proposal’ım <a href="http://www.google-melange.com/gsoc/proposal/public/google/gsoc2014/osa1/5629499534213120">şurada</a>. Kabul edilmem durumunda yaz boyunca GHCJS üzerinde çalışacağım, benim için çok önemli bir fırsat. Kabul edilme ihtimalim camiadan görüştüğüm tecrübeli insanlar tarafından epey yüksek görülüyor, fakat tabii ki Haskell.org’a verilecek kontenjan, diğer başvurular ve başka pek çok şeyle alakalı.</li>
<li>Tip 1 diyabet olduğum ortaya çıktı. Özellikle teşhisten önceki hafta ve insülin almaya başladıktan sonraki birkaç hafta(şu anda 2. haftadayım) çok zor geçti/geçmekte. Çalışmalarım azalmış ve performansım epey düşmüş durumda, fakat toparlayacakmışım. Yeni hayat tarzıma alıştıkça muhtemelen diyabet ile alakalı yazılar görebilirsiniz buralarda :)</li>
<li>Canım sıkıldıkca minCaml dilini C’ye derlemek ile uğraşıyorum. Gitub alanımdan görebilirsiniz. minCaml eğitim amaçlı oluşturulmuş bir OCaml/SML alt kümesi.</li>
</ul>
<p>Ayrıca 11 Nisan’dan sonra TOBB ETÜ ile ilişkimi kesmiş olacağım(sonunda!!!!). Sonrasında Nisan sonunda girmem gereken Almanca sınavı var(TOBB ETÜ’deki 2. yabancı dil saçmalığı) ve başarılı olduğumda diplomamı alacağım.</p>]]></summary>
</entry>
<entry>
    <title>Güncelleme</title>
    <link href="http://osa1.net/posts/2014-01-17-guncelleme.html" />
    <id>http://osa1.net/posts/2014-01-17-guncelleme.html</id>
    <published>2014-01-17T00:00:00Z</published>
    <updated>2014-01-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Biraz hayatımda neler olup bittiğinden bahsedeceğim, son birkaç ayda önemli olduğunu düşündüğüm birkaç şey oldu. Uzun süredir de Türkçe blog yazmamıştım, arayı açmayalım :P</p>
<p>Maddeler halinde, hayatımın son 5-6 aylık dönemi: (sıralama rastgele)</p>
<ul>
<li>An itibari ile okulumda geçirdiğim son dönemdeyim. Benle aynı girişli herhangi bir öğrencinin mezun olması gereken dönemde yani, gecikme falan olmayacak inşallah.</li>
<li>Bu dönem iki ders alıyorum, birisi bitirme projesi dersi, birisi de matematik bölümünden cebir dersi. Sonunda “öğrenmenin yaşı yok, zararın neresinden dönersen …” mantığı ile korkumu yendim ve matematikten bir ders aldım, ve çok memnunum. Dersi anlamakta ve problemleri çözmekte hiçbir sıkıntı yaşamıyorum(ders MAT 3xx kodlu olunca insan bir an tereddüt ediyor, yapabilir miyim diye). Sınıf zaten çok az kişi, hoca da bilgisayar meselelerine ilgili ve öğrencilerle ilgileniyor. Çok süper şeyler yapabiliriz bu ders kapsamında diye düşünüyorum, ama aklımda çok net fikirler yok. Temel cebir kounlarını anladıktan sonra kategorilere geçiş yapmayı hedefliyorum. Bundan sonra eğer akademik ortamda vakit geçirecek olursam kesinlikle matematiğe daha fazla zaman ayırmalıyım. Eğer ders alma imkanım olursa kesinlikle matematik dersleri alacağımdır diye düşünmekteyim.</li>
<li>Bitirme projesini daha önce 14 hafta Özyeğin Üniversitesi’nde beraber çalıştığımız hocam Barış Aktemur danışmanlığında yapıyorum(kendisinin başka okulda olması sorun olmadı). Detaylarından şimdilik bahsedemeyeceğim ama <a href="https://gist.github.com/osa1/f34ec1101e65b490e3b6">şurada</a> bir özet var. Özetin özeti: Programlama dili teorisi ile alaklı işler.</li>
<li>Adımı Rust 0.9 katkıcıları listesine yazdırmaktan gurur duyuyorum: <a href="https://mail.mozilla.org/pipermail/rust-dev/2014-January/007753.html">duyuru maili</a>. Gerçi adımı değil nickimi yazmışlar, neden bilmiyorum. Adımı tercih ederdim.</li>
<li>Derleyici implementasyonuna meraklı arkadaşlar Rust’ı kaçırmasınlar. Yeni bir proje olduğu için çok fazla “low-hanging fruit” var, kolayca katkı yapabilirsiniz ve çok şey öğrenirsiniz. Camia çok aktif ve yardımsever.</li>
<li>Haftaya Pazartesi(20 Ocak) günü saat 15:30’da Amfi 2’de programlama dilleri dersini ben anlatacağım. İstediğimi anlatmakta özgürüm ve çok faydalı olacağına inandığım bir konuşma hazırlamaktayım. TOBB ETÜ’de olan varsa beklerim. Dersten sonra sunumu buraya koyacağım.</li>
<li>1 Eylül - 25 Aralık tarihleri arasında University of Illinois at Urbana-Champaign’de, Formal Systems Lab’da staj yaptım. Labımızda geliştirilen K Framework’e hatırı sayılır katkılar yaptığımı düşünüyorum. Çok zor günler de geçirmekle beraber, hayatımın bazı en güzel ve ilginç günlerini geçirdiğimi söyleyebilirim. Yine ABD’deyken 3 yere doktora başvurusunda bulundum. Not ortalamam rezalet(2.71) olduğundan UIUC gibi “iyi”(ne anlama geliyor bilmiyorum) yerelere başvuramıyorum ama yine de çok güçlü programlama dili ekipleri olan yerlere başvurdum: Indiana University, University of Pennsylvania ve Portland State University. IU ekibi ile bir etkinlikte yüz yüze görüştük ve hocalar çok ilgilendiler. Bir tanesi ile sonradan mail üzerinden görüştük ve CVmden ve niyet mektubumdan çok etkilenmiş gözüktü. Tavsiye mektuplarımın da süper olduğunu varsayarsak kabul şansım not ortalamama rağmen epey yüksek diye düşünüyorum. Hayırlısı artık :-)</li>
<li>ABD’deyken iş görüşmelerini yaptığımız <a href="http://www.soostone.com/">Soostone</a>’da Ocak başında işe başladım. Şimdilik yarı zamanlı çalışıyorum. Soostone olarak bir miktar front-end JavaScript kısımları hariç tüm işlerimizi Haskell ile yapıyoruz. JS kısımları da gelecekte Fay veya GHCJS yardımıyla Haskell’a geçirilecek(bilmeyenler için, ben Fay’in 3 ana geliştiricisinden biriyim). Hobi olarak başlayan Haskell serüvenim süper gitti diyebiliriz. Hatta diyebilirim ki zamanında Haskell’a ciddi vakit ayırmak hayatımda yaptığım en mantıklı hareketlerden biri oldu, fakat bu konu çok uzar, o yüzden şimdilik burada keseyim.</li>
</ul>
<p>Şimdilik aklıma gelenler bunlar. Aslında düşündüm de, böyle madde madde özetler geçmek güzel oluyormuş, belki gelecekte devam ettirmeliyim.</p>
<p>Bu arada not: Okulumda son sınıfta olup bitirme projemle ilgilenen varsa ekibime beklerim(gerçi şimdi düşündüm de, bu blogu okuyan birileri var mı ondan bile emin değilim :-). Şu anda tek kişiyim, konuyu biliyor olmanıza gerek yok, ilgilenmeniz yeterli.</p>]]></summary>
</entry>
<entry>
    <title>Destansı tesadüf</title>
    <link href="http://osa1.net/posts/2013-10-10-destansi-tesaduf.html" />
    <id>http://osa1.net/posts/2013-10-10-destansi-tesaduf.html</id>
    <published>2013-10-10T00:00:00Z</published>
    <updated>2013-10-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün, şu sıralar bir araştırma labında çalıştığım okulumda<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> bir startup etkinliği vardı, 10 civarında startup gelip stand açtılar, tshirt dağıtıp CV topladılar ve tanıtım yaptılar. Buralarda sık sık olan bir olay.</p>
<p>Normalde rastgele yazılım mühendisliği işleri ile ilgilenmediğimden benim pek ilgimi çekemiyor bu gibi şeyler, yine de bir gözatıyorum, çünkü geçen sefer <a href="http://www.spacex.com/">SpaceX</a>’i kaçırmıştım ve hala kendimi affedemedim :p . Her neyse, gezinirken bir şirket gözüme çarptı, salonda önünde tek bir öğrenci bile olmayan tek stand bunlarındı ve açıklamalarına bir göz gezdirdiğimde şöyle anahtar kelimeler gözüme çarptı: “runtime verification”, “correctness”, “LLVM”, “NASA” …</p>
<p>Birkaç saat sonra okuldan çıkarken bir yandan kendi kendime düşünüyorum “havalı olmayan şeye merak sararak 1-0 yenik başlamışız abi zaten” diye haueh. Bu ekibin önünden geçerken yine kimsenin olmaması artık beni rahatsız etmiş olacak herhalde ki bir anda durup adama selam verdim, ne iş yapıyorsunuz dedim. Adam bana benim üzerinde çalıştığım şeyleri anlatmaya başladı :) . Lafını kesip benim zaten bu işleri yaptığımı ve şu labda çalıştığımı falan söyleyince, adam demesin mi “bu senin hocanın startup’ı” diye …</p>
<p>Hocamın startupının olduğunu ve benim geliştirdiğim araç ile çalıştıklarını bu şekilde öğrenmiş oldum.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://fsl.cs.illinois.edu/index.php/Main_Page">University of Illinois at Urbana-Champaign, Formal Systems Lab</a><a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Internet</title>
    <link href="http://osa1.net/posts/2013-08-29-internet.html" />
    <id>http://osa1.net/posts/2013-08-29-internet.html</id>
    <published>2013-08-29T00:00:00Z</published>
    <updated>2013-08-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://i.imgur.com/dx7sVXj.jpg">Şunu</a> görüp, önceki bazı tecrübe ve gözlemlerle beraber üzerinde biraz düşündükten sonra internetin anlamını çözdüğünü düşündüm:</p>
<p>“muhtemelen hepsi uydurma ama yine de güzel”</p>]]></summary>
</entry>
<entry>
    <title>Dinamik programlama hakkında</title>
    <link href="http://osa1.net/posts/2013-07-30-dp-hakkinda.html" />
    <id>http://osa1.net/posts/2013-07-30-dp-hakkinda.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı, inanılmaz yoğun olduğum bir dönemde, acele içerisinde, kulakta müzik ile, 1 saat içerisinde yazılmış bir dinamik programlama tutorialıdır. Belki bir fayda sağlar diye bloguma da koymak istedim. Aslında bir ders kapsamında yazıldı(anlatım kısmı daha önceden yapılmıştı, rapor yazamamıştım).</p>
<p>Yanlışlık görürseniz lütfen yorum kısmında belirtin.</p>
<hr />
<h2 id="giriş">Giriş</h2>
<p>Dinamik programlama, problemlerin bazı özellikleri sağlaması şartıyla, çözümlerin kompleksliğini düşürmeyi amaçlayan bir programlama yöntemidir.</p>
<p>Bir problemin şu iki şartı sağladığını düşünelim:</p>
<ul>
<li>Büyük problemin optimal çözümü aynı problemin küçük örneklerinin optimal çözümlerine bağldır.</li>
<li>Bu küçük problemler büyük problemin çözümü sırasında defalarca çözülmektedir.</li>
</ul>
<p>Bu durumda küçük problemlerin çözümlerini bir şekilde saklayarak problemlerin yeniden çözülmesi önlenmiş olur ve sonuçta daha verimli bir algoritma elde etmiş oluruz.</p>
<p>Basit ve klasik bir örnek ile başlayalım,</p>
<p>(her bir örnek birbirinden farklı çözüm ve düşünme tekniklerini içermekte)</p>
<h2 id="örnek-1-para-üstü-problemi">Örnek 1: Para üstü problemi</h2>
<p>Elimizde farklı değerlerde bozuk paralar var, N para üstünü en az miktarda bozuk para vererek tamamlamak istiyoruz. Elimizde 1 değerinde bozuk para var, dolayısıyla her miktarda para üstünü verebiliriz.</p>
<p>Öncelikle bu çözüm için aç gözlü bir algoritmanın neden çalışmayacağını gözlemleyelim(diğer türlü çözüm aç gözlü bir algoritma olurdu).</p>
<p>37 para üstü vermek istiyoruz ve elimizde 10, 9 ve 1 değerlerinde bozukluklar var. Aç gözlü bir algoritma bu miktarı şöyle tamamlayacaktır:</p>
<pre><code>10 - 10 - 10 - 1 - 1 - 1 - 1 - 1 - 1 - 1 -- toplamda 10 bozuk para.</code></pre>
<p>Fakat aslında daha iyi bir çözüm mevcut:</p>
<pre><code>10 - 9 - 9 - 9 -- toplamda 4 para.</code></pre>
<p>Aç gözlü algoritmanın bu problem için çalışmadığını gözlemlemiş olduk. Dinamik programlamaya geçmeden önce ikinci adım olarak bu problemin optimal çözümünü(yani en az miktarda bozuk para ile çözecek çözüm) bulan özyineli bir algoritma yazalım.</p>
<p>N değerinde para üstü tamamlamaya çalışıyor olalım ve A, B, C, … diye isimlendirdiğimiz bozuk paralarımız olsun. Bu durumda optimal çözüm için ya A değerinde bir bozuk para verip, N - A para üstünü tamamlamaya çalışırız(özyineleme), veya B değerinde bir bozuk para verip, N - B para üstünü tamamlamaya çalışırız(özyineleme) … ta ki tüm paraları deneyene kadar. Bu çözümün C++ programı şeklinde ifade edilmiş hali şöyle:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> findMinCoin(<span class="dt">const</span> vector&lt;<span class="dt">unsigned</span>&gt; &amp;coins, <span class="dt">unsigned</span> amount)
{
  <span class="kw">if</span> (amount == <span class="dv">0</span>)
    <span class="kw">return</span> <span class="dv">0</span>;

  <span class="dt">int</span> result = <span class="dv">-1</span>;

  <span class="kw">for</span> (<span class="dt">unsigned</span> coin : coins) {
    <span class="kw">if</span> (amount &gt;= coin) {
      <span class="dt">int</span> r = findMinCoin(coins, amount - coin) + <span class="dv">1</span>;
      <span class="kw">if</span> (result == <span class="dv">-1</span> || r &lt; result)
        result = r;
    }
  }

  <span class="kw">return</span> result;
}</code></pre>
<p>Bu özyineli çözüm bize dinamik programlama yapabilmek için aradığımız iki şarttan birini sağladığımızı söylüyor.</p>
<p><code>findMinCoin</code>in optimal çözümü bulduğunu varsayalım. <code>amount - coin</code> kısmı bize alt problemlerin çözümünü aradığımızı gösteriyor, ve bu çözümü yine <code>findMinCoin</code> aradığımızdan ve <code>findMinCoin</code> optimal çözümü bulduğundan, dinamik programlama yapabilmemiz için gereken ilk şartı sağlamış oluyoruz.</p>
<p>Diyelim ki varsayımımız yanlıştı ve <code>findMinCoin</code> optimal çözümü bulmuyordu. Bu durumda zaten çözümümüz yanlış oluyor, çünkü <code>findMinCoin</code>i asıl problemimizin optimal çözümünü bulmak için çağırıyoruz.</p>
<p>Dinamik programlamanın ikinci şartı için problemin hangi alt problemin kaç kere çağırıldığını farketmemiz gerekiyor. Bunun için şöyle bir gözlem yapalım:</p>
<p>Para üstümüz 37 ve paralarımız 10, 9 ve 1 (ilk örnek). 37’den 25’e gitmenin çok yolu var, bunlardan bazıları:</p>
<pre><code>10 - 1 - 1
9 - 1 - 1 - 1
1 - 1 - 1 - 1 …. - 1 (12 tane)</code></pre>
<p>Tüm bu durumlar için 25 para üstünü tamamlamayı çözen alt problemimiz paylaşılacak. <code>findMinCoin(coins, 25)</code> çağrısının en azından 3 kere yapıldığını göstermiş olduk. Daha pek çok alt problemin paylaşıldığı benzer bir şekilde kolayca gözlemlenebilir.</p>
<p>Bu durumda, neden <code>findMinCoin(coins, 25)</code> çağrısının cevabını bir yerde saklayıp, gerektiğinde yeniden çözmek yerine cevabı sakladığımız yerden okuyup vermiyoruz? Bu arada tüm özyineli çağrılar için <code>coins</code> parametresinin hep aynı olduğuna dikkat.</p>
<p>Bu dönüş değerlerinin bir yerde saklanıp, yeniden hesaplanmamasına <em>memoization</em> adı veriliyor ve dinamik programlama yapmanın en temel yöntemlerinden biri.</p>
<p>Öncelikle memoization’ın bize ne kazandıracağını farkedelim. İlk çözümümüzde her bir para üstü için problemimiz bozuk para sayısı kadar özyineli çağrı yapacak.</p>
<p>M para üstümüz olsun ve N tane bozuk paramız olsun. Bu durumda M için N tane özyineli çağrı yapılacak. Kabaca, elimizdeki en küçük paranın 1 olduğunu düşündüğümüzde, bu özyineli çağrılar M kere yapılacak. Her seviyede N özyineli çağrı bize O(M ^ N) kompleksliğinde bir algoritma verecektir.</p>
<p>Her bir alt problemi memozation yardımıyla bir kere çözdüğümüz durumda ise, tamamlamak istediğimiz para üstümüz M olduğundan ve M - 1 alt probleme sahip olduğumuzdan O(M*N) bir komplekslik elde edeceğiz.</p>
<p>Örnek implementasyon şöyle:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> findMinCoin(vector&lt;<span class="dt">int</span>&gt; table, <span class="dt">const</span> vector&lt;<span class="dt">unsigned</span>&gt; &amp;coins, <span class="dt">unsigned</span> amount)
{
  <span class="kw">if</span> (table[amount] != <span class="dv">-1</span>)
    <span class="co">// problem daha onceden cozulmus, cevaba tablodan bak</span>
    <span class="kw">return</span> table[amount];

  <span class="co">// problem henuz cozulmemis, coz</span>
  <span class="kw">for</span> (<span class="dt">unsigned</span> coin : coins) {
    <span class="kw">if</span> (amount &gt;= coin) {
      <span class="dt">int</span> r = <span class="dv">1</span> + findMinCoin(table, coins, amount - coin);
      <span class="kw">if</span> (table[amount] == <span class="dv">-1</span> || r &lt; table[amount])
        table[amount] = r;
    }
  }

  <span class="kw">return</span> table[amount];
}</code></pre>
<p>Bu noktada özyineli çağrı yapmadan yapılabilecek alternatif bir çözüm için şunu farketmek gerekir: 0 para üstü için cevap zaten belli. 1 para üstü için cevabımızı sadece 1 değerinde bozuk para verip, 0 alt problemi için tabloya bakarak çözebiliriz. Diyelim ki 10 için çözüyoruz, 1 para verip 9 için cevaba tablodan bakmak isteriz, veya 9 para verip 1 için tabloya bakmak isteriz, veya 10 para verip 0 için tabloya bakmak isteriz vs. Yani aslında tabloda bir M değerinden önceki tüm değerler için cevap belliyse, kolayca o değerler arasından gerekli değerlere bakarak tabloda M’i doldurabiliriz. Bu da bizi 0. elemandan başlayarak tüm tabloyu adımlayarak doldurmayı içeren şu çözüme götürür:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> fillMinCoin(<span class="dt">const</span> vector&lt;<span class="dt">unsigned</span>&gt; &amp;coins, vector&lt;<span class="dt">int</span>&gt; &amp;tbl, <span class="dt">unsigned</span> amount)
{
  <span class="kw">for</span> (<span class="dt">unsigned</span> coin : coins)
    <span class="kw">if</span> (amount &gt;= coin &amp;&amp;
        (tbl[amount - coin] + <span class="dv">1</span> &lt; tbl[amount]
         || tbl[amount] == <span class="dv">-1</span>))
      tbl[amount] = tbl[amount - coin] + <span class="dv">1</span>;
}</code></pre>
<p>Daha sonra bu tablodan gerekli elemana bakarak cevabı öğrenmiş oluruz. Bu şekilde bir çözüm dinamik programlamanın doğasını bize daha iyi gösteriyor. Dinamik programlama temelde tablolamaya dayanıyor.</p>
<h2 id="örnek-2-en-uzun-artan-altdizi-problemi">Örnek 2: En uzun artan altdizi problemi</h2>
<p>İki harf dizisi(string) düşünelim. En uzun artan altdizi, şu şekilde tanımlanmıştır:</p>
<p>A1 A2 A3 … AN</p>
<p>Her bir harf hem ilk dizide hem ikinci dizide bulunmakta, ve herhangi bir A N-1, A N için A N - 1 ilk dizide A N’den önce bulunmakta ve A N - 1 ikinci dizide A N’den önce bulunmaktadır.</p>
<p>Örnek:</p>
<pre><code>String 1: cbeb
String 2: fdceb

Cevap: ceb</code></pre>
<p>olacaktır. c harfi birinci dizide ilk eleman, ikinci dizide 3. eleman olarak bulunuyor, e ilk dizide 3., ikinci dizide 4. eleman, b harfi ilk dizide 4. eleman, ikinci dizide 5. eleman olarak bulunmakta.</p>
<p>Bir probleme dinamik programlamanın uygulanabileceğini görmek için önce başta anlatılan iki şart kontrol edilmelidir. Bunun için güzel bir yolun problemin özyineli bir çözümünü yapmak olduğunu daha önceden anlatmıştık. Şimdi bu sorunu özyineli bir şekilde nasıl çözebileceğimize bakalım. Girdilerimiz S1 ve S2 olsun:</p>
<ul>
<li>Herhangi birinin boş string olması dorumunda cevabımız boş string olacaktır.</li>
<li>Diğer durumda, S1 ve S2’nin son harflerini düşünelim:</li>
<li>Eğer bu harfler aynı ise, cevabımıza dahil olacak bir harfi bulduk demektir. Problemin geriye kalanı S1 ve S2 stringlerinin son harfleri çıkarılmış halleri için çözülmeli ve bu son harf cevaba eklenmelidir.</li>
<li>Eğer harfler farklı ise, iki ayrı alt problem elde ederiz: ya S1 stringinin tamamı ve S2’nin son harfi hariç olan kısmı bize en uzun cevabı verecektir, veya S1 stringinin en son harfi hariç kısmı ile S2’nin tamamı en uzun cevabı verecektir. İkisini de çözeriz ve daha uzun olan cevap çözümümüz olur.</li>
</ul>
<p>Bu çözümün Haskell implementasyonu şu şekilde: (sadelik açısından bu kısım C++ ile yazılmadı, dinamik programlama hali C++ ile verilecek)</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">solve ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
solve s1 s2
  <span class="fu">|</span> null s1 <span class="fu">||</span> null s2 <span class="fu">=</span> <span class="st">&quot;&quot;</span>
solve s1 s2 <span class="fu">=</span>
    <span class="kw">let</span> (h1, t1) <span class="fu">=</span> splitAt (length s1 <span class="fu">-</span> <span class="dv">1</span>) s1
        (h2, t2) <span class="fu">=</span> splitAt (length s2 <span class="fu">-</span> <span class="dv">1</span>) s2
     <span class="kw">in</span> <span class="kw">if</span> t1 <span class="fu">==</span> t1 
          <span class="kw">then</span> solve h1 h2 <span class="fu">++</span> t1
          <span class="kw">else</span>
            <span class="kw">let</span> result1  <span class="fu">=</span> solve h1 s2
                result2  <span class="fu">=</span> solve s1 h2
             <span class="kw">in</span> <span class="kw">if</span> length result1 <span class="fu">&gt;</span> length result2
                  <span class="kw">then</span> result1
                  <span class="kw">else</span> result2</code></pre>
<p>Çözümün kompleksliğini düşünelim: Birbirine eşit olmayan M ve N uzunluğunda iki string düşünelim, M ve N - 1 uzunluğunda, M - 1 ve N uzunluğunda ve M - 1, N - 1 uzunluğunda stringler için özyineli çağrılar yapılacak. Her birinden yine 3 farklı özyineli çağrı ve toplamda M + N seviyede her seviyede 3 çağrı yapılacağından O((M + N) ^ 3) kompleksliğinde bir algoritmamız olur.</p>
<p>Dinamik programlamanın mümkün olduğunu görmek için fonksiyonun iki string girdimizin ilk kaç harfi üzerinden çağırıldığını bir ağaç üzerinden takip etmek yeterli olacaktır.</p>
<p>Bu durumda stringlerin ilk kaç harfi için çözümü bulduğumuzu iki boyutlu bir tabloda tutabiliriz. Örneğin tablodaki (3, 5) elemanı bize ilk stringin ilk 3 elemanı, ikinci stringin ilk 5 elemanı için bulduğumuz çözümü verecektir.</p>
<p>Yazıyı kısa tutmak adına bu noktadan sonra direkt olarak adımlayarak tablo doldurma şeklinde düşünelim. Problemin M ve N harflik hali için (M - 1, N), (M - 1, N - 1) ve (M, N - 1) lik hallerini çözmemiz gerekecek. Tablo üzerinde düşündüğümüzde, eğer tabloyu satır satır doldurursak, her bir sonraki adımda gerekli önceki adımları zaten elde etmiş olduğumuz görülebilir.</p>
<p>Burada tabloda tutacağımız her bir değer iki şeyi göstermeli, 1) string uzunluğu cinsinden cevap 2) o adıma geldiğimizde eğer iki stringin de son harflerini cevaba katıyorsak, bu stringin hangi harf olduğu.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> solve(table &amp;tbl,
    <span class="dt">const</span> string &amp;str1, <span class="dt">const</span> string &amp;str2)
{
  <span class="kw">for</span> (us i = <span class="dv">0</span>; i &lt; str1.size(); i++)
    <span class="kw">if</span> (str2[<span class="dv">0</span>] == str1[i])
      tbl(i, <span class="dv">0</span>) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(<span class="st">&#39; &#39;</span>, <span class="dv">1</span>);
    <span class="kw">else</span>
      tbl(i, <span class="dv">0</span>) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(<span class="st">&#39; &#39;</span>, <span class="dv">0</span>);

  <span class="kw">for</span> (us i = <span class="dv">0</span>; i &lt; str2.size(); i++)
    <span class="kw">if</span> (str1[<span class="dv">0</span>] == str2[i])
      tbl(<span class="dv">0</span>, i) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(<span class="st">&#39; &#39;</span>, <span class="dv">1</span>);
    <span class="kw">else</span>
      tbl(<span class="dv">0</span>, i) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(<span class="st">&#39; &#39;</span>, <span class="dv">0</span>);

  <span class="kw">for</span> (us i = <span class="dv">1</span>; i &lt; str1.size(); i++)
    <span class="kw">for</span> (us j = <span class="dv">1</span>; j &lt; str2.size(); j++)
      <span class="kw">if</span> (str1[i] == str2[j])
        tbl(i, j) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(str1[i], tbl(i - <span class="dv">1</span>, j - <span class="dv">1</span>)-&gt;second + <span class="dv">1</span>);
      <span class="kw">else</span> {
        us s1 = tbl(i - <span class="dv">1</span>, j)-&gt;second;
        us s2 = tbl(i, j - <span class="dv">1</span>)-&gt;second;

        <span class="kw">if</span> (s1 &gt; s2)
          tbl(i, j) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(<span class="st">&#39; &#39;</span>, s1);
        <span class="kw">else</span>
          tbl(i, j) = <span class="kw">new</span> pair&lt;<span class="dt">char</span>, us&gt;(<span class="st">&#39; &#39;</span>, s2);
      }
}</code></pre>
<p>Bu çözümdeki iç içe iki for döngüsü tablonun tamamını bir turda ve her bir adım için 3 işlemde doldurduğumuzu gösteriyor ve çözümümüz dolayısıyla O(M*N).</p>
<p>Bu problemin alıştırması <a href="http://www.spoj.com/SPOJ/problems/TLCS/" class="uri">http://www.spoj.com/SPOJ/problems/TLCS/</a> adresinden yapılabilir.</p>
<h2 id="aşağıdan-yukarıya-ve-yukarıdan-aşağıya-çözümler">Aşağıdan-yukarıya ve yukarıdan-aşağıya çözümler</h2>
<p>Bu noktada iki farklı dinamik programlama tekniği görmüş olduk. Biri memoization, biri ise adımlayarak tablo doldurma. Aralarında birkaç temel farklılık var.</p>
<p>Memoization çözümünde tabloyu nasıl dolduracağımızı düşünmemize gerek kalmadı. Eğer tabloda cevap bulunmamışsa, o yerdeki cevabın bulunması için özyineli çağrı yapıldı. Bu şekilde çözüme “yukarıdan-aşağı (top-down)” diyoruz.</p>
<p>İkinci çözüm yöntemimiz adımlayarak tablo doldurmaydı. Bu çözümün güzel yanı özyineli çağrı yapılmaması, fakat dezavantajı tabloyu nasıl bir sırayla dolduracağımızı düşünüp bulmamızı gerektirmesi. Diğer türlü, tabloda bir sonraki konumu doldururken aradığımız bir cevaba ulaşamayabiliriz.</p>
<p>Komplekslik olarak aralarında bir fark yok. Şahsi görüşüm memoization çözümünün daha güzel olduğu yönünde. Sebebi de yukarıda bahsettiğim gibi, tablo doldurma sırasını düşünmemize gerek olmaması.</p>
<h2 id="bir-soru-barkod">Bir soru: Barkod</h2>
<p>Sorunun tanımını orjinal kaynaktan okuyabilirsiniz: <a href="http://codeforces.com/problemset/problem/225/C" class="uri">http://codeforces.com/problemset/problem/225/C</a></p>
<p>Her bir kolonu tamamen beyaza ve tamamen siyaha boyamanın masraflarını biliyor olalım.</p>
<p>N. kolonu beyaza boyamak istediğimizi düşünelim, en az A en fazla B genişliğinde kolonlar istiyor olalım. Bu durumda X = [A … B] aralığı için N - X. kolonun siyah, [N - X + 1 … N] aralığındaki kolonların beyaz olması bize bir cevap verir(renklerin tam tersi olma durumu 2. bir cevap).</p>
<p>Burada farkedilmesi gereken şen, N - X. kolonun siyah olması aslında bir alt problem, ve en doğal ifade edilme şeklide bir özyineli fonksiyon ile olur.</p>
<p>Peki alt problemler paylaşılıyor mu? Şöyle düşünelim, en az 5, en fazla 10 genişliğinde kolonlar istiyor olalım ve şu anda 15. kolonu boyuyor olalım. Bu durumda 10, 9, 8, 7, … 6. kolona kadar olan kısımlar için aynı problemi yeniden çözeceğiz. 16. kolon için ise 19, 9, … 7. kolona kadar olan kısımları bir yeniden çözmemiz gerekecek. Ciddi miktarda alt problem paylaşılıyor.</p>
<p>Herhangi bir kolon için sadece o kolondan önceki kolonların cevabına ihtiyaç duyuyor olmamız tek boyutlu bir tabloda dinamik programlama yapabileceğimizi gösteriyor. Bu durumda şöyle bir cevap elde ediyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">unsigned</span> us;
...
<span class="dt">void</span> solveDP(vector&lt;<span class="dt">int</span>&gt; &amp;tblWhites, vector&lt;<span class="dt">int</span>&gt; &amp;tblBlacks,
             <span class="dt">const</span> vector&lt;us&gt; &amp;colWhites, <span class="dt">const</span> vector&lt;us&gt; &amp;colBlacks,
             us idx, <span class="dt">const</span> us min, <span class="dt">const</span> us max)
{
  <span class="kw">if</span> (idx &lt; max) {
    tblWhites[idx] = sumInclusive(colBlacks, <span class="dv">0</span>, idx);
    tblBlacks[idx] = sumInclusive(colWhites, <span class="dv">0</span>, idx);
  }

  <span class="dt">const</span> us startIdx = idx &lt; max ? <span class="dv">0</span> : idx - max;
  <span class="dt">const</span> us endIdx   = idx - min;

  <span class="kw">for</span> (us i = startIdx; i &lt;= endIdx; i++) {
    <span class="kw">if</span> (tblBlacks[i] != <span class="dv">-1</span>) {
      us cost = tblBlacks[i] + sumInclusive(colBlacks, i + <span class="dv">1</span>, idx);
      <span class="kw">if</span> (tblWhites[idx] == <span class="dv">-1</span> || cost &lt; <span class="kw">static_cast</span>&lt;us&gt;(tblWhites[idx]))
        tblWhites[idx] = cost;
    }

    <span class="kw">if</span> (tblWhites[i] != <span class="dv">-1</span>) {
      us cost = tblWhites[i] + sumInclusive(colWhites, i + <span class="dv">1</span>, idx);
      <span class="kw">if</span> (tblBlacks[idx] == <span class="dv">-1</span> || cost &lt; <span class="kw">static_cast</span>&lt;us&gt;(tblBlacks[idx]))
        tblBlacks[idx] = cost;
    }
  }
}</code></pre>
<h2 id="bir-soru-two-out-of-three">Bir soru: “Two out of three”</h2>
<p>Bu soru önceki sorudan daha ilginç olmamakla beraber, memoization/tablolama yapma şekli biraz değişik olduğundan anlatmak istedim: <a href="http://codeforces.com/problemset/problem/82/D" class="uri">http://codeforces.com/problemset/problem/82/D</a> .</p>
<p>Sıradaki son 3 elemandan 2 elemanın sürekli azalacağını biliyoruz, ve alt problem bu iki eleman hariç elemanlar için çözülecek. Fakat bu 3 elemandan seçilmeyen elemanı memoization işleminde nasıl kullanabiliriz? Sıradan ayrılan iki insan alt problemin sıradaki ilk 2 eleman hariç olan kısmı olduğunu gösteriyor. 3 kişiden seçilmeyen bir kişi de algoritmaya ekstra bir parametre olarak verildiğinde karşımıza şöyle bir sonuç çıkıyor:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve(<span class="dt">int</span> lastElem, <span class="dt">int</span> offset, <span class="dt">const</span> vector&lt;<span class="dt">int</span>&gt; &amp;ppl,
    matrix&lt;<span class="dt">int</span>&gt; &amp;tbl, matrix&lt;<span class="dt">int</span>&gt; &amp;steps)
{
  <span class="kw">if</span> (lastElem &gt;= <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(ppl.size()))
    <span class="kw">return</span> <span class="dv">0</span>;
  <span class="kw">if</span> (offset &gt;= <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(ppl.size()))
    <span class="kw">return</span> ppl[lastElem];

  <span class="kw">if</span> (tbl(lastElem, offset) != <span class="dv">-1</span>)
    <span class="kw">return</span> tbl(lastElem, offset);

  <span class="dt">int</span> tmp[<span class="dv">3</span>];
  tmp[<span class="dv">0</span>] = max(ppl[lastElem], ppl[offset]) + solve(offset + <span class="dv">1</span>, offset + <span class="dv">2</span>, ppl, tbl, steps);
  tmp[<span class="dv">1</span>] = max(ppl[lastElem], ppl[offset + <span class="dv">1</span>]) + solve(offset, offset + <span class="dv">2</span>, ppl, tbl, steps);
  tmp[<span class="dv">2</span>] = max(ppl[offset], ppl[offset + <span class="dv">1</span>]) + solve(lastElem, offset + <span class="dv">2</span>, ppl, tbl, steps);

  <span class="dt">int</span> idmin = min_element(tmp, tmp + <span class="dv">3</span>) - tmp;
  steps(lastElem, offset) = idmin;

  <span class="kw">return</span> tbl(lastElem, offset) = tmp[idmin];
}</code></pre>
<p>Alt problemlerin nasıl paylaşıldığı daha önceden anlatıldığı gibi görülebilir.</p>]]></summary>
</entry>
<entry>
    <title>ADTler ve sınıflar: bir örnek</title>
    <link href="http://osa1.net/posts/2013-02-21-adtler-siniflar.html" />
    <id>http://osa1.net/posts/2013-02-21-adtler-siniflar.html</id>
    <published>2013-02-21T00:00:00Z</published>
    <updated>2013-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı, <a href="/rowlar-kindlar/">bir önceki yazım</a> gibi, yine bir mail için yazıldı. Birkaç düzenleme ve eklemeden sonra blog yazısı olarak yayınlıyorum.</p>
<hr />
<p>Bir programlama dili meraklısı olarak sık sık yorumlayıcılar ve nadiren derleyiciler yazıyorum. Derleyici/yorumlayıcı yazarken çok sık yapılan işlemlerden biri şudur:</p>
<p>Programda(derleyici/yorumlayıcıda) kod üzerinde çalışabilmek için son kullanıcı tarafından metin olarak girilmiş kodun üzerinde çalışılabilinecek bir veri yapısına dönüştürülmesi gerekir. Buna “parsing” işlemi diyoruz ve yaptığı iş kısaca metni alıp, abstract syntax tree(AST) dediğimiz bir çeşit ağaç yapısına dönüştürmektir.</p>
<p>Bu aşamadan sonra elimizde bir ağaç yapısı olmuş olur. Fakat burdaki ağaç yapısını veri yapıların dersinde gösterilen “binary tree” vs. yapılarla karıştırmamak lazım, burda çok çeşitli nodelar oluyor ve her bir node farklı özelliklere sahip, her birine ayrı muameleler yapılacak oluyor. (kod örnekleri vereceğim)</p>
<p>Bir yorumlayıcı/derleyicinin bu ağaç yapısı üzerinde defalarca gezinmesi gerekir ve genelde her bir gezinmede farklı işlemler yapılır. Bir tur sonrası ağaç üzerinde değişiklikleri yapılabilir ve bir sonraki turda bu yeni ağaç üzerinden devam edilir vs.</p>
<p>Örnek: Statically typed bir dil için yorumlayıcı yazdığımızda, ilk başta type checker ağaç üzerinde gezerek programın type-safe olduğundan emin olur. Program type-safe ise, ağacın biraz değiştirilmiş hali üzerinde(örneğin type annotationları silinmiş, veya ağacın tagless bir hali) yorumlayıcı çalışır.</p>
<p>Derleyicilerde ise ağaç çok daha fazla sayıda adımlanır. Her bir adımlamada ağaç yapısı değiştirilebilir.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>Yani kısaca problem şu: Elimde farklı tiplerde ağaçlar var(örnek: tip bilgilerini içeren, type checking/inference için oluşturulmuş bir ağaç ve tip bilgilerinin büyük oranda silindiği, yorumlama/derleme için kullanılan bir ağaç vs.), bu ağaçlar üzerinde turlar atacağım fakat tur atarken farklı işler yapacağım.</p>
<p>Katkı yaptığım bir derleyici kodundan birkaç örnek vereceğim: Fay, bir Haskell alt kümesinden JavaScript’e derleyici.</p>
<p><a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Compiler/Exp.hs#L21"><code>compileExp</code></a> fonksiyonu, <a href="http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html#g:8"><code>Exp</code></a> ağacı üzerinde gezinir çıktı olarak <a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Types.hs#L242"><code>JsExp</code></a> (yine başka bir ağaç) üretir. Bu bir ağaç üzerinde gezinip farklı işlemler yapıp farklı bir ağaçlar üreten fonksiyonlara bir örnek.</p>
<p><a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Compiler/Optimizer.hs"><code>Optimizer</code></a> modulü çeşitli ağaçlar üzerinde gezinip başka ağaçlar üreten 13 tane fonksiyondan oluşur ve bunların 5-6 tanesi <a href="https://github.com/faylang/fay/blob/9725f4ff8f23297b4efb34e2f241c31a63ff9fef/src/Fay/Types.hs#L227"><code>JsStmt</code></a> ağacını dolaşır. Bu da aynı ağaç üzerinde gezinip farklı işlemler yapan fonksiyonlara örnek.</p>
<p>Algebraic data typelara ve pattern matchinge sahip olan fonksiyonel dillerde(yani belki de tüm statically typed fonksiyonel dillerde) bunu yapmanın bir yolunu göstermek için hemen hiçbir işlevi olmayan çok basit bir aritmetik ifade dili oluşturalım:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span>
    <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Float</span></code></pre>
<p>Bu kadar işlevsiz bir dil olamaz. Şimdi bu ağaç üzerinde iki farklı işlem yapan iki fonksiyon:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
run (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> run e1 <span class="fu">+</span> run e2
run (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> run e1 <span class="fu">*</span> run e2
run (<span class="dt">Number</span> f)  <span class="fu">=</span> f</code></pre>
<p><code>run</code> programı çalıştırıp sonucu dönüyor.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringOfExp ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stringOfExp (<span class="dt">Add</span> e1 e2) <span class="fu">=</span>
    concat [ <span class="st">&quot;(&quot;</span>, stringOfExp e1, <span class="st">&quot; + &quot;</span>, stringOfExp e2, <span class="st">&quot;)&quot;</span> ]
stringOfExp (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span>
    concat [ <span class="st">&quot;(&quot;</span>, stringOfExp e1, <span class="st">&quot; * &quot;</span>, stringOfExp e2, <span class="st">&quot;)&quot;</span> ]
stringOfExp (<span class="dt">Number</span> f) <span class="fu">=</span> show f</code></pre>
<p><code>stringOfExp</code> ise programın string halini dönüyor. Örnek:</p>
<pre><code>ghci&gt; let prog1 = Add (Number 10) (Mul (Number 20) (Add (Number 30) (Number 40)))
ghci&gt; run prog1
1410.0
ghci&gt; stringOfExp prog1
&quot;(10.0 + (20.0 * (30.0 + 40.0)))&quot;</code></pre>
<p>Yarın ağaca yeni bir node eklediğimde ağaç üzerinde çalışan tüm fonksiyonları güncellemem gerekecek.</p>
<p>Herkes için son derece basittir sanıyorum. Şimdi aynısını ADT’lara sahip olmayan, OO bir dil ile yazalım.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Exp { <span class="co">// base class for expressions</span>
<span class="kw">public</span>:
  <span class="kw">virtual</span> ~Exp() {}
};

<span class="kw">class</span> AddExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  AddExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
};

<span class="kw">class</span> MulExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  MulExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
};

<span class="kw">class</span> Number : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> <span class="dt">float</span> f;
  Number(<span class="dt">const</span> <span class="dt">float</span> f) : f(f) {}
};</code></pre>
<p>Örnek programımız da şu şekilde yazılabilir:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Exp *prog1 = <span class="kw">new</span> AddExp(
    <span class="kw">new</span> Number(<span class="dv">10</span>), <span class="kw">new</span> MulExp(
      <span class="kw">new</span> Number(<span class="dv">20</span>), <span class="kw">new</span> AddExp(
        <span class="kw">new</span> Number(<span class="dv">30</span>), <span class="kw">new</span> Number(<span class="dv">40</span>))));</code></pre>
<p>Peki bu ağaç üzerinde gezinmek nasıl mümkün olabilir ? Bir kere, tüm nodelar alt node olarak <code>Exp</code> tipinde bir nesne tutuyor, kesin tip bilgisine sahip değiliz ve bu tip bilgisine sahip olmadan da yorumlamak mümkün değil mi, yorumladığımız node <code>Number</code> mı, <code>MulExp</code> mi vs. bilmemiz gerekir.</p>
<p>Bunu yapmanın çeşitli yolları var, ama güzel bir çözümü yok. Örneğin <code>Exp</code> sınıfında nodeların tipini tutan bir enum tutabiliriz ve <code>Exp *</code>leri gerekli tiplere cast ederiz. Veya Java gibi bir dilde <code>instanceof</code> kontrolü yapılıp cast edilebilir. Başka çözümler de bulunabilir.</p>
<p>Bu gibi durumlarda kabul edilen en yaygın çözüm visitor design patternı. Biraz aradığınızda onlarca tutorial bulabilirsiniz ki tutoriala ihtiyaç duyması bile aslında fonksiyonel dildeki çözümümüzden ne kadar kötü olduğunun bir göstergesi sayılabilir(8 satır son derece basit ve açık bir Haskell koduna denk bir iş yapmaya çalışıyoruz şu anda)</p>
<p>Bu probleme <em>double dispatch</em> problemi de deniyor. Sebebi yapacağımız işleme hem yorumlayıcıya, hem de ağaca göre karar vermek istiyoruz fakat bir yandan da ağaçlara ve yorumlayıcılara aynı muameleyi yapabilmeliyiz. C++ örneğinde her bir node’un bir ağaç oluşturduğuna dikkat.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> AddExp;
<span class="kw">class</span> MulExp;
<span class="kw">class</span> Number;

<span class="kw">class</span> ExpVisitor {
<span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) = <span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) = <span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) = <span class="dv">0</span>;

  <span class="kw">virtual</span> ~ExpVisitor() {};
};

<span class="kw">class</span> Exp { <span class="co">// base class for expressions</span>
<span class="kw">public</span>:
  <span class="kw">virtual</span> ~Exp() {}
  <span class="kw">virtual</span> <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> = <span class="dv">0</span>;
};

<span class="kw">class</span> AddExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  AddExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};

<span class="kw">class</span> MulExp : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> Exp * <span class="dt">const</span> e1, * <span class="dt">const</span> e2;
  MulExp(<span class="dt">const</span> Exp * <span class="dt">const</span> e1, <span class="dt">const</span> Exp * <span class="dt">const</span> e2)
    : e1(e1), e2(e2) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};

<span class="kw">class</span> Number : <span class="kw">public</span> Exp {
<span class="kw">public</span>:
  <span class="dt">const</span> <span class="dt">float</span> f;
  Number(<span class="dt">const</span> <span class="dt">float</span> f) : f(f) {}
  <span class="dt">void</span> accept(ExpVisitor *visitor) <span class="dt">const</span> { visitor-&gt;visit(<span class="kw">this</span>); }
};</code></pre>
<p>Detaylara çok fazla girmek istemiyorum, kısaca, virtual methodların yardımıyla artık bir nesneyi <code>Exp</code> tipine cast etsek de doğru <code>visit</code> methodları çağırılacak. Buna göre ilk yorumlayıcımızı şu şekilde yazabiliyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Run : <span class="kw">public</span> ExpVisitor {
<span class="kw">public</span>:
  <span class="dt">float</span> result;
  Run() : result(<span class="dv">0</span>) {}

  <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) {
    Run v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    Run v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = v1.result + v2.result;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) {
    Run v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    Run v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = v1.result * v2.result;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) {
    result = exp-&gt;f;
  }
};</code></pre>
<p>Bu arada nesnesel çözümümüzün fonksiyonel çözümümüzden bir başka farkı da burda belli oluyor. Visitorlar arası değer dönmenin bir yolu yok ve bu yüzden buradaki <code>result</code> member değişkeni gibi bir mutable değişken kullanmak zorunda kalıyoruz.</p>
<p>İkinci yorumlayıcımız:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> StringOfExp : <span class="kw">public</span> ExpVisitor {
<span class="kw">public</span>:
  std::string result;
  StringOfExp() : result(<span class="kw">new</span> std::string()) {}

  <span class="dt">void</span> visit(<span class="dt">const</span> AddExp * <span class="dt">const</span> exp) {
    StringOfExp v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    StringOfExp v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = <span class="st">&quot;(&quot;</span> + v1.result + <span class="st">&quot; + &quot;</span> +  v2.result + <span class="st">&quot;)&quot;</span>;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> MulExp * <span class="dt">const</span> exp) {
    StringOfExp v1;
    exp-&gt;e1-&gt;accept(&amp;v1);

    StringOfExp v2;
    exp-&gt;e2-&gt;accept(&amp;v2);

    result = <span class="st">&quot;(&quot;</span> + v1.result + <span class="st">&quot; * &quot;</span> +  v2.result + <span class="st">&quot;)&quot;</span>;
  }

  <span class="dt">void</span> visit(<span class="dt">const</span> Number * <span class="dt">const</span> exp) {
    std::ostringstream ss;
    ss &lt;&lt; exp-&gt;f;
    result = ss.str();
  }
};</code></pre>
<p><code>result</code> member değişkeninin tipinin farklı olduğuna dikkat. Buradaki farklılık Haskell fonksiyonlarındaki dönüş tiplerinin farklılığı ile aynı.</p>
<p>Son olarak programı şu şekilde çalıştırabiliyoruz:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Run r;
prog1-&gt;accept(&amp;r);
std::cout &lt;&lt; <span class="st">&quot;return value Run: &quot;</span> &lt;&lt; r.result &lt;&lt; std::endl;

StringOfExp s;
prog1-&gt;accept(&amp;s);
std::cout &lt;&lt; <span class="st">&quot;return value of StringOfExp: &quot;</span> &lt;&lt; s.result &lt;&lt; std::endl;</code></pre>
<p>Çıktı:</p>
<pre><code>➜  cpp  clang++ arith.cpp -g
➜  cpp  ./a.out
return value Run: 1410
return value of StringOfExp: (10 + (20 * (30 + 40)))</code></pre>
<p>Burda 14 satır Haskell kodu ile aynı işi yapan 125 satır C++ kodundan bahsediyoruz. Tabii kodun aynı özelliğe sahip olduğunu sadece aynı sonuca ulaşmasına bakarak karar vermiyoruz. Yapı olarak da oldukça benzerler.</p>
<p>Haskell programında ağaca yeni bir node eklemek için ilk başta <code>Exp</code> tipine yeni bir constructor eklememiz gerekecek ve daha sonra tüm yorumlayıcılarda match edilecek bir pattern daha eklenecek.</p>
<p>C++ programında, <code>Exp</code> sınıfından yeni bir sınıf türeteceğiz ve tamamen aynı <code>accept</code> methoduna sahip olacak. <code>ExpVisitor</code> sınıfına da bir <code>visit</code> methodu daha eklememiz gerek. Daha sonra yorumlayıcılara teker teker alakalı <code>visit</code> methodunun eklenmesi gerek.</p>
<p>Haskell fonksiyonlarının dönüş değerleri, Visitor sınıflarının <code>result</code> değişkeni ile eşleşiyor.</p>
<p>Aslında aynı şeylerden bahsediyoruz yani.</p>
<p>C++ kodunun çalışan bir haline <a href="https://gist.github.com/osa1/5005037">şuradan</a> ulaşabilirsiniz.</p>
<p>Alıştırma: Hem Haskell hem C++ programı için, ağaç üzerinde gezinerek “x + 0” ifadesini “x” haline, “x * 1” ifadesini “x” haline, “x * 0” ifadesini “0” haline getirecek yorumlayıcılar yazın. Anlamı koruyacak şekilde daha küçük bir ağaç elde etmiş olacağız. (bu optimizasyonlar gerçek derleyiciler tarafından yapılıyor)</p>
<h1 id="ifade-problemi">İfade problemi</h1>
<p>Yukarıda anlattıklarımın ifade problemi diye tercüme ettiğim <a href="http://en.wikipedia.org/wiki/Expression_problem">expression problem</a> ile de alakalı.</p>
<p>Problemimiz şu, program iki boyutta gelişebiliyor, 1.si veri yapısı boyutunda, yani ağaca yeni nodelar eklemek, 2.si operasyonlar boyutunda, yani yeni yorumlayıcılar eklemek.</p>
<p>Yukarıdaki çözümler aslında birbirlerine denk: İkisinde de veri yapısını değiştirdiğimizde kodu yeniden derlememiz gerekiyor(dolayısıyla kodun elimizde olması gerekiyor), fakat koda sahip olmadan ve yeniden derleme yapmadan yeni operasyon(yani yorumlayıcı ekleyebiliyoruz).</p>
<p>Bu yazının amacı ifade problemi değil, o yüzden en azından şimdilik bahsetmeyeceğim(yazının orjinalinde bu kısım hiç yoktu), fakat aslında oldukça ilginç bir konu ve Haskell’ın ve Lisp dillerinin getirdiği ilginç çözümler var. OO dillerin çözümleri hakkında pek bir bilgim yok.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Aslında tabii yorumlayıcı bir çeşit byte-code üzerinden değil de, AST üzerinden yorumlama yapıyorsa, program çalıştığı sürece AST’yi geziyor demektir ve bu durumda bir derleyiciden çok daha fazla sayıda tur atmış olur. Benim burada kastettiğim çalıştırılmadan önce ön işlem anlamında yapılan gezinmeler.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Haskell örneğinde yorumlayıcıların tipleri farklı olduğundan ikisine aynı muameleyi yapamıyoruz, farkındayım. Tamamen aynı tipte yorumlayıcılar için Fay için verdiğim linklere göz atabilirsiniz.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Rowlar, kindlar ve tip çıkarımı hakkında öylesine bir yazı</title>
    <link href="http://osa1.net/posts/2013-02-15-rowlar-kindlar.html" />
    <id>http://osa1.net/posts/2013-02-15-rowlar-kindlar.html</id>
    <published>2013-02-15T00:00:00Z</published>
    <updated>2013-02-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bu yazı birkaç gün önce attığım bir mail aslında. Acele ile yazılmış bir yazı olmasına rağmen epey uzun oldu ve maili yazmaya başlamadan önce kafamda karmaşık bir şekilde duran bazı fikirleri toparlamamda yardımcı oldu. Pek kimsenin işine yarayacağını tahmin etmesem de, yine de buraya koyuyorum. Küçük bazı düzenlemeler yaptım. Eklemeler ise yazının en altına yazıldı. Kodlar OCaml dilinde yazıldı.</p>
<hr />
<p>Üzerinde çalıştığım dilin tip sistemi hakkında<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ty =
  | ...
  | <span class="dt">TRow</span> <span class="kw">of</span> tyrow
  | ...

<span class="kw">type</span> fieldty =
  | <span class="dt">Pre</span> ty
  | <span class="dt">Btm</span> <span class="co">(* Abs ismi lambda abstractionlarda kullanildi *)</span>

<span class="kw">type</span> tyrow =
  | <span class="dt">EmptyRow</span>
  | <span class="dt">Row</span> (id * ty * ..<span class="fl">1.</span>.)
  | ..<span class="fl">2.</span>.</code></pre>
<p>1 ve 2 boşluklarını doldurmamız gerekiyor. Sorunlar şunlar:</p>
<p>1 kısmına yazdığımız tip, sadece yine kendi tipiyle(yani <code>TRow</code> ile) unify etmek zorunda(ilk bakışta <code>tyrow</code> yazmak mantıklı gibi geliyor ama bu yüzden değil).</p>
<p>2 kısmına yazdığımız constructor polymorphic row’u temsil edecek. Burada ben ilk başta aslında row değişkenlerini tamamen yok sayıp, recordlar extensible mı değil mi diye bir boolean flag tutayım demiştim. Fakat sorun, recordlar rowları paylaşabiliyorlar, örneğin şöyle bir fonksiyonda <code>\r -&gt; r.x = 10</code> tip <code>{r/x} -&gt; {x:int|r/x}</code> oluyor, başka bir yerde bu <code>r</code> kullanılabilir(parametre olarak verilen record başka yerlerde kullanıldığında fonksiyonun dönüş değeri olan recordın row değişkeni ile aynı row değişkenine sahip birden fazla record oluyor). Dolayısıyla bir değişken olmak zorunda.</p>
<p>Fakat bu <code>typevar</code> tipinde olamaz, çünkü <code>typevar</code> bir <code>ty</code> ile unify edilebiliyor. Rowlarda ise <code>tyrow</code> ile unify etmek istiyoruz. Ayrı bir tip gerekiyor yani.</p>
<p>Temel olarak row variable ile normal variable tamamen aynı olmalı, tek farkla, row değişkenler sadece row değişkenlerle/değerler ile unify edecek, variablelar da aynı şekilde.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<h2 id="neden-tip-seviyesinde-kindlara-ihtiyaç-var">Neden tip seviyesinde kindlara ihtiyaç var ?</h2>
<p>Type schemeler row değişkenler de tutabilir. <code>let</code> ile bir fonksiyon tanımladım, fonksiyon tipindeki free type variableları generalize ederek(terimler teminoloji ile uyumlu olsun diye ingilizce kullanıldı) bu fonksiyon polymorphic hale getiriliyor ve tipi <code>TypeScheme</code> olarak tutuluyor, quantified değişkenler belirtiliyor.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<p>Daha sonra bu fonksiyon kullanıldığında instantiate ediliyor. Burada instantiate edilen quantified değişkenler yerine ancak kendi kindlarında tiplerin konulması bir şekilde sağlanmalı.</p>
<p>Yani şunu demeye çalışıyorum, elimde bir row variable varsa, bu ancak bir row tipi ile yer değiştirebilir(yerine ancak row tipi yazılabilir). Bunu implementasyon sırasında tip sistemi ile garanti etmek gerçekten zor. İnsanlar bu yüzden kind sistemi kullanıyorlar sanırım.</p>
<p>Kind kullanırsam şöyle oluyor, her tipe bir kind veriyorum. Özet geçmek gerekirse, mesela TVar bir type değişkeni tutuyordu, şimdi bir de kind tutacak. Kindlar ise dilimde kaç tip -birbirlerinden farklı- type varsa, o kadar olacak. Örneğin <code>Star</code> int, bool gibi tipler için kullanılırken, <code>Row</code> row tipleri için kullanılır. Bu sayede bir değişkenim Row kindında ise, quantified edilse de instantiate edilse de bu bilgi taşınır ve en son yerine yazılacağında kind kontrol edilir. Tüm yerine yazmalar <code>kind-preserving</code> olmalıdır.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>Bu sayede farklı kindlarda type variablelar için aynı fonksiyonları kullanabilirim, sürekli kind bilgisini de taşırım. En son substitution veya unification yaparken, kindların korunup korunmadığını kontrol ederim ve normal type değişkeni yerine row type yazılmamasını sağlarım veya unification sırasında hata alırım.</p>
<p>–</p>
<p>Kindlarla beraber tipleri şu şekilde tanımlayabiliyoruz(yaklaşık olarak, henüz programı yazmadım)</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> kind =
  | <span class="dt">KStar</span>                 <span class="co">(* kind of term types *)</span>
  | <span class="dt">KRow</span>                  <span class="co">(* kind of row types *)</span>
  | <span class="dt">KArr</span> <span class="kw">of</span> (kind * kind) <span class="co">(* kind of type constructors *)</span>

<span class="kw">type</span> ty =
  | <span class="dt">TCon</span> <span class="kw">of</span> tycon     <span class="co">(* constant *)</span>
  | <span class="dt">TVar</span> <span class="kw">of</span> tyvar     <span class="co">(* type variable *)</span>
  | <span class="dt">TApp</span> <span class="kw">of</span> (ty * ty)
      <span class="co">(* type application, to be well-typed</span>
<span class="co">         kind of first ty should be KArr (k2, k)</span>
<span class="co">         and second ty should be k2 *)</span>
<span class="kw">and</span> tyvar = (tyvarlink <span class="dt">ref</span> * kind)
<span class="kw">and</span> tyvarlink =
  | <span class="dt">NoLink</span> <span class="kw">of</span> id <span class="co">(* just a type variable *)</span>
  | <span class="dt">LinkTo</span> <span class="kw">of</span> ty <span class="co">(* equated to a ty *)</span>
<span class="kw">and</span> tycon = (id * kind) <span class="co">(* kind should be always KStar *)</span>

<span class="kw">let</span> t_int        = <span class="dt">TCon</span> (<span class="st">&quot;int&quot;</span>,  <span class="dt">KStar</span>)
<span class="kw">let</span> t_bool       = <span class="dt">TCon</span> (<span class="st">&quot;bool&quot;</span>, <span class="dt">KStar</span>)
<span class="kw">let</span> t_unit       = <span class="dt">TCon</span> (<span class="st">&quot;unit&quot;</span>, <span class="dt">KStar</span>)
<span class="kw">let</span> t_list       = <span class="dt">TCon</span> (<span class="st">&quot;[]&quot;</span>,   <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>))
<span class="kw">let</span> t_ref        = <span class="dt">TCon</span> (<span class="st">&quot;ref&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>))
<span class="kw">let</span> t_arr        = <span class="dt">TCon</span> (<span class="st">&quot;-&gt;&quot;</span>,   <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KStar</span>)))
<span class="kw">let</span> t_empty_row  = <span class="dt">TCon</span> (<span class="st">&quot;&lt;|&gt;&quot;</span>,  <span class="dt">KRow</span>)
<span class="kw">let</span> t_row_ext    = <span class="dt">TCon</span> (<span class="st">&quot;&lt;+&gt;&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KStar</span>, <span class="dt">KArr</span> (<span class="dt">KRow</span>, <span class="dt">KRow</span>)))
<span class="kw">let</span> t_rec_const  = <span class="dt">TCon</span> (<span class="st">&quot;{_}&quot;</span>,  <span class="dt">KArr</span> (<span class="dt">KRow</span>, <span class="dt">KStar</span>))

<span class="co">(* type of {r1} *)</span>
<span class="kw">let</span> rp1 = <span class="dt">TApp</span> (t_rec_const, <span class="dt">TVar</span> (<span class="dt">ref</span> (<span class="dt">NoLink</span> <span class="st">&quot;r1&quot;</span>), <span class="dt">KRow</span>))

<span class="co">(* type of {r1} -&gt; {_:int|r1} *)</span>
<span class="kw">let</span> f   = <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_arr, rp1), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_row_ext, t_int), rp1))</code></pre>
<p>En sonraki iki tanım örnek olsun diyeydi.</p>
<p>Karmaşık olduğunun farkındayım ama 1) bu tip sistemi implementasyonları için standard yol gibi geldi bana(çok fazla makalede kind sistemlerinden bahsediliyor) 2) diğer türlü de daha az karmaşık değil gibi.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<p>Burda mesela <code>TApp</code> oluşturan bir yardımcı fonksiyon oluştururuz ve kindları kontrol eder, uyumlu mu diye, bir miktar daha kolaylaşır. Yardımcı fonksiyonlarla işi kolaylaştırabiliriz diye düşünüyorum yani.</p>
<p>Bu örnekde <code>rp1</code> yerine mesela <code>{a:bool}</code> (yani <code>TApp (TApp (t_rec_ext, bool_ty), t_empty_row)</code>) yazarsak:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">TApp</span> (<span class="dt">TApp</span> (t_arr, rp1), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_row_ext, t_int), <span class="dt">TApp</span> (<span class="dt">TApp</span> (t_rec_ext, bool_ty), t_empty_row)))</code></pre>
<p>Bana gayet temiz bir şekilde <code>{x:int, a:bool}</code> elde ettik gibi geliyor ve tek yaptığımız yerine yazmak oldu. ( bu sunumda labelların atlandığının farkındayım, tam olarak labelları nasıl bu sisteme entegre ederim düşünmedim )</p>
<p>Diğer türlü yapılamaz mı, tabii ki yapılabilir ve ben zaten çok yaklaşmıştım. Fakat çirkin olmayan bir yolu yok. Kod içerisinde şöyle kısımlar olmak <em>zorunda</em> gibi: “implementasyonum doğru olduğuna göre bu type variable record ile unify edilmiş olacak, exhaustive olmayan pattern matching yap”. Mesela tüm row değişkenler bir record’a unify edilimş olacak, ben pattern matching ile fieldları alacağım kendi recordıma ekleyeceğim vs.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Ama kindler ile yaptığımda bu gibi durumlar olmayacak, ben <code>TApp</code>’lar ile typelar oluşturacağım, kind preserving substitutionlar, generalizationlar, instantiationlar yapılacağından, her zaman row tiplerim well-formed olmuş olacak ben hiçbir kontrol yapmadan <code>TApp</code>’ler oluşturmaya başlayacağım.</p>
<p>Ben bugün akşam birkaç makale daha inceleyeceğim: Type Inference for Records in a Natural Extension of ML (Didier Rémy) ve A Polymorphic Type System for Extensible Records and Variants (Mark P. Jones, Benedict R. Gaster). Bir de Typing Haskell in Haskell (Mark P. Jones)’a baktım, Haskell’da burada konuştuğumuz anlamda recordlar yok, ama kind sisteminden bahsederken “row kindlar da kolayca eklenebilir” diyerek sanırım yukarıda yaptığım şeyi kastetmekte.</p>
<p>Bu nasıl olabiliyor anlayabilmiş değilim ama gerçekten internette hiç örnek implementasyon yok. Bu yüzden ben bir tane yazacağım blog yazısı olarak. Polymorphic recordlara sahip bir dil inceleyeyim dedim, bir tanesi <a href="http://elm-lang.org/">Elm</a> adlı bir dil, kaynağı Haskell ile yazılmış temel olarak “Scoped Labels” makalesini kullanmış, ama kod berbat bir durumda. Çok çok karmaşık, kod stili berbat(type annotationlarını atlamış, Haskell’da bunu hiçbir zaman yapmayız, derleyici uyarı verir, annotationlar OCaml’daki gibi kodun içine yazılmaz, ayrı bir satıra yazılır ve anlaşılabilmeye çok katkı sağlarlar) vs. Yine de okunacak olursa en mantıklısı bu.</p>
<p>İkincisi <a href="http://www.pllab.riec.tohoku.ac.jp/smlsharp/">SML#</a>. Bu da ne yazık ki SML üzerine implement edilmiş ve kaynak kodu devasa. Tüm SML kodunu incelemek gerekecek yani(aradım bulamadım alakalı kısımları).<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Özetle, row polymorphism’e sahip, multi-staged bir dil. Buradaki veri yapısı dilin tip sistemini ifade ediyor. Row tiplerine dikkat. Row polymorphism’de fieldlar üzerinde bazı kısıtlar tanımlamanın birkaç yolu var. Bir yol, benim burada yaptığım ve <a href="http://gallium.inria.fr/~remy/publications.html">D. Rémy</a>’nin “Type inference for records in a natural extension of ML” ve başka makalelerinde gösterdiği gibi, field tiplerinde bir çeşit “flag” tutmak. Makalelerde Abs/Pre diye geçer, benim kodumda Pre/Btm. Bu yolun bu işi yapmak en bariz yol olduğunu söyleyebiliriz belki. Fakat kesinlikle en kolay/güzel yötem değil. Alternatif olarak kısıtlar constraint seviyesinde, kind seviyesinde veya başka bazı seviyelerde tanımlanabiliyor.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Burada anlatmaya çalıştığım problem bana çok vakit kaybettirdi ve aslında pek çok kişiye tanıdık gelebilir. Kısaca yapmaya çalıştığım şey, bazı şeyleri statik olarak garanti etmek için tip sistemini kullanmaya çalışmak. Örneğin bir programlama dilinde syntax ağacını well-formed olmayan programları ifade edebilmesini engelleyecek şekilde oluşturmak gibi. Bu gibi durumlarda eğer yeterince güçlü tip sisteminiz yoksa(örnek: GADTler yardımcı olabiliyor) işiniz çok zorlaşabiliyor. Daha kolay bir yöntemi runtime’da bunu garantilemek. Hemen sonrasında anlattığım şey tam olarak bu aslında. Statik garantiler verebilmek süper birşey aslında. Hiçbir şart altında programınızın yanlış çalışmayacağını garanti altına alıyorsunuz. Ama bazı durumlarda bu mümkün ama çok zor olabiliyor. Diğer yandan, zor da olsa bir kere implement ettikten sonra kesin olarak doğru çalışacağından emin olabiliyorsunuz. Veya test etmesi çok kolay oluyor vs.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Anlattığım şey Damas-Hindley-Milner tip sisteminin temellerinden aslında.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Kindları kendi kendime keşfettiğim an. Aslında Haskell programcısı olduğumdan kind konspetine aşinaydım, ama bu şekilde kullanımı bir bakıma kendi kendime keşfettim diyebilirim. Kind adını da ben vermedim tabii, daha sonra hakkında okudukça farkettim.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>“diğer türlü daha az karmaşık değil gibi” derken kastettiğim, Rémy usulü, field tiplerine bir flag koyarak Abs/Pre özelliğini belirtmekti.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Burda aslında biraz programımın implementasyonu ile alakalı detaylardan bahsediyorum. Belki bir ara biraz daha açarım.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Daha sonradan farkettim ki bir alternatif daha varmış: “Extensible records with scoped labels” makalesinde bahsedilenlerin implement edildiği <a href="http://www.equational.org/morrow/">Morrow</a> programlama dili. En iyi implementasyon şimdilik bu. Tek problemi, kurulmak için <a href="http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem">UUAG attribute grammar system</a>a ihtiyaç duyması. Bir de eğer sadece type inference yapmasın, bir de çalıştırsın derseniz, OCaml’a ihtiyaç duyuyor. Evet çok fantastik. Haskell ile statik analiz kısımları yapılıyor ve OCaml’a derleniyor. Tabii programın asıl olayı tip sistemi olduğundan, deneme için yazdığınız programları çalıştırmak istemeyebilirsiniz, o zaman OCaml’a gerek yok.<a href="#fnref7">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Okudukarım, okunacaklar</title>
    <link href="http://osa1.net/posts/2013-02-12-okuduklarim-okunacaklar.html" />
    <id>http://osa1.net/posts/2013-02-12-okuduklarim-okunacaklar.html</id>
    <published>2013-02-12T00:00:00Z</published>
    <updated>2013-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Son ciddi yazımdan beri epey vakit geçmiş. Henüz buradan duyuramadım ama, bir süredir 2. 14 haftalık stajımı yapıyorum. Detaylar için ayrı bir yazı yazmayı planlıyorum ama şimdilik türkiyedeki tek PLT işinde çalıştığımı söyleyebilirim sanırım(abartmış olabilirim, PLT üzerine çalışan insanlar varsa söyleyin, ben de merak ediyorum). Birkaç ay önce imkansız gibi gözüken bazı şeylerin bu kadar çabuk normalleşmesi ne garip.</p>
<p>Neyse, kısaca şu anda üzerinde çalıştığım proje için okuduğum ve okumakta olduğum makalelerden bahsedeceğim biraz.</p>
<h1 id="okuduklarım">Okuduklarım</h1>
<h2 id="a-polymorphic-modal-type-system-for-lisp-like-multi-staged-languages.">A polymorphic modal type system for lisp-like multi-staged languages.</h2>
<p>Multi-staged programming ile tanıştığım makale bu oldu. Aslında giriş için hiç iyi bir makale değil, kullandığı dil çok büyük, bir tam kolon big-step <a href="http://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a> verilmiş. Tip ve çıkarım kuralları da buna bağlı olarak kompleks.</p>
<p>Multi-staged programming’i kısaca Lisp macroları benzeri bir meta-programming araçları gibi düşünebiliriz. Daha detaylı bilgiyi üzerinde çalıştığım yorumlayıcı bittiğinde, kendisi ile örneklerle vermek istiyorum. Şimdilik şöyle özet geçebilirim: Programların çalıştırılması birden fazla stage’e ayrılmış oluyor ve her iki stage arası bir miktar evaluation yapılıyor. Örnek olarak bir matris çarpımı yapacaksanız, matrislerin uzunluğu belli olduğunda bir miktar evaluation yaparak matris uzunluk kontrolü ve iterasyon içermeyen, girdi olarak verdiğiniz iki matris boyutundaki matrisler için çarpma yapan bir kod üretebilirsiniz. Daha sonra çarpma işlemi nispeten daha hızlı olacaktır.</p>
<p>Bir miktar <a href="http://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a> ile de alakalı. Partial evaluation çok fantastik bir konu, bu yazıyı okuyan herkesin en azından wikipedia sayfasına bakmasını tavsiye ederim(özellikle Futamura projections kısmı fantastik).</p>
<h2 id="static-analysis-of-multi-staged-programs-via-unstaging-translation.">Static analysis of multi-staged programs via unstaging translation.</h2>
<p>Multi-staged programların statik analizlerinin daha zor olduğu gözlemlendikten sonra, multi-staged bir programın anlam korunarak unstaged bir hale tercüme edilebileceğinin farkedilmesi üzerine, multi-staged programların bu tercüme ile statik olarak analiz edilebileceğini söylüyor. Staged expressionlar bir çeşit record-calculus(lambda calculus + recordlar)a tercüme ediliyor ve statik tip sistemi verilmiş.</p>
<p>Bir önceki makaledekine göre çok küçük bir multi-staged dil tanımlıyor ve bu yüzden okuması/anlaması daha kolay. Tip sistemi de daha az farklı olduğundan(hatta makalede tip sistemi anlamında yeni birşey yok) onun da anlaşılması daha kolay olabilir. (benim için farketmedi, benzer bir tip sistemi üzerinde hiç çalışmamıştım)</p>
<p>Tercüme sonrası analizler, tercüme öncesindeki hal ile eşleştiriliyor.</p>
<h2 id="a-modern-eye-on-ml-type-inference.">A modern eye on ML type inference.</h2>
<p>Damas-Hindley-Milner tip sisteminin bir özeti niteliğinde. Pek çok detay bilindiği varsayılarak atlanmış, ve 2. ve 3. bölümleri “gelecek” denmesine rağmen, 2005’den beri, gelmemiş.</p>
<p>Tip çıkarımından bahsedildikten sonra, constraint solving ile alakasından bahsediyor. W ve J algoritmaları ve parametrik HM(X) algoritmasından bahsediliyor. Tip çıkarımı ile constraint oluşturma/çözme arasındaki ilişkiyi anlamak için çok iyi.</p>
<p>Hatırladığım bir başka güzel yanı da constraint oluşturma ve çözme kısımlarının nasıl birbirlerinden ayrılabileceği ve bunun getirdiklerinden bahsetmesiydi. Ayrıca constraintler yardımıyla çıkarımı polymorphism’i anlatmadan önce anlatması da ayrı bir güzellik bence.</p>
<h2 id="record-polymorphism-yazıları">Record polymorphism yazıları</h2>
<p>Refined subtyping and row variables for record types(Didier Remy), Type inference for records in a natural extension of ML(Didier Remy), Extensible records with scoped labels(Daan Leijen), A polymorphic type system for extensible records and variants(Gaster, Jones)</p>
<p>Hepsini tamamen okumasam da, bir göz gezdirdim. Leijen makalesi özellikle çok hoş ve okuması kolay. <a href="http://elm-lang.org/">Elm</a> dilinin <a href="http://elm-lang.org/blog/announce/version-0.7.elm">recordları</a> temel olarak bu makalede anlatılanların bir implementasyonu. Ben de başka bir projem için benzer bir record yapısı planlıyorum.</p>
<p>Bu makalelerden benim çıkardığım en önemli şey şu oldu: Derleme zorluğu önemsenmediğinde, çok güzel record tipleri elde etmek mümkün.</p>
<p>İkinci olarak, aynı kısıtları tanımlamanın farklı yolları var ve çoğu zaman “en iyi” diyebileceğimiz bir yola sahip değiliz. Duruma göre alternatifleri değerlendirmek zorundayız.</p>
<p>Polymorphic recordlar söz konusu olduğunda, bir recordda bir t tipinde bir labelın bulunduğunu veya bulunmadığını belirtmenin birden fazla yolu var. Kind seviyesinde tanımlayabilirsiniz ki kompleks bir kind tipi gerektirir(daha sonra bir de kindların well-formed olduğunu kontrol etmek gerekebiliyor, kind-inference algoritmaları falan var). Ohori’nin makalelerinde bu kullanıyor sanırım. Direkt olarak row field tiplerine gerekli bilgiği yerleştirebilirsiniz ki Remy’nin makalelerinde yapılan bu. Veya constraint oluşturabilirsiniz ki bu benim en sevdiğim yöntem, Jones’un makalesinde kullanılmış(aslında <em>constraint</em> değil de <em>predicate</em> denmiş).</p>
<p>Yani recordlar gibi elinizde nispeten kompleks bir tip olduğunda(en basitinden, label-type ikililerinden oluşan bir kümeden bahsediyoruz ve bazı makalelerdeki sistemlerde birden fazla label olabiliyor), teorik kısıtları ifade etmek için çeşitli yollar var ve elinizdeki mevcut sisteme hangisi daha iyi gidiyorsa onu seçme şansınız var.</p>]]></summary>
</entry>

</feed>
