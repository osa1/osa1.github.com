<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged tr</title>
    <link href="http://osa1.net/tags/tr.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/tr.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2012-11-20T00:00:00Z</updated>
    <entry>
    <title>Alıntılar [1]</title>
    <link href="http://osa1.net/posts/2012-11-20-alintilar-1.html" />
    <id>http://osa1.net/posts/2012-11-20-alintilar-1.html</id>
    <published>2012-11-20T00:00:00Z</published>
    <updated>2012-11-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Paul Feyerabend’in “Özgür bir toplumda bilim” adıyla tercüme edilmiş kitabından bir kısım paylaşacağım. Aslında kitap genel olarak çok ilginç bulduğum pek çok fikirden bahsetmekte, fakat özellikle bu kısımı <a href="http://osa1.net/mathematicianslament/">bir önceki yazımla</a> da alakalı olduğunu düşündüğümden ve başka konular hakkında da hiç düşünmediğim fakat aslında bariz olabilecek fikirlerden bahsettiğinden paylaşmak istedim.</p>
<p><em>Sıradan insanlar bilimi denetleyebilirler ve denetlemelidirler</em> bölümünden:</p>
<blockquote>
<p>Tipik olmaktan hiç de uzak olmayan bu örnekler, bilim adamlarının ve fizikçilerin yargılarını incelemeden kabul etmenin yalnızca aptallık değil, <em>düpedüz sorumsuzluk</em> olduğunu da gösteriyor. Söz konusu olan mesele, ister küçük bir grup için ister tüm bir toplum için, eğer önem taşıyorsa, <em>o zaman bu yargıların en sıkı biçimde incelenmeleri gerekir</em> . Sıradan insanlar arasında konuyla ilgili seçilmiş komiteler, evrim teorisinin gerçekten de biyologların inanmamızı istedikleri kadar sağlam temellere sahip olup olmadığını, onların anladığı anlamda sağlam temellere sahip olmasının meseleyi halledip halletmediğini ve bu teorinin okullarda öğretilen diğer görüşlerin yerini almasının gerekip gerekmediğini incelemelidirler.</p>
</blockquote>
<p>Bu bakış açısı bana epey mantıklı geldi. Devamında şöyle söylüyor:</p>
<blockquote>
<p>Her olayda son sözü, uzmanlar değil, konuyla doğrudan ilgili insanlar söylemelidir. Jürilerin bulunduğu mahkemelerce yapılan her yargılama, sıradan insanların “biraz çaba gösterdiklerinde” uzmanların hatalarını açığa çıkarabilecekleri temel varsayımına dayanır. Yasa, uzamanların sorguları sırasında verdikleri ifadelerin jürinin değerlendirmesine sunulmasını öngörür. Bunu isterken, uzmanların da eninde sonunda insan olduklarını, tümüyle uzmanlık alanları içinde kalan konularda bile hata yaptıklarını, kendi fikirlerinin güvenilirliğini sarsabilecek her türden belirsizliği örtbas etmeye çalıştılarını, uzmanlıklarının hiç de öyle sık sık ima edildiği gibi ulaşılmaz olmadığını varsayar. Yasa ayrıca, sıradan bir insanın, uzmanların kullandıkları usullerin anlaşılması ve hatalarının ortaya çıkarılması için gerekli bilgiyi edinebileceğini de varsayar. Bu vaysayımın doğruluğu bütün davalarda defalarca kanıtlanmıştır.</p>
</blockquote>
<p>Katılıp katılmadığım hakkında bir karara varamamış olsam da, bu bakış açısı hoşuma gidiyor. Yine aynı kısımda, bilim adamlarının da diğer pek çok meslek gruplarına yapıldığı gibi, denetlenmesi gerektiğinden bahsedildikten sonra, konuyu eğitimcilere getirir:</p>
<blockquote>
<p>Eğitimciler olayında durum daha da kötüdür. Zira fiziksel bir tedavinin başarılı olup olmadığını belirlemek olanaklıyken, eğitim denilen zihinsel tedavinin başarısını belirleyecek bir araca sahip değiliz. Okuma, yazma, aritmetik ve temel olgulara ilişkin bilgi hakkında bir yargıya varılabilir. Ama insanları ikinci el varoluşçular ya da bilim felsefecileri haline getiren bir eğitim için ne diyeceğiz? İnsanlar nasıl ki kendi doktorlarını denetlemeye başladılarsa, öğrenciler de kendi öğretmenlerini denetlemeye başlamadıkça, dokunulmazlık zırhı ardıkdaki öğretmen kendi fikirlerini bizlere yutturabilir. Bütün durumlarda tavsiye olunan şey, <em>uzmanlara başvurmak</em> , ama onlara hiç bir zaman <em>güvenmemek</em> ve kesinlikle hiç bir aman <em>onlara</em> tümüyle <em>bel bağlamamaktır</em> .</p>
</blockquote>
<p>Daha pek çok ilginç gözlem ve fikirle dolu. Belki ileride daha da paylaşırım.</p>]]></summary>
</entry>
<entry>
    <title>A Mathematician's Lament</title>
    <link href="http://osa1.net/posts/2012-11-19-mathematicianslament.html" />
    <id>http://osa1.net/posts/2012-11-19-mathematicianslament.html</id>
    <published>2012-11-19T00:00:00Z</published>
    <updated>2012-11-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Geçenlerde Paul Lockhart’ın <a href="http://www.maa.org/devlin/lockhartslament.pdf">A Mathematician’s Lament</a> adlı yazısını okudum. Genel olarak matematik eğitimine ve toplumlarda matematiğe bakışa bir eleştiri niteliğinde olsa da, öğretim, öğrenim ve eğitim sistemleri ile alakalı pek çok süper tespit var. Sadece sorunlar değil, çözümleriyle de alakalı bir yazı olmuş(her ne kadar ben yazar tarafından sunulmuş pek çok çözümü pek de gerçekçi bulmasam da).</p>
<p>Matematikçiler haricindeki insanlar tarafından matematiğe olan görüşü, bunun neden yanlış olduğunu ve daha doğru bir görüşün ne olabileceğini anlamak için okumanızı tavsiye ederim. Her ne kadar ben matematikçi olmasam ve matematik konusunda temellerimin yeterince iyi olmadığını düşünsem de, anlattığı pek çok meseleyi anlayabiliyorum ve açıkçası bazı durumlarda yazarın neler hissetiğini anladığımı ve bazı başka konularda benzerlerini hissettiğimi iddia edebilirim.</p>
<p>Aslında konu hakkında çok fazla şey yazmıştım, ama bir yerden sonra kafamdakileri toplarlayamadım ve ortalık karıştı. Kısaca, yazıda benim en çok dikkatimi çeken ve kendi hayatımdan onlarca örnek bulabildiğim bir kısımdan bahsedeceğim:</p>
<blockquote>
<p>Mathematics is an art, and art should be taught by working artists, or if not, at least by people who appreciate the art form and can recognize it when they see it. It is not necessary that you learn music from a professional composer, but would you want yourself or your child to be taught by someone who doesn’t even play an instrument, and has never listened to a piece of music in their lives? Would you accept as an art teacher someone who has never picked up a pencil or stepped foot in a museum? Why is it that we accept math teachers who have never produced an original piece of mathematics, know nothing of the history and philosophy of the subject, nothing about recent developments, nothing in fact beyond what they are expected to present to their unfortunate students? What kind of a teacher is that? How can someone teach something that they themselves don’t do?</p>
</blockquote>
<p>Burada <em>matematik</em> kelimesini çıkarıp, başka kelimeler koyup, etrafınıza bakın. Ben etrafıma baktığımda bu durum çok bariz.</p>
<p>Bazı şeylere(programlama) küçük yaşta başlayan bir hobici olarak bunu daha kolay farkedebiliyor olabilirim. Bana programlama dilleri anlatmaya çalışan insanın aslında konuyla alakalı herhangi bir ilgisinin olmadığını ve bilgi olarak da yeterli olmadığını anlamak ne kadar kolay, muhtemelen söylesem abarttığımı sanırsınız. Hatta konuyla alakası olmayan başka arkadaşlar bile bizzat bana durumu farkettiklerini söylemişlerdi.</p>
<p>Lise ortamında da hocalarım hakkında aynı şeyleri o dönemlerde tuttuğum blogumda hep yazdım ve bu yüzden pek çok problem yaşadım(gerçi çok sonralardan farkettim ki problem yaşamamın sebebi biraz da üslubummuş).</p>
<p>Peki bu şartlar altında öğrencilerin bundan faydalanmasını nasıl bekleyebilirsiniz? Dersi anlatanın anlattığı ders hakkında yeterince fikri yok ki.</p>
<p>Dikkatimi çeken ikinci bir kısım da şu oldu:</p>
<blockquote>
<p>There is surely no more reliable way to kill enthusiasm and interest in a subject than to make it a mandatory part of the school curriculum. Include it as a major component of standardized testing and you virtually guarantee that the education establishment will suck the life out of it. School boards do not understand what math is, neither do educators, textbook authors, publishing companies, and sadly, neither do most of our math teachers. The scope of the problem is so enormous, I hardly know where to begin.</p>
</blockquote>
<p>Ben de olaya benzer bir açıdan bakıyorum.</p>
<p>Birincisi, öğretilenlerin karşılığında öğrenciden birşeyler beklemek, bana göre, olayın tüm anlamını, faydasını, heyecanını ve zevkini kaçırıyor, ki yukarıdaki paragrafta da bahsedilen temel olarak bu. Özellikle eğitim sistemi yeterince saçmaysa, 2 saat içerisinde maksimum miktarda soru çözme gibi komik kriterler ile birşeyler ölçmeye çabalıyorsanız, herhangi birşey öğretebiliyor olmayı beklemek bana göre son derece saçma(komik diyecektim, sonra artık tadının kaçtığını ve komik olmadığını farkettim).</p>
<p>Bir sene sonra bilgisayar mühendisi olarak mezun olacak arkadaşların benim nasıl hobi olarak programlamayla ilgilendiğimi anlamamalarını bence bu açıklıyor.</p>
<p>Belki bu sefer ben biraz abartmış olacağım ama(bu yazıyı okurken birkaç yerde yazarın çok abarttığını düşümüşümdür mesela, bence bu yazarın olayı ne kadar sahiplendiğini ve önemsediğini gösteriyor), hep şöyle birşey hayal etmişimdir; X okulu(alanı siz belirleyin, örneğin <em>bilgisayar bilimleri</em> olabilir), katılan kimseye hiçbir şekilde ödev verilmiyor, kimse sınavlara girmiyor, bir diploma yok. Herkes başlangıçta neden orada olmak istediğinin farkında(bu kısım bence çok önemli). Günümüzdeki anlamıyla bir müfredat olmasa da, dersler var. Katılımcılardan bazı yeterliliklere sahip olmaları istense de, bu yeterlilikler diplomalar veya testlerle ölçülmüyor, mülakat formatında, veya kağıt üzerinde konunun gerekliliğini de gösteren birkaç <em>gerçek</em> problem ile ölçülebilir(veya başka yöntemler bulunabilir). Yaş ve sınıf konsepti yok. Bu da benim fantezim işte hahah.</p>
<p>İkinci olarak, birşeyi yapmaya mecbur kalmak da benzer bir etki oluşturuyor ki bunu çoğu kişi gözlemlemiştir(özellikle mesleklerini hobilerinden seçenler, mesela ben ;-( ).</p>
<hr />
<p>Bu gibi konulara merak duyuyorsanız okumanızı tavsiye ettiğim keyifli bir yazı olmuş.</p>]]></summary>
</entry>
<entry>
    <title>Assembly programları için kod organizasyonu hakkında</title>
    <link href="http://osa1.net/posts/2012-11-12-assembly-kod-organizasyonu.html" />
    <id>http://osa1.net/posts/2012-11-12-assembly-kod-organizasyonu.html</id>
    <published>2012-11-12T00:00:00Z</published>
    <updated>2012-11-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Düzenlenip yayınlanmayı bekleyen süper yazılar olmasına rağmen şu anda mikroişlemciler sınavı çıkışı bunu yazıyor olamam epey garip.</p>
<p>Her ne kadar 2. vizeden çıkmış olsak da, henüz umudu kesmeyenlerin ve gelecek dönemlerin işine yarayabileceğini düşündüğüm, derste -bana göre yanlış olarak- hiç bahsedilmeyen birkaç şeyden bahsedeceğim.</p>
<p>Ana fikir şu, bu ders kapsamında veya genel olarak x86 ASM kodlarken, bazı <em>convention</em>lar takip etmek program organizasyonu açısından çok faydalı oluyor ve ben birazdan bahsedeceğim conventionlar olmadan ben programlayamazdım.</p>
<p>Bunlardan ilk bahsedeceğim tamamen kozmetik, kodun okunaklığını arttıran ve aslında tamamen programcının yorumlaması gereken basit bir düzenleme.</p>
<p>Etiketleri yerleştirirken, kendi uydurduğum <em>scope</em> kuralları uyguluyorum. Yazdığım kod şu şartları sağlıyor:</p>
<ul>
<li>Zıplama yapılırken, zıplamayı yapan kod ile zıplaya yapılan etikete sahip kod aynı miktarda girintilenmiş olmalı.</li>
<li>Bu iki kısım kod arasında daha az girintilenmiş başka kod olmamalı.</li>
</ul>
<p>Örnek olarak aşağıdaki kod, henüz deadline’ı gelmemiş bir ödevin çözümünün bir parçası. Programın tamamını koyamıyorum o yüzden, sadece etiketleri yerleştireceğim:</p>
<pre><code>...

kopyala:
    ...
    
    kopyala_dongu:
        ...
    
    ...

sirala:
    ...

    sirala_dongu:  
        ...
   
    sirala_son:     
        ...

kaydir:
    ...
    
    kaydir_dongu:
        ...
            
    kaydir_son:
        ...</code></pre>
<p>Yukarıdaki maddeleri açıklamak için birkaç örnek: <code>sirala_dongu</code>den <code>sirala_son</code>a atlanabilir, ama <code>kaydir_dongu</code>ye atlanamaz, çünkü arada daha az girintilenmiş kod var(<code>kaydir</code> prosedürüne ait). Her yerden <code>kaydir</code>, <code>sirala</code> ve <code>kopyala</code> <em>çağırılabilir</em>(<code>call</code>), ancak hiçbir yerden zıplanamaz. Bunun gibi. Bunları takip ettiğinizde, kod çok daha okunaklı bir hale geliyor diye düşünmekteyim.</p>
<p>İkinci kısım aslında daha önemli, prosedür oluşturma ve çağırma hakkında.</p>
<p>Anlatacağım convention, <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a> olarak bilinen, x86-32 sistemlerde C fonksiyonlarının derlenme şekli.</p>
<p>Yapılan şey şu, fonksiyon parametreleri, sondan başlanarak(örneğin 3 parametre varsa, ilk önce 3. parametre) stacke pushlanır. Daha sonra <code>call</code> yapılır. Fonksiyon, önce bp’yi stacke atarak yedekler(<code>push bp</code>), daha sonra parametrelere ve local değişkenlere erişmek için, <code>bp</code>(base pointer)ye <code>sp</code>(stack pointer)ı atar(<code>mov bp, sp</code>). Bu aşamadan sonra, artık <code>[bp+2]</code> bp’nin eski değerini, <code>[bp+4]</code> birinci parametreyi, <code>[bp+6]</code> 2. parametreyi verir.</p>
<p>Bir sonraki aşama olarak, fonksiyon içerisinde kullanılacak local değişken kadar stackde yer açılır. Örneğin 1 değişken varsa, <code>sub sp, 2</code>, 2 değişken varsa <code>sub sp, 4</code> ile stack’de yer açılır. Bu sayede fonksiyon içerisinden başka bir fonksiyon çağırdığımızda, local değişkenlerin üzerine birşey yazılmaz. Aslında <code>bp</code>yi de benzer bir sebeple yedeklemiştik. Başka bir fonksiyon çağırıldığında, bp’yi kendi değişklenlerine ve parametrelerine erişmek için değiştirecek. Birazdan göreceğimiz gibi fonksiyon dönüş yaparken <code>bp</code>yi eski haline getirecek.</p>
<p>stack’de yer açtıkdan sonra da local değişkenlere, 1. değişken için <code>[bp-2]</code>, 2. değişken için <code>[bp-4]</code> ile erişebiliyoruz.</p>
<p>NOT: Bu arada eğer farkedilmediyse belirteyim, 16bit 8086 işlemcilerden bahsediyorum. 32 bit sistemlerde stack pointerını 1 değer için 2 değil 4 azaltmanız gerekecek. Bir diğer farkedilmesi gereken şey de, stack pointer’ın pushlandığında <em>azaldığı</em>.</p>
<p>Fonksiyon işini bitirdiğinde, <code>sp</code>ye local değişkenleri silmek için <code>bp</code>yi atamalı(<code>mov sp, bp</code>, hatırlarsanız fonksiyon çağırıldığında <code>mov bp, sp</code> yapmıştık, ve daha sonra local değişkenler için <code>sp</code>yi kaydırmıştık). Bu aşamada stack’in tepesinde bp’nin eski değeri var. <code>pop bp</code> ile bunu <code>bp</code>ye yükledikten sonra <code>ret</code> ile dönüş yapabiliriz.</p>
<p>Bu arada fonksiyon dönüş değerini <code>ax</code>e koyuyor.</p>
<p>Bundan sonra son olarak yapılması gereken şey, fonksiyonu çağıran kod parametreleri stacke atmıştı, ama temizleyen olmadı. 2 parametre için <code>add sp, 4</code> gibi bir kod ile stack temizlenebilir.</p>
<p>Anlaşılması için bir üs alma fonksiyonu yazacağım. Fonksiyonun adı <code>power</code> olsun. Çağırılışı şu şekilde:</p>
<pre><code>push 2          ; ikinci parametre
push 5          ; birinci parametre
call power
add sp, 4</code></pre>
<p>En sonunda stackin temizlendiğine dikkat. Bu koddan sonra <code>ax</code>de fonksiyonun dönüş değeri olmuş olacak.</p>
<p>Fonksiyon ise şöyle:</p>
<pre><code>power:
    push bp             ; bp&#39;nin eski değerini yedekle
    mov bp, sp          ; bp := sp.
    sub sp, 2           ; 1 local değişken için stackde yer aç
    
    mov bx, [bp+4]      ; birinci parametreyi bx&#39;e yükle
    mov cx, [bp+6]      ; ikinci parametreyi cx&#39;e yükle
    
    mov [bp-2], bx      ; bx&#39;i birinci local değişkene ata

    power_loop_start:
        cmp cx, 1
        je power_end
        
        mov ax, [bp-2]
        mul bx
        
        mov [bp-2], ax
        dec cx
        jmp power_loop_start        
        
    power_end:
        ; birinci local değişkenimiz fonksiyonun dönüş değeri
        ; bu değeri ax&#39;e yükle
        mov ax, [bp-2]
        mov sp, bp        ; sp&#39;yi eski haline getir
        pop bp            ; bp&#39;yi eski haline getir
        ret               ; dön</code></pre>
<p>İşte x86-32’de C fonksiyonları buna benzer bir şekilde derleniyor. 64bit sistemlerde ekstradan 8 yazmaç olduğundan, parametreler direkt olarak stacke atılmaktansa yazmaçlara yazılıyormuş. Başka dillerde de, dilin ihtiyaçlarına göre farklı yollar izleniyor. Örneğin C++ dilindeki <code>this</code> pointerları her seferinde stacke atılmaktansa, sürekli sabit bir yazmaça yükleniyor olabilir.</p>
<p>Bazı calling conventionlar için özet bilgiye Wikipedia sayfalarından ulaşabilirsiniz: <a href="http://en.wikipedia.org/wiki/X86_calling_conventions">X86 calling conventions</a>, <a href="http://en.wikipedia.org/wiki/Calling_convention">bazı farklı mimariler için conventionlar</a>, <a href="http://refspecs.linuxfoundation.org/lsb.shtml">Linux ortamında kullanılan çeşitli conventionlar</a>. Onun dışında AMD64 için <a href="http://www.x86-64.org/">ABI</a>. Intel <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">IA manualları</a>nda da ABIlardan bahsediliyordu yanlış hatırlamıyorsam.</p>
<p>Bu arada her fonksiyon çağırılışında stacki temizlemek, fonksiyonların kaç parametre aldığının fonksiyonun kendisinin her zaman bilmesi durumunda, gereksiz. Yukarıda C conventionlarından bahsettiğimden, ve C’de örneğin <a href="http://en.cppreference.com/w/c/io/fscanf"><code>sscanf</code></a> gibi fonksiyonlar değişik sayılarda parametre alabildiğinden, temizleme işlemini parametreleri gönderen taraf yapıyor.</p>]]></summary>
</entry>
<entry>
    <title>Etkinlik fikri</title>
    <link href="http://osa1.net/posts/2012-10-06-etkinlik-fikri.html" />
    <id>http://osa1.net/posts/2012-10-06-etkinlik-fikri.html</id>
    <published>2012-10-06T00:00:00Z</published>
    <updated>2012-10-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Hep ilgilenen insanların bir araya toplanıp, zorlu bazı problemleri bazı limitler altında çözdükleri etkinliklere özenmişimdir. Aslında çok farklı bir konsept değil, oyun geliştiricileri uzun süredir benzer etkinlikler yapıyorlar(<a href="http://www.ludumdare.com/compo/">1</a>, <a href="http://globalgamejam.org/">2</a>, <a href="http://igda.dk/category/nordic-game-jam/">3</a>, ve pek çok başka yerel etkinlikler).</p>
<p>Bir keresinde bir <a href="http://osa1.net/finaldeyiz/">programlama yarışmasında</a> finale kalmıştım, bir de LudumDare tecrübem var. Bunlardan ikisini de saymıyorum çünkü birincisi aslında benim ilgi alanıma giren birşey değildi ve sırf challange olsun diye girmiştim, ikincisinde de aslında bir “toplanma” yok. Yani dünyanın her yerinden yarışıyorsunuz. Ben daha çok bir araya toplanılıp, daha kısa süre içerisinde(LD 48 saat sürüyor mesela), daha küçük birşeyler yapılıp günün sonunda dağılınan birşeyler hayal etmişimdir. İşin biraz da sosyalleşme ve kafa dengi insanlarla tanışma yönü olmasını istiyorum yani ben.</p>
<p>Mesela şöyle bir fikir var kafamda: Mainstream dillerle katılınamayan bir programlama etkinliği. Örneğin Java, Python, Ruby, JavaScript, C++, C# gibi dillerle katılamazsınız ama Lisp dilleri, Go, Rust, Erlang, Haskell, Smalltalk, Factor, Scala, F#, D vs. kabul. Amaç 10 saat gibi bir süre içerisinde <a href="http://0x10c.com/doc/dcpu-16.txt">DCPU-16</a> assembler/disassembler ve debuggerı yazmak.</p>
<p>Specification’a bakarsanız, ne kadar küçük olduğunu görebilirsiniz. 10 saat içerisinde gelmeden önce birkaç döküman okunup biraz aşina hale gelinmiş farklı bir dil ile yazılabilir. Bu sayede sadece, muhtemelen daha önce karşılaşılmamış bir konuda bazı problemleri çözmüş değil, aynı zamanda bu yeni dili de daha iyi öğrenmiş ve anlamış olur katılanlar.</p>
<p>Gerçi bu problemde birden fazla kişinin iş bölümü yapması pek mümkün olmayabilir(proje zaten yeterince küçük olacaktır), bu durumda da “pair programming” benzeri birşey yapılabilir. 2 kere, her biri birkaç gün süren pair programming tecrübem oldu. Birisinde klavyede hep ben vardım ve yanımdaki arkadaş programcı bile değildi ve ikisinde de çok eğlendiğimi söyleyebilirim(gerçi biraz yorucu oluyor).</p>
<p>Burada üretilen programların pratikte çok bir işe yaramayacak olması ve herhangi bir ödülün olmaması önemli. Bu katılımcıların öğrenme ve eğlenmeye odaklanmalarını sağlar ve sadece bu amaçla katılanları bir araya toplar diye düşünüyorum.</p>
<p>Olamayacak bir fikir mi, engeller neler olabilir, neler değiştirilebilir? İlgilenen varsa, yorum bölümüne birşeyler karalarsa sevinirim :) Belki hayata geçirebiliriz.</p>
<hr />
<p>DÜZENLEME: 2. bir fikir de, yine farklı dillerde, bir C kütüphanesinin <a href="http://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>ının yazılması olabilir. Hem çok zor bir işlem değil (10 saatte epey bir yol katedilir, kullanılır hale getirilebilir), hem de son bir haftamı yoğun bir şekilde FFI bindingleri/wrapperları yazarak geçiren biri olarak, FFI’ı anlamanın inanılmaz önemli ve faydalı bir şey olduğunu düşünüyorum. Burada FFI’ı yazılacak kütüphaneyi iyi belirlemek gerekir.</p>
<p>DÜZENLEME 2: 3 arkadaşımdan olumsuz cevap aldım bile. Bu yazıyı bu blogun en başarısız yazısı ilan ediyor ve ibret olsun diye burada bırakıyorum :P .</p>]]></summary>
</entry>
<entry>
    <title>Kompleks meseleleri anlatmak ve formal diller</title>
    <link href="http://osa1.net/posts/2012-08-28-formal-diller.html" />
    <id>http://osa1.net/posts/2012-08-28-formal-diller.html</id>
    <published>2012-08-28T00:00:00Z</published>
    <updated>2012-08-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün ortamlarda rastgele gezinirken şöyle bir metine denk geldim:</p>
<blockquote>
<p>From William Thurston: <a href="http://arxiv.org/pdf/math/9404236v1.pdf">On proof and progress in mathematics</a></p>
<p>When a significant theorem is proved, it often (but not always) happens that the solution can be communicated in a matter of minutes from one person to another within the subfield. The same proof would be communicated and generally understood in an hour talk to members of the subfield. It would be the subject of a 15- or 20-page paper, which could be read and understood in a few hours or perhaps days by members of the subfield.</p>
<p>Why is there such a big expansion from the informal discussion to the talk to the paper? One-on-one, people use wide channels of communication that go far beyond formal mathematical language. They use gestures, they draw pictures and diagrams, they make sound effects and use body language. Communication is more likely to be two-way, so that people can concentrate on what needs the most attention. With these channels of communication, they are in a much better position to convey what’s going on, not just in their logical and linguistic facilities, but in their other mental facilities as well.</p>
<p>In talks, people are more inhibited and more formal. Mathematical audiences are often not very good at asking the questions that are on most people’s minds, and speakers often have an unrealistic preset outline that inhibits them from addressing questions even when they are asked.</p>
<p>In papers, people are still more formal. Writers translate their ideas into symbols and logic, and readers try to translate back.</p>
</blockquote>
<p>Birkaç aydır neredeyse her gün akademik makaleler vb. okuyan ama hala formal anlatımları anlamayı inanılmaz zor bulan(ama yine de en azından sabırla uğraşıp, anlayabilen) biri olarak, bundan daha iyi bir özet görmemiştim.</p>
<p>Zaten birinin tahtaya çıkıp ders anlatmasına da bu yüzden ihtiyacımız yok mu? Kağıt üzerinde, hiçbir konuda farklı yorumlamaya fırsat bırakmayacak ve bir yandan da özlü bir şekilde meseleyi anlatabilecek formal bir dille öğrenmeye kalktığımıza, yeterli sabrı gösteremeyip, yeterli emeği veremeyiz. Sebebi de, yazıda bahsedildiği gibi, yazar tarafından formal bir dil ile ifade edilmiş meseleleri kendi anlayışımıza göre tercüme etmek zorunda olmamız.</p>
<p>Okul ortamı benim için biraz da bu yüzden moral bozucu aslında. Bir hafta boyunca bir makaleyi anlamaya çalışıp, anladıktan sonra sözlü olarak başka birine ne kadar kolay bir şekilde anlatılabileceğini farkettiğimde, “keşke biri bana anlatıyor olsaymış” diye düşünüyorum. Bir haftamı değil birkaç saatimi vermem yetebilirdi o zaman.</p>]]></summary>
</entry>
<entry>
    <title>call/cc [2]</title>
    <link href="http://osa1.net/posts/2012-08-09-callcc-2.html" />
    <id>http://osa1.net/posts/2012-08-09-callcc-2.html</id>
    <published>2012-08-09T00:00:00Z</published>
    <updated>2012-08-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Scheme çok ilginç bir dil. Çok küçük olmasına rağmen(R5RS 50 sayfa, R6RS 90 sayfa, aradaki fark büyük oranda kütüphanelerden kaynaklanıyor) programlama dilleri camiasından sürekli tartışma konusu, ve bir sonraki standard konusundaki tartışmalar neredeyse hiçbir zaman bitmiyor. Çok fazla tartışmalı özelliği var. Kendisine göre devasa boyutlardaki dillerde bile Scheme’inkiler kadar tartışılan özellikler yoktur büyük ihtimalle(gerçi bu biraz da Scheme camiasının çok sayıda programlama dili meraklısı içermesi ile alakalı olabilir).</p>
<p><code>call/cc</code> bu özelliklerden biri, hakkında buralarda birşeyler yazmıştım. <code>call/cc</code> benim gözümde, birazdan bahsedeceğim yazıdaki tabiriyle, “ultimate abstraction of control” idi. Kendi dilime de call/cc’yi programın kontrol akışı üzerinde değişiklikler gerektiren yapıları implement etmek için kullnacaktım.</p>
<p>Bugün internetteki favori sayfalarımdan <a href="http://okmij.org/ftp/">okmij</a>de <a href="http://okmij.org/ftp/continuations/against-callcc.html">“An argument against call/cc”</a> adlı yazıya denk geldim. Meraklısı olan varsa kaçırmasın.</p>
<p>call/cc’nin neden kötü bir soyutlama olduğunu 7 madde halinde incelemiş. Benim anladığım, tüm bu problemleri delimited continuationlarla çözebiliriz. Delimited continuationlara giriş için <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf">Introduction to Programming with Shift and Reset</a>e bakabilirsiniz. Ben epey anlaşılır buldum(OchaCaml’ı yükleyip denemedim gerçi, içinde yama uygulamayı da içeren birkaç maddelik kurulum komutu var, şaka gibi). Bir maddede <code>dynamic-wind</code>den bahsetmiş. <code>dynamic-wind</code> ile ilk kez bu yazıda karşılaştım, ve anladığım kadarıyla delimited continuationlar buna olan ihtiyacı ortadan kaldırmıyor. Sonuçta örneğin bir dosyaya erişim yapıldığı durumda, continuation dosyanın referansını içerecektir ve daha sonradan bu continuation kullnıldığında, delimited olsa da olmasa da, aynı kaynakların alınıp(dosyanın açılması, sunucuya bağlanılması vs.), işlem sonrasında kapatılması gerekir.</p>
<p>Static bir tip sistemi ve lexical scope ile call/cc implementasyonu benim için zaten yeterince zor bir problem. Belki de tamamen kaldırıp, Lua usulü biraz daha genelleştirilmiş generatorlar<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>ile yola devam etmeliyim.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://dl.acm.org/citation.cfm?id=1462167&amp;CFID=125136476&amp;CFTOKEN=41020401">Revisiting coroutines</a><a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Bir dönemin daha sonu</title>
    <link href="http://osa1.net/posts/2012-08-05-bir-donemin-daha-sonu.html" />
    <id>http://osa1.net/posts/2012-08-05-bir-donemin-daha-sonu.html</id>
    <published>2012-08-05T00:00:00Z</published>
    <updated>2012-08-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün son finalimden çıktım, bir dönem daha bitmiş oldu. Nasıl inanılmaz derecede saçma ve sıkıcı bir dönem olduğundan bahsetmeyeceğim. Okulda dönemler geçtikçe işlerin daha iyiye gidiyor olması gerekirken, daha kötüye gidiyor olması epey ilginç.</p>
<p>4 haftalık çok değerli(!) tatilim için bir yapılacak listesi hazırladım. Aslında yaz dönemleri, ne kadar önemli işim olursa olsun, zaten tatil dönemi gibi geçiyor benim için. Dolayısıyla dinlenmek için ayrıca bir vakit ayırmama gerek yok. Bir de Ramazan’la birleşince, destansı uyuyuşlar, vakit geçirmek için yazılan programlar vs. epey dinlendirici oluyor hahah.</p>
<p>Buna göre <code>TODO</code> dosyamın içeriği şöyle:</p>
<ul>
<li>Oku: Types and Programming Languages. İlk yarısını final haftası falan tanımadan okudum. Bazı önemli kısımları atladım(bazı teoremler ve ispatlar, alıştırmalar). Diyebilirim ki SICP’den sonra okuduğum en iyi kitap. Konusu epey farklı tabii (tip sistemleri).</li>
<li>Oku: <a href="www.cs.cmu.edu/~rwh/papers/callcc/jfp.ps">Typing First-Class Continuations in ML</a>: Kendi dilimde önce first-class continuationları implement edip, sonra tip sistemi yazmaya çalışınca böyle bir problemle karşılaştım tabii.</li>
<li>Bir daha oku: <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.120.5931">Basic Polymorphic Typechecking</a>. Bu sefer çok daha fazla şey anlayacağımı umuyorum :P .</li>
<li>Oku: <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.138.5038">Uniprocessor Garbage Collection Techniques</a>.</li>
<li>Yaz: Kafamda bir oyun fikri var. 19 gün sonraki LD24’de başlamayı planlıyorum. Lua ile yazacağım.</li>
<li>Yaz: OCaml’a derlenen bir dil var kafamda.</li>
<li>Yaz: “Tosbağa” adlı yarım bıraktığım bir yorumlayıcı(veya aslında daha çok sanal makinaya yakın) var, Haskell ile yazıyorum. Turtle graphics. Hiçbir esprisi yok. Basit komutlar hazırlamış, onlarla fonksiyonlar vs. implement etmeye çalışıyordum en son bıraktığımda.</li>
<li>İncele: <a href="http://klisp.org/">klisp</a>, bir Kernel Lisp implementasyonu. First class macrolar, continuationlar ve fexprlar var. Karşılaştığım bazı problemleri çözmüşler.</li>
<li>Oyna: Metal Gear Solid 4: Guns of the Patriots. İlk 3 oyun gözümde efsanedir. Şu anda bunun için önümdeki en büyük engel, oyunu alabilmek :P .</li>
<li>Oyna: Jade Empire. Bioware’ın iyi dönemlerinden kalan son oyunlardan. Oynayamamıştım.</li>
<li>Araştır: Derleyici detaylarını öğrenmek için kaynak ve hedef diller. Kaynak dili kendim oluşturabilirim aslında, problemleri bir bir yerden okumak yerine, onlarla karşılaşmak daha heyecanlı oluyor hehe. Hem okumak genel olarak çok daha sıkıcı. Hedef dil bir assembly dili(MIPS uygun mudur? çalıştırmak için emulator kullanak zorunda kalacak olmam kötü) veya en azından byte-code (Java, Lua) olmalı.</li>
<li>Arkadaşlarla tatile git. Böyle bir plan yapmıştık, 3-4 günlük birşey. Ben zaten son 15 gündür yeterince yattığımdan gitmek için pek bir istek yok içimde, fakat bir yandan da gitmem gerektiğini biliyorum.</li>
<li>Blogu güncelle. Komple statik sayfalara geçireceğim. Octopress’i inceledim, epey rahat gözüküyor ve hazır temalar da var. Benim için uygun gibi. Problem, yazılarımı markdown formatında saklıyorum ama syntax olarak biraz farklı(kod kısımları özellikle). Bunları düzeltecek bir program yazmam gerekecek(Python bilgime başvurabilirim, epeydir yazmamıştım, regexleri de güzeldir :P ).</li>
</ul>
<p>4 hafta için biraz uzun oldu sanırım, artık ne kadar olursa.</p>
<h2 id="bundan-sonrası">Bundan sonrası</h2>
<p>Bundan sonrası hakkında kafam epey karışık. İnsan üstü bir çaba gösterip(kendime göre), ikinci bir yabancı dil öğrenemezsem, mezun olamıyorum. Ve bu çabayı ikinci bir yabancı dil öğrenmek için göstereceğime, örneğin derleyici yazmak için göstersem, zaten mezun olmama gerek kalmaz. Bunun yanında ikinci yabancı dil öğrenmenin bana sağlayacağı herhangi bir fayda yok. Saçma bir yatırım yani. Dolayısıyla mezun olmak istiyorsam, ikinci yabancı dil dersini vermeden mezun olmanın bir yolunu bulmam gerek.</p>
<p>Şu anda iki sonraki dönemden itibaren bir şekilde okul ile alakalı işlerde minimum miktarda vakit harcayıp, her ne ile ilgileneceksem uğraşmaya başlamam lazım(önümde çok güzel bir staj imkanı var, bir dönem sonra, 14 hafta sürecek). Mezun olmama yaklaşık 1.5 sene var, vakit sıkıntım yok gibi yani. Bu 1.5 senede de toplamda 28 hafta staj yapacağım, çok faydalı olabilir(dediğim gibi çok güzel bir staj ayarladım zaten ilk 14 hafta için, iki taraf da memnun kalırsa, diğer stajımı da aynı yerde yapabilirim, okul açısından bir engel yok).</p>
<p>Sonuçta bu okuldan mezun olmak bana sembolik bir diplomadan başka hiçbir şey sağlamayacak ve karşılığında göstermem gereken çabaya değeceğini düşünmüyorum.</p>
<p>Diğer yandan, Türkiye’de Haskell ile, veya derleyiciler ve programlama dilleri üzerine çalışan yerler olmadığından, yurt dışına çıkmanın bir yolunu bulamazsam, Türkiye’de Java yazmak zorunda kalacağım kesin gibi. Neyse ki bir aydan daha uzak bir geleceği kafama takmama gibi garip bir adetim var. Mezun olmama 1 ay kala düşünürüm :P .</p>]]></summary>
</entry>
<entry>
    <title>Arc ve Lisp hakkında</title>
    <link href="http://osa1.net/posts/2012-06-27-arc-ve-lisp-hakkinda.html" />
    <id>http://osa1.net/posts/2012-06-27-arc-ve-lisp-hakkinda.html</id>
    <published>2012-06-27T00:00:00Z</published>
    <updated>2012-06-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Paul Graham’ın Arc dilinin tasarımı ve genel olarak Lisp hakkındaki yazıları o kadar müthiş ki, burada okuduklarımın linklerini paylaşacağım.</p>
<ul>
<li><p><a href="http://www.paulgraham.com/ilc03.html">Some Work on Arc (2009)</a>. Bunu okumayan kalmasın, bir programlama dilinde beni en çok heyecanlandıran fikirleri ve şimdiye kadar gördüğüm en güzel Lisp tanımını içeriyor. Normalde sadece bu yazı hakkında uzun bir yazı hazırlamıştım, ama sonra neredeyse tüm yazıyı alıntıladığımı farkedip bu formata döndüm.</p></li>
<li><p><a href="http://paulgraham.com/arcll1.html">Arc: An Unfinished Dialect of Lisp (2001)</a>: Arc dilinin tasarımı hakkında alınmış kararların nedenlerinden ve nasıllarından bahsediliyor. Bu yazıda bahsedilen isimsiz fonksiyon syntaxının ve veri yapılarının indexler üzerine fonksiyonlar olmasının şu anda Clojure tarafından kullanıldığını farkedebilirsiniz.</p></li>
<li><p><a href="http://paulgraham.com/syntaxquestion.html">Steele and Gabriel: The Syntax Question</a>: Neden Lisp’ler Algol tarzı syntaxa sahip değiller? Neden Algor tarzı syntax için uygun değiller?</p></li>
<li><p><a href="http://www.paulgraham.com/vanlfsp.html">Michael Vanier: LFM and LFSP</a>: Programlama dillerinin hitap ettiği kitleler ve dilin güçleri, tasarım kararları ile alakalı.</p></li>
</ul>
<p>Bir de meraklısı varsa Arc dilinin <a href="http://arclanguage.org/">sayfası</a>. <em>Core</em> diye bahsedilen çekirdek kısım 1500 satır Scheme kodundan ibaret. Dil Scheme’e derleniyor. Şimdi düşünüyorum da, bir Lisp dili yazıyor olsaydım(aslında yazıyorum zaten, daha ciddi olsaydım diyecektim) ben de Scheme’e derlerdim. Mesela <a href="http://www.iro.umontreal.ca/~gambit/">Gambit</a>e derleyebilmek, Racket’a derlemek kadar kolay olmaz ama süper olurdu.</p>
<p>Paul Graham’ın yukarıdaki yazılarda bahsettiği, dillerin implementasyonları konusundaki fikirlerden bazılarını <a href="http://www.shenlanguage.org/">Shen</a>de görebilmek mümkün. Shen, <em>K Lambda</em> adı verilen 46 fonksiyon içeren bir dil üzerine inşa edildi ve şimdiden 3 farklı platformda(Common Lisp, Clojure, JavaScript) çalışıyor.</p>]]></summary>
</entry>
<entry>
    <title>call/cc</title>
    <link href="http://osa1.net/posts/2012-06-23-callcc.html" />
    <id>http://osa1.net/posts/2012-06-23-callcc.html</id>
    <published>2012-06-23T00:00:00Z</published>
    <updated>2012-06-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Son zamanlarda uğraştığım konulardan biri hakkında birşeyler karalayacağım. Genelde zor bir konspetle karşılaştığımda anladığımı anlamak için 2 şey yapıyorum, 1) programlıyorum, 2) anlatıyorum. Uğraştığım işlerle ilgilenen kimse olmadığından, anlatabiliyor olmamı bu blog sağlıyor. Bu sefer Scheme’in call/cc fonksiyonundan bahsedeceğim, epey ilginç bir iş yaptığını düşünüyorum.</p>
<p><code>call/cc</code>de benim ilgimi çeken şey, Scheme’i bir yorumlayıcı ortamı olarak düşündüğümüzde, yorumlayacağımız dile exceptionlar, coroutineler gibi kontrol akışınıda değişiklikler yapması gereken yapıları kolayca ekleyebilmemizi sağlaması.</p>
<p>Continuation-passing style’a aşina olduğunuzu varsayıyorum. Aşina olmayanlar Google’dan kolaylıkla süper kaynaklar edinebilir. JavaScript gibi yaygın bir dilin CPS kullanabilmek için gereken fonksiyonelliği sağlıyor olması çok büyük şans, yoksa CPSı anlamak için Scheme kodu okumak zorunda kalabilirdiniz :P . Ben implementasyonu Common Lisp ile vereceğim.</p>
<p><code>call-with-current-continuation</code> veya kısaca <code>call/cc</code>nin genel olarak iki farklı implementasyon yöntemi var<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> biri stack kopyalama işlemi, diğeri <em>CPS conversion</em> dediğimiz, benim birazdan anlatım Common Lisp ile yazacağım yöntem.</p>
<p>Tüm programlarımızın üstü kapalı bir şekilde(<em>implicit</em>) CPS yazıldığını düşünelim. Yani tüm fonksiyon çağrıları aslında bir değer dönmek yerine, bu döneceği değer ile continuation’ı çağırmalı<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> Bunu sağlamak için tüm fonksiyonlar ilk parametre olarak continuation alabilir ve diğer parametreleri fonksiyon tanımı sırasında verilen parametreler olur. Daha sonra fonksiyon döneceği değer ile ilk parametresini, yani continuation’ı çağırır. Bu fonksiyonları bir macro ile kolayca oluşturabiliriz<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defmacro</span><span class="fu"> defcont </span>(name (&amp;<span class="kw">rest</span> params) &amp;body body)
  (<span class="kw">let</span> ((result (<span class="kw">gensym</span>)))
    `(<span class="kw">defun</span><span class="fu"> </span>,name (continuation ,@params)
       (<span class="kw">let</span> ((,result ,@body))
         (<span class="kw">funcall</span> continuation ,result)))))</code></pre>
<p>Bu macronun syntaxı <code>defun</code>un tamamen aynısı, sadece ekstradan ilk parametre olarak continuation alıyor ve dönüş değeriyle aslında continuation’ı çağırıyor. Bu şekilde yazılan fonksiyonlar <em>CPS conversion</em> a maruz kalıyor yani.</p>
<p>Örnek olarak bu şekilde basit bir toplama ve çarpma fonksiyonları oluşturalım:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(defcont multiply (&amp;<span class="kw">rest</span> args)
  (<span class="kw">apply</span> #&#39;* args))
(defcont add (&amp;<span class="kw">rest</span> args)
  (<span class="kw">apply</span> #&#39;+ args))</code></pre>
<p>Burda fonksiyonların içinde CPS formatında olmayan, dilin kendi fonksiyonlarını çağırıyoruz ama bu sorun değil.</p>
<p>Bu durumda normalde <code>(* 3 (+ 1 2))</code> şeklinde yazacağımız fonksiyonu şu şekilde yazmamız gerekiyor: <code>(add (lambda (r) (multiply #'identity r 3)) 1 2)</code>. İşte bu dönüşümü yapmaya <code>CPS conversion</code> diyoruz. Ne yaptığına bakalım, çarpma işleminin sonucu <code>(+ 1 2)</code> çağrısının dönüş değerine bağlı, buna göre ilk başta toplama işlemi yapılıp, sonucu çarpma işlemine aktarılmalı. Çarpma işlemi de toplama işleminin sonucunu alıp, 3 ile çarptıktan sonra bir continuation’a aktarmalı. Burda bu son continuation olarak <code>identity</code> fonksiyonunu seçtim ki sonucu elde edebilelim. Normalde, eğer örneğin sonucu yazdırmak istiyorsak, orata <code>prin1</code> gibi bir fonksiyon göndermemiz gerekir.</p>
<p>Bu şekilde yazılan programların nasıl çalıştığına bakarsanız, aslında fonksiyon çağrıları için stack modeline ne kadar benzediğini farkedersiniz. Stack modelinde, çarpma fonksiyonu çağırıldığında stack’de fonksiyon çağrısı hakkında gerekli verileri tutan bir kayıt oluşturulacak, daha sonra toplama işlemi çağırıldığında bunun üzerine bir kayıt daha eklenecek, ve fonksiyon çağrıları bittikçe bu kayıtlar stackten toplanarak bir alt seviyeye dönüş değerlerini bir şekilde aktaracak.</p>
<p>CPS’de tamamen aynı, toplama işlemi önce bitecek ve çarpma işlemine dönüş değerini aktaracak. Bunun için çarpma fonksiyonunu ilk parametresi olarak alacak, çarpma fonksiyonu da kendi sonucunu hangi fonksiyona aktaracaksa o fonksiyonu ilk parametre olarak alacak gibi.</p>
<p>Buraya kadar herşey anlaşıldıysa, <code>call/cc</code>yi yazmak çok kolay. <code>call/cc</code>nin yaptığı, o anki continuation’ı açık bir şekilde kullanıcıya vermek. Normalde yukarıda bahsettiğim tüm olaylar derlenme aşamasında <em>CPS conversion</em> veya başka yöntemlerle hallediliyor ve kullanıcı aslında fonksiyonlarını bizim örneğimizdeki gibi yazmıyor. Dolayısıyla fonksiyonuna aktarılan continuation’a erişme şansı yok. Fakat <code>call/cc</code> hariç, <code>call/cc</code> tam olarak bu işi yapıyor, o anki continuation’a erişim izni veriyor. Şu şekilde:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> call/cc </span>(continuation fun)
  (<span class="kw">funcall</span> fun continuation))</code></pre>
<p>Bu fonksiyonun <code>defcont</code> ile tanımlandmadığına dikkat. Bu şu anlama geliyor, programlama dili böyle bir fonksiyon sunmuyorsa, bu fonksiyonun yazılması imkansız. Kullanıcının tek sahip olduğunun <code>defcont</code> olduğunu düşünün, yani tüm fonksiyonları <em>CPS conversion</em>a mağruz kalıyor, ve fonksiyon çağrıları otomatik olarak CPS’e dönüştürülüyor. Programcı yazdığı fonksiyonlara continuation’ın nasıl aktarıldığını bilmiyor veya bilse bile buna erişmesinin hiçbir yolu yok.</p>
<p><code>call/cc</code>, kendi aldığı continuation’ı <code>fun</code> parametresi olarka aldığı fonksiyona aktarıyor, ve daha sonra <code>fun</code> fonksiyonu o continuation ile her türlü çılgınlık yapabilir, örneğin bu continuation’ı bir yere kaydedip, bir daha bir daha çağırmak gibi. Bu continuation, dönüş değerinin aktarılacağı fonksiyonu tutuyor aslında.</p>
<p>Hemen basit birkaç örnek yapalım. Şu iki fonksiyon arasındaki fark ne?</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) (<span class="kw">funcall</span> cont <span class="dv">11</span>)))
(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) <span class="dv">11</span>))</code></pre>
<p>İlk çağrıda continuation’a 11 değerini gönderiyoruz ve sonuç beklenen gibi 21 oluyor, ikinci durumda ise continuation’ı yok sayıp 11 değerini dönüyoruz ve cevap 11 oluyor. Stack modelinde düşünürsek, ikinci örnekte yapılan şey, stackdeki bazı fonksiyon kayıtlarının atlanması aslında. Buna sanırım <code>stack unwinding</code> deniyor(emin değilim). Bu şekilde dil seviyesinde exception mekanizmaları yazılabilir, continuationlar kaydedilerek ve sırayla çağırılarak coroutineler<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup>veya <em>lightweight thread</em>ler elde edilebilir(<em>green thread</em> de diyorlar sanırım).</p>
<p>Scheme bilenler için bu kodun Scheme karşılıkları şu:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="kw">+</span> <span class="dv">10</span> <span class="dv">11</span>)))
(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="kw">+</span> <span class="dv">10</span> (cont <span class="dv">11</span>))))</code></pre>
<p>Aralarındaki fark, Scheme kodu <em>CPS conversion</em>a mağruz kalmamış, Common Lisp kodu ise kalmış hali.</p>
<p>Bu aşamada yapılabilecek çok fazla fantastik iş var ve çoğu durumda neler olup bittiğini anlama çok güç. Zaten bu yüzden <code>GOTO</code>larla karşılaştırılıyorlar bazen. Benim hoşuma giden bir kullanımını şu:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defvar</span><span class="fu"> creturn </span><span class="kw">nil</span>)
(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> <span class="dv">1</span> r))
         (<span class="kw">lambda</span> (cont)
           (<span class="kw">setf</span> creturn cont)
           <span class="dv">1</span>))</code></pre>
<p>Continuation’ı bir değişkene kaydediyorum ve daha sonra istediğim zaman o continuation’ı çağırıp işlemi kaldığı yerden devam ettiriyorum.</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">15</span>)
<span class="dv">16</span>
CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">20</span>)
<span class="dv">21</span></code></pre>
<p>Kısaca, işlemi istediğim bir yerden durdurdum ve kopyaladım. Daha sonra durdurduğum andan itibaren istediğim bir değer ile devam ettiriyorum. Müthiş bir olay. Bu gösterdiğim örnekler en basit ve sıradan örnekler, neler yapılabileceği hakkında çok fazla güzel kaynak var, açıkçası ben çoğunun ne yaptığını anlamakta güçlük çekiyorum, bazı patternlara aşina olmak gerekiyor. <code>call/cc</code>nin Scheme’den kaldırılması da <a href="http://lists.scheme-reports.org/pipermail/scheme-reports/2012-February/001824.html">şu ortamda</a> epey tartışılmış.</p>
<p>Çok bilinen iki implementasyon yöntemi demiştim, diğer yöntem de stack kopyalama. Bu örneği düşünelim, <code>call/cc</code> aslında stack’in o anki durumunu aktarıyor aslında. Burda yapılan işlem büyük ihtimalle en baştan beri tüm stackin kopyalanması değil. <a href="http://en.wikipedia.org/wiki/Spaghetti_stack">Sphagetti stack</a> gibi bir yapı kullanılıyor olabilir.</p>
<p>Bu arada, coroutine demişken, implementasyon detaylarını merak eden varsa: <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;ved=0CHgQFjAF&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.104.1441%26rep%3Drep1%26type%3Dpdf&amp;ei=PAXmT8TBEaeB4ASj-5ygAQ&amp;usg=AFQjCNENWM4b5ib96CKcno8KgEeJk4KQ6g">Coroutines in Lua</a>. Lua’yı seviyoruz.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Aslında, birkaç tane çok bilinen(yazılmış) implementasyonu var ve dahası da gereksinimlere/şartlara göre uydurulabilir. Detayları merak eden varsa: <a href="http://www.cs.indiana.edu/~dyb/papers/3imp.pdf">Three Implementation Models for Scheme</a>. Ve büyük ihtimalle şu kitapta da bahsediliyordur: <a href="ref=sr_1_1?ie=UTF8&amp;qid=1340471949&amp;sr=8-1&amp;keywords=lisp+in+small+pieces">Lisp in Small Pieces</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Bu durumda, <em>sanırım</em>, teorik olarak stack denen yapıya ihtiyaç kalmıyor.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Bu macroda bir sorun var fakat konumuzun dışında olduğundan, işleri karıştırmamak için önemsemedim: <code>continuation</code> parametresi <a href="http://www.bookshelf.jp/texi/onlisp/onlisp_10.html#SEC67"><em>variable capture</em></a>a maruz kalabilir. <code>gensym</code> ile parametre adı oluşturulması gerekir.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Şu anda coroutineleri implement etmek için sanırım zaten stackin bir kopyasını çıkarmak zorundasınız.<a href="#fnref4">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Gramerlerde bağlam bağımsızlık ve indentation-based gramerlerin çözümlenmesi</title>
    <link href="http://osa1.net/posts/2012-06-12-gramerlerde-baglam-bagmszlk-ve-indentation-based-gramerlerin-cozumlenmesi.html" />
    <id>http://osa1.net/posts/2012-06-12-gramerlerde-baglam-bagmszlk-ve-indentation-based-gramerlerin-cozumlenmesi.html</id>
    <published>2012-06-12T00:00:00Z</published>
    <updated>2012-06-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Yazıda terimleri Türkçe kullanmaya çalıştım, bağlam bağımsız = context-free, çözümleme = parsing, indentation-based ve lexing/lexer için güzel bir Türkçe karşılık bulamadım, önerilere açığım.)</p>
<p>Indentation-based gramerlerin çözümlenmesi her zamankinden biraz daha zor. Sebebi bunların aslında bağlam bağımsız(bu kelime grubu bana çok anlamsız geliyor, context-free yani) olmaması. Birazdan bunun ne anlama geldiğinden bahsedeceğim. <code>lex</code> programının Haskell karşılığı olan Alex için kod örnekleri vereceğim. Şu anda elimde çalışan bir derleyici olsa da, kaynak kodunu açmam için epey bir vakit var sanırım.</p>
<p>Çoğu ayrıştırıcı kütüphane/programlar aslında bağlam bağımsız gramerlerin bazı alt kümelerini ayrıştırabiliyor(yeterince esnek olanlarıyla bağlam bağımsız olmayan bazı örnekleri de çözümleyebiliyorsunuz, örneğin çözümleme aşamasında bazı durum değişkenleri tutarak). Örneğin aşağıdan yukarı(bottom-up) veya yukarıdan aşağı(top-down) bir yol izlemelerine göre, LL(n), LR(n), LALR, SLR, PEG(packrat çözümleyiciler) gibi. Genel olarak tüm bağlam bağımsız gramerleri(BNF şeklinde gösterilebildikleri sürece, ve tüm bağlam bağımsız gramerler BNF formunda gösterilebiliyorlar) çözümleyebilen algoritmalar olsa da(örneğin CYK, Unger algoritmaları), bu yöntemler zaman ve bazen bellek kullanımı açısından verimsiz olduklarındaın ve aslında programlama dilleri gramerlerinde çoğu zaman bağlam bağımsız gramerlerin bazı özelliklere sahip olabilen alt kümelerini kullandığımızdan, çözümleyiciler de bağlam-bağımsız gramerlerin çeşitli alt kümeleri üzerinde çalışıyorlar.</p>
<p>Bir dilin bağlam bağımsız olduğunu bağlam bağımsız bir gramerle ifade edilip edilemeyeceğinden anlıyoruz. Bağlam bağımsız gramerde şu anlama geliyor: tüm dönüşümler, <code>A</code> bir değişken ve <code>a</code> değişkenler ve terminaller dizisi olmak üzere, <code>A -&gt; a</code> şeklinde olmalı. Dönüşümün sol tarafında sadece bir değişken oluyor yani. Bu aslında şu anlama geliyor: <code>A</code> gördüğümüz her yerde, herhangi bir başka duruma(yani <em>context</em>e) bakmaksızın dönüşümü yapabiliyorz. Bağlam bağımlı olma durumda ise örneğin şöyle oluyor: <code>xAb -&gt; xab</code>. Burda <code>A</code>yı dönüştürebilmek için, etrafını da kontrol etmemiz, yani durum/içerikten haberdar olmamız gerekiyor.</p>
<p>Peki indentation-based gramerlerle ne alakası var? Bu tip gramerleri kullanan bir dil düşünelim, Python veya YAML mesela. Bu dillerde bir blokun bittiğini anlamamız için, önceki satır hakkında bilgi sahibi olmamız gerekiyor. Örneğin bir önceki satırın kaç birim girintilenmiş olduğunu bilmemiz lazım. Eğer şu anda incelemdiğimiz satır ondan çok girintilenmişse, yeni bir blok başlangıcı, az girintilenmişse bir veya birde fazla blok bitişi anlamına geliyor.</p>
<p>Bu da indentation-based gramerleri <em>bağlam bağımlı</em> yapıyor. Yani şu anda kullanılan neredeyse hiçbir çözümleyici kütüphane/programla bunu ayrıştıramazsınız<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Çoğu zaten tüm bağlam bağımsız gramerleri bile çözümleyemiyor.</p>
<p>İşin sırrı lexing aşamasında, satır satır girintilemeleri takip edip, satır başlarında ne kadar değişiklik olduğuna göre gerekli <code>indent</code> ve <code>dedent</code> tokenlarını oluşturmak. Çözümleme aşamasında yapamayıp, daha güçsüz olmasına rağmen(bkz. düzenli diller, DFA) lexing aşamasında bunu yapabilmemizin sebebi şu, çözümleme aşaması daha kompleks olduğundan, kütüphaneler kullanıcıya daha az imkan veriyor. Çoğunda BNF formuna yakın bir formda(dilin izin verdiği ölçüde, veya kimisi farklı bir formattan programlama diline derleme yapıyor, mesela Bison, ANTLR, bu yazıda bahsettiğim Happy) ifade edilmiş bağlam bağımlı gramerlerden direkt olarak parse tree oluşturuyor ve bu sürece çok fazla müdahele edemiyoruz. Lexing aşamasında bunu çözdüğümüzde çözümleme aşamasına bağlam bağımsız bir gramer ile çözümleyebileceğimiz bir dil sunmuş oluyoruz.</p>
<p>Algoritma şu: Tamamen boşluk karakterlerinden oluşmayan her satır için, eğer bir önceki satırdaki girintileme daha azsa, bir tane <em>indent</em> tokenı oluştur, eğer daha azsa, ne kadar daha az olduğuna göre, bir veya birkaç tane <em>dedent</em> tokenı oluştur. Bu tokenlar aslında <code>{</code> ve <code>}</code> kullanan dillerdeki bu karakterlerle tamamen aynı anlama geliyor yani(veya Pascal tarzı syntax kullanılıyorsa, <em>begin/do</em> ve <em>end</em> kelimeleri).</p>
<p>Alex’de bu işi şöyle yapıyorum(kodun sadece alakalı kısımlarını koyuyorum):</p>
<pre><code>...
$whitespace = [\ \t\b]
...
\n $whitespace* \n { skip }
\n $whitespace*    { setIndent }
$whitespace+       { skip }
...</code></pre>
<p>İkinci satır tamamen boşluklardan oluşan satırı hiç hesaba katmıyor. Üçüncü satır eğer satırda boşluklardan başka karakter varsa, girintilemeyi hesap ediyor ve gerekli işlemleri yapıyor(birazdan geleceğiz). 3. satır da satır içindeki normal boşluk karakterleri.</p>
<p>Bir önceki satırın girintileme sayısını tutmak istediğimizden, wrapper olarak <code>monadUserState</code> kullanmamız gerekiyor. Bu durumda Alex bir veri tipi ve veri tipi için bir başlangıç durumu istiyor:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AlexUserState</span> <span class="fu">=</span> <span class="dt">AlexUserState</span> {<span class="ot"> indent ::</span> <span class="dt">Int</span> }
<span class="ot">alexInitUserState ::</span> <span class="dt">AlexUserState</span>
alexInitUserState <span class="fu">=</span> <span class="dt">AlexUserState</span> <span class="dv">0</span></code></pre>
<p>Artık burda başka ne gibi durumlara ihtiyacınız varsa eklersiniz. Bu durum(state) üzerinde çalışmak için 2 tane yardımcı fonksiyon tanımlayacağım:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getLexerIndentLevel ::</span> <span class="dt">Alex</span> <span class="dt">Int</span>
getLexerIndentLevel <span class="fu">=</span> <span class="dt">Alex</span> <span class="fu">$</span> \s<span class="fu">@</span><span class="dt">AlexState</span>{alex_ust<span class="fu">=</span>ust} <span class="ot">-&gt;</span> <span class="kw">Right</span> (s, indent ust)
<span class="ot">setLexerIndentLevel ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Alex</span> ()
setLexerIndentLevel i <span class="fu">=</span> <span class="dt">Alex</span> <span class="fu">$</span> \s<span class="fu">@</span><span class="dt">AlexState</span>{alex_ust<span class="fu">=</span>ust} <span class="ot">-&gt;</span> <span class="kw">Right</span> (s{alex_ust<span class="fu">=</span>(<span class="dt">AlexUserState</span> i)}, ())</code></pre>
<p>Ne yaptıkları sanırım barizdir. Bu aşamadan sonra asıl işi <code>setIndent</code> fonksiyonu yapıyor. Bu fonksiyon İlk verdiğim kod parçasındaki regex ne zaman bir eşleşse, eşlesen karakter dizisi ile çağırılacak:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">...</span>
<span class="kw">data</span> <span class="dt">LexemeClass</span>
    <span class="fu">...</span>
    <span class="fu">|</span> <span class="dt">LTIndent</span> <span class="dt">Int</span>
    <span class="fu">|</span> <span class="dt">LTDedent</span> <span class="dt">Int</span>
    <span class="fu">|</span> <span class="dt">LIndent</span>
    <span class="fu">|</span> <span class="dt">LDedent</span>
    <span class="fu">...</span>
    <span class="kw">deriving</span> (<span class="kw">Show</span>, <span class="kw">Eq</span>)
<span class="fu">...</span>
<span class="ot">setIndent ::</span> <span class="dt">AlexInput</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Alex</span> <span class="dt">Lexeme</span>
setIndent input<span class="fu">@</span>(p, _, _, str) i <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">--let !x = unsafePerformIO $ putStrLn str</span>
    lastIndent <span class="ot">&lt;-</span> getLexerIndentLevel
    currIndent <span class="ot">&lt;-</span> countIndent (<span class="fu">drop</span> <span class="dv">1</span> str) <span class="dv">0</span> <span class="co">-- first char is always \n</span>
    <span class="kw">if</span> (lastIndent <span class="fu">&lt;</span> currIndent) <span class="kw">then</span>
        <span class="kw">do</span> setLexerIndentLevel currIndent
           mkL (<span class="dt">LTIndent</span> (currIndent <span class="fu">-</span> lastIndent)) input i
    <span class="kw">else</span> <span class="kw">if</span> (lastIndent <span class="fu">&gt;</span> currIndent) <span class="kw">then</span>
        <span class="kw">do</span> setLexerIndentLevel currIndent
           mkL (<span class="dt">LTDedent</span> (lastIndent <span class="fu">-</span> currIndent)) input i
    <span class="kw">else</span> alexMonadScan
  <span class="kw">where</span>
    countIndent str total
        <span class="fu">|</span> <span class="fu">take</span> <span class="dv">1</span> str <span class="fu">==</span> <span class="st">&quot;\t&quot;</span> <span class="fu">=</span> <span class="kw">do</span> skip input <span class="dv">1</span>
                                  countIndent (<span class="fu">drop</span> <span class="dv">1</span> str) (total<span class="fu">+</span><span class="dv">1</span>)
        <span class="fu">|</span> <span class="fu">take</span> <span class="dv">4</span> str <span class="fu">==</span> <span class="st">&quot;    &quot;</span> <span class="fu">=</span> <span class="kw">do</span> skip input <span class="dv">4</span>
                                    countIndent (<span class="fu">drop</span> <span class="dv">4</span> str) (total<span class="fu">+</span><span class="dv">1</span>)
        <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="fu">return</span> total</code></pre>
<p>Burda bir problem, aslında bir eşleşmede birden fazla token oluşturamadığımızdan(Alex’in bir kısıtlaması, belki de bir yolu vardır ama ben bulamamışımdır), ben <code>LTDedent</code> adlı bir lexeme oluşturuyorum, burdaki <code>T</code> temporary, yani geçici anlamına geliyor. Çünkü daha sonra token listesinden bu elemanları silip başka tokenlar ekleyeceğim. Bu tokenların her biri ne kadar <em>indent</em> veya <em>dedent</em> olduğunu tutuyor. Yani örneğin bir önceki satıra göre 2 birim dışarı çıkmışsa, <code>LTIndent 2</code> ile bir <code>LexemeClass</code> oluşturuyorum. Daha sonra bunu 2 ayrı <code>LIndent</code>e dönüştürmeliyim ki, dilimin <code>{</code> ve <code>}</code> gibi karakterler kullanan dillerden hiçbir farkı kalmasın(bu arada şimdi farkettim, <code>LTIndent</code> diye bir sınıfa ihtiyacım yok, çünkü zaten bir önceki satırdan daha fazla girintilenmişse kesin olarak bir yeni blok oluşmuştur, bir ara düzeltirim artık :).</p>
<p><code>runAlex</code> fonksiyonu yardımıyla <code>Lexeme</code> listesini elde ettikten sonra şu şekilde bu tokenları ayrı ayrı girintileme tokenları ile değiştiriyorum(kod tekrarı için kusura bakmayın :P )</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addIndentations ::</span> [<span class="dt">Lexeme</span>] <span class="ot">-&gt;</span> [<span class="dt">Lexeme</span>]
<span class="co">-- ML style pattern matching for patterns with same cases or maybe view patterns</span>
<span class="co">-- could be useful here</span>
addIndentations (lex<span class="fu">@</span>(<span class="dt">Lexeme</span> pos (<span class="dt">LTIndent</span> c) _)<span class="fu">:</span>ls) <span class="fu">=</span>
    <span class="fu">concat</span> [iter <span class="fu">lex</span> c, addIndentations ls]
  <span class="kw">where</span> iter <span class="fu">lex</span> c <span class="fu">=</span> <span class="kw">if</span> c <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> []
                     <span class="kw">else</span> (<span class="dt">Lexeme</span> pos <span class="dt">LIndent</span> <span class="kw">Nothing</span>)<span class="fu">:</span>(iter <span class="fu">lex</span> (c<span class="fu">-</span><span class="dv">1</span>))
addIndentations (lex<span class="fu">@</span>(<span class="dt">Lexeme</span> pos (<span class="dt">LTDedent</span> c) _)<span class="fu">:</span>ls) <span class="fu">=</span>
    <span class="fu">concat</span> [iter <span class="fu">lex</span> c, addIndentations ls]
  <span class="kw">where</span> iter <span class="fu">lex</span> c <span class="fu">=</span> <span class="kw">if</span> c <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> []
                     <span class="kw">else</span> (<span class="dt">Lexeme</span> pos <span class="dt">LDedent</span> <span class="kw">Nothing</span>)<span class="fu">:</span>(iter <span class="fu">lex</span> (c<span class="fu">-</span><span class="dv">1</span>))
addIndentations (l<span class="fu">:</span>ls) <span class="fu">=</span> l<span class="fu">:</span>(addIndentations ls)
addIndentations [] <span class="fu">=</span> []</code></pre>
<p>Ve böylece bağlam bağımlı bir grameri, lexing aşamasında basit bir hileyle bağlam bağımsız hale getirmiş oluyoruz. Indentation-based gramerlerde yapılabilecek en mantıklı iş bu gibi. Bağlam bağımlı gramerleri çözümlemek için bilinen çok iyi algoritmalar/kütüphaneler/programlar var ve bu iş lexing aşamasında çok kolay yapılabiliyor.</p>
<p>Değişik olduğunu düşündüğüm bir programlama dili üzerinde çalışıyorum, beklemede kalın :P .</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Tabii ki istisnalar olabilir. Bunu yapabilen kütüphanelerin nasıl yapabildiğini birazdan anlatacağım, bağlam bağımsızlığın dışına çıkıyorlar.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
