<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged prolog</title>
    <link href="http://osa1.net/tags/prolog.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/prolog.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-07-31T00:00:00Z</updated>
    <entry>
    <title>MANTI - Prolog implementation in 515 lines of Haskell</title>
    <link href="http://osa1.net/posts/2013-07-31-announce-manti.html" />
    <id>http://osa1.net/posts/2013-07-31-announce-manti.html</id>
    <published>2013-07-31T00:00:00Z</published>
    <updated>2013-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/osa1/MANTI">MANTI</a> is a pure Prolog implementation in 515 lines of Haskell. It’s only implements pure parts, meaning it doesn’t have cuts, IO predicates, non-pure arithmetic(<code>is</code> structures in modern Prolog implementation) or other structures that break logical reasoning of Prolog programs.</p>
<p>Here are some example Prolog programs that currently runs under MANTI: (you can find these in <code>tests/</code> folder in source repository)</p>
<ul>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/einstein.pl">Einstein’s riddle</a> – also called Zebra Puzzle. You can see problem definition in <a href="http://en.wikipedia.org/wiki/Zebra_Puzzle">Wikipedia - Zebra Puzzle</a>.</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/nqueens.pl">N-queens problem</a> (not that it takes some time to solve it for board bigger than 5x5, reasons for that slowness explained below)</li>
<li><a href="https://github.com/osa1/MANTI/blob/master/tests/zurg.pl">Escape from Zurg puzzle</a> - you can see a paper with definition of this problem <a href="http://web.engr.oregonstate.edu/~erwig/zurg/">here</a>.</li>
</ul>
<p>My aim while writing MANTI was to make it as simple as possible, yet a complete Prolog implementation that is capable to solve some real problems. For this reasons, it doesn’t have arithmetic, list structures and list operations built-in. Instead, arithmetic is implemented using <a href="http://en.wikipedia.org/wiki/Peano_axioms">Peano definitions</a>, you can see the implementation <a href="https://github.com/osa1/MANTI/blob/master/tests/peano.pl">here</a>. List operations are also implemented in MANTI itself, you can see definitions <a href="https://github.com/osa1/MANTI/blob/master/tests/list.pl">here</a>. List syntax is nothing special, it’s just a syntactic sugar that destructs to ordinary Prolog functors(you can see parser for list syntax <a href="https://github.com/osa1/MANTI/blob/master/src/Parser.hs#L80">here</a>).</p>
<p>For these reasons(and probably others, for instance, unification and <code>not</code> connective are implemented in most inefficient ways possible), it’s very slow. Also, there’s no way to disable occurs check without recompiling MANTI.</p>
<p>It’s mostly done and I don’t think I’ll work more on that. I hope you find MANTI useful(for learning purposes or others).</p>]]></summary>
</entry>
<entry>
    <title>Type checking with Prolog</title>
    <link href="http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html" />
    <id>http://osa1.net/posts/2013-06-13-type-checking-with-prolog.html</id>
    <published>2013-06-13T00:00:00Z</published>
    <updated>2013-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There is a deep relation between a type inference system and a logic programming system. I don’t fully understand this relation. <a href="http://stackoverflow.com/questions/13899586/haskells-type-system-and-logic-programming-how-to-port-prolog-programs-to-typ">This question</a> I asked at StackOverflow a few months ago gives some tips, but doesn’t explain much.</p>
<p>I could finally spare some time and play with a type checker implementation in Prolog. What I had in mind before starting writing this code was that having a unification mechanism at hand should make type checking easier.</p>
<p>Indeed that is the case, as you’ll see shortly. Type inference is harder, and I also explain the reason and how could it be done.</p>
<hr />
<p>I will not formally define the type system here, but I think it can be seen as a simple Damas-Hindley-Milner style type system.</p>
<p>This implementation basically embeds type definitions in Prolog. This is what makes this implementation simple. You can always implement a fully-featured type system in Prolog just like you can do it in any other language. What I’m trying to show here that it’s very simple to do when there is a way to implement types as rules in Prolog.</p>
<p>Here’s knowledge base of types:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb1-1" title="1">nat(o)<span class="kw">.</span></a>
<a class="sourceLine" id="cb1-2" title="2">nat(s(<span class="dt">N</span>)) <span class="kw">:-</span> nat(<span class="dt">N</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">bool(<span class="kw">true</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb1-5" title="5">bool(<span class="kw">false</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7">type(<span class="dt">A</span><span class="kw">,</span> nat) <span class="kw">:-</span> nat(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span></a>
<a class="sourceLine" id="cb1-8" title="8">type(<span class="dt">A</span><span class="kw">,</span> bool) <span class="kw">:-</span> bool(<span class="dt">A</span>)<span class="kw">,</span> <span class="kw">!.</span></a>
<a class="sourceLine" id="cb1-9" title="9">type(id<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)) <span class="kw">:-</span> <span class="kw">!.</span></a>
<a class="sourceLine" id="cb1-10" title="10">type(add<span class="kw">,</span> arrow(nat<span class="kw">,</span> arrow(nat<span class="kw">,</span> nat))) <span class="kw">:-</span> <span class="kw">!.</span></a>
<a class="sourceLine" id="cb1-11" title="11">type(not<span class="kw">,</span> arrow(bool<span class="kw">,</span> bool)) <span class="kw">:-</span> <span class="kw">!.</span></a>
<a class="sourceLine" id="cb1-12" title="12">type(const<span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> arrow(<span class="dt">_</span><span class="kw">,</span> <span class="dt">A</span>)))<span class="kw">.</span></a></code></pre></div>
<p>Implementing type definitions as rules in a Prolog system is what makes this implementation simple. Here <code>id</code> is a function with type <code>forall a. a -&gt; a</code>, <code>add</code> is <code>nat -&gt; nat</code>, <code>not</code> is <code>bool -&gt; bool</code>, and <code>const</code> is <code>forall a b. a -&gt; b -&gt; a</code>.</p>
<p>Type checking of function applications is also simple:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb2-1" title="1">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb2-2" title="2">    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">R</span>))<span class="kw">,</span></a>
<a class="sourceLine" id="cb2-3" title="3">    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></a></code></pre></div>
<p>And we’re done. This much code is enough for type checking polymorphic functions. Here are some examples:</p>
<pre><code>?- type(app(id, false), T).
T = bool.

?- type(app(id, o), T).
T = nat.

?- type(app(add, o), T).
T = arrow(nat, nat).

?- type(app(app(add, o), s(o)), T).
T = nat.

?- type(app(app(add, o), false), T).
false.

?- type(app(app(const, false), o), T).
T = bool.

?- type(app(app(const, false), true), T).
T = bool.</code></pre>
<p>One major limitation of this implementation is that there is no way to implement monomorphic functions. To do this, we should somehow have two different kinds of Prolog variables, one for polymorphic variables and one for monomorphic ones.</p>
<p>Since there’s no way to directly express this in Prolog, I had to extend this code with a typing environment. In the implementation above, if parameter of a function is an atom and not a variable, then it’s looked in a global environment.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb4-1" title="1">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb4-2" title="2">    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">var</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% polymorphic parameter</span></a>
<a class="sourceLine" id="cb4-4" title="4">    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">R</span> <span class="kw">=</span> <span class="dt">B</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">!.</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb4-9" title="9">    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span></a>
<a class="sourceLine" id="cb4-11" title="11">    get_type(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="co">% type already exists in environment</span></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">!,</span></a>
<a class="sourceLine" id="cb4-14" title="14">    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeA</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-15" title="15">    type_in_env(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="kw">!.</span></a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18">type(app(<span class="dt">F</span><span class="kw">,</span> <span class="dt">P</span>)<span class="kw">,</span> <span class="dt">R</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb4-19" title="19">    type(<span class="dt">F</span><span class="kw">,</span> arrow(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span>))<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="dt">atom</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="co">% monomorphic parameter</span></a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="co">% type doesn&#39;t exist in environment</span></a>
<a class="sourceLine" id="cb4-22" title="22">    type(<span class="dt">P</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-23" title="23">    add_type(types<span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">TypeP</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-24" title="24">    type_in_env(<span class="dt">B</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-25" title="25">    <span class="kw">!.</span></a></code></pre></div>
<p>First rule is for polymorphic parameters, only difference from the first code is <code>var(A)</code>, which ensures the parameter type is a variable.</p>
<p>Second rule does a similar check, but this time to ensure the parameter is an atom and not a variable. After that, type of this parameter is looked from an environment and checked against it. The third rule is when a type is not found in the environment. In that case, a new type is added to the environment.</p>
<p>Note that first cut is required in second rule. Because otherwise, when a type checking fails, third rule would be executed and a new type would be added to the environment.</p>
<p>Here are environment operations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb5-1" title="1">init_state(<span class="dt">Name</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb5-2" title="2">    empty_assoc(<span class="dt">A</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb5-3" title="3">    nb_setval(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5">add_type(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb5-6" title="6">    nb_getval(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb5-7" title="7">    put_assoc(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb5-8" title="8">    nb_setval(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">NewState</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">get_type(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">TermName</span><span class="kw">,</span> <span class="dt">Type</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb5-11" title="11">    nb_getval(<span class="dt">SName</span><span class="kw">,</span> <span class="dt">State</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb5-12" title="12">    get_assoc(<span class="dt">TermName</span><span class="kw">,</span> <span class="dt">State</span><span class="kw">,</span> <span class="dt">Type</span>)<span class="kw">.</span></a></code></pre></div>
<p>Environment operations get a environment name to keep the state local. ie. you can be sure your state is local if name of the state is not used somewhere else :-)</p>
<p>This helper is used to get type of a term when term is an atom, and it’s type is available in environment. Otherwise it returns the term itself.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb6-1" title="1">type_in_env(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>) <span class="kw">:-</span> get_type(types<span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span> <span class="dt">T1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb6-2" title="2">type_in_env(<span class="dt">T</span><span class="kw">,</span> <span class="dt">T</span>)<span class="kw">.</span></a></code></pre></div>
<p>An example monomorphic function rule:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb7-1" title="1">type(mono_id<span class="kw">,</span> arrow(mono_id__a<span class="kw">,</span> mono_id__a)) <span class="kw">:-</span> <span class="kw">!.</span></a></code></pre></div>
<p>It should be guaranteed by the programmer that <code>mono_id__a</code> atom is only used for <code>mono_id</code> function.</p>
<p>Here are some examples for checking monomorphic functions(others work as before):</p>
<pre><code>?- init_state(types).
true.

?- type(app(mono_id, o), T).
T = nat.

?- type(app(mono_id, s(o)), T).
T = nat.

?- type(app(mono_id, false), T).
false.

?- init_state(types).
true.

?- type(app(mono_id, false), T).
T = bool.

?- type(app(mono_id, o), T).
false.</code></pre>
<p>This code should demonstrate how easy it’s to implement a type checker when there’s a way to express typing rules as Prolog rules. We had type checker for polymorphic and monomorphic functions in 57 lines of Prolog.</p>
<p>For type inference, we need to generate new rules in runtime. I’m looking for ways to do this. <code>assert/1</code> and <code>dynamic/1</code> predicates make this possible, but I still couldn’t find a way to generate fresh Prolog variables(like <code>gensym</code>, but for variables). I’ll update this post later.</p>]]></summary>
</entry>

</feed>
