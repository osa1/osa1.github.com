<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged lisp</title>
    <link href="http://osa1.net/tags/lisp.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/lisp.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2012-08-09T00:00:00Z</updated>
    <entry>
    <title>call/cc [2]</title>
    <link href="http://osa1.net/posts/2012-08-09-callcc-2.html" />
    <id>http://osa1.net/posts/2012-08-09-callcc-2.html</id>
    <published>2012-08-09T00:00:00Z</published>
    <updated>2012-08-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Scheme çok ilginç bir dil. Çok küçük olmasına rağmen(R5RS 50 sayfa, R6RS 90 sayfa, aradaki fark büyük oranda kütüphanelerden kaynaklanıyor) programlama dilleri camiasından sürekli tartışma konusu, ve bir sonraki standard konusundaki tartışmalar neredeyse hiçbir zaman bitmiyor. Çok fazla tartışmalı özelliği var. Kendisine göre devasa boyutlardaki dillerde bile Scheme’inkiler kadar tartışılan özellikler yoktur büyük ihtimalle(gerçi bu biraz da Scheme camiasının çok sayıda programlama dili meraklısı içermesi ile alakalı olabilir).</p>
<p><code>call/cc</code> bu özelliklerden biri, hakkında buralarda birşeyler yazmıştım. <code>call/cc</code> benim gözümde, birazdan bahsedeceğim yazıdaki tabiriyle, “ultimate abstraction of control” idi. Kendi dilime de call/cc’yi programın kontrol akışı üzerinde değişiklikler gerektiren yapıları implement etmek için kullnacaktım.</p>
<p>Bugün internetteki favori sayfalarımdan <a href="http://okmij.org/ftp/">okmij</a>de <a href="http://okmij.org/ftp/continuations/against-callcc.html">“An argument against call/cc”</a> adlı yazıya denk geldim. Meraklısı olan varsa kaçırmasın.</p>
<p>call/cc’nin neden kötü bir soyutlama olduğunu 7 madde halinde incelemiş. Benim anladığım, tüm bu problemleri delimited continuationlarla çözebiliriz. Delimited continuationlara giriş için <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf">Introduction to Programming with Shift and Reset</a>e bakabilirsiniz. Ben epey anlaşılır buldum(OchaCaml’ı yükleyip denemedim gerçi, içinde yama uygulamayı da içeren birkaç maddelik kurulum komutu var, şaka gibi). Bir maddede <code>dynamic-wind</code>den bahsetmiş. <code>dynamic-wind</code> ile ilk kez bu yazıda karşılaştım, ve anladığım kadarıyla delimited continuationlar buna olan ihtiyacı ortadan kaldırmıyor. Sonuçta örneğin bir dosyaya erişim yapıldığı durumda, continuation dosyanın referansını içerecektir ve daha sonradan bu continuation kullnıldığında, delimited olsa da olmasa da, aynı kaynakların alınıp(dosyanın açılması, sunucuya bağlanılması vs.), işlem sonrasında kapatılması gerekir.</p>
<p>Static bir tip sistemi ve lexical scope ile call/cc implementasyonu benim için zaten yeterince zor bir problem. Belki de tamamen kaldırıp, Lua usulü biraz daha genelleştirilmiş generatorlar<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>ile yola devam etmeliyim.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="http://dl.acm.org/citation.cfm?id=1462167&amp;CFID=125136476&amp;CFTOKEN=41020401">Revisiting coroutines</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Arc ve Lisp hakkında</title>
    <link href="http://osa1.net/posts/2012-06-27-arc-ve-lisp-hakkinda.html" />
    <id>http://osa1.net/posts/2012-06-27-arc-ve-lisp-hakkinda.html</id>
    <published>2012-06-27T00:00:00Z</published>
    <updated>2012-06-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Paul Graham’ın Arc dilinin tasarımı ve genel olarak Lisp hakkındaki yazıları o kadar müthiş ki, burada okuduklarımın linklerini paylaşacağım.</p>
<ul>
<li><p><a href="http://www.paulgraham.com/ilc03.html">Some Work on Arc (2009)</a>. Bunu okumayan kalmasın, bir programlama dilinde beni en çok heyecanlandıran fikirleri ve şimdiye kadar gördüğüm en güzel Lisp tanımını içeriyor. Normalde sadece bu yazı hakkında uzun bir yazı hazırlamıştım, ama sonra neredeyse tüm yazıyı alıntıladığımı farkedip bu formata döndüm.</p></li>
<li><p><a href="http://paulgraham.com/arcll1.html">Arc: An Unfinished Dialect of Lisp (2001)</a>: Arc dilinin tasarımı hakkında alınmış kararların nedenlerinden ve nasıllarından bahsediliyor. Bu yazıda bahsedilen isimsiz fonksiyon syntaxının ve veri yapılarının indexler üzerine fonksiyonlar olmasının şu anda Clojure tarafından kullanıldığını farkedebilirsiniz.</p></li>
<li><p><a href="http://paulgraham.com/syntaxquestion.html">Steele and Gabriel: The Syntax Question</a>: Neden Lisp’ler Algol tarzı syntaxa sahip değiller? Neden Algor tarzı syntax için uygun değiller?</p></li>
<li><p><a href="http://www.paulgraham.com/vanlfsp.html">Michael Vanier: LFM and LFSP</a>: Programlama dillerinin hitap ettiği kitleler ve dilin güçleri, tasarım kararları ile alakalı.</p></li>
</ul>
<p>Bir de meraklısı varsa Arc dilinin <a href="http://arclanguage.org/">sayfası</a>. <em>Core</em> diye bahsedilen çekirdek kısım 1500 satır Scheme kodundan ibaret. Dil Scheme’e derleniyor. Şimdi düşünüyorum da, bir Lisp dili yazıyor olsaydım(aslında yazıyorum zaten, daha ciddi olsaydım diyecektim) ben de Scheme’e derlerdim. Mesela <a href="http://www.iro.umontreal.ca/~gambit/">Gambit</a>e derleyebilmek, Racket’a derlemek kadar kolay olmaz ama süper olurdu.</p>
<p>Paul Graham’ın yukarıdaki yazılarda bahsettiği, dillerin implementasyonları konusundaki fikirlerden bazılarını <a href="http://www.shenlanguage.org/">Shen</a>de görebilmek mümkün. Shen, <em>K Lambda</em> adı verilen 46 fonksiyon içeren bir dil üzerine inşa edildi ve şimdiden 3 farklı platformda(Common Lisp, Clojure, JavaScript) çalışıyor.</p>]]></summary>
</entry>
<entry>
    <title>call/cc</title>
    <link href="http://osa1.net/posts/2012-06-23-callcc.html" />
    <id>http://osa1.net/posts/2012-06-23-callcc.html</id>
    <published>2012-06-23T00:00:00Z</published>
    <updated>2012-06-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Son zamanlarda uğraştığım konulardan biri hakkında birşeyler karalayacağım. Genelde zor bir konspetle karşılaştığımda anladığımı anlamak için 2 şey yapıyorum, 1) programlıyorum, 2) anlatıyorum. Uğraştığım işlerle ilgilenen kimse olmadığından, anlatabiliyor olmamı bu blog sağlıyor. Bu sefer Scheme’in call/cc fonksiyonundan bahsedeceğim, epey ilginç bir iş yaptığını düşünüyorum.</p>
<p><code>call/cc</code>de benim ilgimi çeken şey, Scheme’i bir yorumlayıcı ortamı olarak düşündüğümüzde, yorumlayacağımız dile exceptionlar, coroutineler gibi kontrol akışınıda değişiklikler yapması gereken yapıları kolayca ekleyebilmemizi sağlaması.</p>
<p>Continuation-passing style’a aşina olduğunuzu varsayıyorum. Aşina olmayanlar Google’dan kolaylıkla süper kaynaklar edinebilir. JavaScript gibi yaygın bir dilin CPS kullanabilmek için gereken fonksiyonelliği sağlıyor olması çok büyük şans, yoksa CPSı anlamak için Scheme kodu okumak zorunda kalabilirdiniz :P . Ben implementasyonu Common Lisp ile vereceğim.</p>
<p><code>call-with-current-continuation</code> veya kısaca <code>call/cc</code>nin genel olarak iki farklı implementasyon yöntemi var<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> biri stack kopyalama işlemi, diğeri <em>CPS conversion</em> dediğimiz, benim birazdan anlatım Common Lisp ile yazacağım yöntem.</p>
<p>Tüm programlarımızın üstü kapalı bir şekilde(<em>implicit</em>) CPS yazıldığını düşünelim. Yani tüm fonksiyon çağrıları aslında bir değer dönmek yerine, bu döneceği değer ile continuation’ı çağırmalı<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Bunu sağlamak için tüm fonksiyonlar ilk parametre olarak continuation alabilir ve diğer parametreleri fonksiyon tanımı sırasında verilen parametreler olur. Daha sonra fonksiyon döneceği değer ile ilk parametresini, yani continuation’ı çağırır. Bu fonksiyonları bir macro ile kolayca oluşturabiliriz<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> defcont </span>(name (&amp;<span class="kw">rest</span> params) &amp;body body)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((result (<span class="kw">gensym</span>)))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    `(<span class="kw">defun</span><span class="fu"> </span>,name (continuation ,@params)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>       (<span class="kw">let</span> ((,result ,@body))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>         (<span class="kw">funcall</span> continuation ,result)))))</span></code></pre></div>
<p>Bu macronun syntaxı <code>defun</code>un tamamen aynısı, sadece ekstradan ilk parametre olarak continuation alıyor ve dönüş değeriyle aslında continuation’ı çağırıyor. Bu şekilde yazılan fonksiyonlar <em>CPS conversion</em> a maruz kalıyor yani.</p>
<p>Örnek olarak bu şekilde basit bir toplama ve çarpma fonksiyonları oluşturalım:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>(defcont multiply (&amp;<span class="kw">rest</span> args)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  (<span class="kw">apply</span> #&#39;* args))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>(defcont add (&amp;<span class="kw">rest</span> args)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  (<span class="kw">apply</span> #&#39;+ args))</span></code></pre></div>
<p>Burda fonksiyonların içinde CPS formatında olmayan, dilin kendi fonksiyonlarını çağırıyoruz ama bu sorun değil.</p>
<p>Bu durumda normalde <code>(* 3 (+ 1 2))</code> şeklinde yazacağımız fonksiyonu şu şekilde yazmamız gerekiyor: <code>(add (lambda (r) (multiply #'identity r 3)) 1 2)</code>. İşte bu dönüşümü yapmaya <code>CPS conversion</code> diyoruz. Ne yaptığına bakalım, çarpma işleminin sonucu <code>(+ 1 2)</code> çağrısının dönüş değerine bağlı, buna göre ilk başta toplama işlemi yapılıp, sonucu çarpma işlemine aktarılmalı. Çarpma işlemi de toplama işleminin sonucunu alıp, 3 ile çarptıktan sonra bir continuation’a aktarmalı. Burda bu son continuation olarak <code>identity</code> fonksiyonunu seçtim ki sonucu elde edebilelim. Normalde, eğer örneğin sonucu yazdırmak istiyorsak, orata <code>prin1</code> gibi bir fonksiyon göndermemiz gerekir.</p>
<p>Bu şekilde yazılan programların nasıl çalıştığına bakarsanız, aslında fonksiyon çağrıları için stack modeline ne kadar benzediğini farkedersiniz. Stack modelinde, çarpma fonksiyonu çağırıldığında stack’de fonksiyon çağrısı hakkında gerekli verileri tutan bir kayıt oluşturulacak, daha sonra toplama işlemi çağırıldığında bunun üzerine bir kayıt daha eklenecek, ve fonksiyon çağrıları bittikçe bu kayıtlar stackten toplanarak bir alt seviyeye dönüş değerlerini bir şekilde aktaracak.</p>
<p>CPS’de tamamen aynı, toplama işlemi önce bitecek ve çarpma işlemine dönüş değerini aktaracak. Bunun için çarpma fonksiyonunu ilk parametresi olarak alacak, çarpma fonksiyonu da kendi sonucunu hangi fonksiyona aktaracaksa o fonksiyonu ilk parametre olarak alacak gibi.</p>
<p>Buraya kadar herşey anlaşıldıysa, <code>call/cc</code>yi yazmak çok kolay. <code>call/cc</code>nin yaptığı, o anki continuation’ı açık bir şekilde kullanıcıya vermek. Normalde yukarıda bahsettiğim tüm olaylar derlenme aşamasında <em>CPS conversion</em> veya başka yöntemlerle hallediliyor ve kullanıcı aslında fonksiyonlarını bizim örneğimizdeki gibi yazmıyor. Dolayısıyla fonksiyonuna aktarılan continuation’a erişme şansı yok. Fakat <code>call/cc</code> hariç, <code>call/cc</code> tam olarak bu işi yapıyor, o anki continuation’a erişim izni veriyor. Şu şekilde:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(<span class="kw">defun</span><span class="fu"> call/cc </span>(continuation fun)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  (<span class="kw">funcall</span> fun continuation))</span></code></pre></div>
<p>Bu fonksiyonun <code>defcont</code> ile tanımlandmadığına dikkat. Bu şu anlama geliyor, programlama dili böyle bir fonksiyon sunmuyorsa, bu fonksiyonun yazılması imkansız. Kullanıcının tek sahip olduğunun <code>defcont</code> olduğunu düşünün, yani tüm fonksiyonları _CPS conversion_a mağruz kalıyor, ve fonksiyon çağrıları otomatik olarak CPS’e dönüştürülüyor. Programcı yazdığı fonksiyonlara continuation’ın nasıl aktarıldığını bilmiyor veya bilse bile buna erişmesinin hiçbir yolu yok.</p>
<p><code>call/cc</code>, kendi aldığı continuation’ı <code>fun</code> parametresi olarka aldığı fonksiyona aktarıyor, ve daha sonra <code>fun</code> fonksiyonu o continuation ile her türlü çılgınlık yapabilir, örneğin bu continuation’ı bir yere kaydedip, bir daha bir daha çağırmak gibi. Bu continuation, dönüş değerinin aktarılacağı fonksiyonu tutuyor aslında.</p>
<p>Hemen basit birkaç örnek yapalım. Şu iki fonksiyon arasındaki fark ne?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(call/cc (<span class="kw">lambda</span> (r) (<span class="op">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) (<span class="kw">funcall</span> cont <span class="dv">11</span>)))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>(call/cc (<span class="kw">lambda</span> (r) (<span class="op">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) <span class="dv">11</span>))</span></code></pre></div>
<p>İlk çağrıda continuation’a 11 değerini gönderiyoruz ve sonuç beklenen gibi 21 oluyor, ikinci durumda ise continuation’ı yok sayıp 11 değerini dönüyoruz ve cevap 11 oluyor. Stack modelinde düşünürsek, ikinci örnekte yapılan şey, stackdeki bazı fonksiyon kayıtlarının atlanması aslında. Buna sanırım <code>stack unwinding</code> deniyor(emin değilim). Bu şekilde dil seviyesinde exception mekanizmaları yazılabilir, continuationlar kaydedilerek ve sırayla çağırılarak coroutineler<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>veya _lightweight thread_ler elde edilebilir(<em>green thread</em> de diyorlar sanırım).</p>
<p>Scheme bilenler için bu kodun Scheme karşılıkları şu:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="op">+</span> <span class="dv">10</span> <span class="dv">11</span>)))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="op">+</span> <span class="dv">10</span> (cont <span class="dv">11</span>))))</span></code></pre></div>
<p>Aralarındaki fark, Scheme kodu _CPS conversion_a mağruz kalmamış, Common Lisp kodu ise kalmış hali.</p>
<p>Bu aşamada yapılabilecek çok fazla fantastik iş var ve çoğu durumda neler olup bittiğini anlama çok güç. Zaten bu yüzden <code>GOTO</code>larla karşılaştırılıyorlar bazen. Benim hoşuma giden bir kullanımını şu:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>(<span class="kw">defvar</span><span class="fu"> creturn </span><span class="kw">nil</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>(call/cc (<span class="kw">lambda</span> (r) (<span class="op">+</span> <span class="dv">1</span> r))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>         (<span class="kw">lambda</span> (cont)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>           (<span class="kw">setf</span> creturn cont)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>           <span class="dv">1</span>))</span></code></pre></div>
<p>Continuation’ı bir değişkene kaydediyorum ve daha sonra istediğim zaman o continuation’ı çağırıp işlemi kaldığı yerden devam ettiriyorum.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">15</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="dv">16</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">20</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="dv">21</span></span></code></pre></div>
<p>Kısaca, işlemi istediğim bir yerden durdurdum ve kopyaladım. Daha sonra durdurduğum andan itibaren istediğim bir değer ile devam ettiriyorum. Müthiş bir olay. Bu gösterdiğim örnekler en basit ve sıradan örnekler, neler yapılabileceği hakkında çok fazla güzel kaynak var, açıkçası ben çoğunun ne yaptığını anlamakta güçlük çekiyorum, bazı patternlara aşina olmak gerekiyor. <code>call/cc</code>nin Scheme’den kaldırılması da <a href="http://lists.scheme-reports.org/pipermail/scheme-reports/2012-February/001824.html">şu ortamda</a> epey tartışılmış.</p>
<p>Çok bilinen iki implementasyon yöntemi demiştim, diğer yöntem de stack kopyalama. Bu örneği düşünelim, <code>call/cc</code> aslında stack’in o anki durumunu aktarıyor aslında. Burda yapılan işlem büyük ihtimalle en baştan beri tüm stackin kopyalanması değil. <a href="http://en.wikipedia.org/wiki/Spaghetti_stack">Sphagetti stack</a> gibi bir yapı kullanılıyor olabilir.</p>
<p>Bu arada, coroutine demişken, implementasyon detaylarını merak eden varsa: <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;ved=0CHgQFjAF&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.104.1441%26rep%3Drep1%26type%3Dpdf&amp;ei=PAXmT8TBEaeB4ASj-5ygAQ&amp;usg=AFQjCNENWM4b5ib96CKcno8KgEeJk4KQ6g">Coroutines in Lua</a>. Lua’yı seviyoruz.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Aslında, birkaç tane çok bilinen(yazılmış) implementasyonu var ve dahası da gereksinimlere/şartlara göre uydurulabilir. Detayları merak eden varsa: <a href="http://www.cs.indiana.edu/~dyb/papers/3imp.pdf">Three Implementation Models for Scheme</a>. Ve büyük ihtimalle şu kitapta da bahsediliyordur: <a href="ref=sr_1_1?ie=UTF8&amp;qid=1340471949&amp;sr=8-1&amp;keywords=lisp+in+small+pieces">Lisp in Small Pieces</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Bu durumda, <em>sanırım</em>, teorik olarak stack denen yapıya ihtiyaç kalmıyor.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Bu macroda bir sorun var fakat konumuzun dışında olduğundan, işleri karıştırmamak için önemsemedim: <code>continuation</code> parametresi <a href="http://www.bookshelf.jp/texi/onlisp/onlisp_10.html#SEC67"><em>variable capture</em></a>a maruz kalabilir. <code>gensym</code> ile parametre adı oluşturulması gerekir.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Şu anda coroutineleri implement etmek için sanırım zaten stackin bir kopyasını çıkarmak zorundasınız.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Micro-Manual for Lisp in Python</title>
    <link href="http://osa1.net/posts/2012-03-23-micro-manual-lisp-python.html" />
    <id>http://osa1.net/posts/2012-03-23-micro-manual-lisp-python.html</id>
    <published>2012-03-23T00:00:00Z</published>
    <updated>2012-03-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I was reading some papers about first Lisps and their implementations, and I came across with <a href="http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a>’s <a href="http://www.ee.ryerson.ca/~elf/pub/misc/micromanualLISP.pdf">A Micro-Manual for Lisp - Not the Whole Truth</a>. I had heard about it some time ago but never read the paper, and as a programming exercise, I implemented in Python within an hour or so.</p>
<p>If you’re into Lisps, I highly recommend you <a href="http://www-formal.stanford.edu/jmc/recursive.html">Recursive Functions of Symbolic Expressions and their Computation by Machine (Part I)</a> and the micro-manual. What I really love about micro-manual is that it’s a great way to see simplicity in original Lisp. With just 9 forms you have a working Lisp system. It also introduces it’s own <code>eval</code> function in Lisp.</p>
<p>In the rest of the post, when I use <code>Lisp</code>, I’ll be mentioning the Lisp in micro-manual, not the modern dialects.</p>
<p>Lisp programs are formed by symbolic expressions(s-exps, sexps, sexprs), and a sexp is either a <code>list</code> or an <code>atom</code>. Before interpreting our Lisp, we should read sexps and convert them into a form that we can work on with our host language(in my case, it’s Python).</p>
<p>I’ll convert Lisp lists into ordinary Python lists, and atoms into Python strings. My reader has two parts, the first part is getting the input and parsing tokens:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> Reader:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, form):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>        <span class="va">self</span>.form <span class="op">=</span> form</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span class="va">self</span>.index <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> seek_char(<span class="va">self</span>):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.index <span class="op">&gt;=</span> <span class="bu">len</span>(<span class="va">self</span>.form):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.form[<span class="va">self</span>.index]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="kw">def</span> unread_char(<span class="va">self</span>):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>        <span class="va">self</span>.index <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="kw">def</span> read_char(<span class="va">self</span>):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.index <span class="op">&gt;=</span> <span class="bu">len</span>(<span class="va">self</span>.form):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>        <span class="va">self</span>.index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.form[<span class="va">self</span>.index<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    <span class="kw">def</span> read_token(<span class="va">self</span>):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>        ch <span class="op">=</span> <span class="va">self</span>.read_char()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        <span class="cf">if</span> ch <span class="op">==</span> <span class="st">&#39;(&#39;</span>:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>            <span class="cf">return</span> <span class="st">&#39;(&#39;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>        <span class="cf">elif</span> ch <span class="op">==</span> <span class="st">&#39;)&#39;</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>.seek_char() <span class="op">==</span> <span class="st">&#39; &#39;</span>:</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>                <span class="va">self</span>.read_char()</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>            <span class="cf">return</span> <span class="st">&#39;)&#39;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>            buf <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>            <span class="cf">while</span> ch <span class="op">!=</span> <span class="st">&#39; &#39;</span> <span class="kw">and</span> ch <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>                <span class="cf">if</span> ch <span class="op">==</span> <span class="st">&#39;)&#39;</span>:</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>                    <span class="va">self</span>.unread_char()</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>                    <span class="cf">return</span> buf</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>                <span class="cf">else</span>:</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>                    buf <span class="op">+=</span> ch</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>                    ch <span class="op">=</span> <span class="va">self</span>.read_char()</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>            <span class="cf">return</span> buf</span></code></pre></div>
<p>Well, it may not be the best way to parse an input to tokens, but it works great. It return a <code>(</code>, <code>)</code>, or a string each time you call <code>read_token</code>. When we read <code>(</code>, we start collecting a list, until reading a <code>)</code>(we should also consider lists into lists):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">def</span> read_list(reader):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    result <span class="op">=</span> []</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    token <span class="op">=</span> reader.read_token()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="cf">while</span> token:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>        <span class="cf">if</span> token <span class="op">==</span> <span class="st">&#39;(&#39;</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>            result.append(read_list(reader))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="cf">elif</span> token <span class="op">==</span> <span class="st">&#39;)&#39;</span>:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>            <span class="cf">return</span> result</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>            result.append(token)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>        token <span class="op">=</span> reader.read_token()</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    <span class="cf">return</span> result</span></code></pre></div>
<p><code>read_atom</code> functions is easier, since each each atom is also a token:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">def</span> read_atom(reader):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="cf">return</span> reader.read_token()</span></code></pre></div>
<p>At this point, we have a Lisp reader that reading s-expressions, converting lists to Python lists and atoms to Python strings. Now we can define our 9 primitive procedures(<code>quote</code>, <code>car</code>, <code>cdr</code>, <code>cons</code>, <code>equal</code>, <code>atom</code>, <code>cond</code>, <code>lambda</code>, <code>label</code>):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">def</span> quote(e):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="cf">return</span> e</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">def</span> car(e):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="cf">assert</span> <span class="bu">isinstance</span>(e, <span class="bu">list</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="cf">return</span> e[<span class="op">^</span><span class="dv">0</span>]<span class="kw">def</span> cdr(e):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="cf">assert</span> <span class="bu">isinstance</span>(e, <span class="bu">list</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="cf">return</span> e[<span class="dv">1</span>:]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="kw">def</span> cons(e1, e2):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(e2, <span class="bu">list</span>):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        <span class="cf">return</span> [e1] <span class="op">+</span> e2</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="cf">return</span> [e1, e2]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="kw">def</span> equal(e1, e2):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    <span class="cf">return</span> e1 <span class="op">==</span> e2</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="kw">def</span> atom(e):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">not</span> <span class="bu">isinstance</span>(e, <span class="bu">list</span>)</span></code></pre></div>
<p>These are obvious. Since I’ve already converted sexp lists into Python lists, all I need to do is to call some Python list methods.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">def</span> cond(<span class="op">*</span>cases):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="cf">for</span> case <span class="kw">in</span> cases:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        <span class="cf">if</span> eval_(case[<span class="op">^</span><span class="dv">0</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>            <span class="cf">for</span> expr <span class="kw">in</span> cdr(case)[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>                eval_(expr)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>            <span class="cf">return</span> eval_(case[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div>
<p>An important point here is that in <code>cond</code>, I’m not evaluating all expressions, but I’m evaluating the test forms until I find a form that evaluates something that’s not <code>nil</code>, and then evaluating it’s form.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">def</span> lambda_(args, <span class="op">*</span>exprs):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="kw">def</span> fn(<span class="op">*</span>arg_vals):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>        fn_env <span class="op">=</span> {k:v <span class="cf">for</span> (k, v) <span class="kw">in</span> <span class="bu">zip</span>(args, arg_vals)}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>        fn_env[<span class="st">&#39;parent_env&#39;</span>] <span class="op">=</span> env</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>        <span class="cf">for</span> expr <span class="kw">in</span> exprs[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>            eval_(expr, fn_env)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>        <span class="cf">return</span> eval_(exprs[<span class="op">-</span><span class="dv">1</span>], fn_env)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    <span class="cf">return</span> fn</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="kw">def</span> label(name, lambda_exp, <span class="op">*</span>exprs):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    func <span class="op">=</span> eval_(lambda_exp)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    label_env <span class="op">=</span> env.copy()</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    label_env[name] <span class="op">=</span> func</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    <span class="cf">for</span> exp <span class="kw">in</span> exprs[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>        eval_(exp, label_env)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="cf">return</span> eval_(exprs[<span class="op">-</span><span class="dv">1</span>], label_env)</span></code></pre></div>
<p><code>label</code> is a way to name lambdas, so you can create recursive functions. I’m creating a new environment for each label, and connecting it to the parent environment.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>env <span class="op">=</span> {<span class="st">&#39;quote&#39;</span>: quote,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>       <span class="st">&#39;car&#39;</span>: car,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>       <span class="st">&#39;cdr&#39;</span>: cdr,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>       <span class="st">&#39;cons&#39;</span>: cons,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>       <span class="st">&#39;equal&#39;</span>: equal,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>       <span class="st">&#39;atom&#39;</span>: atom,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>       <span class="st">&#39;cond&#39;</span>: cond,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>       <span class="st">&#39;lambda&#39;</span>: Lambda,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>       <span class="st">&#39;label&#39;</span>: label,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>       <span class="st">&#39;defun&#39;</span>: defun}</span></code></pre></div>
<p>The global environment. When an atom is evaluated, it’s value is searched in here, with this function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">def</span> search_in_env(env, key):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    val <span class="op">=</span> env.get(key)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="cf">if</span> val:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>        <span class="cf">return</span> val</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="cf">if</span> env.has_key(<span class="st">&#39;parent_env&#39;</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>        <span class="cf">return</span> search_in_env(env[<span class="st">&#39;parent_env&#39;</span>], key)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="cf">raise</span> <span class="pp">KeyError</span>(key)</span></code></pre></div>
<p>Since each environment may be connected to a parent environment(the case of <code>label</code>), we should search all the chain of environments.</p>
<p>So now we have the Lisp described in the micro-manual, we only need the eval:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">def</span> eval_(exp, env<span class="op">=</span>env):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="co"># print &quot;evaluating: %s&quot; % str(exp)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(exp, <span class="bu">list</span>):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(exp[<span class="op">^</span><span class="dv">0</span>] <span class="bu">list</span>):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>            op <span class="op">=</span> eval_(exp[<span class="op">^</span><span class="dv">0</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>            op <span class="op">=</span> search_in_env(env, exp[<span class="op">^</span><span class="dv">0</span>]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        <span class="cf">if</span> op <span class="kw">in</span> [quote, cond, lambda_, label, defun]:</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>            <span class="cf">return</span> <span class="bu">apply</span>(op, exp[<span class="dv">1</span>:])</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">apply</span>(op, [eval_(e, env) <span class="cf">for</span> e <span class="kw">in</span> exp[<span class="dv">1</span>:]])</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    <span class="cf">return</span> search_in_env(env, exp)</span></code></pre></div>
<p>And some helpers for REPL:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">def</span> eval_from_string(string):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="cf">return</span> eval_(read(Reader(string)))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">def</span> expr_repr(expr):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(expr, <span class="bu">list</span>):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&#39;(&#39;</span> <span class="op">+</span> <span class="st">&#39; &#39;</span>.join([expr_repr(e) <span class="cf">for</span> e <span class="kw">in</span> expr]) <span class="op">+</span> <span class="st">&#39;)&#39;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, <span class="bu">bool</span>):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>        <span class="cf">if</span> expr:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>            <span class="cf">return</span> <span class="st">&#39;T&#39;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&#39;nil&#39;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">str</span>(expr)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a><span class="kw">def</span> repl():</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>            <span class="bu">input</span> <span class="op">=</span> <span class="bu">raw_input</span>(<span class="st">&quot;&gt; &quot;</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>            <span class="bu">print</span> expr_repr(eval_(read(Reader(<span class="bu">input</span>))))</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>        <span class="cf">except</span> (<span class="pp">KeyboardInterrupt</span>, <span class="pp">EOFError</span>):</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>            <span class="cf">return</span></span></code></pre></div>
<p>I also wrote some unit-tests based on examples in the paper. You can read the implementation and tests from <a href="https://gist.github.com/2147404">the gist</a>. To run the interpreter, just save the code and run <code>python lisp.py</code>.</p>]]></summary>
</entry>
<entry>
    <title>CL-Mustache, Common Lisp için Mustache renderer</title>
    <link href="http://osa1.net/posts/2012-02-02-cl-mustache-common-lisp-icin-mustache-renderer.html" />
    <id>http://osa1.net/posts/2012-02-02-cl-mustache-common-lisp-icin-mustache-renderer.html</id>
    <published>2012-02-02T00:00:00Z</published>
    <updated>2012-02-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Biraz eski bir olay ama yarım kalan yazı arşivimde kaybolmuş, şimdi ekleyeyim(tamamlanmayı bekleyen bir sürü yazı var, sıkı durun).</p>
<p>Mustache, “logic-less templates” diye bahsedilen bir template motoru(bu arada ben hala “logic-less” ne demek bilmiyorum ehehe). <a href="http://mustache.github.com/mustache.5.html">Şuradan</a> örneklere bakabilirsiniz.</p>
<p>Common Lisp için Mustache kütüphanesi, en azındaın Google ile aratıp bulunabilecek bir yerde, yoktu. Ben de henüz öğrenme aşamasındaydım ve belki camiaya da bir katkım olur diye girişmiştim bu işe.</p>
<p>Github <a href="https://github.com/osa1/cl-mustache">deposu</a>ndan edinebilirsiniz. Arayüz olarak sadece tek bir fonksiyon sunuyor, <code>mustache-render</code>. Herhangi bir input stream’ı ve Common Lisp veri yapılarına dönüştürülmüş JSON verisi ile çağırdığınızda render edilmiş halini elde ediyorsunuz. Şu anda Mustache <a href="https://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=mustache+specs">specler</a>inden çok satırlı yorumlar hariç hepsini geçiyor. comp.lang.lisp’e attığım maile de <a href="https://groups.google.com/group/comp.lang.lisp/browse_thread/thread/3002d02bfe42a87b">şuradan</a> bakabilirsiniz.</p>
<p>Lambda desteği için speclerde yapmamız gereken değişiklikleri üşendiğim için bir türlü yapamamıştım, comp.lang.lisp’deki mailime cevap yazanlardan birisi ekleyip <a href="https://github.com/mustache/spec/pull/36">pull request</a> yollamış. Eklenip JSON hali hazırlandığında lambda desteği de ekleyeceğim(bu arada Common Lisp için YAML parser’ı da yok şu anda, bu projeyi bitirene kadar ne kadar çok şey öğrendiğimi düşünüyoru da, o işe de girişebilirim aslında).</p>
<p>Şimdi hazır lafa girmişken teknik detaylardan bahsetmezsem ölürüm. Öncelikle kodu iyileştirmek için(ilk Common Lisp kütüphanem sonuçta), IRC’de comp.lang.lisp’de yardım istedim, ama pek bir cevap alamadım. Birkaç ihtimal var, ya Common Lisp camiasının pek umurunda değil, ya sayıca az olduğumuzdan ilgilenecke kimseye denk gelmedim(zaten kaç kişiyiz şurda), ya da kütüphane aslında iyi durumda.</p>
<p>Toplamda 291 satır. Mustache sayfasından diğer diller ile yapılmış implementasyonlar ile karşılaştırdığınızda gayet iyi olduğunu görebilirsiniz. Kodun küçük olması çok birşey ifade etmiyor olabilir tabii ama bir dilde binlerce satırda yaptığınız bir işi başka bir dilde 300 satırda yapabiliyorsanız, benim gözümde bu dil ifade gücü açısından daha <em>güçlü</em>dür(ya da diğer dil çok kötü hehe). En azından gündüz enterprise ortamında Java, gece Common Lisp yazan biri olarak ben böyle düşünüyorum hehe.</p>
<p>Neyse, kodda hala TODO yorumları duruyor. Düzenlenecek birkaç yer var. Onun dışında iyi bir durumda olduğunu düşünüyorum. Şu anda performans olarak aklımdaki bir iyileştirme şu:</p>
<p>Input stream’den girdiyi satır satır okuyorum ve okuduğum her satırı tokenlere ayırıp bir listeye kaydediyorum. Daha sonra renderer JSON verisini alıp gerekli etiketleri gerekli veriyle değiştiriyor.</p>
<p>Burda aslında tüm template’i tokenlara ayırıp bir listeye kaydetmek yerine, Common Lisp’de listeleri bir şekilde lazy bir şekilde oluşturabilseydim, kodda birkaç kelimelik değişiklik yaparak, hesaplamayı(yani tokenlere ayırma işlemini) render edilmiş metni okumanın gerektiği ana kadar erteleyebilirdim ve tüm tokenları bellekte tutmama gerek kalmazdı, sadece okumak istediğim yeri bellekte tutmuş olurdum.</p>
<p>Clojure bu açında iyi mesela. Lazy bir dil değil aslında ama listeleri lazy bir şekilde oluşturabiliyoruz <code>lazy-seq</code> ile. Tam olarak benim ihtiyacım olan şey.</p>
<p>Aslında Common Lisp gibi okuyucusunun(Lisp konseptini yapancı olanlar için, derleyicinin bir kısmı diyebiliriz sanırım) kolayca değiştirilebildiği bir dilde bu çok zor bir olay değil. Hatta aslında Lisp’in temelini düşündüğünüzde, sadece <code>CONS</code>, <code>CAR</code> ve <code>CDR</code>ı lazy bir hale getirdiğinizde tüm listelerin lazy olmasını bekleyebilirsiniz(bekleyebilirsiniz diyorum çünkü muhtemelen bugün aktif olarak kullanılan Common Lisp implementasyonlarında tüm listeler <code>CONS</code> ile üretilmiyordur, performans vb. sebeplerden). Ama tabii böyle bir proje için bu tarz macrolar falan bana biraz abartı geldi, kodda da ciddi değişiklikler yapmak istemiyorum şu anda. Bir yolunu bulacağım artık.</p>
<p>Öyle işte, forklarınızı veya en azından yorumlarınızı bekliyorum(buralarda pek Lisper yok ama olsun ben şansımı deneyeyim hehe).</p>]]></summary>
</entry>
<entry>
    <title>Binary dosyaları okumak için basit bir DSL</title>
    <link href="http://osa1.net/posts/2012-01-31-binary-dosyalari-okumak-icin-basit-bir-dsl.html" />
    <id>http://osa1.net/posts/2012-01-31-binary-dosyalari-okumak-icin-basit-bir-dsl.html</id>
    <published>2012-01-31T00:00:00Z</published>
    <updated>2012-01-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Hiçbir motivasyonum olmaksızın Common Lisp ile uğraştığım şu günlerde(şu ana kadar kullandığım diller arasında bariz bir şekilde kullanması en zevkli olanı, bu konu hakkında bir yazı yazdım birkaç düzenlemeye hazır olur), staj projem için yaptığım çalışmalar sırasında öğrendiğim bazı şeyleri Common Lisp ile uyguluyorum. Bunlardan birisi de JVM yapısı. Common Lisp ile basit bir JVM işine giriştim. Şimdilik epey iyi gidiyorum, amacım birkaç JVM komutu(instructuion, opcode, artık ne derseniz) çalıştırabilen bir altyapı. Tüm native kütüphaneleriyle beraber Java programlarını çalıştırabilecek bir JVM yapmıyorum tabii ki.</p>
<p>İlk adım olarak bir Java class dosyasını okuyup, istediğim kısımlarına kolayla ulaşabileceğim bir şekilde yüklemekti. class dosyalarının yapısını <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">şuradan</a> inceleyebilirsiniz.</p>
<p>Bunu yaparken bazı kod parçalarının çok tekrar ettiğini farkettim, örneğin n byte’lık bir kısmı, bir sonraki kısımdan(bu 1 byte’lık bir veri de olabilir, tamamen farklı bir yapı da olabilir, örneğin bir interface referansı) kaç tane olduğunu bilmek için okumak. Şu şekilde birşeyler yani:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span class="kw">let*</span> ((constant-count (read-bytes <span class="dv">2</span> <span class="kw">stream</span>))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>       (constants (<span class="kw">make-array</span> constant-count)))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  (<span class="kw">loop</span> for i from <span class="dv">0</span> to (<span class="op">1-</span> constant-count) <span class="kw">do</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    (<span class="kw">setf</span> (<span class="kw">elt</span> constants i) (read-constant <span class="kw">stream</span>))))</span></code></pre></div>
<p>Burda yaptığım, 2 byte okuyarak constant pool’da kaç tane sabit olduğunu öğrenmek. Buna göre kaç byte daha okuyacağıma karar vereceğim çünkü.</p>
<p>Tabii bir de class dosyasının istediğim kısımlarına kolayca ulaşabilmek için dosyayı farklı parçaları için structlara bölmem gerekti. Bir yerden sonra her bir struct için farklı bir okuma fonksiyonu oluşturmuştum. Ve bu okuma fonksiyonlarında da bir sürü ortak kısım vardı. Bir DSL’e çevirmeye karar verdim.</p>
<p>Aslında DSL ile API’ın arasındaki fark tam belli değil. Benim DSL’den kastettiğim arayüzü sunarken kendisine özel bir syntax ile sunmak. Bu yaptığım biraz da yeni birşey öğrenince hemen uygulamaya çalışma merakı aslında.</p>
<p>Önce nasıl kullanıldığını göstereyim, sonra macrolardan bahsedeceğim. Tüm kodu görmek isteyenler için, <a href="https://gist.github.com/1706229">şu</a> class dosyasını ayrıştıran kod, <a href="https://gist.github.com/1704351">şu</a> da DSL macroları. Tüm class dosyasını tanımladığım yapı şöyle birşey:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>(defbinstruct class-file</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  (magic <span class="dv">4</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  (minor-version <span class="dv">2</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  (major-version <span class="dv">2</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  (constant-pool (:struct constant-pool))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  (access-flags <span class="dv">2</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  (this-class <span class="dv">2</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  (super-class <span class="dv">2</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  (:temp (interfaces-count <span class="dv">2</span>))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  (interfaces (:list <span class="dv">2</span> interfaces-count))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>  (:temp (fields-count <span class="dv">2</span>))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  (fields (:list (:struct field) fields-count))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>  (:temp (jmethods-count <span class="dv">2</span>))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>  (methods (:list (:struct jmethod) jmethods-count))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>  (:temp (attributes-count <span class="dv">2</span>))</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  (attributes (:list (:struct attribute) attributes-count)))</span></code></pre></div>
<p>Tanımın yukarıda linkini verdiğim class dosyası yapısına ne kadar benzediğine dikkat edin. Şöyle çalışıyor, her <code>defbinstruct</code> için bir <code>struct</code> oluşturuluyor, içindeki her bir liste için gerekiyorsa(<code>:temp</code> olup olmadığına göre) struct’a <code>slot</code> ekleniyor. <code>:temp</code> değişkenler farklı amaçlar için gerekebilir. Örneğin dosyadaki boşluklar(<code>padding</code> diye geçer genelde) için, veya dosyada bir yapıdan kaç tane olduğunu okumanız gerektiğinde, ama bu değeri okuduyup oluşturduğunuz yapıya dahil etmek istemiyorsanız. Her bir <code>defbinstruct</code> için bir de okuma fonksiyonu oluşturuluyor, yapının adına “read” eklenerek(burdaki örnek için <code>read-class-file</code> yani).</p>
<p>Değişken isminden sonra gelen kısım eğer tamsayı ise, o tamsayı kadar byte okunup bu slota atanıyor, eğer <code>(:list a b)</code> veya <code>(:vector a b)</code> şeklinde birşeyse, <code>a</code>dan <code>b</code> kere okunup, liste veya vector olarak atanıyor. Eğer tamsayı kısmına <code>(:struct a)</code> gibi birşey gelmişse, <code>a</code>nın bir <code>defbinstruct</code> ile oluşturulmuş yapı olması gerekiyor(yani <code>read-a</code> diye bir fonksiyon olmalı). Bu tanımlamaların recursive bir formda olabileceğine dikkat. Şöyle birşey olabilir mesela: <code>(field-1 (:list (:list (:struct sub-field) sub-field-count) field-count))</code>.</p>
<p>Dönüş değeri de tanımladığınız yapıdan oluşturulmuş bir <code>struct</code>. Örnekteki kodda <code>class-file-interfaces</code> ile interfaces alanına ulaşabilirsiniz mesela.</p>
<p>Okunan değerlere göre daha kompleks işler yapmanız gerektiğinde <code>:custom</code> keywordu ile <code>read</code> fonksiyonunu kendiniz tanımlayabilirsiniz. <code>:custom</code> keywordunden sonraki kısım da yapıda olacak slotların listesi. Örneğin <code>constant-pool</code>u okumak biraz daha zor(mesela double ve long sabitler constant-pool’da 2 slot kaplıyor), şöyle:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(defbinstruct constant-pool</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  :custom</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  (constants)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  (<span class="kw">let*</span> ((constant-pool-count (<span class="op">1-</span> (read-bytes <span class="dv">2</span> <span class="kw">stream</span>)))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>         (constants (<span class="kw">make-array</span> constant-pool-count)))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    (<span class="kw">loop</span> for i from <span class="dv">0</span> to (<span class="op">1-</span> constant-pool-count) <span class="kw">do</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>      (<span class="kw">let</span> ((tag (read-bytes <span class="dv">1</span> <span class="kw">stream</span>)))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>        (<span class="kw">if</span> (<span class="kw">or</span> (<span class="op">=</span> tag <span class="dv">5</span>) (<span class="op">=</span> tag <span class="dv">6</span>))</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>            (<span class="kw">let</span> ((constant (<span class="kw">if</span> (<span class="op">=</span> tag <span class="dv">5</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>                                (read-jlong <span class="kw">stream</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>                                (read-jdouble <span class="kw">stream</span>))))</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>              (<span class="kw">setf</span> (<span class="kw">elt</span> constants i) constant</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>                    (<span class="kw">elt</span> constants (<span class="op">1+</span> i)) constant)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>              (<span class="kw">incf</span> i))</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>            (<span class="kw">setf</span> (<span class="kw">elt</span> constants i)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>                  (<span class="kw">funcall</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>                   (<span class="kw">case</span> tag</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>                     (<span class="dv">1</span> #&#39;read-utf<span class="dv">-8</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>                     (<span class="dv">8</span> #&#39;read-string-ref)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>                     (<span class="dv">3</span> #&#39;read-jinteger)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>                     (<span class="dv">4</span> #&#39;read-jfloat)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>                     (<span class="dv">7</span> #&#39;read-class-ref)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>                     (<span class="dv">9</span> #&#39;read-field-ref)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>                     (<span class="dv">10</span> #&#39;read-method-ref)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>                     (<span class="dv">11</span> #&#39;read-interface-method-ref)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>                     (<span class="dv">12</span> #&#39;read-descriptor))</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>                   <span class="kw">stream</span>)))))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>    (make-constant-pool :constants constants)))</span></code></pre></div>
<p>Bu tanımladığımız read fonksiyonuna <code>stream</code> diye bir parametre aktarıldığını varsayıyoruz(macro tarafından oluşturulmuş kodda aktarılıyor). Burda aslında stream yerine lexical scope ile <code>*standard-input*</code>a bu <code>stream</code> atanabilir. Yine de çaktırmadan <code>*standard-input*</code> ile oynamak bana çok iyi bir yolmuş gibi gelmedi.</p>
<p>Bir başka örnek olarak da yine constant-pooldaki string sabitlerini nasıl okuduğumu göstereyim:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(defbinstruct utf<span class="dv">-8</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  (:temp (<span class="kw">length</span> <span class="dv">2</span>))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  (value (:vector <span class="dv">1</span> <span class="kw">length</span>)))</span></code></pre></div>
<p>İlk 2 byte, string’in uzunluğunu veriyor. Daha sonra bu uzunluk kadar 1 byte okuyup bir vector olarak kaydediyorum.</p>
<p>Şimdi macrolara bakalım. İlk önce <code>defbinstruct</code> kodundaki keywordleri(<code>:vector</code>, <code>:list</code>, <code>:struct</code>) recursive olarak silip yerine gerekli Lisp kodunu ekleyen <code>remove-keywords</code> macrosu:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> remove-keywords </span>(form)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  (<span class="kw">cond</span> ((<span class="kw">null</span> form) &#39;())</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        ((<span class="kw">integerp</span> form)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>         `(read-bytes ,form <span class="kw">stream</span>))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        ((<span class="kw">and</span> (<span class="kw">consp</span> form) (<span class="kw">keywordp</span> (<span class="kw">first</span> form)))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>         (<span class="kw">case</span> (<span class="kw">first</span> form)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>           ((:list)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>            `(<span class="kw">loop</span> for s from <span class="dv">0</span> to (<span class="op">1-</span> ,(<span class="kw">third</span> form))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>                   collect (remove-keywords ,(<span class="kw">second</span> form))))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>           ((:vector)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>            `(<span class="kw">coerce</span> (<span class="kw">loop</span> for s from <span class="dv">0</span> to (<span class="op">1-</span> ,(<span class="kw">third</span> form))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>                           collect (remove-keywords ,(<span class="kw">second</span> form)))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>                     &#39;vector))</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>           ((:struct)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>            `(,(<span class="kw">intern</span> (<span class="kw">concatenate</span> &#39;string <span class="st">&quot;READ-&quot;</span> (<span class="kw">string</span> (<span class="kw">second</span> form)))) <span class="kw">stream</span>))))</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>        (<span class="kw">t</span> form)))</span></code></pre></div>
<p>Yaptığı şey çok basit, her <code>:struct</code> keywordu gördüğü yere <code>(read-x)</code> fonksiyonunu ekliyor, <code>:list</code> veya <code>:vector</code> gördüğü yerde de gereken <code>loop</code> kodunu. İkinci olarak olarak <code>defbinstruct</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> defbinstruct </span>(name &amp;body attributes)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  (<span class="kw">labels</span> ((make-reader-name (name-symbol)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>             (<span class="kw">intern</span> (<span class="kw">concatenate</span> &#39;string <span class="st">&quot;READ-&quot;</span> (<span class="kw">string</span> name-symbol)))))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    (<span class="kw">if</span> (<span class="kw">and</span> (<span class="kw">keywordp</span> (<span class="kw">first</span> attributes))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>             (<span class="kw">eql</span> (<span class="kw">first</span> attributes) :custom))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        (<span class="kw">let</span> ((attributes (<span class="kw">second</span> attributes))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>              (body (<span class="kw">cddr</span> attributes)))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>          `(<span class="kw">progn</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>             (<span class="kw">defstruct</span><span class="fu"> </span>,name</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>               ,@attributes)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>             (<span class="kw">defun</span><span class="fu"> </span>,(make-reader-name name) (<span class="kw">stream</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>               ,@body)))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>        (<span class="kw">let</span> ((attr-struct-names (<span class="kw">remove-if-not</span> #&#39;identity</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>                                                (<span class="kw">mapcar</span> (<span class="kw">lambda</span> (attr)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>                                                          (<span class="kw">unless</span> (<span class="kw">keywordp</span> (<span class="kw">first</span> attr))</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>                                                            (<span class="kw">first</span> attr)))</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>                                                        attributes))))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>          `(<span class="kw">progn</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>             (<span class="kw">defstruct</span><span class="fu"> </span>,name</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>               ,@attr-struct-names)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>             (<span class="kw">defun</span><span class="fu"> </span>,(make-reader-name name) (<span class="kw">stream</span>)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>               (<span class="kw">let*</span> (,@(<span class="kw">mapcar</span> (<span class="kw">lambda</span> (attr)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>                                  (<span class="kw">destructuring-bind</span> (attr-name . bytes)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>                                      (<span class="kw">if</span> (<span class="kw">keywordp</span> (<span class="kw">first</span> attr))</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>                                          (<span class="kw">cons</span> (<span class="kw">caadr</span> attr) (<span class="kw">cadadr</span> attr))</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>                                          (<span class="kw">cons</span> (<span class="kw">first</span> attr) (<span class="kw">second</span> attr)))</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>                                    `(,attr-name ,(<span class="kw">if</span> (<span class="kw">integerp</span> bytes)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>                                                      `(read-bytes ,bytes <span class="kw">stream</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>                                                      `(remove-keywords ,bytes)))))</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>                                attributes))</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>                 </span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>                 (,(<span class="kw">intern</span> (<span class="kw">concatenate</span> &#39;string <span class="st">&quot;MAKE-&quot;</span> (<span class="kw">string</span> name)))</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>                  ,@(<span class="kw">mapcan</span> (<span class="kw">lambda</span> (name) (<span class="kw">list</span> (<span class="kw">intern</span> (<span class="kw">string</span> name) <span class="st">&quot;KEYWORD&quot;</span>) name))</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>                            attr-struct-names)))))))))</span></code></pre></div>
<p>Burda da <code>defbinstruct</code> altındaki listeleri gezip, oluşturulacak olan <code>struct</code>a gerekli <code>slot</code>ları ekliyorum ve <code>read</code> fonksiyonunu oluşturuyorum. Her bir <code>defbinstruct</code> için bir <code>struct</code> bir de fonksiyon tanımlıyorum yani.</p>
<p>Kütüphane toplam 52 satır. İkinci bir örnek olarak da ID3 etiketlerini okuyacaktım ama çok kompleks geldi. Dikkat edilmesi gereken çok fazla istisna var. Aklıma daha basit bir örnek gelirse ekleyeceğim(ara ara kütüphaneyi de güncelliyorum, gistlerden takip edebilirsiniz).</p>]]></summary>
</entry>
<entry>
    <title>Common Lisp için Clojure usulü multimethodlar</title>
    <link href="http://osa1.net/posts/2012-01-08-common-lisp-icin-clojure-usulu-multimethodlar.html" />
    <id>http://osa1.net/posts/2012-01-08-common-lisp-icin-clojure-usulu-multimethodlar.html</id>
    <published>2012-01-08T00:00:00Z</published>
    <updated>2012-01-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bir önceki yazımda biraz bahsetmiştim Clojure ve Common Lisp multimethodları arasındaki farklardan. Bugün Common Lisp için olabilecek en basit Clojure usulü multimethod implementasyonu yaptım. 2 macro ve toplamda 14 satır sürdü. Örnek olarak Joy of Clojure kitabındaki bir kod parçasını Common Lisp ile yazacağım. Clojure hali şöyle:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span class="bu">defmulti</span><span class="fu"> compiler </span><span class="at">:os</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>(<span class="bu">defmethod</span><span class="fu"> compiler </span><span class="at">::unix</span> [m] (<span class="kw">get</span> m <span class="at">:c-compiler</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>(<span class="bu">defmethod</span><span class="fu"> compiler </span><span class="at">::osx</span>  [m] (<span class="kw">get</span> m <span class="at">:c-compiler</span>))</span></code></pre></div>
<p>Burda yapılan şey şu, <code>compiler</code> adlı bir multimethod oluşturuluyor ve dispatch fonksiyonunu seçmek için kullanılacak fonksiyon olarak <code>:os</code> keywordu olarak belirleniyor<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Daha sonra iki tane method tanımlanıyor, ilkinde test fonksiyonumuz(yani <code>:os</code> fonksiyonu) <code>:unix</code> keywordünü dönerse çalıştırılacak fonksiyon, ikincisinde de <code>:osx</code> keywordünü dönerse çalıştırılacak fonksiyonu belirleniyor. Test fonksiyonuna da <code>m</code> parametresinin aktarıldığına dikkat. Yani <code>m</code> önce test fonksiyonu tarafından kullanılıyor, sonra da dönüş değerine göre dispatch fonksiyonlarından biri tarafından.</p>
<p>Kullanımı şöyle:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> unix </span>{<span class="at">:os</span> <span class="at">::unix</span>, <span class="at">:c-compiler</span> <span class="st">&quot;cc&quot;</span>})</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> osx  </span>{<span class="at">:os</span> <span class="at">::osx</span>,  <span class="at">:c-compiler</span> <span class="st">&quot;gcc&quot;</span>})</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>(compiler unix)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>=&gt; <span class="st">&quot;cc&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>(compiler osx)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>=&gt; <span class="st">&quot;gcc&quot;</span></span></code></pre></div>
<p>multimethodların test fonksiyonunu ve bunun dönüş değerlerine karşılık gelen dispatch fonksiyonlarını tutmaları lazım. dönüş değeri-dispatch fonksiyonu ikililerini bir hash-table’da tuttum. Her bir multimethod için 2 tane closure oluşturdum, bir tanesi yeni methodlar eklemek istediğimizde çağırılık dönüş değeri-dispatch fonksiyonları ikililerini tutan hash-table’ı güncelleyecek, diğeri de testi yapıp hash-table’dan fonksiyonu çekip çağıracak.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> defmulti </span>(name (&amp;<span class="kw">rest</span> args) dispatch-fn)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((dispatch-table (<span class="kw">gensym</span>)))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    `(<span class="kw">let</span> ((,dispatch-table (<span class="kw">make-hash-table</span> <span class="bu">:test</span> #&#39;equal)))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>       (<span class="kw">defun</span><span class="fu"> </span>,name (,@args)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>         (<span class="kw">funcall</span> (<span class="kw">gethash</span> (<span class="kw">funcall</span> ,dispatch-fn ,@args) ,dispatch-table)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>                  ,@args))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>       (<span class="kw">defun</span><span class="fu"> </span>,(<span class="kw">intern</span> (<span class="kw">concatenate</span> &#39;string (<span class="kw">string</span> name) <span class="st">&quot;-ADD-METHOD&quot;</span>))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>           (dispatch-fn-return-val <span class="kw">method</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>         (<span class="kw">setf</span> (<span class="kw">gethash</span> dispatch-fn-return-val ,dispatch-table) <span class="kw">method</span>)))))</span></code></pre></div>
<p>Görüldüğü gibi multimethodlar aslında normal fonksiyonlar(aslında closure, <code>dispatch-table</code>ı tutuyor). Bu sayede herhangi bir fonksiyona aktarılabilirler. Özel bir yapı yok yani ortada. Bir de aslında çaktırmadan tanımladığımız multimethod’a <code>-add-method</code> eki getirerek bir fonksiyon daha oluşturuyoyruz. Bunu kullanıcının çağırmasına hiç gerek yok, sadece yeni method ekleme işlemini kolaylaştırmak için.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> defmulmethod </span>(name dispatch-fn-return-val <span class="kw">method</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  `(,(<span class="kw">intern</span> (<span class="kw">concatenate</span> &#39;string (<span class="kw">string</span> name) <span class="st">&quot;-ADD-METHOD&quot;</span>))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    ,dispatch-fn-return-val</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    ,<span class="kw">method</span>))</span></code></pre></div>
<p><code>defmethod</code> adı Common Lisp’e ait olduğundan adını <code>defmulmethod</code> yaptım. Önceki macroda oluşturulan <code>-add-method</code> fonksiyonu yardımıyla <code>dispatch-table</code>a yeni fonksiyonu ekliyor. Bundan sonra aynı örneği Common Lisp ile şöyle yapabiliriz.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(defmulti compiler (x) (<span class="kw">lambda</span> (x) (<span class="kw">gethash</span> :os x)))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>(defmulmethod compiler :unix (<span class="kw">lambda</span> (x) (<span class="kw">gethash</span> :c-compiler x)))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>(defmulmethod compiler :osx (<span class="kw">lambda</span> (x) (<span class="kw">gethash</span> :c-compiler x)))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>(<span class="kw">setf</span> unix (<span class="kw">make-hash-table</span>))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>(<span class="kw">setf</span> (<span class="kw">gethash</span> :os unix) :unix)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>(<span class="kw">setf</span> (<span class="kw">gethash</span> :c-compiler unix) :cc)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>(<span class="kw">setf</span> osx (<span class="kw">make-hash-table</span>))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>(<span class="kw">setf</span> (<span class="kw">gethash</span> :os osx) :osx)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>(<span class="kw">setf</span> (<span class="kw">gethash</span> :c-compiler osx) :gcc)</span></code></pre></div>
<pre><code>CL-USER&gt; (compiler unix)
:CC

CL-USER&gt; (compiler osx)
:GCC</code></pre>
<p>Common Lisp halinin çok daha uzun olmasının birkaç sebebi var: Birincisi, Common Lisp hash-tablelarının başlangıç değerlerini belirlemenin bir yolu yok. hash-table’ların özel bir syntax’ı da yok. <code>make-hash-table</code> ile oluşturup teker teker elemanları koymamız gerekiyor. İkincisi, <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> notta yazdığım şey.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Clojure hakkında sevdiğim bir özellik, keywordler aynı zamanda fonksiyon, çağırıldıklarında parametre olarak bir map alıyorlar ve anahtar görevi görerek değeri dönüyorlar.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Clojure hakkında sevdiğim bir özellik, keywordler aynı zamanda fonksiyon, çağırıldıklarında parametre olarak bir map alıyorlar ve anahtar görevi görerek değeri dönüyorlar.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Common Lisp ile IRC botu ve web arayüzü</title>
    <link href="http://osa1.net/posts/2012-01-06-common-lisp-ile-irc-botu-ve-web-arayuzu.html" />
    <id>http://osa1.net/posts/2012-01-06-common-lisp-ile-irc-botu-ve-web-arayuzu.html</id>
    <published>2012-01-06T00:00:00Z</published>
    <updated>2012-01-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Tamamen Common Lisp ile basit bir IRC botu ve web arayüzünün nasıl yazılabileceğinden bahsedeceğim biraz. Web kısmında web server dahil herşey yine Common Lisp ile yazılmış olacak.</p>
<p><img src="/images/made-with-lisp-logo.jpg" /></p>
<p>Gistler: <a href="https://gist.github.com/1570375">arayüz</a> <a href="https://gist.github.com/1566862">bot</a></p>
<p>Öncelikle botun ne yapacağına karar verelim, benim amacım çalışan en minimal botu yazmak. Daha sonra üzerine istediğimiz özelliği ekleyebiliriz. Bu yüzden şimdilik sadece bağlandığı kanalları ve kendisine atılan özel mesajları kaydedip, bir web sayfasında yayınlayacak.</p>
<figure>
<img src="/images/bot-web-ui.png" alt="" /><figcaption>/images/bot-web-ui.png</figcaption>
</figure>
<p>Öncelikle IRC sunucusuna bağlanabilmemiz için bir socket kütüphanesine ihtiyacımız var(evet Common Lisp standardı socket içermiyor). Bu iş için <a href="http://common-lisp.net/project/usocket/">usocket</a>’i seçtim(uğraşacak olan varsa bir diğer alternatif de <a href="http://common-lisp.net/project/iolib/">iolib</a>, fakat ikisi için de işe yarar dökümantasyon yok dolayısıyla her türlü yolumuzu kendimiz bulmamız gerek).</p>
<p>Programımızın ana döngüsü gayet basit:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span class="kw">defun</span><span class="fu"> run </span>()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  (<span class="kw">let*</span> ((socket (socket-connect <span class="st">&quot;irc.freenode.org&quot;</span> <span class="dv">8001</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>         (socket-stream (socket-stream socket))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>         (start-time (<span class="kw">get-universal-time</span>)))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    (<span class="kw">loop</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>      (<span class="kw">let</span> ((msg (<span class="kw">read-line</span> socket-stream)))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;~A~%&quot;</span> msg) <span class="co">;; debug ve gozetleme amacli</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        (<span class="kw">multiple-value-bind</span> (prefix command params) (parse-msg msg)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>          (handle-command prefix (<span class="kw">intern</span> (<span class="kw">string-upcase</span> command)) params socket-stream)))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>      (<span class="kw">let</span> ((time-passed (<span class="op">-</span> (<span class="kw">get-universal-time</span>) start-time)))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>        (<span class="kw">when</span> (<span class="op">&gt;</span> time-passed (<span class="op">*</span> <span class="dv">1</span> <span class="dv">30</span>))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>          (update-html)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>          (<span class="kw">setf</span> start-time (<span class="kw">get-universal-time</span>)))))))</span></code></pre></div>
<p>Bir socket oluşturup Freenode sunucularına bağlanıyoruz. Socket’e yazma ve socket’den okuma işlemlerini socket’in stream’ine yapacağız<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <code>read-line</code> ile sunucudan her seferinde bir tam satır okuyoruz ve <code>parse-msg</code>a gönderiyoruz. <code>parse-msg</code> gelen mesajı <a href="http://www.irchelp.org/irchelp/rfc/rfc.html">IRC RFC</a>’de belirtilen mesaj formatında göre <code>prefix</code>, <code>command</code> ve <code>params</code> olarak 3 parçaya bölüyor ve Common Lisp’in <code>values</code> özel formu ile bunları dönüyor<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Daha sonra bu parçaları <code>handle-command</code> generic fonksiyonuna gönderiyoruz. <code>handle-command</code> <code>command</code> parametresine göre gerekli dispatch fonksiyonunu çağırıyor<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Daha basit olamazdı. Son olarak yeterli vakit geçtiyse(ben 30 saniyede bir güncelliyordum sık sık debug ile uğraştığımdan), static html sayfalarını güncelleyecek olan <code>update-html</code>i çağırıyoruz. Burda zamanı çok da düzgün tutmadığımıza dikkat. Eğer socket’den 10 dakika yanıt gelmezse 30 saniyede bir de güncelliyor olsak 10 dakika beklemek zorundayız<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Mesajları parçalara ayıran fonksiyonumuz şöyle:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>(<span class="kw">defun</span><span class="fu"> parse-msg </span>(msg)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="st">&quot;Parse irc message to prefix, command and params.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="st">http://www.irchelp.org/irchelp/rfc/chapter2.html#c2_3_1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="st">&lt;message&gt; ::=</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="st">    [&#39;:&#39; &lt;prefix&gt; &lt;SPACE&gt; ] &lt;command&gt; &lt;params&gt; &lt;crlf&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="st">&lt;prefix&gt; ::=</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="st">    &lt;servername&gt; | &lt;nick&gt; [ &#39;!&#39; &lt;user&gt; ] [ &#39;@&#39; &lt;host&gt; ]</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="st">&lt;command&gt; ::=</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="st">    &lt;letter&gt; { &lt;letter&gt; } | &lt;number&gt; &lt;number&gt; &lt;number&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="st">&lt;params&gt; ::=</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="st">    &lt;SPACE&gt; [ &#39;:&#39; &lt;trailing&gt; | &lt;middle&gt; &lt;params&gt; ]</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="st">&quot;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>  (<span class="kw">let*</span> ((first-space (<span class="kw">position</span> <span class="ch">#\s</span>pace msg))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>         (<span class="kw">first</span> (<span class="kw">subseq</span> msg <span class="dv">0</span> first-space))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>         (<span class="kw">rest</span> (<span class="kw">subseq</span> msg (<span class="op">1+</span> first-space)))</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>         (prefix (<span class="kw">if</span> (<span class="kw">eq</span> (<span class="kw">elt</span> <span class="kw">first</span> <span class="dv">0</span>) <span class="ch">#\:</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>                     (<span class="kw">subseq</span> <span class="kw">first</span> <span class="dv">1</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>                     <span class="kw">nil</span>))</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>         (second-space (<span class="kw">position</span> <span class="ch">#\s</span>pace <span class="kw">rest</span>)))</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>    (<span class="kw">if</span> prefix</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>        (<span class="kw">let</span> ((command (<span class="kw">subseq</span> <span class="kw">rest</span> <span class="dv">0</span> second-space))</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>              (params (<span class="kw">subseq</span> <span class="kw">rest</span> (<span class="op">1+</span> second-space))))</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>          (<span class="kw">values</span> prefix command params))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>        (<span class="kw">let</span> ((command (<span class="kw">subseq</span> <span class="kw">first</span> <span class="dv">0</span> first-space))</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>              (params <span class="kw">rest</span>))</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>          (<span class="kw">values</span> <span class="kw">nil</span> command params)))))</span></code></pre></div>
<p>Ben burda ciddi bir şekilde parse etmektense, önek, komut ve parametreleri birbirlerinden ayıran boşluklar olduğunu farkettim ve basitçe bu boşluklara göre ayırdım. Saatlerdir log tutuyor henüz bir problem yaşamadım.</p>
<p>Mesajları parçaladıktan sonra şu generic fonksiyona gönderiyoruz:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(<span class="kw">defgeneric</span><span class="fu"> handle-command </span>(prefix command params socket-stream))</span></code></pre></div>
<p>Bu fonksiyonu çağırırken <code>command</code> parametresinin her zaman bir sembol olması lazım. Başka türlü command parametresine göre dispatch fonksiyonuna karar veremiyoruz<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Ana döngüde string’i sembole çevirdiğim hacky kısım bu yüzden.</p>
<p>Şu aşamada ilgimizi çeken 3 komut var. <code>PRIVMSG</code>, <code>NOTICE</code>, ve <code>PING</code>. <code>PING</code> komutunu sunucu bize, uzun süre yanıt vermediğimiz için gönderecek(sürekli dinlemede olacağımızdan) ve hemen <code>PONG</code> cevabını vermemiz lazım. <code>PRIVMSG</code> herhangi bir kanala veya bize bir mesaj gönderildiğinde gelecek. <code>NOTICE</code>de ne zaman login olmak için komut göndermemiz gerektiğine karar vermemiz için. Burda en kritik olanı <code>PRIVMSG</code>, diğerlerine gist’den bakabilirsiniz:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(<span class="kw">defmethod</span><span class="fu"> handle-command </span>(prefix (command (<span class="kw">eql</span> &#39;privmsg)) params socket-stream)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  (<span class="kw">let</span> ((channel-or-nick (<span class="kw">subseq</span> params <span class="dv">0</span> (<span class="kw">position</span> <span class="ch">#\s</span>pace params)))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        (sender (<span class="kw">subseq</span> prefix <span class="dv">0</span> (<span class="kw">position</span> <span class="ch">#\!</span> prefix)))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        (msg (<span class="kw">subseq</span> params (<span class="op">+</span> <span class="dv">2</span> (<span class="kw">position</span> <span class="ch">#\s</span>pace params)))))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    (<span class="kw">multiple-value-bind</span> (channel-message-queue channel-exists)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        (<span class="kw">gethash</span> channel-or-nick *channels*)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>      (<span class="kw">unless</span> channel-exists</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        (<span class="kw">setf</span> (<span class="kw">gethash</span> channel-or-nick *channels*) &#39;()))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>      (<span class="kw">setf</span> (<span class="kw">gethash</span> channel-or-nick *channels*)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>            (<span class="kw">cons</span> (make-message :msg msg</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>                                :sender sender) channel-message-queue)))))</span></code></pre></div>
<p><code>*channels*</code>, tüm kanallar için bir liste tuttuğumuz hash tablomuz. Burda static web sayfalarını güncelleme vaktimiz gelene kadar gelen mesajları tutuyoruz(gelen mesajı yine IRC RFC’nin <a href="http://www.irchelp.org/irchelp/rfc/chapter4.html#c4_4_1">şu bölümü</a>ne göre parçalıyorum). Mesajları tuttuğumuz yapımız basitçe sadece mesajın içeriğini ve göndereni tutuyor:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span class="kw">defstruct</span><span class="fu"> message </span>msg sender)</span></code></pre></div>
<p>Son olarak static sayfaları güncellemek için çağırdığımız <code>update-html</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>(<span class="kw">defun</span><span class="fu"> update-html </span>()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  (<span class="kw">loop</span> for channel-or-nick being <span class="kw">the</span> hash-keys of *channels* <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    (<span class="kw">let</span> ((msgs (<span class="kw">reverse</span> (<span class="kw">gethash</span> channel-or-nick *channels*))))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>      (<span class="kw">with-open-file</span> (<span class="kw">file-stream</span> (concat <span class="st">&quot;/home/sinan/Desktop/cl/logs/&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>                                           (<span class="kw">if</span> (<span class="kw">equal</span> <span class="ch">#\#</span> (<span class="kw">elt</span> channel-or-nick <span class="dv">0</span>))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>                                               (<span class="kw">subseq</span> channel-or-nick <span class="dv">1</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>                                               <span class="st">&quot;direct-messages&quot;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>                                           <span class="st">&quot;.html&quot;</span>) <span class="co">;; remove # from channel name</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>                                   <span class="bu">:direction</span> <span class="bu">:output</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>                                   :if-exists <span class="bu">:append</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>                                   :if-does-not-exist <span class="bu">:create</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>        (with-html-output (<span class="kw">file-stream</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>          (<span class="kw">dolist</span> (msg msgs)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>            (<span class="kw">let</span> ((message-text (concat (message-sender msg)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>                                        <span class="st">&quot;&gt; &quot;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>                                        (message-msg msg))))</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>              (htm (:p :class <span class="st">&quot;msg&quot;</span> (str message-text)))))))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>      (<span class="kw">setf</span> (<span class="kw">gethash</span> channel-or-nick *channels*) &#39;()))))</span></code></pre></div>
<p>Burda html çıktısını üretmek için <a href="http://weitz.de/cl-who/">cl-who</a> kütüphanesini kullanıyoruz<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> <code>with-open-file</code> ile kanal adına ait dosyayı açıp(yoksa oluşturup, varsa sonuna ekleyerek) <code>with-html-output</code> ile html elementlerini Lisp formları ve keywordler ile yazarak html kodunu dosyaya yazıyoruz ve hash tablomuzdaki mesaj listesini boşaltıyoruz(henüz tüm sayfayı oluşturmuyoruz, sadece mesajları html formatında kaydettik).</p>
<p>Şu anda sunucuda istediğiniz kanalları dinleyip kaydeden bir botumuz var(kod hakkında eksik olan birkaç tanımlama için en başta verdiğim gistlere bakabilirsiniz).</p>
<p>İkinci adım olarak web arayüzü. Static sayfaları sunmak için <a href="http://weitz.de/hunchentoot/">Hunchentoot</a> kullanacağız. Bu gibi basit işler için inanılmaz rahat bir kütüphane.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>(<span class="kw">defvar</span><span class="fu"> server </span>(<span class="kw">make-instance</span> &#39;easy-acceptor :port <span class="dv">4242</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>                                             :document-root <span class="st">&quot;/home/sinan/Desktop/cl/static&quot;</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>(start server)</span></code></pre></div>
<p>Hunchentoot ile 4242. portu dinleyen bir sunucu oluşturduk ve başlattık. <code>document-root</code>, static dosyaların(css dosyaları, resimler vs.) tutulduğu klasör. Hunchentoot sayfa yönlendirmelerini <code>*dispatch-table*</code> listesinden yapıyor. Yönlendirme işlemi birkaç farklı dispatcher ile yapılabiliyor ama biz şu anki basit sayfamız için sadece kanal adlarını yönlendirmekle ilgileneceğiz. Bu yüzden kullanacağımız dispatcher <code>prefix-dispatcher</code> olacak.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> define-url-fn </span>((name) &amp;body body)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  `(<span class="kw">progn</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>     (<span class="kw">defun</span><span class="fu"> </span>,name ()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>       ,@body)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>     (<span class="kw">push</span> (create-prefix-dispatcher ,(<span class="kw">format</span> <span class="kw">nil</span> <span class="st">&quot;/~(~a~).html&quot;</span> name) &#39;,name) *dispatch-table*)))</span></code></pre></div>
<p>Genel olarak sayfa oluşturma yapımız bu. <code>(define-url-fn (sayfa-adi) icerik)</code> şeklinde çağırdığımızda, <code>localhost:4242/sayfa-adi</code> adresinde <code>icerik</code>i gösterek şekilde ayarlıyor. Bu kadar basit. Şimdi sayfa içeriğimizi oluşturmadan önce her sayfada olacak kısımları ayıralım:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>(<span class="kw">defmacro</span><span class="fu"> standard-page </span>((&amp;key title) &amp;body body)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  `(with-html-output-to-string (<span class="va">*standard-output*</span> <span class="kw">nil</span> :prologue <span class="kw">t</span> :indent <span class="kw">t</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>     (:html</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>      (:meta :charset <span class="st">&quot;utf-8&quot;</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>      (:head</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>       (:title ,title)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>       (:link <span class="bu">:type</span> <span class="st">&quot;text/css&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>              :rel <span class="st">&quot;stylesheet&quot;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>              :href <span class="st">&quot;/static/reset.css&quot;</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>       (:link <span class="bu">:type</span> <span class="st">&quot;text/css&quot;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>              :rel <span class="st">&quot;stylesheet&quot;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>              :href <span class="st">&quot;/static/main.css&quot;</span>))</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>      (:body</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>       (:div :class <span class="st">&quot;main&quot;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>             ,@body)))))</span></code></pre></div>
<p>Bu şekilde sadece bir sayfayı diğer sayfadan ayıracak kısımlarla ilgileneceğiz ve <code>standard-page</code> macrosuna göndereceğiz. Web arayüzümüz tamamen ayrı bir program olduğundan, önce logların tutulduğu klasöre bakıp kanal listesini çıkaralım:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>(<span class="kw">defun</span><span class="fu"> list-file-names </span>(&amp;optional (folder *log-folder*))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  (<span class="kw">mapcar</span> (<span class="kw">lambda</span> (<span class="kw">pathname</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>            (<span class="kw">let</span> ((filename (<span class="kw">file-namestring</span> <span class="kw">pathname</span>)))</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>              (<span class="kw">pathname-name</span> filename)))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>          (<span class="kw">directory</span> (<span class="kw">make-pathname</span> <span class="bu">:directory</span> folder <span class="bu">:name</span> :wild <span class="bu">:type</span> <span class="st">&quot;html&quot;</span>))))</span></code></pre></div>
<p>Burda yapılan bariz gibi. Bir klasördeki html dosyalarının adlarını listeliyoruz. Bu kadar. Bu aşamadan sonra ana menü(kanal listesinin bulunduğu) ve kanal loglarının görüntüleneceği sayfaları oluşturmak kalıyor.</p>
<pre><code>;; ana menu
(define-url-fn (log-list)
  (standard-page (:title &quot;log list&quot;)
    (:div :class &quot;header&quot; &quot;Channel List:&quot;)
    (loop for log in (list-file-names)
          collect (htm (:div :class &quot;menulink&quot;
                             (:a :href (concat log &quot;.html&quot;) (str log)))))))</code></pre>
<p>Kanal log sayfalarını oluşturmak biraz zor oldu ve aslında yukarıda hazırladığım hiçbir macroyu kullanmadım. Benim gibi herhangi bir Lisp diline yeni başlayanlara bir not(gerçi Scheme macroları epey farklıymış, pattern matching yapabiliyorlarmış ve hijyeniklermiş): Bir macroya parametre olarak macro alan bir macro gönderiyorsanız ve macrolara tam olarak hakim değilseniz, debug etmek yerine elle yazmak daha pratik olabilir ehehe:</p>
<pre><code>;; kanal loglari
(dolist (page-name (list-file-names))
  (let* ((in (open (merge-pathnames *log-folder*
                                    (make-pathname :name page-name
                                                   :type &quot;html&quot;))))
         (text (car (loop for line = (read-line in nil)
                          while line collect line))))
    (push
     (create-prefix-dispatcher
      (concat &quot;/&quot; page-name &quot;.html&quot;)
      (lambda ()
        (standard-page (:title &quot;Channel logs&quot;)
          (:div :class &quot;header&quot; (str (concat &quot;Chat logs for #&quot; page-name)))
          (str text))))
     *dispatch-table*)))</code></pre>
<p>Ve bu kadar. Bot + web arayüzü toplamda 207 satır. Yorumlar dahil.</p>
<p>Eklenebilecekler:</p>
<ul>
<li>Common Lisp HyperSpec Lookup: Kendisine atılan bir mesajla CLHS’den istenilen sembolle alakalı döküman linkini getirebilir.</li>
<li>Link başlıkları: Kanala atılan linklere girip başlığı kanala yazabilir.</li>
<li>Çok sorulan sorular için cevaplar: Yetki verilen bazı kullanıcılar belirli komutlar için yazılacak cevabı belirleyebilir. Birisi bir soru sorduğunda bota ona istenilen cevabı vermesi söylenebilir.</li>
<li>Hata/durum(exception/condition) kontrolü. Bağlantı bir şekilde kesildiğinde yeniden bağlanabilir vs.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Common Lisp’in bir güzel yanı, lexical scope veya direkt olarak parametre olarak aktararak, kullanıcıya yazdırıp kullanıcıdan okuduğumuz fonksiyonların hepsini dosya, socket vs. için çok rahat kullanabiliyoruz<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Common Lisp’de bir fonksiyon birden fazla değer dönebiliyor, epey ilginç bir özellik, gerekliliği tartışılır tabii, sonuçta bir tuple/list/vs. dönmekten pek bir farkı yok, yanlızca eğer özel olarak belirtilmezse çağırana sadece otomatik olarak ilk değer dönüyor böylece her fonkisyon için “acaba kaç değer dönüyor?” diye düşünmüyoruz.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Burada Clojure’dan bahsetmem lazım. Clojure multimethod’ları isteğe bağlı dispatch fonksiyonları ile çalışıyorken Common Lisp bu konuda daha kısıtlı. Clojure multimethodları hakkında <a href="http://clojure.org/multimethods">şuraya</a> bakabilirsiniz. Pascal usta buna benzer bir yapıyı Common Lisp için implement etmiş. <a href="http://www.p-cos.net/research.html">Şurda biryerlerde</a>ydi ama bulamadım şimdi.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Socket’ler konusunda çok bilgili değilim. usocket ve iolib kütüphaneleri direkt olarak unix socketlerini(posix socketleri mi oluyor?) implement etmişler, api olarak çok benzerler. Yine de ben non-blocking io yapmayı bir türlü beceremedim. Thread’lerden de bir süredir nefret ediyorum. Common Lisp’de çok kullanılan <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux Threads</a> kütüphanesinde(Common Lisp standardının thread de içermediğini söylemiş miydim?) de timer yok.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Common Lisp’in karşılaştırmayı <code>eql</code> fonksiyoinu ile yapmasıyla alakalı. Daha önce bahsettiğim kısıtlama.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Lisp dillerinin bir başka güzel yanı: kendi syntaxları ile kolaylıkla herhangi bir markup dilini ifade edebilirsiniz(şansınızı zorlarsanız JavaScript’i bile ifade edebilirsiniz ama bana delilik gibi geliyor açıkçası, bkz. <a href="http://common-lisp.net/project/parenscript/">parenscript</a>).<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>ctpop ve bitmapler</title>
    <link href="http://osa1.net/posts/2011-12-31-ctpop-ve-bitmapler.html" />
    <id>http://osa1.net/posts/2011-12-31-ctpop-ve-bitmapler.html</id>
    <published>2011-12-31T00:00:00Z</published>
    <updated>2011-12-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Bugün çok fantastik birşey gördüm, anlatmazsam ölürüm(uygun bir başlık düşünmem tüm yazıyı yazmamdan daha uzun sürdü o yüzden idare edin hehe).</p>
<p>Diyelim ki bir veri yapısı tasarlıyoruz, bir nodedan bir sürü başka nodea veya elemana pointerlar olacak. Bir yandan da bellek kullanımını minimum tutmak istiyoruz. Pointerları tutan arrayimizde hiç boş yer olmamalı.</p>
<p>Bir bitmap tutuyoruz. Büyük ihtimalle integer oluyor(Java primitive int tipi 32bit olmak zorunda mesela). Diyelim ki bu node’un n. indexine bir eleman/pointer ekleyeceksiniz. Bitmap ilk başta 0 tabii. Şu şekilde bitmap’de ilgili elemanı 1 yapıyoruz:</p>
<pre><code>bmp = bmp | 1 &lt;&lt; n</code></pre>
<p>Buraya kadar herşey çok basit. Bu noktadan sonra bu bitmape göre 30. elemanın arrayde nereye denk geldiğini bulmamız lazım. Bunun için şu formülü kullanıyoruz:</p>
<pre><code>ctpop(bmp &amp; ((1&lt;&lt;n)-1))</code></pre>
<p><code>ctpop</code>, population count fonksiyonu, yani bir sayının iki tabanında gösterilişindeki 1 bitleri sayıyor. Bu Java’da <code>Integer.bitCount</code> fonksiyonu(öhm, static methodu) ile bulunabilir.</p>
<p>Birkaç deneme yaparak nasıl yaptığını anlayabilir ve kendimizi ikna edebiliriz:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">2</span>]: bmp <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">3</span>]: bmp <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">15</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">4</span>]: ctpop(bmp <span class="op">&amp;</span> ((<span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">15</span>)<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>Out[<span class="op">^</span><span class="dv">4</span>]: <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">5</span>]: bmp <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">21</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">6</span>]: bmp <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">10</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">7</span>]: ctpop(bmp <span class="op">&amp;</span> ((<span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">10</span>)<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>Out[<span class="op">^</span><span class="dv">7</span>]: <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">8</span>]: ctpop(bmp <span class="op">&amp;</span> ((<span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">15</span>)<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>Out[<span class="op">^</span><span class="dv">8</span>]: <span class="dv">1</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>In [<span class="op">^</span><span class="dv">9</span>]: ctpop(bmp <span class="op">&amp;</span> ((<span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">21</span>)<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>Out[<span class="op">^</span><span class="dv">9</span>]: <span class="dv">2</span></span></code></pre></div>
<p>Eğer arraydeki n. yere bir eleman ekliyorsak, n’den itibaren arrayi bir kaydırmamız lazım. En büyük index her zaman arrayde de daha sonda oluyor.</p>
<p>Ne yaptığına bakalım. 25. elemanın arraydeki yerine bakarken, <code>1 &lt;&lt; 25</code>i hesaplıyorum ki bu aslında (2 tabanında) 1 ve yanına 25 tane 0 koymak demek. Daha sonra bu sayıdan 1 çıkararak, en sağdan itibaren(en anlamsız bitten itibaren) tüm 0ları 1 yapıyorum, ilk gördüğüm 1’i 0 yapıyorum, gerisine dokunmuyorum(bu şartlar altında geriye kalan tüm bitler 0 oluyor). Daha sonra bu sayı ile bitmap’i logical and(bazı yerlerde bitwise and diyor, aynı şeyler sanırım?) işlemine sokup ctpop yaptığımda, bitmap’de (1 &lt;&lt; n)’den itibaren kaç tane 1 olduğunu saymış oluyorum ve bu da bana array’deki indeximi veriyor. Çok mantıklı.</p>
<p>Bu arada kullandığınız dile göre bu işlemi daha kolay bir şekilde yapabilirsiniz. Bazı diller(Java’da <code>Integer.bitcount</code>, Common Lisp’de <code>logcount</code> gibi) direkt olarak <code>bitCount</code> gibi fonksiyonlar sunuyor. Bir de ben Common Lisp’de hiç kaydır 1 çıkart falan demeden direkt “şu bitle şu bit arasında kaç 1 olduğunu say” şeklinde bir fonksiyon yazdım, bitwise trickler yapmadan, şöyle:</p>
<pre><code>(defun ctpop (bitmap &amp;key (start 0) (end 32))
  (logcount (ldb (byte (- end start) start) bitmap)))</code></pre>]]></summary>
</entry>
<entry>
    <title>SICP hakkında</title>
    <link href="http://osa1.net/posts/2011-11-30-sicp-hakkinda.html" />
    <id>http://osa1.net/posts/2011-11-30-sicp-hakkinda.html</id>
    <published>2011-11-30T00:00:00Z</published>
    <updated>2011-11-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>~2 ay kadar önce okumaya başladığım <a href="http://mitpress.mit.edu/sicp/">SICP</a> hakkında birkaç birşey yazmak istedim. Okumak isteyenlere de birkaç tavsiyede bulunacağım. Bu kitabın yanlış anlaşıldığını, küçümsendiğini düşünüyorum. SICP nedir, veya neden SICP diye düşünen varsa, Google’da küçük bir araştırma sizi süper sayfalara yönlendirecektir.</p>
<p>Öncelikle biraz ön bilgi vereyim, kitabı ciddi anlamda okumaya ~2 ay kadar önce başladım, ve fonksiyonel programalama, Lisp dilleri, ve haliyle genel olarak programlama hakkında epey tecrübem vardı. Kitabı ilk okuma denemem lisans’a başladığım dönem(hatta hafta) içinde, bir şekilde biryerlerden kitapdan haberdar olup kütüphanemde bulunduğunu öğrenmemle oldu. Birkaç ay sonra da <a href="http://ff.im/tnz3f">şöyle bir feed</a> girmişim. Farkedebileceğiniz gibi pek de iyi gitmemiş. Şu anda ise ikinci ve üçüncü bölümdeki 179 alıştırmadan 168’ini çözdüm ve not aldım(%93.8). Çözmediklerimin 5 tanesi 2. bölümün son 5 sorusu, artık konuyu anladığımı düşündüğümden çözmeyeceğim, geriye kalan 6 tanesini de çözemedim, aklımdalar.</p>
<p>İlk bölüm hariç çözdüğüm tüm alıştırmaların çözümleri ve açıklamaları <a href="https://github.com/osa1/sicp-solutions">github alanım</a>da. Kitabı okumaya başladığımda çözümlerimi yayınlama gibi bir amacım yoktu, o yüzden ilk bölümdeki alıştırmaların çözümlerini not almadım. Bu aşamadan sonra ~2 hafta kadar ara verip(biraz finallerle ilgileneyim de şu dönemi kazasız belasız atlatıyorum diyorum), kitabı bitirmeye devam edeceğim. Gerçi ara verebileceğimi sanmıyorum, yine okuyacağım ama alıştırmalarla şu ana kadarki gibi yoğun bir şekilde ilgilenemeyeceğim.</p>
<p>Şimdi biraz okumak isteyenler için birşeyler söyleyeyim:</p>
<h2 id="çalışma-ortamı">Çalışma ortamı</h2>
<p>Emacs’e aşina değilseniz veya benim gibi VIM olmadan düz metin bile yazamayacak halde değilseniz, Racket en ideal ortam gibi. Kendi REPL/Editor’ü yeterince iyi. Kurulumu çok kolay(hatta linux ortamında kurulum yapmadan da çalıştırabiliyorsunuz). “Picture language” bölümündeki gibi tanımı verilmemiş fonksiyonlar kolayca temin edilebiliyor(yeri geldiğimde açıklamalarımda yazdım bunları).</p>
<p>Racket’in kötü yanı, tam olarak Scheme olmadığından, bazı kısımlar çalışmıyor, farklı bir yol izlemeniz gerekiyor. Örneğin <code>mutable data</code> ile ilgilendiğimiz 3. bölümde. Racket’ın <code>pair</code>ları <code>immutable</code> olduğundan(Scheme’dekinin aksine), <code>set-car!</code> ve <code>set-cdr!</code> gibi fonksiyonlar yok. Çözümü, bir modül aracılığıyla <code>pair</code> yerine <code>mpair</code>(mutable pair), <code>set-car!</code> yerine <code>set-mcar!</code> vs. kullanmak. Bunları hep açıklamalarda yazdım yeri geldiğinde.</p>
<p>Bu kısımlar için de ben kullandığım dağıtımın(openSUSE 11.4) paket yöneticisinde gördüğüm Scheme48’i kullandım. Her hangi bir standart Scheme implementasyonu kullanılabilir.</p>
<p>Emacs’e alışkın olanlar, veya illa VIM tuşları diyenler için çözüm <a href="http://www.neilvandyke.org/quack/">Quack</a>. Açıkçası profesyonel anlamda Scheme yazacaksanız ne kadar iyidir bilemiyorum, benim ihtiyacım olan Scheme REPL’i ve editorden kulayca kod çalıştırmayı mümkün kılıyor. Tuşları SLIME ile epey benzer. İstediğiniz Scheme’i kullanabiliyorsunuz(<code>run-scheme</code>i çalıştırdığınızda kullanmak istediğiniz Scheme’i soruyor). Eğer Racket kullanıyorsanız, <code>mzscheme</code>i çalıştırıyorsunuz. Emacs VIM tuşları için de <a href="http://emacswiki.org/emacs/Evil">Evil</a>.</p>
<p>Bu arada kitabın bir sürü ders videoları var sağda solda. Berkeley ve MIT’ninkiler gayet iyiydi diye hatırlıyorum. Bana süper sıkıcı geldiğinden(gözlerim kapanıyor ya) dersleri izlemedim.</p>
<h2 id="zorluk">Zorluk</h2>
<p>Baştan söyleyeyim, kitap zor. Alıştırmaları çözmeden öğrenmeniz imkansız. Örneğin ikinci bölümde 90 küsür alıştırma var. Konunun bir kısmı(hatta belki de çoğu kısmı) alıştırmalarda anlatılıp, program yazarak öğretiliyor. Alıştırmalar birbirlerine bağlı, çoğu zaman bir bölüm içinde önceki alıştırmaları çözmeden sonrakini çözemiyorsunuz. Bazı bölümlerde bir paragraf birşey anlatıp, birkaç paragraflık problemler geliyor falan. Çoğu alıştırma çok zevkli olsa da, bazen kendini tekrar edebiliyor(örneğin 2. bölümün sonlarına doğru).</p>
<p>İlk 3 bölümü epey hızlı bitirdiğimi düşünüyorum. Bu şu yüzden olabildi: Kitaba başladığımda, fonksiyonel programlama, Lisp dilleri, ve haliyle programlama hakkında epey tecrübeliydim. Bir süre Common Lisp ile uğraşmıştım, The Little Schemer’ı okumuştum, ve Clojure ile uğraşıyordum. Özellikle ilk bölüm için çok gerekli olan bazı matematiksel kavramları ayrık matematik ve calculus derslerinde görmüştüm. Kitabı ilk okuma denememde aslında bu yüzden yapamamıştım. İşin matematiğinde takılmıştım, ve ilk bölüm matematik ağırlıklı(Scheme biliyorsanız bile kesinlikle atlamamalısınız, iterative process vs. recursive process, tail-call optimization, basit lambda calculus, fixed-point combinator gibi süper konulardan bahsediliyor). Bunların hepsine sıfırda başlayacak biri için bu süreç epey uzun olabilir(MIT veya bu kitabın okutulduğu diğer okullarda kaç dönem sürüyor tüm kitap acaba?).</p>
<h2 id="fonksiyonel-programlama">Fonksiyonel programlama</h2>
<p>\3. bölüme kadar tamamen fonksiyonel programlama yapıyoruz. 3. bölümde de atama işleminden, mutable datadan, avantajlarından, dezavantajlarından, programları nasıl kompleks bir hale getirdiğinden, fonksiyonel/imperative programlama arasında dengeden bahsediliyor. Daha sonra %100 fonksiyonel bir yol izlemesek de(3. bölümü yeni bitirdim, tam emin değilim) geri kalan kısım yine büyük oranda fonksiyonel gibi.</p>
<p>Burda SICP’in fonksiyonel programlama için mükemmel bir kaynak olduğunu düşünüyorum. Sadece ilk 3 bölüm okunsa bile yeterli olur. 3. bölüme geçtiğimde hiç farkında olmadan sürekli fonksiyonel programlama yaptığımı ve artık bu yolun bana çok doğal geldiğini farkettim. Bundan 1 yıl kadar önce imperative dillerde çok rahat çözebildiğim tüm problemleri şu anda fonksiyonel bir şekilde çözebiliyorum(hatta belkide daha bile rahatımdır, bir süredir imperative dillerle uğraşmıyorum). SICP bu şekilde düşünmeye başlayabilmek için mükemmel bence.</p>
<h2 id="common-lisp-vs-scheme-vs-clojure">Common Lisp vs Scheme vs Clojure</h2>
<p>Bazen denk geliyorum, SICP’i Common Lisp veya Clojure ile çözmeye çalışıyor birileri. Bunun mantıklı olduğunu düşünmüyorum. SICP’i bir Scheme kitabı olarak görmeyin, dil hakkında birşler anlattığı kısımları birleştirsek, ilk 3 bölümde toplam 10 sayfa bile etmez. Scheme çok küçük bir dil. Pek çok dili öğrenirken vaktimizin çoğunu syntax’ını anlamakla geçiriyoruz zaten(programlamaya yeni başlamıyorsak veya çok farklı bir paradigm öğrenmiyorsak). Scheme’de öyle bir dert yok. Ekstra bir dil öğrenmiyorsunuz yani aslında.</p>
<p>Kaldı ki Scheme(ve aslında Common Lisp, ama kendisi çok kompleks bir dil olduğundan bu süreç epey uzun sürecektir) sadece kendisi ile yazılan kitaplar için bile öğrenilebilir bence.</p>
<p>Bir de olaya şu açıdan bakın, bir programlama kitabı düşünün, anlattığı konuların herhangi bir dille alakası yok, genel olarak programalama, programların yapımı, soyutlama, problemlere yaklaşımlar, concurrency, programların yorumlanması ile alakalı, bir yerden sonra okuyucuya o ana kadar kullandığı dilin yorumlayıcısı yazdırılıyor. Bir programlama dili kitabı değil kesinlikle. Bir derleyici kitabı da değil. Daha iyi bir dil biliyor musunuz?</p>
<hr />
<p>SICP hakkında şimdilik bu kadar. Paylaşmak istediğim birşeyler olursa yine yazacağım. Üzerinde çalıştığım(henüz elle tutulur birşey değil ama) bir Scheme yorumlayıcısıyla alakalı da dağınık notlar var, bir ara ekleyeceğim(4. bölüm tam olarak bu işle alakalı olduğundan, sanırım 4. bölümü bitireceğim önce).</p>]]></summary>
</entry>

</feed>
