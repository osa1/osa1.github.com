<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged lua</title>
    <link href="http://osa1.net/tags/lua.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/lua.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2013-04-24T00:00:00Z</updated>
    <entry>
    <title>An interesting case of closures: is closed-over variable reference or value?</title>
    <link href="http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html" />
    <id>http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html</id>
    <published>2013-04-24T00:00:00Z</published>
    <updated>2013-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I discovered an interesting behavior of JavaScript’s closures while writing a nodejs script.</p>
<p>This behavior is pretty easy to observe when writing a nodejs application, because of it’s callback-based asynchronous nature, you’ll be writing callbacks all the time. Let’s say I’ll create a callback function which uses a variable defined in outer-scope, then do some actions using that variable:</p>
<pre class="sourceCode JavaScript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>(<span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
    });
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>What I expect from this program is to print <code>foo\nbar\nbaz</code>, but it instead prints <code>baz\nbaz\nbaz</code>. It’s like <code>say</code> variable used inside the callback is a reference and not a value. But it’s still strange because the reference should be local to for-loop’s body, so each <code>var say = ...</code> assignment should create a separate reference.</p>
<p>I find this behavior very counterintuitive. Before moving to solutions to fix this, I tried same program with several other languages.</p>
<p>Python also has this problem<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback():
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>This prints same wrong output as with JavaScript.</p>
<p>Lua, my favorite dynamic language, does great:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">callbacks</span> <span class="ot">=</span> <span class="ot">{}</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">({</span> <span class="st">&quot;foo&quot;</span><span class="ot">,</span> <span class="st">&quot;bar&quot;</span><span class="ot">,</span> <span class="st">&quot;baz&quot;</span> <span class="ot">})</span> <span class="kw">do</span>
  <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">,</span> <span class="kw">function</span> <span class="ot">()</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;say &quot;</span> <span class="ot">..</span> <span class="kw">v</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="kw">end</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">)</span> <span class="kw">do</span>
  v<span class="ot">()</span>
<span class="kw">end</span></code></pre>
<p>It prints <code>foo\nbar\nbaz</code> as expected. Trying this in functional languages may be pointless, since variables are actually not <em>variables</em>(they’re immutable), but it may be still useful for demonstration purposes, here’s the Haskell code that works as expected:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

main <span class="fu">=</span> <span class="fu">sequence_</span> callbacks
  <span class="kw">where</span> callbacks <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">putStrLn</span> <span class="fu">.</span> (<span class="st">&quot;say &quot;</span> <span class="fu">++</span> )) [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]</code></pre>
<p>I’ll show how to get JavaScript’s behavior in languages that handle this right, and in Haskell it’s harder to get this behavior because we will need to use reference cells explicitly.</p>
<p>I think in Python it’s more understandable, because it doesn’t have any scope declarations. ie. we can’t reason about <code>say</code> variable’s scope by the look of it. In JavaScript, we have <code>var</code> keyword that indicates a new variable is created in the scope. But it still works wrong.</p>
<p>Indeed, in JavaScript, the worst language ever, <code>var</code> keyword is just like any other strange JavaScript feature and works in an unexpected way:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">for</span> (<span class="kw">var</span> v <span class="kw">in</span> [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ]) { <span class="ot">console</span>.<span class="fu">log</span>(v); }
<span class="dv">0</span>
<span class="dv">1</span>
<span class="dv">2</span>
&gt; v
<span class="st">&quot;2&quot;</span></code></pre>
<p>So one explanation of this behavior may be this: In Python, we don’t know the scope of variable and it looks like it’s global. So in closure, it works like a reference. And in JavaScript, <code>var</code> keyword is simply broken(and also variable inside closure works like reference).</p>
<h1 id="fixing-it">Fixing it</h1>
<p>Let’s fix that in JavaScript and Python.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>((<span class="kw">function</span> (say) {
      <span class="kw">return</span> <span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
      }
    })(say));
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>Here we’re creating a new scope with function(remember the JavaScript module pattern?), and then passing <code>say</code> variable to it. This guarantees that we have <code>say</code> variable local to the function. Then in callback returned by wrapper function, we have a reference just like before, but it’s not shared with any other functions.</p>
<p>In Python, there’s a cleaner way to do same thing:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback(say=say):
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>Here the parameter is passed implicitly. (to me it’s still very strange and it shouldn’t be working, but for now I’ll just keep this post short)</p>
<h1 id="breaking-it">Breaking it</h1>
<p>Let’s have JavaScript’s behavior in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Data.IORef

printFromRef r <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">=&lt;&lt;</span> readIORef r

mkCallbacks (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
    ref <span class="ot">&lt;-</span> newIORef w
    r   <span class="ot">&lt;-</span> iter ref ws
    <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> r
  <span class="kw">where</span> iter ref []     <span class="fu">=</span> <span class="fu">return</span> []
        iter ref (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
          writeIORef ref w
          cs <span class="ot">&lt;-</span> iter ref ws
          <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> cs

main <span class="fu">=</span> <span class="kw">do</span>
  callbacks <span class="ot">&lt;-</span> mkCallbacks [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]
  <span class="fu">sequence_</span> callbacks</code></pre>
<p>The reason this code is that long is because we need to create and pass references explicitly.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Calling this behavior <em>problem</em> may be a bit wrong, maybe it’s just a design decision. To me it’s a <em>problem</em> because this behavior is really counterintuitive.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>On typing dynamic langs</title>
    <link href="http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html" />
    <id>http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html</id>
    <published>2013-04-19T00:00:00Z</published>
    <updated>2013-04-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://marijnhaverbeke.nl/blog/tern.html">This excellent post</a> on Tern’s internals reminded me of why I lost interest of my statically typed Lua project.</p>
<p>I lost my interest in a program exponentially with the amount of hacky solutions it involves.</p>
<p>I love Lua, it’s so simple but it is so powerful at the same time, without having any quirks most other dynamic languages have. But when it comes developing a type inference system for such a dynamic language, the result will have to contain a lot of hacks.</p>
<p>Here’s a quote from Tern post, which explains handling dynamically extending objects:</p>
<blockquote>
<p>And now we’re off into dodgy hack land. In order to meet this challenge, Tern uses a special treatment for for/in loops that appear to be copying properties. When it encounters them, it assumes that the properties from the source object will be copied to the target object. It ignores control flow (conditionals and such) and simply copies all properties.</p>
</blockquote>
<p>Similar situation is applied to Lua and this is where I dropped my project. Basically, there is no way to give a type to an object without actually running the program to the point where completion is needed. But even then you can’t have completely correct type information because for instance, you may have a different object in second iteration of loop but your type inference system would be only run it for one iteration. Still, I think running a program in an isolated environment to the point where enough type information is acquired is the best way to infer types in dynamic languages.</p>
<p>Accepting having a subset of Lua and forbidding object extensions in run-time is not a solution because then you can’t even use tables as, well, tables, rather than objects.</p>
<p>The obvious solution is creating a new syntax for defining objects. That syntax should be allowed only in top-level of a file, ie. you can’t use object definition syntax inside of a function.</p>
<p>But then a new language that is not Lua would be invented. I deliberately wanted to avoid this situation because in my opinion, it’s slightly missing the point of that kind of languages. I don’t like CoffeeScript’s additional compile step to my workflow. One nice property of dynamic languages is that we don’t have any visible intermediate steps between writing the source code and running it. All intermediate steps(parsing, compiling to some kind of byte-code, like Python does) are completely hidden to programmer.</p>
<p>Maybe the problem is that I’m looking for a perfect solution which does not exist in reality. I’m not sure how can I overcome this problem, I don’t want to work on programs full of hacks in my free time(well, I don’t want to work on this kind of programs in <em>any</em> time, but doing that as a hobby is more unbearable).</p>]]></summary>
</entry>
<entry>
    <title>Getting different distributions out of uniform distribution</title>
    <link href="http://osa1.net/posts/2012-12-19-different-distributions-from-uniform.html" />
    <id>http://osa1.net/posts/2012-12-19-different-distributions-from-uniform.html</id>
    <published>2012-12-19T00:00:00Z</published>
    <updated>2012-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I don’t know much about statistics and distributions, but I needed some differently distributed pseudo-random numbers for a project I’m working on.</p>
<p>I think most programming languages have a pseudo-random number generator, and that generators probably generate <a href="http://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniformly-distributed</a> pseudo-randoms. I’m using Lua and Lua’s <a href="http://www.lua.org/manual/5.2/manual.html#pdf-math.random">math.random</a> generates pretty much uniformly distributed numbers:</p>
<div class="figure">
<img src="/images/distroyazi/uniformdistro.png" />
</div>
<p>It’s written in Lua’s manual(link is given above) that it’s statistical properties cannot be guaranteed. It still works fine for my purposes as a uniformly distributed number generator.</p>
<p>If you’re working with <a href="http://processing.org/">Processing</a> or some other visualization libraries, you probably also have uniformly-distributed generator<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> in stdlib. But if you’re like me, you have to hack yourself one. I found a method called <a href="http://en.wikipedia.org/wiki/Box-Muller_transform">Box-Muller transform</a> that generates normally-distributed numbers out of uniformly-distributed ones.</p>
<p>I also read some discussions on why one shouldn’t use that, and instead move to other methods like <a href="http://en.wikipedia.org/wiki/Ziggurat_algorithm">Ziggurat algorithm</a>(and some other I can’t remember now), but I think Box-Muller method is easy to implement and works fine for my purposes, so I’m using it now:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> box_muller<span class="ot">()</span>
    <span class="kw">return</span> <span class="kw">math</span><span class="ot">.</span>sqrt<span class="ot">(-</span><span class="dv">2</span> <span class="ot">*</span> <span class="fu">math.log</span><span class="ot">(</span><span class="fu">math.random</span><span class="ot">()))</span> <span class="ot">*</span> <span class="fu">math.cos</span><span class="ot">(</span><span class="dv">2</span> <span class="ot">*</span> <span class="kw">math</span><span class="ot">.</span><span class="kw">pi</span> <span class="ot">*</span> <span class="fu">math.random</span><span class="ot">())</span> <span class="ot">/</span> <span class="dv">2</span>
<span class="kw">end</span></code></pre>
<p>This function returns numbers in range [-1,1]. I’m using it with some code like that:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> <span class="kw">dev</span> <span class="ot">=</span> <span class="dv">100</span>
<span class="kw">local</span> <span class="kw">rand</span> <span class="ot">=</span> box_muller<span class="ot">()</span>
<span class="kw">return</span> <span class="fu">math.floor</span><span class="ot">(</span><span class="kw">rand</span> <span class="ot">*</span> <span class="kw">dev</span> <span class="ot">+</span> <span class="kw">myLimit</span><span class="ot">/</span><span class="dv">2</span><span class="ot">)</span></code></pre>
<p>Here the variable <code>dev</code> stands for <a href="http://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>, though note that it’s value is not <em>standard deviation</em>, but just a value to play with to set standard deviation. I don’t know how can I set standard deviation with Box-Muller method. By playing this value you can get distributions with different standard deviations.</p>
<div class="figure">
<img src="/images/distroyazi/normaldistro.png" />
</div>
<p>I also generated two custom distributions, I don’t know if people gave them any special names, first one is this:</p>
<div class="figure">
<img src="/images/distroyazi/customdistro.png" />
</div>
<p>I think this is a very useful one, this means that if I give some <em>actions</em> in my game different numbers depending on their <em>priority</em> and use this random number generator, I get numbers of actions with more priority more than the ones with less priority. Here’s the code:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="ot">()</span>
    <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
        <span class="kw">local</span> <span class="kw">r1</span> <span class="ot">=</span> <span class="fu">math.random</span><span class="ot">(</span><span class="kw">range</span><span class="ot">)</span>
        <span class="kw">local</span> <span class="kw">r2</span> <span class="ot">=</span> <span class="fu">math.random</span><span class="ot">(</span><span class="kw">range</span><span class="ot">)</span>
        <span class="kw">if</span> <span class="ot">(</span><span class="kw">r2</span> <span class="ot">&lt;</span> <span class="kw">r1</span><span class="ot">)</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">r1</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>Last one is similar:</p>
<div class="figure">
<img src="/images/distroyazi/customdistro2.png" />
</div>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="ot">()</span>
    <span class="kw">local</span> <span class="kw">rate</span> <span class="ot">=</span> <span class="dv">3</span>
    <span class="kw">local</span> <span class="kw">r</span> <span class="ot">=</span> <span class="fu">math.random</span><span class="ot">(</span><span class="dv">500</span><span class="ot">^</span><span class="kw">rate</span><span class="ot">)</span>
    <span class="fu">print</span><span class="ot">(</span><span class="kw">r</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="fu">math.floor</span><span class="ot">(</span><span class="kw">r</span><span class="ot">^(</span><span class="dv">1</span><span class="ot">/</span><span class="kw">rate</span><span class="ot">))</span>
<span class="kw">end</span></code></pre>
<p>In this code, if you make <code>rate</code> variable 2, you get pretty much same distribution with the last one above. In my case, for some reason, making it 4 gives a value that doesn’t fit into 32bit, and so <code>math.random</code> call fails. When I tried with Lua 5.2 compiled by myself on my 64bit machine, <code>math.random</code> works fine with 64bit values, so I think it’s a problem with the app I’m using<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup>.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>and you may even have a <a href="http://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> <a href="http://processing.org/reference/noise_.html">generator</a> too!<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For those interested: It’s <a href="http://love2d.org">Love2d</a>. Recently(while working on this code) I realized that Love2d is not a Lua library, but a complete C++ program that has Lua interpreter. In most cases you can’t see the difference but there are some edge cases like I mentioned above that makes your program runs fine with Lua, but fails with Love2d programs.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>call/cc</title>
    <link href="http://osa1.net/posts/2012-06-23-callcc.html" />
    <id>http://osa1.net/posts/2012-06-23-callcc.html</id>
    <published>2012-06-23T00:00:00Z</published>
    <updated>2012-06-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Son zamanlarda uğraştığım konulardan biri hakkında birşeyler karalayacağım. Genelde zor bir konspetle karşılaştığımda anladığımı anlamak için 2 şey yapıyorum, 1) programlıyorum, 2) anlatıyorum. Uğraştığım işlerle ilgilenen kimse olmadığından, anlatabiliyor olmamı bu blog sağlıyor. Bu sefer Scheme’in call/cc fonksiyonundan bahsedeceğim, epey ilginç bir iş yaptığını düşünüyorum.</p>
<p><code>call/cc</code>de benim ilgimi çeken şey, Scheme’i bir yorumlayıcı ortamı olarak düşündüğümüzde, yorumlayacağımız dile exceptionlar, coroutineler gibi kontrol akışınıda değişiklikler yapması gereken yapıları kolayca ekleyebilmemizi sağlaması.</p>
<p>Continuation-passing style’a aşina olduğunuzu varsayıyorum. Aşina olmayanlar Google’dan kolaylıkla süper kaynaklar edinebilir. JavaScript gibi yaygın bir dilin CPS kullanabilmek için gereken fonksiyonelliği sağlıyor olması çok büyük şans, yoksa CPSı anlamak için Scheme kodu okumak zorunda kalabilirdiniz :P . Ben implementasyonu Common Lisp ile vereceğim.</p>
<p><code>call-with-current-continuation</code> veya kısaca <code>call/cc</code>nin genel olarak iki farklı implementasyon yöntemi var<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> biri stack kopyalama işlemi, diğeri <em>CPS conversion</em> dediğimiz, benim birazdan anlatım Common Lisp ile yazacağım yöntem.</p>
<p>Tüm programlarımızın üstü kapalı bir şekilde(<em>implicit</em>) CPS yazıldığını düşünelim. Yani tüm fonksiyon çağrıları aslında bir değer dönmek yerine, bu döneceği değer ile continuation’ı çağırmalı<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> Bunu sağlamak için tüm fonksiyonlar ilk parametre olarak continuation alabilir ve diğer parametreleri fonksiyon tanımı sırasında verilen parametreler olur. Daha sonra fonksiyon döneceği değer ile ilk parametresini, yani continuation’ı çağırır. Bu fonksiyonları bir macro ile kolayca oluşturabiliriz<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defmacro</span><span class="fu"> defcont </span>(name (&amp;<span class="kw">rest</span> params) &amp;body body)
  (<span class="kw">let</span> ((result (<span class="kw">gensym</span>)))
    `(<span class="kw">defun</span><span class="fu"> </span>,name (continuation ,@params)
       (<span class="kw">let</span> ((,result ,@body))
         (<span class="kw">funcall</span> continuation ,result)))))</code></pre>
<p>Bu macronun syntaxı <code>defun</code>un tamamen aynısı, sadece ekstradan ilk parametre olarak continuation alıyor ve dönüş değeriyle aslında continuation’ı çağırıyor. Bu şekilde yazılan fonksiyonlar <em>CPS conversion</em> a maruz kalıyor yani.</p>
<p>Örnek olarak bu şekilde basit bir toplama ve çarpma fonksiyonları oluşturalım:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(defcont multiply (&amp;<span class="kw">rest</span> args)
  (<span class="kw">apply</span> #&#39;* args))
(defcont add (&amp;<span class="kw">rest</span> args)
  (<span class="kw">apply</span> #&#39;+ args))</code></pre>
<p>Burda fonksiyonların içinde CPS formatında olmayan, dilin kendi fonksiyonlarını çağırıyoruz ama bu sorun değil.</p>
<p>Bu durumda normalde <code>(* 3 (+ 1 2))</code> şeklinde yazacağımız fonksiyonu şu şekilde yazmamız gerekiyor: <code>(add (lambda (r) (multiply #'identity r 3)) 1 2)</code>. İşte bu dönüşümü yapmaya <code>CPS conversion</code> diyoruz. Ne yaptığına bakalım, çarpma işleminin sonucu <code>(+ 1 2)</code> çağrısının dönüş değerine bağlı, buna göre ilk başta toplama işlemi yapılıp, sonucu çarpma işlemine aktarılmalı. Çarpma işlemi de toplama işleminin sonucunu alıp, 3 ile çarptıktan sonra bir continuation’a aktarmalı. Burda bu son continuation olarak <code>identity</code> fonksiyonunu seçtim ki sonucu elde edebilelim. Normalde, eğer örneğin sonucu yazdırmak istiyorsak, orata <code>prin1</code> gibi bir fonksiyon göndermemiz gerekir.</p>
<p>Bu şekilde yazılan programların nasıl çalıştığına bakarsanız, aslında fonksiyon çağrıları için stack modeline ne kadar benzediğini farkedersiniz. Stack modelinde, çarpma fonksiyonu çağırıldığında stack’de fonksiyon çağrısı hakkında gerekli verileri tutan bir kayıt oluşturulacak, daha sonra toplama işlemi çağırıldığında bunun üzerine bir kayıt daha eklenecek, ve fonksiyon çağrıları bittikçe bu kayıtlar stackten toplanarak bir alt seviyeye dönüş değerlerini bir şekilde aktaracak.</p>
<p>CPS’de tamamen aynı, toplama işlemi önce bitecek ve çarpma işlemine dönüş değerini aktaracak. Bunun için çarpma fonksiyonunu ilk parametresi olarak alacak, çarpma fonksiyonu da kendi sonucunu hangi fonksiyona aktaracaksa o fonksiyonu ilk parametre olarak alacak gibi.</p>
<p>Buraya kadar herşey anlaşıldıysa, <code>call/cc</code>yi yazmak çok kolay. <code>call/cc</code>nin yaptığı, o anki continuation’ı açık bir şekilde kullanıcıya vermek. Normalde yukarıda bahsettiğim tüm olaylar derlenme aşamasında <em>CPS conversion</em> veya başka yöntemlerle hallediliyor ve kullanıcı aslında fonksiyonlarını bizim örneğimizdeki gibi yazmıyor. Dolayısıyla fonksiyonuna aktarılan continuation’a erişme şansı yok. Fakat <code>call/cc</code> hariç, <code>call/cc</code> tam olarak bu işi yapıyor, o anki continuation’a erişim izni veriyor. Şu şekilde:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> call/cc </span>(continuation fun)
  (<span class="kw">funcall</span> fun continuation))</code></pre>
<p>Bu fonksiyonun <code>defcont</code> ile tanımlandmadığına dikkat. Bu şu anlama geliyor, programlama dili böyle bir fonksiyon sunmuyorsa, bu fonksiyonun yazılması imkansız. Kullanıcının tek sahip olduğunun <code>defcont</code> olduğunu düşünün, yani tüm fonksiyonları <em>CPS conversion</em>a mağruz kalıyor, ve fonksiyon çağrıları otomatik olarak CPS’e dönüştürülüyor. Programcı yazdığı fonksiyonlara continuation’ın nasıl aktarıldığını bilmiyor veya bilse bile buna erişmesinin hiçbir yolu yok.</p>
<p><code>call/cc</code>, kendi aldığı continuation’ı <code>fun</code> parametresi olarka aldığı fonksiyona aktarıyor, ve daha sonra <code>fun</code> fonksiyonu o continuation ile her türlü çılgınlık yapabilir, örneğin bu continuation’ı bir yere kaydedip, bir daha bir daha çağırmak gibi. Bu continuation, dönüş değerinin aktarılacağı fonksiyonu tutuyor aslında.</p>
<p>Hemen basit birkaç örnek yapalım. Şu iki fonksiyon arasındaki fark ne?</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) (<span class="kw">funcall</span> cont <span class="dv">11</span>)))
(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) <span class="dv">11</span>))</code></pre>
<p>İlk çağrıda continuation’a 11 değerini gönderiyoruz ve sonuç beklenen gibi 21 oluyor, ikinci durumda ise continuation’ı yok sayıp 11 değerini dönüyoruz ve cevap 11 oluyor. Stack modelinde düşünürsek, ikinci örnekte yapılan şey, stackdeki bazı fonksiyon kayıtlarının atlanması aslında. Buna sanırım <code>stack unwinding</code> deniyor(emin değilim). Bu şekilde dil seviyesinde exception mekanizmaları yazılabilir, continuationlar kaydedilerek ve sırayla çağırılarak coroutineler<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup>veya <em>lightweight thread</em>ler elde edilebilir(<em>green thread</em> de diyorlar sanırım).</p>
<p>Scheme bilenler için bu kodun Scheme karşılıkları şu:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="kw">+</span> <span class="dv">10</span> <span class="dv">11</span>)))
(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="kw">+</span> <span class="dv">10</span> (cont <span class="dv">11</span>))))</code></pre>
<p>Aralarındaki fark, Scheme kodu <em>CPS conversion</em>a mağruz kalmamış, Common Lisp kodu ise kalmış hali.</p>
<p>Bu aşamada yapılabilecek çok fazla fantastik iş var ve çoğu durumda neler olup bittiğini anlama çok güç. Zaten bu yüzden <code>GOTO</code>larla karşılaştırılıyorlar bazen. Benim hoşuma giden bir kullanımını şu:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defvar</span><span class="fu"> creturn </span><span class="kw">nil</span>)
(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> <span class="dv">1</span> r))
         (<span class="kw">lambda</span> (cont)
           (<span class="kw">setf</span> creturn cont)
           <span class="dv">1</span>))</code></pre>
<p>Continuation’ı bir değişkene kaydediyorum ve daha sonra istediğim zaman o continuation’ı çağırıp işlemi kaldığı yerden devam ettiriyorum.</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">15</span>)
<span class="dv">16</span>
CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">20</span>)
<span class="dv">21</span></code></pre>
<p>Kısaca, işlemi istediğim bir yerden durdurdum ve kopyaladım. Daha sonra durdurduğum andan itibaren istediğim bir değer ile devam ettiriyorum. Müthiş bir olay. Bu gösterdiğim örnekler en basit ve sıradan örnekler, neler yapılabileceği hakkında çok fazla güzel kaynak var, açıkçası ben çoğunun ne yaptığını anlamakta güçlük çekiyorum, bazı patternlara aşina olmak gerekiyor. <code>call/cc</code>nin Scheme’den kaldırılması da <a href="http://lists.scheme-reports.org/pipermail/scheme-reports/2012-February/001824.html">şu ortamda</a> epey tartışılmış.</p>
<p>Çok bilinen iki implementasyon yöntemi demiştim, diğer yöntem de stack kopyalama. Bu örneği düşünelim, <code>call/cc</code> aslında stack’in o anki durumunu aktarıyor aslında. Burda yapılan işlem büyük ihtimalle en baştan beri tüm stackin kopyalanması değil. <a href="http://en.wikipedia.org/wiki/Spaghetti_stack">Sphagetti stack</a> gibi bir yapı kullanılıyor olabilir.</p>
<p>Bu arada, coroutine demişken, implementasyon detaylarını merak eden varsa: <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;ved=0CHgQFjAF&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.104.1441%26rep%3Drep1%26type%3Dpdf&amp;ei=PAXmT8TBEaeB4ASj-5ygAQ&amp;usg=AFQjCNENWM4b5ib96CKcno8KgEeJk4KQ6g">Coroutines in Lua</a>. Lua’yı seviyoruz.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Aslında, birkaç tane çok bilinen(yazılmış) implementasyonu var ve dahası da gereksinimlere/şartlara göre uydurulabilir. Detayları merak eden varsa: <a href="http://www.cs.indiana.edu/~dyb/papers/3imp.pdf">Three Implementation Models for Scheme</a>. Ve büyük ihtimalle şu kitapta da bahsediliyordur: <a href="ref=sr_1_1?ie=UTF8&amp;qid=1340471949&amp;sr=8-1&amp;keywords=lisp+in+small+pieces">Lisp in Small Pieces</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Bu durumda, <em>sanırım</em>, teorik olarak stack denen yapıya ihtiyaç kalmıyor.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Bu macroda bir sorun var fakat konumuzun dışında olduğundan, işleri karıştırmamak için önemsemedim: <code>continuation</code> parametresi <a href="http://www.bookshelf.jp/texi/onlisp/onlisp_10.html#SEC67"><em>variable capture</em></a>a maruz kalabilir. <code>gensym</code> ile parametre adı oluşturulması gerekir.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Şu anda coroutineleri implement etmek için sanırım zaten stackin bir kopyasını çıkarmak zorundasınız.<a href="#fnref4">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Lazy lists in Lua and eliminating tail-calls with continuations</title>
    <link href="http://osa1.net/posts/2012-05-20-lazy-lists-in-lua-and-eliminating-tail-calls-with-continuations.html" />
    <id>http://osa1.net/posts/2012-05-20-lazy-lists-in-lua-and-eliminating-tail-calls-with-continuations.html</id>
    <published>2012-05-20T00:00:00Z</published>
    <updated>2012-05-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I was reading some papers about parsing with continuations and I realized that I had never implemented continuations in any language. Since I’m interested in Lua nowadays, I want to implement it in Lua.</p>
<p>After a while, I realized that you could use continuations to eliminate recursive calls to prevent stack overflows. Now, in a language like Lua, we have tail-call optimization(TCO) and recursive calls in tail positoins are not problem, but even in languages that don’t have TCO, you can easily convert tail calls to loops with help of continuations. And I found the underlying idea of this is pretty similar to lazy-lists. Now I’m going to try to explain how.</p>
<p>For those who want to see the code, here’s the <a href="https://gist.github.com/2757232">gist</a>.</p>
<p>Nowadays most of modern languages(functional ones or not), have some primitives for lazy evaluation(like Python’s generators), and I’m not an expert on Lua but AFAIK, Lua’s coroutines can be used for lazy evaluation. But even if you use a language that doesn’t have any non-strict primitives, you can have some lazy structures(ie. in JavaScript).</p>
<p>The main idea of this is that you can always pass functions in a form that holds the function itself and a list of arguments that will be passed to function. And when you want to evaluate the result of the function call, you just call the function in that form with the arguments. Note that by “function itself”, I mean the function callback. Most modern languages nowadays have functions as first-class values or at least some kind of function pointers/referances, so this is not a problem.</p>
<p>I’ll give the code in Lua. We’ll call the structure that holds a function callback(or whatever your language call it) and a list of parameters, <code>thunk</code><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> In Lua, this will be a table with two keys: <code>f</code> and <code>args</code>. Here’s an example thunk.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">t</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">f</span> <span class="ot">=</span> <span class="fu">print</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="ot">{</span><span class="st">&quot;first arg&quot;</span><span class="ot">,</span> <span class="st">&quot; second arg&quot;</span><span class="ot">}</span> <span class="ot">}</span></code></pre>
<p>So when we want to run the function in the thunk, we just call <code>evalThunk</code>, which is pretty straightforward to implement:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="kw">t</span><span class="ot">.</span>f<span class="ot">(</span><span class="fu">unpack</span><span class="ot">(</span><span class="kw">t</span><span class="ot">.</span><span class="kw">args</span><span class="ot">))</span>
<span class="kw">end</span>
<span class="ot">&gt;</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
<span class="kw">first</span> <span class="kw">arg</span>        <span class="kw">second</span> <span class="kw">arg</span></code></pre>
<p>Basically, when we want to make a function non-strict, we just create a thunk of it, with <code>f</code> = function itself, and the <code>args</code> = the args we want to pass to the function when we run it. Here’s a helper for it:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> makeThunk<span class="ot">(</span><span class="kw">f</span><span class="ot">,</span> <span class="kw">args</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="ot">{</span> <span class="fu">tag</span> <span class="ot">=</span> <span class="st">&quot;thunk&quot;</span><span class="ot">,</span> <span class="kw">f</span> <span class="ot">=</span> <span class="kw">f</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="kw">args</span> <span class="ot">}</span>
<span class="kw">end</span></code></pre>
<p>Now, with the help of this two functions, we can create a infinite-length lazy linked-lists. Each node in our linked-lists will have two keys: <code>first</code> and <code>rest</code>. <code>first</code> will have the value of that node, and <code>rest</code> will have the next node connected to that node. Here’s a helper to create linked-list nodes.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> cons<span class="ot">(</span><span class="kw">first</span><span class="ot">,</span> <span class="kw">rest</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="ot">{</span> <span class="kw">first</span> <span class="ot">=</span> <span class="kw">first</span><span class="ot">,</span>
             <span class="kw">rest</span>  <span class="ot">=</span> <span class="kw">rest</span> <span class="ot">}</span>
<span class="kw">end</span></code></pre>
<p>In lazy-lists, we always have the <code>rest</code> part of the list as unevaluated thunks. To traverse the list to some point, we need to evaluate the nodes we passed, and when we evaluate this nodes, we just replace the thunks with evaluated values. Because we don’t want to evaluate the same node again and again for eact iteration.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="kw">p</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">t</span> <span class="ot">==</span> <span class="kw">nil</span> <span class="kw">then</span>
        <span class="kw">return</span> <span class="kw">nil</span>
    <span class="kw">elseif</span> <span class="fu">type</span><span class="ot">(</span><span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">])</span> <span class="ot">==</span> <span class="st">&quot;table&quot;</span> <span class="kw">and</span> <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">].</span><span class="kw">tag</span> <span class="ot">==</span> <span class="st">&quot;thunk&quot;</span> <span class="kw">then</span>
        <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">]</span> <span class="ot">=</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">])</span>
    <span class="kw">end</span>
    <span class="kw">return</span> <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">]</span>
<span class="kw">end</span>
<span class="kw">function</span> first<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="st">&quot;first&quot;</span><span class="ot">)</span>
<span class="kw">end</span>
<span class="kw">function</span> rest<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="st">&quot;rest&quot;</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p><code>first</code> and <code>rest</code> functions are returning the <code>first</code> and <code>rest</code> parts of our linked-list nodes. We’re expecting this parts to be unevaluated thunks. So if they’re thunks, we just evaluate them and replace the return value with thunks so that we don’t need to re-evaluate everytime we get a node.</p>
<p>And with the last helper, we can start creating infinite lazy-lists in Lua:</p>
<pre><code>function nth(t, n)
    if n == 0 then
        return first(t)
    end
    return nth(rest(t), n-1)
end</code></pre>
<p>This function is just getting the n. node in a linked list. And while getting this node, it’s evaluating all the thunk on the way with help of <code>rest</code> function. This is important because as you’ll see, we will be creating the rest of the lists while we’re traversing it.</p>
<p>Let’s see an example of infinite lazy-list that creates a list of factorials, starting from 1!:</p>
<pre><code>function fact(n, f)
    n = n or 1
    f = f or 1
    return cons(n, makeThunk(fact, {n*f, f+1}))
end</code></pre>
<p>This function returns a linked-list that contains factorial of 1, and then a thunk of the same factorial function, but with different parameters. The function call in the <code>rest</code> part of the thunk will return the next factorial, and then the same function as a thunk in <code>rest</code> part of the thunk, in a recursive fashion. Note that our <code>nth</code> function is tail-recursive so we’ll never have stack overflows while traversing the list(it’s also trivial to implement an iterative loop version of it).</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="ot">&gt;</span> <span class="kw">a</span> <span class="ot">=</span> fact<span class="ot">()</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">))</span>
<span class="dv">1</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">))</span>
<span class="dv">2</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">10</span><span class="ot">))</span>
<span class="dv">3628800</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">20</span><span class="ot">))</span>
<span class="dv">2.4329020081766e+18</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">30</span><span class="ot">))</span>
<span class="dv">2.6525285981219e+32</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">40</span><span class="ot">))</span>
<span class="dv">8.159152832479e+47</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">50</span><span class="ot">))</span>
<span class="dv">3.0414093201713e+64</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">250</span><span class="ot">))</span>
<span class="kw">inf</span></code></pre>
<p>So it’s obviously generating all the factorials while we traverse the list. You can also try to see that every thunk is evaluated only once by adding some <code>print</code> functions to thunks.</p>
<p>Here’s a lazy-list that contains all fibonacci numbers:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> fib<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="kw">b</span><span class="ot">)</span>
    <span class="kw">a</span> <span class="ot">=</span> <span class="kw">a</span> <span class="kw">or</span> <span class="dv">0</span>
    <span class="kw">b</span> <span class="ot">=</span> <span class="kw">b</span> <span class="kw">or</span> <span class="dv">1</span>
    <span class="kw">return</span> cons<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> makeThunk<span class="ot">(</span><span class="kw">fib</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">b</span><span class="ot">,</span> <span class="kw">a</span><span class="ot">+</span><span class="kw">b</span><span class="ot">}))</span>
<span class="kw">end</span></code></pre>
<p>You can also easily define functions that take linked-lists and map/filter and return the result as lazy-lists. I added them the to the gist.</p>
<p>Now, how’s that related with continuations that eliminate tail-calls? Let’s work on an exmple:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">n</span> <span class="ot">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span>
        <span class="kw">return</span> cont<span class="ot">(</span><span class="dv">1</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> newCont<span class="ot">(</span><span class="kw">v</span><span class="ot">)</span>
        <span class="kw">return</span> cont<span class="ot">(</span><span class="kw">v</span><span class="ot">+</span><span class="kw">n</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="kw">return</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">-</span><span class="dv">1</span><span class="ot">,</span> <span class="kw">newCont</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>I found JavaScript version of this example in <a href="http://nathansuniversity.com/cont3.html">Nathan’s University</a> and I think it’s a typical usage of continuations. Instead of returning the result, we’re passing the result to the continuation function. And when we hit the buttom(ie. when n &lt;= 1) we pass the last result to continuation function and return it.</p>
<p>I don’t explain why one would do that, you can read it from Nathan’s University.</p>
<p>If you run a function like this in JavaScript, you get a stack overflow after a while since this function is recursive. But with the help of thunks, you can eliminate the recursive call entirely, even in JavaScript. Let’s change it to:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">n</span> <span class="ot">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span>
        <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="dv">1</span><span class="ot">})</span>
    <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> newCont<span class="ot">(</span><span class="kw">v</span><span class="ot">)</span>
        <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">v</span><span class="ot">+</span><span class="kw">n</span><span class="ot">})</span>
    <span class="kw">end</span>
    <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">sum</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">n</span><span class="ot">-</span><span class="dv">1</span><span class="ot">,</span> <span class="kw">newCont</span><span class="ot">})</span>
<span class="kw">end</span></code></pre>
<p>We replaced every function call with thunks. Now you can realize that <code>makeThunk</code> calls are just linking function calls together. For example, after calling <code>sum(10, function(n) print(&quot;result: &quot;, n) end)</code>, we get this thunk:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="ot">{</span> <span class="fu">tag</span> <span class="ot">=</span> <span class="st">&quot;thunk&quot;</span><span class="ot">,</span> <span class="kw">f</span> <span class="ot">=</span> <span class="kw">sum</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="ot">{</span><span class="dv">9</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">v</span><span class="ot">)</span> <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">v</span><span class="ot">+</span><span class="dv">10</span><span class="ot">})</span> <span class="kw">end</span><span class="ot">}}</span></code></pre>
<p>When we evaluate this thunk, we just get another thunk unless the first arg is not &lt;= 1. Now we need a helper to evaluate the thunk, and then evaluate the thunk returned by the first thunk, until we evaluate all the thunks. This is what’s called “trampoline”:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> trampoline<span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span>
    <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
        <span class="kw">if</span> <span class="fu">type</span><span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span> <span class="ot">~=</span> <span class="st">&quot;table&quot;</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">thunk</span>
        <span class="kw">elseif</span> <span class="kw">thunk</span><span class="ot">.</span><span class="kw">tag</span> <span class="ot">==</span> <span class="st">&quot;thunk&quot;</span> <span class="kw">then</span>
            <span class="kw">thunk</span> <span class="ot">=</span> evalThunk<span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">end</span>
<span class="ot">&gt;</span> <span class="kw">a</span> <span class="ot">=</span> sum<span class="ot">(</span><span class="dv">10</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">n</span><span class="ot">)</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;result: &quot;</span><span class="ot">,</span> <span class="kw">n</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">tag</span><span class="ot">)</span>
<span class="kw">thunk</span>
<span class="ot">&gt;</span> trampoline<span class="ot">(</span><span class="kw">a</span><span class="ot">)</span>
<span class="kw">result</span>:         <span class="dv">55</span></code></pre>
<p>We’re evaluating the thunks in a <code>while</code> loop. This is how you can eliminate tail calls. Now, this exactly looks like the lazy-list method I mentioned in this post. And we already used the same thunk structure for both of them.</p>
<p>The only difference is, in continuations we don’t save old thunks anywhere and just replace them with new continuations, and we only return a value other than new thunks when we finished the calculation(ie. when we reach the base case).</p>
<p>So essentially, both continuations and lazy-lists have the same idea. And these are very easy to implement even in langauges that doesn’t support any non-strict primitives.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For a better explanation of <code>thunk</code>s, see <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#footnote_Temp_580">SICP</a>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Lua - basitlik ve esneklik hakkında birkaç şey</title>
    <link href="http://osa1.net/posts/2012-05-07-lua-basitlik-ve-esneklik-hakknda-birkac-sey.html" />
    <id>http://osa1.net/posts/2012-05-07-lua-basitlik-ve-esneklik-hakknda-birkac-sey.html</id>
    <published>2012-05-07T00:00:00Z</published>
    <updated>2012-05-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Programlama dillerini incelediğimi buraları okuyanlar farketmiştir herhalde :) . Bir süredir Lua ile alakalı birşeyler okuyordum. Beni epey etkiledi. İlk yorumlayıcısı ve performansı etkilemişti<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Daha sonradan kaynağını kurcalamış ve ne kadar küçük ve düzenli olduğunu görüp şaşırmıştım. Dilin desteklediği Tail-call optimization ve <a href="https://plus.google.com/112211667397241192219/posts/QE1noJjQYwz">lexical scope</a>’un(ve dolayısıyla closureların) zaten hastasyım. Sonralardan SO gibi ortamlarda “mühendislik harikası” şeklinde nitelendirildiğini gördüm. Henüz bu kısımları değerlendirebilecek seviyede değilim. Ben dilin sadeliği ve bu sadeliğe rağmen nasıl kolayca esneklik sağlayabildiği hakkında birşeyler yazacağım.</p>
<p>Dildeki tek veri yapısı tablolar. Arrayler, mapler, modüller ve dil ile gelen tüm yapılar direkt olarak tablo. Bir veri yapısı yazmak istediğiniz de de tabloları kullanmak zorundasınız. Nasıl Python’da herşey nesneyse, Lua’da da <em>neredeyse</em> herşey tablo<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> Sınıflarla sağlanan bir nesne tabanlı programlama desteği yok. Ama çok basit ve güzel bir özellik sayesinde, multiple inheritance bile sağlayabiliyorsunuz.</p>
<p>Tüm tablolara <code>metatable</code> denilen bir tablo atayabiliyorsunuz. Bu metatablolar(ne diyeyim bilemedim bunlara) tablolar operatörlerle işleme sokulduğunda çağırılacak fonksiyonları tutuyorlar. Örneğin bir tablonun metatablosu <code>__add</code> gibi bir fonksiyona sahipse, bu tabloyu toplama işlemine sokabiliyoruz. Aynı <a href="http://docs.python.org/reference/datamodel.html#object.__add__">Python’daki <code>__add__</code> methodu</a> gibi. Eğer tabloda olmayan bir değer erişmek istersek de, benzer bir şekilde metatablodaki <code>__index</code> fonksiyonuna, eğer tabloda olmayan bir değer eklemeye çalışırsak(mevcut bir değeri değiştirme değil de farklı anahtara sahip bir değer ekleme yani) da <code>__newindex</code> fonksiyonu çağırılıyor. Bunlar aynı Python’daki <a href="http://docs.python.org/reference/datamodel.html#object.__getattr__"><code>__getattr__</code></a> ve <a href="http://docs.python.org/reference/datamodel.html#object.__setattr__"><code>__setattr__</code></a> gibiler.</p>
<p>Bugün yazdığım uygulamada şöyle bir sorun yaşadım. <em>Rect</em> adlı bir tablo tutuyorum ve bu tabloyu metatablo olarak kullanan başka tablolar oluşturuyorum. Sanki <em>Rect</em> diye bir sınıfım varmış da nesneler oluşturuyormuşum gibi. Bir yerden sonra bu tablonun implementasyonunda ciddi bir değişiklik yapıyorum ve <code>x</code> ve <code>y</code> özellikleri yerine artık bir <code>center</code> ve <code>angle</code> diye iki özellik ekliyorum. Ama bu tablonun bazı <code>x</code> ve <code>y</code> özelliklerini kullanan fonksiyonlarımı teker teker değiştirmemem gerek. Python konuşanlara bunu şöyle özetleyebiliriz, sınıfımdan iki özellik siliyorum, bunların artık sınıftaki diğer özelliklerden hesaplanması gerek. Ama kodumu refactor etmek istemiyorum. Bu durumda Python’da yapılacak işlem bariz: <code>x</code> ve <code>y</code>yi <a href="http://docs.python.org/library/functions.html#property"><code>property</code></a> decoratorü içerisinde methodlar olarak tanımlamak<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> Lua’da bunu şöyle yaptım:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">Rect</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">width</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">height</span> <span class="ot">=</span> <span class="dv">0</span> <span class="ot">}</span>
<span class="kw">function</span> Rect_indexfn <span class="ot">(</span><span class="kw">table</span><span class="ot">,</span> <span class="kw">key</span><span class="ot">)</span>
    <span class="kw">local</span> <span class="kw">f</span><span class="ot">,</span> <span class="kw">o</span>
    <span class="kw">if</span> <span class="kw">key</span> <span class="ot">==</span> <span class="st">&#39;x&#39;</span> <span class="kw">then</span>
        <span class="kw">f</span> <span class="ot">=</span> <span class="fu">math.cos</span>
        <span class="kw">o</span> <span class="ot">=</span> <span class="kw">table</span><span class="ot">.</span><span class="kw">centerx</span>
    <span class="kw">elseif</span> <span class="kw">key</span> <span class="ot">==</span> <span class="st">&#39;y&#39;</span> <span class="kw">then</span>
        <span class="kw">f</span> <span class="ot">=</span> <span class="fu">math.sin</span>
        <span class="kw">o</span> <span class="ot">=</span> <span class="kw">table</span><span class="ot">.</span><span class="kw">centery</span>
    <span class="kw">end</span>
    <span class="kw">if</span> <span class="kw">f</span> <span class="kw">then</span>
        <span class="kw">return</span> <span class="kw">o</span><span class="ot">-</span><span class="fu">math.abs</span><span class="ot">(</span>f<span class="ot">(</span><span class="fu">math.rad</span><span class="ot">(</span><span class="kw">table</span><span class="ot">.</span><span class="kw">angle</span><span class="ot">)))*</span><span class="kw">math</span><span class="ot">.</span>pow<span class="ot">(</span><span class="kw">math</span><span class="ot">.</span>pow<span class="ot">(</span><span class="kw">table</span><span class="ot">.</span><span class="kw">height</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">)+</span><span class="kw">math</span><span class="ot">.</span>pow<span class="ot">(</span><span class="kw">table</span><span class="ot">.</span><span class="kw">width</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">),</span> <span class="dv">0.5</span><span class="ot">)/</span><span class="dv">2</span>
    <span class="kw">end</span>
<span class="kw">end</span>
<span class="kw">function</span> <span class="kw">Rect</span>:new<span class="ot">()</span>
    <span class="fu">setmetatable</span><span class="ot">(</span><span class="kw">self</span><span class="ot">,</span> <span class="ot">{</span> <span class="kw">__index</span> <span class="ot">=</span> <span class="kw">Rect_indexfn</span> <span class="ot">})</span>
    <span class="kw">return</span> <span class="kw">self</span>
<span class="kw">end</span>
<span class="kw">a</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">})</span>
<span class="kw">b</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">})</span>
<span class="kw">b</span><span class="ot">.</span><span class="kw">angle</span> <span class="ot">=</span> <span class="dv">60</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">x</span><span class="ot">)</span> <span class="co">-- -4.3301270189222</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">b</span><span class="ot">.</span><span class="kw">y</span><span class="ot">)</span> <span class="co">-- -4.3301270189222</span></code></pre>
<p>Tek yaptığım, yeni bir Rect oluşturuğum tablonun metatablosunu daha önceden belirlediğim <code>Rect_indexfn</code> fonksiyonunun <code>__index</code> fonksiyonu olarak tutan bir tablo olarak belirlemek. Bundan ne zaman kendisinin sahip olmadığı bir değere erişilmeye çalışsa, bu fonksiyon çalışarak erişilmek istenen değere göre işlemler yapıyor. Bu arada <code>:</code> ile tanımladığım fonksiyonların aldığı ilk parametre <code>self</code> değerine atanıyor. <code>Rect:new()</code> fonksiyonum hiçbir parametre almıyormuş gibi gözüksede, <code>self</code> adlı bir parametre alıyor yani aslında.</p>
<p>Şimdi normalde bunu gösterip bitirecektim ama multiple inheritance implementasyonu da o kadar kolay ki atlayamadım:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="kw">Rect</span>:new<span class="ot">(</span><span class="kw">ps</span><span class="ot">)</span>
    <span class="co">-- lua&#39;da vararglar biraz sorunlu oldugundan superclasslari</span>
    <span class="co">-- bir array olarak alacagim. detaylar icin: http://lua-users.org/wiki/VarargTheSecondClassCitizen</span>
    <span class="kw">local</span> <span class="kw">function</span> indexfn <span class="ot">(</span><span class="kw">table</span><span class="ot">,</span> <span class="kw">key</span><span class="ot">)</span>
        <span class="kw">local</span> <span class="kw">v</span> <span class="ot">=</span> Rect_indexfn<span class="ot">(</span><span class="kw">table</span><span class="ot">,</span> <span class="kw">key</span><span class="ot">)</span>
        <span class="kw">if</span> <span class="kw">v</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">v</span>
        <span class="kw">end</span>
        <span class="kw">for</span> <span class="kw">i</span><span class="ot">,</span><span class="kw">v</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">ps</span><span class="ot">)</span> <span class="kw">do</span>
            <span class="kw">v</span> <span class="ot">=</span> <span class="kw">v</span><span class="ot">[</span><span class="kw">key</span><span class="ot">]</span>
            <span class="kw">if</span> <span class="kw">v</span> <span class="kw">then</span>
                <span class="kw">return</span> <span class="kw">v</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
    <span class="fu">setmetatable</span><span class="ot">(</span><span class="kw">self</span><span class="ot">,</span> <span class="ot">{</span> <span class="kw">__index</span> <span class="ot">=</span> <span class="kw">indexfn</span> <span class="ot">})</span>
    <span class="kw">return</span> <span class="kw">self</span>
<span class="kw">end</span>
<span class="co">-- bu ikisi superclass gorevinde</span>
<span class="kw">st1</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">attr1</span> <span class="ot">=</span> <span class="st">&quot;st1 attr1&quot;</span> <span class="ot">}</span>
<span class="kw">st2</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">attr1</span> <span class="ot">=</span> <span class="st">&quot;st2 attr1&quot;</span><span class="ot">,</span> <span class="kw">attr2</span> <span class="ot">=</span> <span class="st">&quot;st2 attr2&quot;</span> <span class="ot">}</span>
<span class="kw">a</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">},</span> <span class="ot">{</span> <span class="kw">st1</span><span class="ot">,</span> <span class="kw">st2</span> <span class="ot">})</span>
<span class="kw">b</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">},</span> <span class="ot">{</span> <span class="kw">st2</span> <span class="ot">})</span>
<span class="kw">b</span><span class="ot">.</span><span class="kw">angle</span> <span class="ot">=</span> <span class="dv">60</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">x</span><span class="ot">)</span>     <span class="co">-- -4.3301270189222</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">b</span><span class="ot">.</span><span class="kw">y</span><span class="ot">)</span>     <span class="co">-- -4.3301270189222</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">attr1</span><span class="ot">)</span> <span class="co">-- st1 attr1</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">attr2</span><span class="ot">)</span> <span class="co">-- st2 attr2</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">b</span><span class="ot">.</span><span class="kw">attr1</span><span class="ot">)</span> <span class="co">-- st2 attr1</span></code></pre>
<p>Constructoru bu şekilde değiştirdim. <code>__index</code> fonksiyonunun yeni haline bakarsanız, ilk başta <code>Rect_indexfn</code>yi çağırıyor, eğer hala gerekli değerler bulunamıyorsa, soldan itibaren superclassları aramaya başlıyor. Burda ben en basit implementasyonu yapmaya çalıştım, eğer superclasslar da bu şekilde tanımlanmış metatabloya sahiplerse, arama işlemi ilk superclassın superclasslarıyla devam edecek. Kolayca farklı davranışlar tanımlanabilir, tüm algoritma <code>indexfn</code> fonksiyonundan ibaret. Hayal gücünüzce geliştirip, <a href="http://en.wikipedia.org/wiki/Diamond_problem">diamond problem</a> ile karşılaşıp, kendi çözümünüzü uydurabilirsiniz :) .</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>İlgili makaleler: <a href="http://www.lua.org/doc/jucs05.pdf">Implementation of Lua 5.0</a>, <a href="http://www.lua.org/spe.html">Lua - an extensible extension language</a>, <a href="http://www.lua.org/doc/hopl.pdf">The Evolution of Lua</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Neredeyse. Sayılar(<code>number</code>) değil. Başka tablo olmayan var mı şu anda aklıma gelmiyor. Tablo implementasyon detayları için “Implementation of Lua 5.0” yazısına bakabilirsiniz.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Java’cılar zaten tüm özellikleri private yapıp, bir refleks olarak getter/setterlar tanımladıkları için onlar için sorun yok ehuaehe.<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
