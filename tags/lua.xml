<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged lua</title>
    <link href="http://osa1.net/tags/lua.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/lua.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2014-04-27T00:00:00Z</updated>
    <entry>
    <title>Calling Haskell from Lua and Lua from Haskell</title>
    <link href="http://osa1.net/posts/2014-04-27-calling-haskell-lua.html" />
    <id>http://osa1.net/posts/2014-04-27-calling-haskell-lua.html</id>
    <published>2014-04-27T00:00:00Z</published>
    <updated>2014-04-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/osa1/hslua"><code>hslua</code></a> provides Lua 5.1 C API to the programmer, and using it we can call Lua functions from Haskell and Haskell functions from Lua. In this post, I’m going to give two example Lua function implementations in Haskell. This functions will be mapped to a global name in Lua and one of them will be getting Lua functions as it’s arguments.</p>
<h1 id="two-ways-of-writing-lua-functions-in-haskell">Two ways of writing Lua functions in Haskell</h1>
<p>There are two ways of writing Lua functions in Haskell using hslua. First is the high-level method, where the Haskell function is just any function, provided that it’s type is an instance of <code>LuaImport</code>(we’ll come to this later). Second method is what I’d like to call the <em>raw</em> Haskell function method. <em>Raw</em> Haskell functions should have the type <code>LuaState -&gt; IO CInt</code>, where <code>LuaState</code> is Lua interpreter state provided by <code>hslua</code> and return type <code>CInt</code> represents the amount of return values(e.g. values that are left on the stack by this function). In <em>raw</em> functions, you need to do Lua stack manipulation using standard <a href="http://www.lua.org/manual/5.1/manual.html#3">Lua 5.1 API</a>.</p>
<p>While first method gives you a nice, abstracted way of writing Lua functions in Haskell, <em>raw</em> function method gives you the maximum amount of flexibility that Lua can provide. First method has lots of limitations when compared with <em>raw</em> method.</p>
<h1 id="higher-level-haskell-functions-in-lua">Higher-level Haskell functions in Lua</h1>
<p>In first method all you have to do is to write a Haskell function with it’s type is an instance of <code>LuaImport</code>. So let’s see what types are instances:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">StackValue</span> a) <span class="ot">=&gt;</span> <span class="dt">LuaImport</span> (<span class="dt">IO</span> a) <span class="kw">where</span>
<span class="kw">instance</span> (<span class="dt">StackValue</span> a, <span class="dt">LuaImport</span> b) <span class="ot">=&gt;</span> <span class="dt">LuaImport</span> (a <span class="ot">-&gt;</span> b)</code></pre>
<p>So basically every function type where it’s argument types are instances of <code>StackValue</code> and return type is <code>IO a</code> where <code>a</code> is also an instance of <code>StackValue</code> is an instance of <code>LuaImport</code> and thus can be used in this higher-level method of writing Lua functions in Haskell. Let’s see which types are <code>StackValue</code>s:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaInteger</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaNumber</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Int</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Double</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">String</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">Bool</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> (<span class="dt">FunPtr</span> <span class="dt">LuaCFunction</span>)
<span class="kw">instance</span> <span class="dt">StackValue</span> (<span class="dt">Ptr</span> a)
<span class="kw">instance</span> <span class="dt">StackValue</span> <span class="dt">LuaState</span>
<span class="kw">instance</span> <span class="dt">StackValue</span> ()</code></pre>
<p>We have basic Haskell types <code>Int</code>, <code>Double</code>, <code>String</code>, and <code>Bool</code> as instances. Other types are for more advanced use, for example, <code>Ptr a</code> is used for <code>userdata</code>(basically any binary data that you want to pass to Lua stack and later get back, see <a href="http://www.lua.org/manual/5.1/manual.html#2.2">reference manual</a> for more details).</p>
<p>This two functions are instances of <code>LuaImport</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">concat&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
concat&#39; s1 s2 <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> s1 <span class="fu">++</span> s2

<span class="ot">pow ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span>
pow d1 d2 <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> d1 <span class="fu">**</span> d2</code></pre>
<p>And we can push this functions to Lua stack using <code>pushhsfunction</code> or directly assign them to a global variable using <code>registerhsfunction</code>. In this post I’ll use register functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Scripting.Lua <span class="kw">as</span> Lua

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> newstate
    openlibs l
    registerhsfunction l <span class="st">&quot;concat&quot;</span> concat&#39;
    registerhsfunction l <span class="st">&quot;pow&quot;</span> pow
    loadfile l <span class="st">&quot;haskellfun.lua&quot;</span>
    call l <span class="dv">0</span> <span class="dv">0</span>
    close l</code></pre>
<p>With 11 lines of code, we can create a Lua state and map this Haskell functions to some names and call them from Lua. This program runs Lua file <code>haskellfun.lua</code>, which you can see in examples folder of <a href="https://github.com/osa1/hslua/tree/master/examples/haskellfun"><code>hslua</code> repository</a>.</p>
<p>Apart from the simplicity, another good thing about this method is that it handles type checking of Lua values automatically. Internally, this functions are wrapped with another function which gets <code>LuaState</code> as parameter and collects Lua values from stack, checks their types(and throws error in case of a type mismatch), and push return value of the function to the Lua stack again. Here’s an example call with wrong type of values:</p>
<pre><code>print(pow(&quot;wrong&quot;))
...
bad argument #1 to &#39;?&#39; (number expected, got string)</code></pre>
<p>Major limitation of this method is that you can only get basic Lua types from the Lua stack. For example, you can’t get a Lua table automatically like you get a Lua string. This because Lua needs to keep track of tables and some other values for garbage collection.</p>
<h1 id="working-on-more-complex-lua-types-and-the-registry">Working on more complex Lua types and the registry</h1>
<p>The Lua way of using Lua tables, Lua functions etc. in Lua API is to register that values to the Lua table called <em>registry</em>, and refer to that values using their index at <em>registry</em>. Using <em>registry</em>, Lua keeps tracks of references to Lua values that are available for garbage collection. See <a href="http://www.lua.org/manual/5.1/manual.html#3.5">reference manual section 3.5</a> for more details.</p>
<h1 id="raw-haskell-function-method">Raw Haskell function method</h1>
<p>We can do this writing <em>raw</em> Haskell functions. Raw functions have type <code>LuaState -&gt; IO CInt</code> and <code>LuaState</code> allows us to run any C API function. <em>raw</em> functions are pushed to Lua stack using <code>pushrawhsfunction</code> and registered as global variable using <code>registerrawhsfunction</code>.</p>
<p><a href="https://github.com/osa1/hslua/tree/master/examples/callbacks"><code>callbacks</code> example</a> in the <code>hslua</code> repository takes Lua callbacks in Haskell functions and later call them in FIFO order and return their return values as a Lua array(table with int keys). You can see the complete program in the repository and here I’ll give only the tricky parts.</p>
<p><em>Raw</em> Haskell functions should return number of values left on the Lua stack as return values. As an example, <code>addLuaCallbacks</code> function uses this for simple error reporting, it puts the error string to the Lua stack and return <code>1</code> in case of an error, and return <code>0</code> otherwise:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addLuaCallbacks l <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
    <span class="kw">case</span> as <span class="kw">of</span>
      <span class="kw">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="co">-- arguments are functions, add them to callback queue and return</span>
        <span class="co">-- nothing</span>
        addCallbacks <span class="dv">1</span> args
        <span class="fu">return</span> <span class="dv">0</span>
      <span class="kw">Just</span> errArg <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="co">-- error: argument at `errArg` is not a function, return error</span>
        <span class="co">-- string</span>
        pushstring l <span class="fu">$</span> <span class="st">&quot;argument &quot;</span> <span class="fu">++</span> <span class="fu">show</span> errArg <span class="fu">++</span> <span class="st">&quot; is not a function&quot;</span>
        <span class="fu">return</span> <span class="dv">1</span></code></pre>
<p>This example program keeps track of passed Lua callbacks in an <code>IORef</code>. Here’s the part that handles getting Lua callbacks from Lua stack:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addCallbacks n <span class="fu">max</span>
  <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="fu">max</span> <span class="fu">=</span> <span class="fu">return</span> ()
  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">do</span>
      <span class="co">-- move nth argument to top of the stack</span>
      pushvalue l n
      <span class="co">-- add function reference to registry</span>
      refId <span class="ot">&lt;-</span> ref l registryindex
      <span class="co">-- add registry index to IORef</span>
      modifyIORef cs (<span class="fu">++</span> [refId])
      <span class="co">-- continue adding other arguments</span>
      addCallbacks (n<span class="fu">+</span><span class="dv">1</span>) <span class="fu">max</span></code></pre>
<p>Note how we’re adding the function to the <em>registry</em> and getting it’s index at the <em>registry</em> in Haskell. We can now refer to this functions(e.g. push this function to Lua stack) using this index. Here’s the relevant code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Call Lua callbacks collected with `addLuaCallbacks`.</span>
<span class="ot">callLuaCallbacks ::</span> <span class="dt">LuaState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CInt</span>
callLuaCallbacks l <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
  <span class="kw">where</span>
    iter [] <span class="fu">=</span> <span class="fu">return</span> ()
    iter (c <span class="fu">:</span> rest) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">...</span>
      pushinteger l (<span class="fu">fromIntegral</span> c)
      gettable l registryindex
      <span class="co">-- call the callback</span>
      call l <span class="dv">0</span> <span class="dv">1</span>
      <span class="fu">...</span>
      iter rest</code></pre>
<p>We’re pushing the index to the Lua stack, and calling <code>gettable</code> to push actual function to the stack using the index. Complete program is longish, so I’m omitting it here, you can see it in <a href="https://github.com/osa1/hslua"><code>hslua</code>s Github repository</a> with an example Lua program that uses defined Haskell functions to pass Lua callbacks to Haskell.</p>
<h1 id="a-note-about-safety">A note about safety</h1>
<p>Lua tolerates some incorrect stack operations and if you do that while writing <em>raw</em> Haskell functions, you can have hard times debugging your programs. Fortunately, Lua also provides a compile time flag to enable checking API usage for safety. If you install <code>hslua</code> using <code>-fapicheck</code> Cabal flag, it compiled Lua with API checking enabled and Lua gives you errors instead of silently doing something not intended. For example, if you refer to a Lua value at stack index <code>-4</code> while your stack has only <code>3</code> elements, you get something like:</p>
<pre><code>callbacks: src/lapi.c:57: index2adr: Assertion `idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base&#39; failed.</code></pre>
<p>This helps making sure that your API usage is correct.</p>
<h1 id="using-hslua-for-reading-configuration-files-written-in-lua">Using hslua for reading configuration files written in Lua</h1>
<p>hslua also provides a module for reading configuration files. As an example, using <code>Scripting.Lua.ConfigFile.getNestedAssocLists</code>, you can execute the Lua file given below and get resulting nested table as Haskell <code>[(String, [(String, String)])]</code>:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"> <span class="kw">someVal</span> <span class="ot">=</span> <span class="ot">{</span>
    <span class="kw">something</span> <span class="ot">=</span> <span class="ot">{</span>
       <span class="kw">foo</span> <span class="ot">=</span> <span class="st">&quot;aaa&quot;</span><span class="ot">,</span>
       <span class="kw">bar</span> <span class="ot">=</span> <span class="st">&quot;bbb&quot;</span><span class="ot">,</span>
       <span class="kw">baz</span> <span class="ot">=</span> <span class="st">&quot;ccc&quot;</span>
    <span class="ot">},</span>
    <span class="kw">somethingElse</span> <span class="ot">=</span> <span class="ot">{</span>
       <span class="ot">...</span>
    <span class="ot">}</span>
 <span class="ot">}</span></code></pre>
<h1 id="running-lua-programs-using-lua-interpreters">Running Lua programs using Lua interpreters</h1>
<p>In all hslua examples, we needed to create Lua state in Haskell, register Haskell functions inside Haskell and then run Lua files using Lua C API again in Haskell. I think in theory it is also possible to run Lua programs using standard Lua interpreter executables(instead of running the interpreter using Lua C API inside Haskell) and load Haskell functions compiled to <code>*.so</code> shared library files.</p>
<p>About one year ago, I did something similar using C instead of Haskell. You can see the code <a href="https://github.com/osa1/lcl">here</a>. The library compiled to a <code>.so</code> file and by using Lua’s <code>package.loadlib</code>, you can load functions defined in the <code>.so</code>.</p>
<p>Compiling raw Haskell <code>hslua</code> functions to a <code>.so</code> should not be tricky. <code>LuaState</code> type is just a wrapper around <code>Ptr ()</code>, and <code>CInt</code> is just a C integer, so it’s signature is already compatible. We probably need to use <code>foreign export ...</code> of GHC FFI and find GHC parameters to compile to <code>.so</code>. I’ll investigate this further and post updates.</p>]]></summary>
</entry>
<entry>
    <title>lcl -- Lua Container Library and The One Data Structure to Rule Them All</title>
    <link href="http://osa1.net/posts/2013-06-08-lcl-and-one-data-structure.html" />
    <id>http://osa1.net/posts/2013-06-08-lcl-and-one-data-structure.html</id>
    <published>2013-06-08T00:00:00Z</published>
    <updated>2013-06-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><strong>Note: Sorry for organization of this post. We were talking about this stuff over #lua IRC channel for an hour, and before that I had worked on various bugs and I’m incredibly tired now.</strong></p>
<p>I’ve been working with an experimental Lua library lately. It had started as a learning exercise, and after first iteration, it turned out to be an experiment about Lua’s internals, dynamic linking, and data structures.</p>
<p>Lua Container Lib(lcl or liblcl for short) is a Lua library to use C++ STL containers from within Lua. It’s compiled to a single <code>.so</code>(or <code>.dll</code>) and it can be loaded from Lua 5.1.5, 5.2.2, LuaJIT 2.0.2 and Love2D with <code>package.loadlib</code> standard function. It provides some STL containers with an object-oriented interface.</p>
<p>You can see the source <a href="https://github.com/osa1/lcl">here</a>. There isn’t any tutorials yet, I think it’s simple enough to learn it from examples, see <code>tests/</code> folder.</p>
<p>For now, it only contains set and deque containers, but it should be very easy to add more. Also, not all operations on sets and deques are supported yet. Again, this should also be very easy to add. Current code base should have all kinds of code to implement more containers/operations on containers by just looking for others’ implementations. Pull requests are welcome!</p>
<p><code>tests/</code> folder also have a simple benchmark. Output of benchmark is in files <code>benchmark.output</code> and <code>benchmark.output_luajit</code>. I think most people find the output interesting. Before explaining what’s going on in that benchmark, here are some stuff I learned while developing this library:</p>
<h2 id="lessons-learned">Lessons learned</h2>
<p>Lua has some rules about the use of C API, but when you don’t follow the rules, you don’t immediately get caught. For instance, you should return the number of elements placed to the stack in your C functions. I had a bug in my code and one of my functions was returning 1 even though it returns with an empty stack. Nevertheless, the library worked fine until I tried it with LuaJIT.</p>
<p>LuaJIT is more picky about that rules and it fails in strange ways. Sometimes my program was failing with strange memory allocation errors, but program was still running. In the best case, I was getting a segmentation fault.</p>
<p>After several hours of debugging and some help from mailing list(see my mail <a href="http://www.freelists.org/post/luajit/cant-load-so-with-packageloadlib-undefined-symbol-error">here</a>) I could solve it. Best helper was the <code>LUA_USE_APICHECK</code> debug macro. It’s added to Lua in somewhere between Lua 5.1.5 and 5.2.2. When you compile Lua with <code>LUA_USE_APICHECK</code> defined, Lua makes some assertions in code to make sure stack is in correct state. You should always develop C libraries to Lua with this enabled.</p>
<p>Now, as for benchmarks; two things can be seen immediately from benchmarks: 1) All operations on STL containers are slower 2) LuaJIT is awesome.</p>
<p>Let’s first start from second point. LuaJIT is awesome. It’s best thing happened to Lua. It’s binary compatible with Lua 5.1.5, which means with minimal effort, you can gain some real performance benefits. You can see the difference by comparing <code>benchmark.output</code> and <code>benchmark.output_luajit</code> files. All I had to do was to run program with LuaJIT instead of Lua.</p>
<p>Now, as for STL containers .. Before starting this project, I was considering having a better performance for specialized data structures, ie. STL deques should be faster than Lua tables used as deques. As can be seen from benchmarks, that’s not the case. I made a simplest possible deque implementation possible in Lua(you can see it <a href="https://github.com/osa1/lcl/blob/master/tests/deque.lua">here</a>) and it’s still faster than STL deque(with minor difference).</p>
<p>I think there are several reasons for that.</p>
<p>There is no way to get a Lua value out of Lua interpreter. Lua C API deliberately avoid this because this may lead to memory leaks or memory corruptions.</p>
<p>You can only have a reference to a Lua value, and in that case, that value has to be written in some table. <a href="http://www.lua.org/manual/5.2/manual.html#luaL_ref"><code>luaL_ref</code></a> creates a reference and writes it to a Lua table, and then return that reference(as an <code>int</code>). Generally, you would use global register at <code>LUA_REGISTRYINDEX</code> to save Lua values.</p>
<p>This implies that you cannot have a container with insertion faster than Lua table insertion. Because every insertion also have to insert to a Lua table. This table is generally the global register at index <code>LUA_REGISTRYINDEX</code>. For example, when I add 1000000 elements to a set, all those elements is also added to the register.</p>
<p>You can see that STL deque insertions time is almost the same as Lua implementation’s. The reason for this is that even though STL deque insertion is O(1) with a minimal constant factor, you have to insert to a Lua table like explained above.</p>
<p>In case of set data structure: STL’s set implementation is generally a kind of tree, and elements are stored in sorted order(this makes possible to use STL sets as heaps like I did in <a href="https://github.com/osa1/lcl/blob/master/tests/dynload.lua"><code>dynload.lua</code></a> example). This causes extra O(log N) function calls for comparisons, where N is number of elements in tree. ie. when a new element added, it’s place is determined by comparing it with elements at each level and then moving down to next level in tree. In case of Lua tables, all insertions are amortized O(1) and no comparison functions are called.</p>
<p>These are my explanations to reasons of why STL operations are slower.</p>
<p>Still, I don’t think adding C/C++ containers in Lua is completely pointless. Significant memory savings may be possible with C/C++ containers. For example, 32 flags can be held in a 32bit integer in C/C++, but to do this in Lua, you need to use a double for every flag, and a table. A double is 8 bytes in my 64bit machine. And with 32 flags it costs you 32*8 = 256 bytes. In C/C++ you can have it with only 4 bytes.</p>
<p>There may be also performance advantages for really complex algorithms, but I don’t have a particular example in mind.</p>]]></summary>
</entry>
<entry>
    <title>Compiling Love2D with LuaJIT</title>
    <link href="http://osa1.net/posts/2013-06-08-compiling-love2d-with-luajit.html" />
    <id>http://osa1.net/posts/2013-06-08-compiling-love2d-with-luajit.html</id>
    <published>2013-06-08T00:00:00Z</published>
    <updated>2013-06-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For some reason, I couldn’t load my dynamic library(compiled to <code>.so</code>) in Love2D linked with Lua 5.1.5. It was failing with <code>undefined symbol: lua_getfield</code> error. Interesting point is that I could load same library from directly in Lua 5.1.5 interpreter, which is the same thing as Love2D’s Lua interpreter. They’re compiled with same headers and linked with same object files.</p>
<p>I wasted several hours trying to compile Love2D with LuaJIT with the hope of loading my library from Love2D. I had tried loading my library from several different Lua versions before, Lua 5.1.5, Lua 5.2.5 and LuaJIT 2.0.2, and everything had worked perfectly. So I was expecting it to work with Love2D’s Lua interpreter too.</p>
<p>The problem was that Love2D’s configure script was not using environment variables to look for headers/object files. I was using same environment variables to build some other programs that use LuaJIT, and only Love2D had that problem.</p>
<p>To overcome this, I had to install LuaJIT to <code>/usr/</code>. There no way to compile Love2D with LuaJIT other than installing LuaJIT to <code>/usr/</code>. Installing <code>/usr/local/</code> doesn’t work. Setting environment variables(<code>LDFLAGS</code>, <code>LIBS</code> and <code>CPPFLAGS</code>) doesn’t work.</p>
<p>After that, I could compile Love2D. But that wasn’t enough because then generated executable was failing with <code>libluajit-5.1.so.2: cannot open shared object file: No such file or directory</code>. The reason of this error is latest version of LuaJIT generates a library file with different name: <code>libluajit-5.1.so.2.0.2</code>. This makes sense, I think most C/C++ libraries use same naming conventions.</p>
<p>Thankfully, renaming it works. Just rename that so file with required file.</p>
<p>I’m working on some Lua libraries written in C++, and testing gets painful when you can’t be sure which libraries you’re library is linked against. For this reason I don’t install Lua to <code>/usr</code> or <code>/usr/local</code>, and manually specify header/object file locations while compiling my library. So I removed all LuaJIT files from <code>/usr/lib</code>, <code>/usr/include</code>, etc. But to make Love2D work, I need <code>libluajit-5.1.so.2</code>. So I created a <code>lib</code> folder in my home dir, moved LuaJIT file there, and add that folder to <code>$LD_LIBRARY_PATH</code> environment variable. With this, I had a Love2D working with latest LuaJIT.</p>
<p>Hope this helps other people who want LuaJIT enabled Love2D on Linux.</p>]]></summary>
</entry>
<entry>
    <title>A converter from Lua tables to JavaScript objects</title>
    <link href="http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html" />
    <id>http://osa1.net/posts/2013-05-06-lua-tables-to-js-objs.html</id>
    <published>2013-05-06T00:00:00Z</published>
    <updated>2013-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote a simple Haskell program to convert some data encoded as Lua tables to JavaScript objects/arrays to be used in another project of mine:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span>           Language.Lua.Parser
<span class="kw">import</span>           Language.Lua.Types

<span class="kw">import</span> <span class="kw">qualified</span> Language.ECMAScript3.Syntax       <span class="kw">as</span> JS
<span class="kw">import</span>           Language.ECMAScript3.PrettyPrint  (renderExpression)

<span class="kw">import</span>           System.Environment                (getArgs)
<span class="kw">import</span>           Control.Monad
<span class="kw">import</span>           Prelude                           <span class="kw">hiding</span> (exp)

<span class="ot">unsupported ::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
unsupported <span class="fu">=</span> <span class="fu">error</span> <span class="fu">.</span> (<span class="st">&quot;unsupported exp: &quot;</span> <span class="fu">++</span>) <span class="fu">.</span> <span class="fu">show</span>

<span class="kw">class</span> <span class="dt">ToJsExp</span> a <span class="kw">where</span>
<span class="ot">    toJsExp ::</span> a <span class="ot">-&gt;</span> <span class="dt">JS.Expression</span> ()

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Exp</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Nil</span> _) <span class="fu">=</span> <span class="dt">JS.NullLit</span> ()
    toJsExp (<span class="dt">Bool</span> _ bool) <span class="fu">=</span> <span class="dt">JS.BoolLit</span> () bool
    toJsExp (<span class="dt">Number</span> _ num) <span class="fu">=</span> <span class="dt">JS.NumLit</span> () (<span class="fu">read</span> num)
    toJsExp (<span class="dt">String</span> _ str) <span class="fu">=</span> <span class="dt">JS.StringLit</span> () str
    toJsExp (<span class="dt">TableConst</span> _ table) <span class="fu">=</span> toJsExp table
    toJsExp unsupportedexp <span class="fu">=</span> unsupported (<span class="fu">fmap</span> (<span class="fu">const</span> ()) unsupportedexp)

<span class="kw">instance</span> <span class="dt">ToJsExp</span> (<span class="dt">Table</span> a) <span class="kw">where</span>
    toJsExp (<span class="dt">Table</span> _ fields)
      <span class="fu">|</span> <span class="fu">all</span> arrField fields <span class="fu">=</span>
          <span class="dt">JS.ArrayLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">Field</span> _ <span class="fu">exp</span>) <span class="ot">-&gt;</span> toJsExp <span class="fu">exp</span>) fields
      <span class="fu">|</span> <span class="fu">all</span> objField fields <span class="fu">=</span>
          <span class="dt">JS.ObjectLit</span> () <span class="fu">$</span> <span class="fu">map</span> (\(<span class="dt">NamedField</span> _ (<span class="dt">Name</span> _ name) <span class="fu">exp</span>) <span class="ot">-&gt;</span> (<span class="dt">JS.PropId</span> () (<span class="dt">JS.Id</span> () name), toJsExp <span class="fu">exp</span>)) fields
      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> unsupported (<span class="fu">map</span> (<span class="fu">fmap</span> (<span class="fu">const</span> ())) fields)

      <span class="kw">where</span>
        arrField <span class="dt">Field</span>{} <span class="fu">=</span> <span class="kw">True</span>
        arrField _       <span class="fu">=</span> <span class="kw">False</span>

        objField <span class="dt">NamedField</span>{} <span class="fu">=</span> <span class="kw">True</span>
        objField _            <span class="fu">=</span> <span class="kw">False</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    contents <span class="ot">&lt;-</span> <span class="fu">readFile</span> (<span class="fu">head</span> args)
    <span class="kw">case</span> parseText <span class="fu">exp</span> contents <span class="kw">of</span>
      <span class="kw">Left</span> err <span class="ot">-&gt;</span> <span class="fu">print</span> err
      <span class="kw">Right</span> result <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> renderExpression <span class="fu">$</span> toJsExp result</code></pre>
<p>It uses <a href="http://hackage.haskell.org/package/language-lua">language-lua</a>, a Lua parser and pretty-printer which I wrote to use in some other project of mine(a static analysis tool for Lua, I have big plans about it) and <a href="http://hackage.haskell.org/package/language-ecmascript">language-ecmascript</a>, JavaScript parser and pretty-printer.</p>]]></summary>
</entry>
<entry>
    <title>An interesting case of closures: is closed-over variable reference or value?</title>
    <link href="http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html" />
    <id>http://osa1.net/posts/2013-04-24-interesting-case-of-closures.html</id>
    <published>2013-04-24T00:00:00Z</published>
    <updated>2013-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I discovered an interesting behavior of JavaScript’s closures while writing a nodejs script.</p>
<p>This behavior is pretty easy to observe when writing a nodejs application, because of it’s callback-based asynchronous nature, you’ll be writing callbacks all the time. Let’s say I’ll create a callback function which uses a variable defined in outer-scope, then do some actions using that variable:</p>
<pre class="sourceCode JavaScript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>(<span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
    });
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>What I expect from this program is to print <code>foo\nbar\nbaz</code>, but it instead prints <code>baz\nbaz\nbaz</code>. It’s like <code>say</code> variable used inside the callback is a reference and not a value. But it’s still strange because the reference should be local to for-loop’s body, so each <code>var say = ...</code> assignment should create a separate reference.</p>
<p>I find this behavior very counterintuitive. Before moving to solutions to fix this, I tried same program with several other languages.</p>
<p>Python also has this problem<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback():
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>This prints same wrong output as with JavaScript.</p>
<p>Lua, my favorite dynamic language, does great:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">callbacks</span> <span class="ot">=</span> <span class="ot">{}</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">({</span> <span class="st">&quot;foo&quot;</span><span class="ot">,</span> <span class="st">&quot;bar&quot;</span><span class="ot">,</span> <span class="st">&quot;baz&quot;</span> <span class="ot">})</span> <span class="kw">do</span>
  <span class="fu">table.insert</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">,</span> <span class="kw">function</span> <span class="ot">()</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;say &quot;</span> <span class="ot">..</span> <span class="kw">v</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="kw">end</span>

<span class="kw">for</span> <span class="kw">_</span><span class="ot">,</span> <span class="kw">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="ot">(</span><span class="kw">callbacks</span><span class="ot">)</span> <span class="kw">do</span>
  v<span class="ot">()</span>
<span class="kw">end</span></code></pre>
<p>It prints <code>foo\nbar\nbaz</code> as expected. Trying this in functional languages may be pointless, since variables are actually not <em>variables</em>(they’re immutable), but it may be still useful for demonstration purposes, here’s the Haskell code that works as expected:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

main <span class="fu">=</span> <span class="fu">sequence_</span> callbacks
  <span class="kw">where</span> callbacks <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">putStrLn</span> <span class="fu">.</span> (<span class="st">&quot;say &quot;</span> <span class="fu">++</span> )) [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]</code></pre>
<p>I’ll show how to get JavaScript’s behavior in languages that handle this right, and in Haskell it’s harder to get this behavior because we will need to use reference cells explicitly.</p>
<p>I think in Python it’s more understandable, because it doesn’t have any scope declarations. ie. we can’t reason about <code>say</code> variable’s scope by the look of it. In JavaScript, we have <code>var</code> keyword that indicates a new variable is created in the scope. But it still works wrong.</p>
<p>Indeed, in JavaScript, the worst language ever, <code>var</code> keyword is just like any other strange JavaScript feature and works in an unexpected way:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">for</span> (<span class="kw">var</span> v <span class="kw">in</span> [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ]) { <span class="ot">console</span>.<span class="fu">log</span>(v); }
<span class="dv">0</span>
<span class="dv">1</span>
<span class="dv">2</span>
&gt; v
<span class="st">&quot;2&quot;</span></code></pre>
<p>So one explanation of this behavior may be this: In Python, we don’t know the scope of variable and it looks like it’s global. So in closure, it works like a reference. And in JavaScript, <code>var</code> keyword is simply broken(and also variable inside closure works like reference).</p>
<h1 id="fixing-it">Fixing it</h1>
<p>Let’s fix that in JavaScript and Python.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> callbacks = [];
<span class="kw">var</span> words = [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ];

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> words) {
    <span class="kw">var</span> say = <span class="st">&quot;say &quot;</span> + words[idx];
    <span class="ot">callbacks</span>.<span class="fu">push</span>((<span class="kw">function</span> (say) {
      <span class="kw">return</span> <span class="kw">function</span> () {
        <span class="ot">console</span>.<span class="fu">log</span>(say);
      }
    })(say));
}

<span class="kw">for</span> (<span class="kw">var</span> idx <span class="kw">in</span> callbacks) {
    callbacks[idx]();
}</code></pre>
<p>Here we’re creating a new scope with function(remember the JavaScript module pattern?), and then passing <code>say</code> variable to it. This guarantees that we have <code>say</code> variable local to the function. Then in callback returned by wrapper function, we have a reference just like before, but it’s not shared with any other functions.</p>
<p>In Python, there’s a cleaner way to do same thing:</p>
<pre class="sourceCode python"><code class="sourceCode python">callbacks = []

<span class="kw">for</span> i in [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>]:
    say = <span class="st">&quot;say &quot;</span> + i
    <span class="kw">def</span> callback(say=say):
        <span class="kw">print</span> say
    callbacks.append(callback)

<span class="kw">for</span> c in callbacks:
    c()</code></pre>
<p>Here the parameter is passed implicitly. (to me it’s still very strange and it shouldn’t be working, but for now I’ll just keep this post short)</p>
<h1 id="breaking-it">Breaking it</h1>
<p>Let’s have JavaScript’s behavior in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Data.IORef

printFromRef r <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">=&lt;&lt;</span> readIORef r

mkCallbacks (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
    ref <span class="ot">&lt;-</span> newIORef w
    r   <span class="ot">&lt;-</span> iter ref ws
    <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> r
  <span class="kw">where</span> iter ref []     <span class="fu">=</span> <span class="fu">return</span> []
        iter ref (w<span class="fu">:</span>ws) <span class="fu">=</span> <span class="kw">do</span>
          writeIORef ref w
          cs <span class="ot">&lt;-</span> iter ref ws
          <span class="fu">return</span> <span class="fu">$</span> printFromRef ref <span class="fu">:</span> cs

main <span class="fu">=</span> <span class="kw">do</span>
  callbacks <span class="ot">&lt;-</span> mkCallbacks [ <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span> ]
  <span class="fu">sequence_</span> callbacks</code></pre>
<p>The reason this code is that long is because we need to create and pass references explicitly.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Calling this behavior <em>problem</em> may be a bit wrong, maybe it’s just a design decision. To me it’s a <em>problem</em> because this behavior is really counterintuitive.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>On typing dynamic langs</title>
    <link href="http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html" />
    <id>http://osa1.net/posts/2013-04-19-on-typing-dynamic-langs.html</id>
    <published>2013-04-19T00:00:00Z</published>
    <updated>2013-04-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://marijnhaverbeke.nl/blog/tern.html">This excellent post</a> on Tern’s internals reminded me of why I lost interest of my statically typed Lua project.</p>
<p>I lost my interest in a program exponentially with the amount of hacky solutions it involves.</p>
<p>I love Lua, it’s so simple but it is so powerful at the same time, without having any quirks most other dynamic languages have. But when it comes developing a type inference system for such a dynamic language, the result will have to contain a lot of hacks.</p>
<p>Here’s a quote from Tern post, which explains handling dynamically extending objects:</p>
<blockquote>
<p>And now we’re off into dodgy hack land. In order to meet this challenge, Tern uses a special treatment for for/in loops that appear to be copying properties. When it encounters them, it assumes that the properties from the source object will be copied to the target object. It ignores control flow (conditionals and such) and simply copies all properties.</p>
</blockquote>
<p>Similar situation is applied to Lua and this is where I dropped my project. Basically, there is no way to give a type to an object without actually running the program to the point where completion is needed. But even then you can’t have completely correct type information because for instance, you may have a different object in second iteration of loop but your type inference system would be only run it for one iteration. Still, I think running a program in an isolated environment to the point where enough type information is acquired is the best way to infer types in dynamic languages.</p>
<p>Accepting having a subset of Lua and forbidding object extensions in run-time is not a solution because then you can’t even use tables as, well, tables, rather than objects.</p>
<p>The obvious solution is creating a new syntax for defining objects. That syntax should be allowed only in top-level of a file, ie. you can’t use object definition syntax inside of a function.</p>
<p>But then a new language that is not Lua would be invented. I deliberately wanted to avoid this situation because in my opinion, it’s slightly missing the point of that kind of languages. I don’t like CoffeeScript’s additional compile step to my workflow. One nice property of dynamic languages is that we don’t have any visible intermediate steps between writing the source code and running it. All intermediate steps(parsing, compiling to some kind of byte-code, like Python does) are completely hidden to programmer.</p>
<p>Maybe the problem is that I’m looking for a perfect solution which does not exist in reality. I’m not sure how can I overcome this problem, I don’t want to work on programs full of hacks in my free time(well, I don’t want to work on this kind of programs in <em>any</em> time, but doing that as a hobby is more unbearable).</p>]]></summary>
</entry>
<entry>
    <title>Getting different distributions out of uniform distribution</title>
    <link href="http://osa1.net/posts/2012-12-19-different-distributions-from-uniform.html" />
    <id>http://osa1.net/posts/2012-12-19-different-distributions-from-uniform.html</id>
    <published>2012-12-19T00:00:00Z</published>
    <updated>2012-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I don’t know much about statistics and distributions, but I needed some differently distributed pseudo-random numbers for a project I’m working on.</p>
<p>I think most programming languages have a pseudo-random number generator, and that generators probably generate <a href="http://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniformly-distributed</a> pseudo-randoms. I’m using Lua and Lua’s <a href="http://www.lua.org/manual/5.2/manual.html#pdf-math.random">math.random</a> generates pretty much uniformly distributed numbers:</p>
<div class="figure">
<img src="/images/distroyazi/uniformdistro.png" />
</div>
<p>It’s written in Lua’s manual(link is given above) that it’s statistical properties cannot be guaranteed. It still works fine for my purposes as a uniformly distributed number generator.</p>
<p>If you’re working with <a href="http://processing.org/">Processing</a> or some other visualization libraries, you probably also have uniformly-distributed generator<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> in stdlib. But if you’re like me, you have to hack yourself one. I found a method called <a href="http://en.wikipedia.org/wiki/Box-Muller_transform">Box-Muller transform</a> that generates normally-distributed numbers out of uniformly-distributed ones.</p>
<p>I also read some discussions on why one shouldn’t use that, and instead move to other methods like <a href="http://en.wikipedia.org/wiki/Ziggurat_algorithm">Ziggurat algorithm</a>(and some other I can’t remember now), but I think Box-Muller method is easy to implement and works fine for my purposes, so I’m using it now:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> box_muller<span class="ot">()</span>
    <span class="kw">return</span> <span class="kw">math</span><span class="ot">.</span>sqrt<span class="ot">(-</span><span class="dv">2</span> <span class="ot">*</span> <span class="fu">math.log</span><span class="ot">(</span><span class="fu">math.random</span><span class="ot">()))</span> <span class="ot">*</span> <span class="fu">math.cos</span><span class="ot">(</span><span class="dv">2</span> <span class="ot">*</span> <span class="kw">math</span><span class="ot">.</span><span class="kw">pi</span> <span class="ot">*</span> <span class="fu">math.random</span><span class="ot">())</span> <span class="ot">/</span> <span class="dv">2</span>
<span class="kw">end</span></code></pre>
<p>This function returns numbers in range [-1,1]. I’m using it with some code like that:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> <span class="kw">dev</span> <span class="ot">=</span> <span class="dv">100</span>
<span class="kw">local</span> <span class="kw">rand</span> <span class="ot">=</span> box_muller<span class="ot">()</span>
<span class="kw">return</span> <span class="fu">math.floor</span><span class="ot">(</span><span class="kw">rand</span> <span class="ot">*</span> <span class="kw">dev</span> <span class="ot">+</span> <span class="kw">myLimit</span><span class="ot">/</span><span class="dv">2</span><span class="ot">)</span></code></pre>
<p>Here the variable <code>dev</code> stands for <a href="http://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>, though note that it’s value is not <em>standard deviation</em>, but just a value to play with to set standard deviation. I don’t know how can I set standard deviation with Box-Muller method. By playing this value you can get distributions with different standard deviations.</p>
<div class="figure">
<img src="/images/distroyazi/normaldistro.png" />
</div>
<p>I also generated two custom distributions, I don’t know if people gave them any special names, first one is this:</p>
<div class="figure">
<img src="/images/distroyazi/customdistro.png" />
</div>
<p>I think this is a very useful one, this means that if I give some <em>actions</em> in my game different numbers depending on their <em>priority</em> and use this random number generator, I get numbers of actions with more priority more than the ones with less priority. Here’s the code:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="ot">()</span>
    <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
        <span class="kw">local</span> <span class="kw">r1</span> <span class="ot">=</span> <span class="fu">math.random</span><span class="ot">(</span><span class="kw">range</span><span class="ot">)</span>
        <span class="kw">local</span> <span class="kw">r2</span> <span class="ot">=</span> <span class="fu">math.random</span><span class="ot">(</span><span class="kw">range</span><span class="ot">)</span>
        <span class="kw">if</span> <span class="ot">(</span><span class="kw">r2</span> <span class="ot">&lt;</span> <span class="kw">r1</span><span class="ot">)</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">r1</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>Last one is similar:</p>
<div class="figure">
<img src="/images/distroyazi/customdistro2.png" />
</div>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="ot">()</span>
    <span class="kw">local</span> <span class="kw">rate</span> <span class="ot">=</span> <span class="dv">3</span>
    <span class="kw">local</span> <span class="kw">r</span> <span class="ot">=</span> <span class="fu">math.random</span><span class="ot">(</span><span class="dv">500</span><span class="ot">^</span><span class="kw">rate</span><span class="ot">)</span>
    <span class="fu">print</span><span class="ot">(</span><span class="kw">r</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="fu">math.floor</span><span class="ot">(</span><span class="kw">r</span><span class="ot">^(</span><span class="dv">1</span><span class="ot">/</span><span class="kw">rate</span><span class="ot">))</span>
<span class="kw">end</span></code></pre>
<p>In this code, if you make <code>rate</code> variable 2, you get pretty much same distribution with the last one above. In my case, for some reason, making it 4 gives a value that doesn’t fit into 32bit, and so <code>math.random</code> call fails. When I tried with Lua 5.2 compiled by myself on my 64bit machine, <code>math.random</code> works fine with 64bit values, so I think it’s a problem with the app I’m using<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup>.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>and you may even have a <a href="http://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> <a href="http://processing.org/reference/noise_.html">generator</a> too!<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For those interested: It’s <a href="http://love2d.org">Love2d</a>. Recently(while working on this code) I realized that Love2d is not a Lua library, but a complete C++ program that has Lua interpreter. In most cases you can’t see the difference but there are some edge cases like I mentioned above that makes your program runs fine with Lua, but fails with Love2d programs.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>call/cc</title>
    <link href="http://osa1.net/posts/2012-06-23-callcc.html" />
    <id>http://osa1.net/posts/2012-06-23-callcc.html</id>
    <published>2012-06-23T00:00:00Z</published>
    <updated>2012-06-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Son zamanlarda uğraştığım konulardan biri hakkında birşeyler karalayacağım. Genelde zor bir konspetle karşılaştığımda anladığımı anlamak için 2 şey yapıyorum, 1) programlıyorum, 2) anlatıyorum. Uğraştığım işlerle ilgilenen kimse olmadığından, anlatabiliyor olmamı bu blog sağlıyor. Bu sefer Scheme’in call/cc fonksiyonundan bahsedeceğim, epey ilginç bir iş yaptığını düşünüyorum.</p>
<p><code>call/cc</code>de benim ilgimi çeken şey, Scheme’i bir yorumlayıcı ortamı olarak düşündüğümüzde, yorumlayacağımız dile exceptionlar, coroutineler gibi kontrol akışınıda değişiklikler yapması gereken yapıları kolayca ekleyebilmemizi sağlaması.</p>
<p>Continuation-passing style’a aşina olduğunuzu varsayıyorum. Aşina olmayanlar Google’dan kolaylıkla süper kaynaklar edinebilir. JavaScript gibi yaygın bir dilin CPS kullanabilmek için gereken fonksiyonelliği sağlıyor olması çok büyük şans, yoksa CPSı anlamak için Scheme kodu okumak zorunda kalabilirdiniz :P . Ben implementasyonu Common Lisp ile vereceğim.</p>
<p><code>call-with-current-continuation</code> veya kısaca <code>call/cc</code>nin genel olarak iki farklı implementasyon yöntemi var<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> biri stack kopyalama işlemi, diğeri <em>CPS conversion</em> dediğimiz, benim birazdan anlatım Common Lisp ile yazacağım yöntem.</p>
<p>Tüm programlarımızın üstü kapalı bir şekilde(<em>implicit</em>) CPS yazıldığını düşünelim. Yani tüm fonksiyon çağrıları aslında bir değer dönmek yerine, bu döneceği değer ile continuation’ı çağırmalı<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> Bunu sağlamak için tüm fonksiyonlar ilk parametre olarak continuation alabilir ve diğer parametreleri fonksiyon tanımı sırasında verilen parametreler olur. Daha sonra fonksiyon döneceği değer ile ilk parametresini, yani continuation’ı çağırır. Bu fonksiyonları bir macro ile kolayca oluşturabiliriz<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defmacro</span><span class="fu"> defcont </span>(name (&amp;<span class="kw">rest</span> params) &amp;body body)
  (<span class="kw">let</span> ((result (<span class="kw">gensym</span>)))
    `(<span class="kw">defun</span><span class="fu"> </span>,name (continuation ,@params)
       (<span class="kw">let</span> ((,result ,@body))
         (<span class="kw">funcall</span> continuation ,result)))))</code></pre>
<p>Bu macronun syntaxı <code>defun</code>un tamamen aynısı, sadece ekstradan ilk parametre olarak continuation alıyor ve dönüş değeriyle aslında continuation’ı çağırıyor. Bu şekilde yazılan fonksiyonlar <em>CPS conversion</em> a maruz kalıyor yani.</p>
<p>Örnek olarak bu şekilde basit bir toplama ve çarpma fonksiyonları oluşturalım:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(defcont multiply (&amp;<span class="kw">rest</span> args)
  (<span class="kw">apply</span> #&#39;* args))
(defcont add (&amp;<span class="kw">rest</span> args)
  (<span class="kw">apply</span> #&#39;+ args))</code></pre>
<p>Burda fonksiyonların içinde CPS formatında olmayan, dilin kendi fonksiyonlarını çağırıyoruz ama bu sorun değil.</p>
<p>Bu durumda normalde <code>(* 3 (+ 1 2))</code> şeklinde yazacağımız fonksiyonu şu şekilde yazmamız gerekiyor: <code>(add (lambda (r) (multiply #'identity r 3)) 1 2)</code>. İşte bu dönüşümü yapmaya <code>CPS conversion</code> diyoruz. Ne yaptığına bakalım, çarpma işleminin sonucu <code>(+ 1 2)</code> çağrısının dönüş değerine bağlı, buna göre ilk başta toplama işlemi yapılıp, sonucu çarpma işlemine aktarılmalı. Çarpma işlemi de toplama işleminin sonucunu alıp, 3 ile çarptıktan sonra bir continuation’a aktarmalı. Burda bu son continuation olarak <code>identity</code> fonksiyonunu seçtim ki sonucu elde edebilelim. Normalde, eğer örneğin sonucu yazdırmak istiyorsak, orata <code>prin1</code> gibi bir fonksiyon göndermemiz gerekir.</p>
<p>Bu şekilde yazılan programların nasıl çalıştığına bakarsanız, aslında fonksiyon çağrıları için stack modeline ne kadar benzediğini farkedersiniz. Stack modelinde, çarpma fonksiyonu çağırıldığında stack’de fonksiyon çağrısı hakkında gerekli verileri tutan bir kayıt oluşturulacak, daha sonra toplama işlemi çağırıldığında bunun üzerine bir kayıt daha eklenecek, ve fonksiyon çağrıları bittikçe bu kayıtlar stackten toplanarak bir alt seviyeye dönüş değerlerini bir şekilde aktaracak.</p>
<p>CPS’de tamamen aynı, toplama işlemi önce bitecek ve çarpma işlemine dönüş değerini aktaracak. Bunun için çarpma fonksiyonunu ilk parametresi olarak alacak, çarpma fonksiyonu da kendi sonucunu hangi fonksiyona aktaracaksa o fonksiyonu ilk parametre olarak alacak gibi.</p>
<p>Buraya kadar herşey anlaşıldıysa, <code>call/cc</code>yi yazmak çok kolay. <code>call/cc</code>nin yaptığı, o anki continuation’ı açık bir şekilde kullanıcıya vermek. Normalde yukarıda bahsettiğim tüm olaylar derlenme aşamasında <em>CPS conversion</em> veya başka yöntemlerle hallediliyor ve kullanıcı aslında fonksiyonlarını bizim örneğimizdeki gibi yazmıyor. Dolayısıyla fonksiyonuna aktarılan continuation’a erişme şansı yok. Fakat <code>call/cc</code> hariç, <code>call/cc</code> tam olarak bu işi yapıyor, o anki continuation’a erişim izni veriyor. Şu şekilde:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> call/cc </span>(continuation fun)
  (<span class="kw">funcall</span> fun continuation))</code></pre>
<p>Bu fonksiyonun <code>defcont</code> ile tanımlandmadığına dikkat. Bu şu anlama geliyor, programlama dili böyle bir fonksiyon sunmuyorsa, bu fonksiyonun yazılması imkansız. Kullanıcının tek sahip olduğunun <code>defcont</code> olduğunu düşünün, yani tüm fonksiyonları <em>CPS conversion</em>a mağruz kalıyor, ve fonksiyon çağrıları otomatik olarak CPS’e dönüştürülüyor. Programcı yazdığı fonksiyonlara continuation’ın nasıl aktarıldığını bilmiyor veya bilse bile buna erişmesinin hiçbir yolu yok.</p>
<p><code>call/cc</code>, kendi aldığı continuation’ı <code>fun</code> parametresi olarka aldığı fonksiyona aktarıyor, ve daha sonra <code>fun</code> fonksiyonu o continuation ile her türlü çılgınlık yapabilir, örneğin bu continuation’ı bir yere kaydedip, bir daha bir daha çağırmak gibi. Bu continuation, dönüş değerinin aktarılacağı fonksiyonu tutuyor aslında.</p>
<p>Hemen basit birkaç örnek yapalım. Şu iki fonksiyon arasındaki fark ne?</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) (<span class="kw">funcall</span> cont <span class="dv">11</span>)))
(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> r <span class="dv">10</span>)) (<span class="kw">lambda</span> (cont) <span class="dv">11</span>))</code></pre>
<p>İlk çağrıda continuation’a 11 değerini gönderiyoruz ve sonuç beklenen gibi 21 oluyor, ikinci durumda ise continuation’ı yok sayıp 11 değerini dönüyoruz ve cevap 11 oluyor. Stack modelinde düşünürsek, ikinci örnekte yapılan şey, stackdeki bazı fonksiyon kayıtlarının atlanması aslında. Buna sanırım <code>stack unwinding</code> deniyor(emin değilim). Bu şekilde dil seviyesinde exception mekanizmaları yazılabilir, continuationlar kaydedilerek ve sırayla çağırılarak coroutineler<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup>veya <em>lightweight thread</em>ler elde edilebilir(<em>green thread</em> de diyorlar sanırım).</p>
<p>Scheme bilenler için bu kodun Scheme karşılıkları şu:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="kw">+</span> <span class="dv">10</span> <span class="dv">11</span>)))
(<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cont) (<span class="kw">+</span> <span class="dv">10</span> (cont <span class="dv">11</span>))))</code></pre>
<p>Aralarındaki fark, Scheme kodu <em>CPS conversion</em>a mağruz kalmamış, Common Lisp kodu ise kalmış hali.</p>
<p>Bu aşamada yapılabilecek çok fazla fantastik iş var ve çoğu durumda neler olup bittiğini anlama çok güç. Zaten bu yüzden <code>GOTO</code>larla karşılaştırılıyorlar bazen. Benim hoşuma giden bir kullanımını şu:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defvar</span><span class="fu"> creturn </span><span class="kw">nil</span>)
(call/cc (<span class="kw">lambda</span> (r) (<span class="kw">+</span> <span class="dv">1</span> r))
         (<span class="kw">lambda</span> (cont)
           (<span class="kw">setf</span> creturn cont)
           <span class="dv">1</span>))</code></pre>
<p>Continuation’ı bir değişkene kaydediyorum ve daha sonra istediğim zaman o continuation’ı çağırıp işlemi kaldığı yerden devam ettiriyorum.</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">15</span>)
<span class="dv">16</span>
CL-USER&gt; (<span class="kw">funcall</span> creturn <span class="dv">20</span>)
<span class="dv">21</span></code></pre>
<p>Kısaca, işlemi istediğim bir yerden durdurdum ve kopyaladım. Daha sonra durdurduğum andan itibaren istediğim bir değer ile devam ettiriyorum. Müthiş bir olay. Bu gösterdiğim örnekler en basit ve sıradan örnekler, neler yapılabileceği hakkında çok fazla güzel kaynak var, açıkçası ben çoğunun ne yaptığını anlamakta güçlük çekiyorum, bazı patternlara aşina olmak gerekiyor. <code>call/cc</code>nin Scheme’den kaldırılması da <a href="http://lists.scheme-reports.org/pipermail/scheme-reports/2012-February/001824.html">şu ortamda</a> epey tartışılmış.</p>
<p>Çok bilinen iki implementasyon yöntemi demiştim, diğer yöntem de stack kopyalama. Bu örneği düşünelim, <code>call/cc</code> aslında stack’in o anki durumunu aktarıyor aslında. Burda yapılan işlem büyük ihtimalle en baştan beri tüm stackin kopyalanması değil. <a href="http://en.wikipedia.org/wiki/Spaghetti_stack">Sphagetti stack</a> gibi bir yapı kullanılıyor olabilir.</p>
<p>Bu arada, coroutine demişken, implementasyon detaylarını merak eden varsa: <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;ved=0CHgQFjAF&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.104.1441%26rep%3Drep1%26type%3Dpdf&amp;ei=PAXmT8TBEaeB4ASj-5ygAQ&amp;usg=AFQjCNENWM4b5ib96CKcno8KgEeJk4KQ6g">Coroutines in Lua</a>. Lua’yı seviyoruz.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Aslında, birkaç tane çok bilinen(yazılmış) implementasyonu var ve dahası da gereksinimlere/şartlara göre uydurulabilir. Detayları merak eden varsa: <a href="http://www.cs.indiana.edu/~dyb/papers/3imp.pdf">Three Implementation Models for Scheme</a>. Ve büyük ihtimalle şu kitapta da bahsediliyordur: <a href="ref=sr_1_1?ie=UTF8&amp;qid=1340471949&amp;sr=8-1&amp;keywords=lisp+in+small+pieces">Lisp in Small Pieces</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Bu durumda, <em>sanırım</em>, teorik olarak stack denen yapıya ihtiyaç kalmıyor.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Bu macroda bir sorun var fakat konumuzun dışında olduğundan, işleri karıştırmamak için önemsemedim: <code>continuation</code> parametresi <a href="http://www.bookshelf.jp/texi/onlisp/onlisp_10.html#SEC67"><em>variable capture</em></a>a maruz kalabilir. <code>gensym</code> ile parametre adı oluşturulması gerekir.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Şu anda coroutineleri implement etmek için sanırım zaten stackin bir kopyasını çıkarmak zorundasınız.<a href="#fnref4">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Lazy lists in Lua and eliminating tail-calls with continuations</title>
    <link href="http://osa1.net/posts/2012-05-20-lazy-lists-in-lua-and-eliminating-tail-calls-with-continuations.html" />
    <id>http://osa1.net/posts/2012-05-20-lazy-lists-in-lua-and-eliminating-tail-calls-with-continuations.html</id>
    <published>2012-05-20T00:00:00Z</published>
    <updated>2012-05-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I was reading some papers about parsing with continuations and I realized that I had never implemented continuations in any language. Since I’m interested in Lua nowadays, I want to implement it in Lua.</p>
<p>After a while, I realized that you could use continuations to eliminate recursive calls to prevent stack overflows. Now, in a language like Lua, we have tail-call optimization(TCO) and recursive calls in tail positoins are not problem, but even in languages that don’t have TCO, you can easily convert tail calls to loops with help of continuations. And I found the underlying idea of this is pretty similar to lazy-lists. Now I’m going to try to explain how.</p>
<p>For those who want to see the code, here’s the <a href="https://gist.github.com/2757232">gist</a>.</p>
<p>Nowadays most of modern languages(functional ones or not), have some primitives for lazy evaluation(like Python’s generators), and I’m not an expert on Lua but AFAIK, Lua’s coroutines can be used for lazy evaluation. But even if you use a language that doesn’t have any non-strict primitives, you can have some lazy structures(ie. in JavaScript).</p>
<p>The main idea of this is that you can always pass functions in a form that holds the function itself and a list of arguments that will be passed to function. And when you want to evaluate the result of the function call, you just call the function in that form with the arguments. Note that by “function itself”, I mean the function callback. Most modern languages nowadays have functions as first-class values or at least some kind of function pointers/referances, so this is not a problem.</p>
<p>I’ll give the code in Lua. We’ll call the structure that holds a function callback(or whatever your language call it) and a list of parameters, <code>thunk</code><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> In Lua, this will be a table with two keys: <code>f</code> and <code>args</code>. Here’s an example thunk.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">t</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">f</span> <span class="ot">=</span> <span class="fu">print</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="ot">{</span><span class="st">&quot;first arg&quot;</span><span class="ot">,</span> <span class="st">&quot; second arg&quot;</span><span class="ot">}</span> <span class="ot">}</span></code></pre>
<p>So when we want to run the function in the thunk, we just call <code>evalThunk</code>, which is pretty straightforward to implement:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="kw">t</span><span class="ot">.</span>f<span class="ot">(</span><span class="fu">unpack</span><span class="ot">(</span><span class="kw">t</span><span class="ot">.</span><span class="kw">args</span><span class="ot">))</span>
<span class="kw">end</span>
<span class="ot">&gt;</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
<span class="kw">first</span> <span class="kw">arg</span>        <span class="kw">second</span> <span class="kw">arg</span></code></pre>
<p>Basically, when we want to make a function non-strict, we just create a thunk of it, with <code>f</code> = function itself, and the <code>args</code> = the args we want to pass to the function when we run it. Here’s a helper for it:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> makeThunk<span class="ot">(</span><span class="kw">f</span><span class="ot">,</span> <span class="kw">args</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="ot">{</span> <span class="fu">tag</span> <span class="ot">=</span> <span class="st">&quot;thunk&quot;</span><span class="ot">,</span> <span class="kw">f</span> <span class="ot">=</span> <span class="kw">f</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="kw">args</span> <span class="ot">}</span>
<span class="kw">end</span></code></pre>
<p>Now, with the help of this two functions, we can create a infinite-length lazy linked-lists. Each node in our linked-lists will have two keys: <code>first</code> and <code>rest</code>. <code>first</code> will have the value of that node, and <code>rest</code> will have the next node connected to that node. Here’s a helper to create linked-list nodes.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> cons<span class="ot">(</span><span class="kw">first</span><span class="ot">,</span> <span class="kw">rest</span><span class="ot">)</span>
    <span class="kw">return</span> <span class="ot">{</span> <span class="kw">first</span> <span class="ot">=</span> <span class="kw">first</span><span class="ot">,</span>
             <span class="kw">rest</span>  <span class="ot">=</span> <span class="kw">rest</span> <span class="ot">}</span>
<span class="kw">end</span></code></pre>
<p>In lazy-lists, we always have the <code>rest</code> part of the list as unevaluated thunks. To traverse the list to some point, we need to evaluate the nodes we passed, and when we evaluate this nodes, we just replace the thunks with evaluated values. Because we don’t want to evaluate the same node again and again for eact iteration.</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="kw">p</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">t</span> <span class="ot">==</span> <span class="kw">nil</span> <span class="kw">then</span>
        <span class="kw">return</span> <span class="kw">nil</span>
    <span class="kw">elseif</span> <span class="fu">type</span><span class="ot">(</span><span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">])</span> <span class="ot">==</span> <span class="st">&quot;table&quot;</span> <span class="kw">and</span> <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">].</span><span class="kw">tag</span> <span class="ot">==</span> <span class="st">&quot;thunk&quot;</span> <span class="kw">then</span>
        <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">]</span> <span class="ot">=</span> evalThunk<span class="ot">(</span><span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">])</span>
    <span class="kw">end</span>
    <span class="kw">return</span> <span class="kw">t</span><span class="ot">[</span><span class="kw">p</span><span class="ot">]</span>
<span class="kw">end</span>
<span class="kw">function</span> first<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="st">&quot;first&quot;</span><span class="ot">)</span>
<span class="kw">end</span>
<span class="kw">function</span> rest<span class="ot">(</span><span class="kw">t</span><span class="ot">)</span>
    <span class="kw">return</span> evalPart<span class="ot">(</span><span class="kw">t</span><span class="ot">,</span> <span class="st">&quot;rest&quot;</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p><code>first</code> and <code>rest</code> functions are returning the <code>first</code> and <code>rest</code> parts of our linked-list nodes. We’re expecting this parts to be unevaluated thunks. So if they’re thunks, we just evaluate them and replace the return value with thunks so that we don’t need to re-evaluate everytime we get a node.</p>
<p>And with the last helper, we can start creating infinite lazy-lists in Lua:</p>
<pre><code>function nth(t, n)
    if n == 0 then
        return first(t)
    end
    return nth(rest(t), n-1)
end</code></pre>
<p>This function is just getting the n. node in a linked list. And while getting this node, it’s evaluating all the thunk on the way with help of <code>rest</code> function. This is important because as you’ll see, we will be creating the rest of the lists while we’re traversing it.</p>
<p>Let’s see an example of infinite lazy-list that creates a list of factorials, starting from 1!:</p>
<pre><code>function fact(n, f)
    n = n or 1
    f = f or 1
    return cons(n, makeThunk(fact, {n*f, f+1}))
end</code></pre>
<p>This function returns a linked-list that contains factorial of 1, and then a thunk of the same factorial function, but with different parameters. The function call in the <code>rest</code> part of the thunk will return the next factorial, and then the same function as a thunk in <code>rest</code> part of the thunk, in a recursive fashion. Note that our <code>nth</code> function is tail-recursive so we’ll never have stack overflows while traversing the list(it’s also trivial to implement an iterative loop version of it).</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="ot">&gt;</span> <span class="kw">a</span> <span class="ot">=</span> fact<span class="ot">()</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">))</span>
<span class="dv">1</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">))</span>
<span class="dv">2</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">10</span><span class="ot">))</span>
<span class="dv">3628800</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">20</span><span class="ot">))</span>
<span class="dv">2.4329020081766e+18</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">30</span><span class="ot">))</span>
<span class="dv">2.6525285981219e+32</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">40</span><span class="ot">))</span>
<span class="dv">8.159152832479e+47</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">50</span><span class="ot">))</span>
<span class="dv">3.0414093201713e+64</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span>nth<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="dv">250</span><span class="ot">))</span>
<span class="kw">inf</span></code></pre>
<p>So it’s obviously generating all the factorials while we traverse the list. You can also try to see that every thunk is evaluated only once by adding some <code>print</code> functions to thunks.</p>
<p>Here’s a lazy-list that contains all fibonacci numbers:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> fib<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> <span class="kw">b</span><span class="ot">)</span>
    <span class="kw">a</span> <span class="ot">=</span> <span class="kw">a</span> <span class="kw">or</span> <span class="dv">0</span>
    <span class="kw">b</span> <span class="ot">=</span> <span class="kw">b</span> <span class="kw">or</span> <span class="dv">1</span>
    <span class="kw">return</span> cons<span class="ot">(</span><span class="kw">a</span><span class="ot">,</span> makeThunk<span class="ot">(</span><span class="kw">fib</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">b</span><span class="ot">,</span> <span class="kw">a</span><span class="ot">+</span><span class="kw">b</span><span class="ot">}))</span>
<span class="kw">end</span></code></pre>
<p>You can also easily define functions that take linked-lists and map/filter and return the result as lazy-lists. I added them the to the gist.</p>
<p>Now, how’s that related with continuations that eliminate tail-calls? Let’s work on an exmple:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">n</span> <span class="ot">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span>
        <span class="kw">return</span> cont<span class="ot">(</span><span class="dv">1</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> newCont<span class="ot">(</span><span class="kw">v</span><span class="ot">)</span>
        <span class="kw">return</span> cont<span class="ot">(</span><span class="kw">v</span><span class="ot">+</span><span class="kw">n</span><span class="ot">)</span>
    <span class="kw">end</span>
    <span class="kw">return</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">-</span><span class="dv">1</span><span class="ot">,</span> <span class="kw">newCont</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<p>I found JavaScript version of this example in <a href="http://nathansuniversity.com/cont3.html">Nathan’s University</a> and I think it’s a typical usage of continuations. Instead of returning the result, we’re passing the result to the continuation function. And when we hit the buttom(ie. when n &lt;= 1) we pass the last result to continuation function and return it.</p>
<p>I don’t explain why one would do that, you can read it from Nathan’s University.</p>
<p>If you run a function like this in JavaScript, you get a stack overflow after a while since this function is recursive. But with the help of thunks, you can eliminate the recursive call entirely, even in JavaScript. Let’s change it to:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> sum<span class="ot">(</span><span class="kw">n</span><span class="ot">,</span> <span class="kw">cont</span><span class="ot">)</span>
    <span class="kw">if</span> <span class="kw">n</span> <span class="ot">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span>
        <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="dv">1</span><span class="ot">})</span>
    <span class="kw">end</span>
    <span class="kw">local</span> <span class="kw">function</span> newCont<span class="ot">(</span><span class="kw">v</span><span class="ot">)</span>
        <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">v</span><span class="ot">+</span><span class="kw">n</span><span class="ot">})</span>
    <span class="kw">end</span>
    <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">sum</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">n</span><span class="ot">-</span><span class="dv">1</span><span class="ot">,</span> <span class="kw">newCont</span><span class="ot">})</span>
<span class="kw">end</span></code></pre>
<p>We replaced every function call with thunks. Now you can realize that <code>makeThunk</code> calls are just linking function calls together. For example, after calling <code>sum(10, function(n) print(&quot;result: &quot;, n) end)</code>, we get this thunk:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="ot">{</span> <span class="fu">tag</span> <span class="ot">=</span> <span class="st">&quot;thunk&quot;</span><span class="ot">,</span> <span class="kw">f</span> <span class="ot">=</span> <span class="kw">sum</span><span class="ot">,</span> <span class="kw">args</span> <span class="ot">=</span> <span class="ot">{</span><span class="dv">9</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">v</span><span class="ot">)</span> <span class="kw">return</span> makeThunk<span class="ot">(</span><span class="kw">cont</span><span class="ot">,</span> <span class="ot">{</span><span class="kw">v</span><span class="ot">+</span><span class="dv">10</span><span class="ot">})</span> <span class="kw">end</span><span class="ot">}}</span></code></pre>
<p>When we evaluate this thunk, we just get another thunk unless the first arg is not &lt;= 1. Now we need a helper to evaluate the thunk, and then evaluate the thunk returned by the first thunk, until we evaluate all the thunks. This is what’s called “trampoline”:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> trampoline<span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span>
    <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span>
        <span class="kw">if</span> <span class="fu">type</span><span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span> <span class="ot">~=</span> <span class="st">&quot;table&quot;</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">thunk</span>
        <span class="kw">elseif</span> <span class="kw">thunk</span><span class="ot">.</span><span class="kw">tag</span> <span class="ot">==</span> <span class="st">&quot;thunk&quot;</span> <span class="kw">then</span>
            <span class="kw">thunk</span> <span class="ot">=</span> evalThunk<span class="ot">(</span><span class="kw">thunk</span><span class="ot">)</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">end</span>
<span class="ot">&gt;</span> <span class="kw">a</span> <span class="ot">=</span> sum<span class="ot">(</span><span class="dv">10</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">n</span><span class="ot">)</span> <span class="fu">print</span><span class="ot">(</span><span class="st">&quot;result: &quot;</span><span class="ot">,</span> <span class="kw">n</span><span class="ot">)</span> <span class="kw">end</span><span class="ot">)</span>
<span class="ot">&gt;</span> <span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">tag</span><span class="ot">)</span>
<span class="kw">thunk</span>
<span class="ot">&gt;</span> trampoline<span class="ot">(</span><span class="kw">a</span><span class="ot">)</span>
<span class="kw">result</span>:         <span class="dv">55</span></code></pre>
<p>We’re evaluating the thunks in a <code>while</code> loop. This is how you can eliminate tail calls. Now, this exactly looks like the lazy-list method I mentioned in this post. And we already used the same thunk structure for both of them.</p>
<p>The only difference is, in continuations we don’t save old thunks anywhere and just replace them with new continuations, and we only return a value other than new thunks when we finished the calculation(ie. when we reach the base case).</p>
<p>So essentially, both continuations and lazy-lists have the same idea. And these are very easy to implement even in langauges that doesn’t support any non-strict primitives.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For a better explanation of <code>thunk</code>s, see <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#footnote_Temp_580">SICP</a>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Lua - basitlik ve esneklik hakkında birkaç şey</title>
    <link href="http://osa1.net/posts/2012-05-07-lua-basitlik-ve-esneklik-hakknda-birkac-sey.html" />
    <id>http://osa1.net/posts/2012-05-07-lua-basitlik-ve-esneklik-hakknda-birkac-sey.html</id>
    <published>2012-05-07T00:00:00Z</published>
    <updated>2012-05-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Programlama dillerini incelediğimi buraları okuyanlar farketmiştir herhalde :) . Bir süredir Lua ile alakalı birşeyler okuyordum. Beni epey etkiledi. İlk yorumlayıcısı ve performansı etkilemişti<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Daha sonradan kaynağını kurcalamış ve ne kadar küçük ve düzenli olduğunu görüp şaşırmıştım. Dilin desteklediği Tail-call optimization ve <a href="https://plus.google.com/112211667397241192219/posts/QE1noJjQYwz">lexical scope</a>’un(ve dolayısıyla closureların) zaten hastasyım. Sonralardan SO gibi ortamlarda “mühendislik harikası” şeklinde nitelendirildiğini gördüm. Henüz bu kısımları değerlendirebilecek seviyede değilim. Ben dilin sadeliği ve bu sadeliğe rağmen nasıl kolayca esneklik sağlayabildiği hakkında birşeyler yazacağım.</p>
<p>Dildeki tek veri yapısı tablolar. Arrayler, mapler, modüller ve dil ile gelen tüm yapılar direkt olarak tablo. Bir veri yapısı yazmak istediğiniz de de tabloları kullanmak zorundasınız. Nasıl Python’da herşey nesneyse, Lua’da da <em>neredeyse</em> herşey tablo<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> Sınıflarla sağlanan bir nesne tabanlı programlama desteği yok. Ama çok basit ve güzel bir özellik sayesinde, multiple inheritance bile sağlayabiliyorsunuz.</p>
<p>Tüm tablolara <code>metatable</code> denilen bir tablo atayabiliyorsunuz. Bu metatablolar(ne diyeyim bilemedim bunlara) tablolar operatörlerle işleme sokulduğunda çağırılacak fonksiyonları tutuyorlar. Örneğin bir tablonun metatablosu <code>__add</code> gibi bir fonksiyona sahipse, bu tabloyu toplama işlemine sokabiliyoruz. Aynı <a href="http://docs.python.org/reference/datamodel.html#object.__add__">Python’daki <code>__add__</code> methodu</a> gibi. Eğer tabloda olmayan bir değer erişmek istersek de, benzer bir şekilde metatablodaki <code>__index</code> fonksiyonuna, eğer tabloda olmayan bir değer eklemeye çalışırsak(mevcut bir değeri değiştirme değil de farklı anahtara sahip bir değer ekleme yani) da <code>__newindex</code> fonksiyonu çağırılıyor. Bunlar aynı Python’daki <a href="http://docs.python.org/reference/datamodel.html#object.__getattr__"><code>__getattr__</code></a> ve <a href="http://docs.python.org/reference/datamodel.html#object.__setattr__"><code>__setattr__</code></a> gibiler.</p>
<p>Bugün yazdığım uygulamada şöyle bir sorun yaşadım. <em>Rect</em> adlı bir tablo tutuyorum ve bu tabloyu metatablo olarak kullanan başka tablolar oluşturuyorum. Sanki <em>Rect</em> diye bir sınıfım varmış da nesneler oluşturuyormuşum gibi. Bir yerden sonra bu tablonun implementasyonunda ciddi bir değişiklik yapıyorum ve <code>x</code> ve <code>y</code> özellikleri yerine artık bir <code>center</code> ve <code>angle</code> diye iki özellik ekliyorum. Ama bu tablonun bazı <code>x</code> ve <code>y</code> özelliklerini kullanan fonksiyonlarımı teker teker değiştirmemem gerek. Python konuşanlara bunu şöyle özetleyebiliriz, sınıfımdan iki özellik siliyorum, bunların artık sınıftaki diğer özelliklerden hesaplanması gerek. Ama kodumu refactor etmek istemiyorum. Bu durumda Python’da yapılacak işlem bariz: <code>x</code> ve <code>y</code>yi <a href="http://docs.python.org/library/functions.html#property"><code>property</code></a> decoratorü içerisinde methodlar olarak tanımlamak<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> Lua’da bunu şöyle yaptım:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">Rect</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">width</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span>
         <span class="kw">height</span> <span class="ot">=</span> <span class="dv">0</span> <span class="ot">}</span>
<span class="kw">function</span> Rect_indexfn <span class="ot">(</span><span class="kw">table</span><span class="ot">,</span> <span class="kw">key</span><span class="ot">)</span>
    <span class="kw">local</span> <span class="kw">f</span><span class="ot">,</span> <span class="kw">o</span>
    <span class="kw">if</span> <span class="kw">key</span> <span class="ot">==</span> <span class="st">&#39;x&#39;</span> <span class="kw">then</span>
        <span class="kw">f</span> <span class="ot">=</span> <span class="fu">math.cos</span>
        <span class="kw">o</span> <span class="ot">=</span> <span class="kw">table</span><span class="ot">.</span><span class="kw">centerx</span>
    <span class="kw">elseif</span> <span class="kw">key</span> <span class="ot">==</span> <span class="st">&#39;y&#39;</span> <span class="kw">then</span>
        <span class="kw">f</span> <span class="ot">=</span> <span class="fu">math.sin</span>
        <span class="kw">o</span> <span class="ot">=</span> <span class="kw">table</span><span class="ot">.</span><span class="kw">centery</span>
    <span class="kw">end</span>
    <span class="kw">if</span> <span class="kw">f</span> <span class="kw">then</span>
        <span class="kw">return</span> <span class="kw">o</span><span class="ot">-</span><span class="fu">math.abs</span><span class="ot">(</span>f<span class="ot">(</span><span class="fu">math.rad</span><span class="ot">(</span><span class="kw">table</span><span class="ot">.</span><span class="kw">angle</span><span class="ot">)))*</span><span class="kw">math</span><span class="ot">.</span>pow<span class="ot">(</span><span class="kw">math</span><span class="ot">.</span>pow<span class="ot">(</span><span class="kw">table</span><span class="ot">.</span><span class="kw">height</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">)+</span><span class="kw">math</span><span class="ot">.</span>pow<span class="ot">(</span><span class="kw">table</span><span class="ot">.</span><span class="kw">width</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">),</span> <span class="dv">0.5</span><span class="ot">)/</span><span class="dv">2</span>
    <span class="kw">end</span>
<span class="kw">end</span>
<span class="kw">function</span> <span class="kw">Rect</span>:new<span class="ot">()</span>
    <span class="fu">setmetatable</span><span class="ot">(</span><span class="kw">self</span><span class="ot">,</span> <span class="ot">{</span> <span class="kw">__index</span> <span class="ot">=</span> <span class="kw">Rect_indexfn</span> <span class="ot">})</span>
    <span class="kw">return</span> <span class="kw">self</span>
<span class="kw">end</span>
<span class="kw">a</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">})</span>
<span class="kw">b</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">})</span>
<span class="kw">b</span><span class="ot">.</span><span class="kw">angle</span> <span class="ot">=</span> <span class="dv">60</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">x</span><span class="ot">)</span> <span class="co">-- -4.3301270189222</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">b</span><span class="ot">.</span><span class="kw">y</span><span class="ot">)</span> <span class="co">-- -4.3301270189222</span></code></pre>
<p>Tek yaptığım, yeni bir Rect oluşturuğum tablonun metatablosunu daha önceden belirlediğim <code>Rect_indexfn</code> fonksiyonunun <code>__index</code> fonksiyonu olarak tutan bir tablo olarak belirlemek. Bundan ne zaman kendisinin sahip olmadığı bir değere erişilmeye çalışsa, bu fonksiyon çalışarak erişilmek istenen değere göre işlemler yapıyor. Bu arada <code>:</code> ile tanımladığım fonksiyonların aldığı ilk parametre <code>self</code> değerine atanıyor. <code>Rect:new()</code> fonksiyonum hiçbir parametre almıyormuş gibi gözüksede, <code>self</code> adlı bir parametre alıyor yani aslında.</p>
<p>Şimdi normalde bunu gösterip bitirecektim ama multiple inheritance implementasyonu da o kadar kolay ki atlayamadım:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="kw">Rect</span>:new<span class="ot">(</span><span class="kw">ps</span><span class="ot">)</span>
    <span class="co">-- lua&#39;da vararglar biraz sorunlu oldugundan superclasslari</span>
    <span class="co">-- bir array olarak alacagim. detaylar icin: http://lua-users.org/wiki/VarargTheSecondClassCitizen</span>
    <span class="kw">local</span> <span class="kw">function</span> indexfn <span class="ot">(</span><span class="kw">table</span><span class="ot">,</span> <span class="kw">key</span><span class="ot">)</span>
        <span class="kw">local</span> <span class="kw">v</span> <span class="ot">=</span> Rect_indexfn<span class="ot">(</span><span class="kw">table</span><span class="ot">,</span> <span class="kw">key</span><span class="ot">)</span>
        <span class="kw">if</span> <span class="kw">v</span> <span class="kw">then</span>
            <span class="kw">return</span> <span class="kw">v</span>
        <span class="kw">end</span>
        <span class="kw">for</span> <span class="kw">i</span><span class="ot">,</span><span class="kw">v</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="ot">(</span><span class="kw">ps</span><span class="ot">)</span> <span class="kw">do</span>
            <span class="kw">v</span> <span class="ot">=</span> <span class="kw">v</span><span class="ot">[</span><span class="kw">key</span><span class="ot">]</span>
            <span class="kw">if</span> <span class="kw">v</span> <span class="kw">then</span>
                <span class="kw">return</span> <span class="kw">v</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
    <span class="fu">setmetatable</span><span class="ot">(</span><span class="kw">self</span><span class="ot">,</span> <span class="ot">{</span> <span class="kw">__index</span> <span class="ot">=</span> <span class="kw">indexfn</span> <span class="ot">})</span>
    <span class="kw">return</span> <span class="kw">self</span>
<span class="kw">end</span>
<span class="co">-- bu ikisi superclass gorevinde</span>
<span class="kw">st1</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">attr1</span> <span class="ot">=</span> <span class="st">&quot;st1 attr1&quot;</span> <span class="ot">}</span>
<span class="kw">st2</span> <span class="ot">=</span> <span class="ot">{</span> <span class="kw">attr1</span> <span class="ot">=</span> <span class="st">&quot;st2 attr1&quot;</span><span class="ot">,</span> <span class="kw">attr2</span> <span class="ot">=</span> <span class="st">&quot;st2 attr2&quot;</span> <span class="ot">}</span>
<span class="kw">a</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">},</span> <span class="ot">{</span> <span class="kw">st1</span><span class="ot">,</span> <span class="kw">st2</span> <span class="ot">})</span>
<span class="kw">b</span> <span class="ot">=</span> <span class="kw">Rect</span><span class="ot">.</span>new<span class="ot">({</span><span class="kw">centerx</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">centery</span> <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">angle</span> <span class="ot">=</span> <span class="dv">30</span><span class="ot">,</span> <span class="kw">width</span> <span class="ot">=</span> <span class="dv">6</span><span class="ot">,</span> <span class="kw">height</span> <span class="ot">=</span> <span class="dv">8</span><span class="ot">},</span> <span class="ot">{</span> <span class="kw">st2</span> <span class="ot">})</span>
<span class="kw">b</span><span class="ot">.</span><span class="kw">angle</span> <span class="ot">=</span> <span class="dv">60</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">x</span><span class="ot">)</span>     <span class="co">-- -4.3301270189222</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">b</span><span class="ot">.</span><span class="kw">y</span><span class="ot">)</span>     <span class="co">-- -4.3301270189222</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">attr1</span><span class="ot">)</span> <span class="co">-- st1 attr1</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">a</span><span class="ot">.</span><span class="kw">attr2</span><span class="ot">)</span> <span class="co">-- st2 attr2</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">b</span><span class="ot">.</span><span class="kw">attr1</span><span class="ot">)</span> <span class="co">-- st2 attr1</span></code></pre>
<p>Constructoru bu şekilde değiştirdim. <code>__index</code> fonksiyonunun yeni haline bakarsanız, ilk başta <code>Rect_indexfn</code>yi çağırıyor, eğer hala gerekli değerler bulunamıyorsa, soldan itibaren superclassları aramaya başlıyor. Burda ben en basit implementasyonu yapmaya çalıştım, eğer superclasslar da bu şekilde tanımlanmış metatabloya sahiplerse, arama işlemi ilk superclassın superclasslarıyla devam edecek. Kolayca farklı davranışlar tanımlanabilir, tüm algoritma <code>indexfn</code> fonksiyonundan ibaret. Hayal gücünüzce geliştirip, <a href="http://en.wikipedia.org/wiki/Diamond_problem">diamond problem</a> ile karşılaşıp, kendi çözümünüzü uydurabilirsiniz :) .</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>İlgili makaleler: <a href="http://www.lua.org/doc/jucs05.pdf">Implementation of Lua 5.0</a>, <a href="http://www.lua.org/spe.html">Lua - an extensible extension language</a>, <a href="http://www.lua.org/doc/hopl.pdf">The Evolution of Lua</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Neredeyse. Sayılar(<code>number</code>) değil. Başka tablo olmayan var mı şu anda aklıma gelmiyor. Tablo implementasyon detayları için “Implementation of Lua 5.0” yazısına bakabilirsiniz.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Java’cılar zaten tüm özellikleri private yapıp, bir refleks olarak getter/setterlar tanımladıkları için onlar için sorun yok ehuaehe.<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
