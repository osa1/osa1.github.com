<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>osa1.net - Posts tagged ghc</title>
    <link href="http://osa1.net/tags/ghc.xml" rel="self" />
    <link href="http://osa1.net" />
    <id>http://osa1.net/tags/ghc.xml</id>
    <author>
        <name>Ömer Sinan Ağacan</name>
        <email>omeragaca@gmail.com</email>
    </author>
    <updated>2019-01-22T00:00:00Z</updated>
    <entry>
    <title>Some arguments against small syntax extensions in GHC</title>
    <link href="http://osa1.net/posts/2019-01-22-no-small-syntax-extensions.html" />
    <id>http://osa1.net/posts/2019-01-22-no-small-syntax-extensions.html</id>
    <published>2019-01-22T00:00:00Z</published>
    <updated>2019-01-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I realized recently that I haven’t published a single post in 2019. I think that’s the longest break I ever took to blogging, and it kinda made me motivated to publish some of the draft posts that I’ve been keeping in private Github gists.</p>
<p>This post is originally written in 11 January 2019. Becuase it is more of an angry rant than a constructive piece, I wasn’t sure at the time that publishing it is a good idea. However reading it again now, I see that it’s not directed at a person, a group, or a specific proposal/patch, so I think it shouldn’t be offensive to anyone and I should be able to publish it on my personal blog.</p>
<p>(original post starts below)</p>
<hr />
<p>So I woke up at 5AM today and felt like writing about one of my frustrations. These are my personal opinions, and I don’t represent GHC HQ here.</p>
<hr />
<p>At this point adding new syntax to GHC/Haskell is a bad idea. Before moving on to examples, here are some facts:</p>
<ul>
<li><p>The language that GHC supports is incredibly complex. GHC 8.6.3 man page lists 115 language pragmas.</p></li>
<li><p>You just can’t have a good understanding of <em>all</em> of these features and know interactions of the proposed syntax with all combinations of these.</p></li>
<li><p>GHC is a complex and old compiler with parts that today no active contributor knows well. The compiler (ignoring all the libraries, the RTS, tools etc.) currently has 189,699 lines of code (ignoring comments and whitespace). That’s a lot of complexity to deal with.</p></li>
<li>When you propose a new syntax, what you’re actually proposing is:
<ul>
<li>At least one more pragma</li>
<li>More user manual sections</li>
<li>MVP implementation of your syntax (which is usually not bug-free)</li>
<li>A few common-case tests (which are usually not enough)</li>
<li>More headache for tool developers</li>
<li>Scaring more potential new Haskell developers away</li>
<li>Adding to the frustration of existing Haskell developers</li>
<li>Adding maintanence burden to GHC devs</li>
</ul></li>
<li><p>Becuase you can’t predict all the interactions of your new syntax (conceptually, or in the implementation) your syntax will cause a ton of problems.</p></li>
<li><p>Those problems will sit there unfixed for months/years.</p></li>
<li><p>GHC maintainers barely have enough time and manpower to provide stable releases. 8.6.1 and 8.6.2 are completely broken (<a href="https://gitlab.haskell.org/ghc/ghc/issues/15544">#15544</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15696">#15696</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15892">#15892</a>), and 8.6.3 doesn’t <a href="https://gitlab.haskell.org/ghc/ghc/issues/16057">work well on Windows</a>.</p></li>
</ul>
<p>You might not accept some of these, however in my experience these are facts. If you disagree with any of these let me know and I can elaborate.</p>
<p>I’ll have only two examples for now, because I don’t normally work on front-end parts of the compiler I don’t notice most of the problems.</p>
<h1 id="example-1-tiny-addition-to-ghci-syntax">Example 1: Tiny addition to GHCi syntax</h1>
<p><a href="https://gitlab.haskell.org/ghc/ghc/issues/7253">#7253</a> proposed a tiny new syntax in GHCi. A few years later a new contributor picked it up and submitted a <a href="https://phabricator.haskell.org/D1299">patch</a>. This trivial new syntax later caused <a href="https://gitlab.haskell.org/ghc/ghc/issues/11606">#11606</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/12091">#12091</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/15721">#15721</a>. That’s 3 too many tickets for a trivial syntax that buys us so little. It also generated at least one <a href="https://stackoverflow.com/questions/53898220/sprint-and-seq-together-missing-evaluation">SO question</a>, and invalidated an answer to <a href="https://stackoverflow.com/questions/14052093/ghci-let-what-does-it-do/14052220#14052220">another SO question</a> by making things more complicated.</p>
<p>The implementation is finally <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/97">fixed by a frustrated maintainer</a>, but the additional complexity (both in the implementation, and as the GHCi syntax to be explained to users) it added won’t be fixed.</p>
<h1 id="example-2--xblockarguments">Example 2: -XBlockArguments</h1>
<p>This was proposed as <a href="https://github.com/ghc-proposals/ghc-proposals/pull/90">a GHC proposal</a>. It’s a trivial syntax change that in the best case can save 3 characters (including spaces). So far it generated two tickets: <a href="https://gitlab.haskell.org/ghc/ghc/issues/16137">#16137</a>, <a href="https://gitlab.haskell.org/ghc/ghc/issues/16097">#16097</a>. Even worse than the previous example is none of these tickets mention <code>-XBlockArguments</code>, they don’t even use it! Yet the error messages got significantly worse because of it.</p>
<hr />
<h1 id="just-to-be-clear">Just to be clear</h1>
<p>I think some of the extensions are quite useful. However I also think that at this point new syntax extensions are doing more harm than good. Problems from a maintainer’s point of view are as listed above (arguably maintainers’ problems are also users’ problems because they lead to poor product, but let’s ignore this aspect for now). Now I want to add one more problem, this time from a software developer/engineer’s point of view:</p>
<ul>
<li>Adding a different way of doing things, especially when the difference is so small, does more harm than good.</li>
</ul>
<p>Here’s why. Now that we have two ways of using <code>do</code> syntax:</p>
<pre><code>-- (1)
atomically $ do
  ...
-- (2) with -XBlockArguments
atomically do
  ...</code></pre>
<p>with my team I have to do one of these</p>
<ol type="1">
<li>Decide which one to use, and somehow manually make sure to use it consistently (this can’t be done automatically as we lack the tooling)</li>
<li>Let everyone use whatever they want.</li>
</ol>
<p>(1) means wasting the team’s time and energy on endless bikeshedding. (2) means being inconsistent in the source code. Either way we lose.</p>
<p>You might argue that with good tooling (1) is not a problem, and I’d agree. However as we add new syntax the tooling story will only get worse. GHC Haskell syntax is already so complex we don’t even have a good formatter. We should first stop making it even more complex if we want the tooling story to get better.</p>
<h1 id="what-we-need">What we need</h1>
<p>In my opinion what we need is principles to guide the language and the compiler. Currently <a href="https://github.com/ghc-proposals/ghc-proposals/pull/190#issuecomment-450440245">we don’t have this</a> (last paragraph), and the result is 100+ pragmas, a buggy compiler, and frustrated users and maintainers.</p>
<h1 id="my-advice-to-users">My advice to users</h1>
<p>If you’re proposing a new syntax; don’t! If you know someone who will, point them to this blog post.</p>]]></summary>
</entry>
<entry>
    <title>A project we've been working on presented at MuniHac 2018</title>
    <link href="http://osa1.net/posts/2018-10-22-gc-work-presented.html" />
    <id>http://osa1.net/posts/2018-10-22-gc-work-presented.html</id>
    <published>2018-10-22T00:00:00Z</published>
    <updated>2018-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new low-latency garbage collector for GHC that <a href="http://bgamari.github.io/">Ben Gamari</a> and I have been working on for the last year or so has recently been presented at <a href="https://munihac.github.io/">MuniHac 2018</a>. I’d like to thank Ben for the great talk.</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7_ig6r2C-d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
<p>I’ve been answering some questions on the <a href="https://www.reddit.com/r/haskell/comments/9ygoy1/munihac_2018_keynote_a_lowlatency_garbage/">/r/haskell thread</a> (I’m /u/semanticistZombie on Reddit). If you have any questions please don’t hesitate to add a comment in the reddit thread (make sure to ping me so that I get a notification), or even better, add a comment below.</p>]]></summary>
</entry>
<entry>
    <title>New blog post published elsewhere</title>
    <link href="http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html" />
    <id>http://osa1.net/posts/2018-05-19-new-post-published-elsewhere.html</id>
    <published>2018-05-19T00:00:00Z</published>
    <updated>2018-05-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A new blog post that I’ve authored has been published on <a href="http://www.well-typed.com/blog/2018/05/ghc-special-gc-objects/">Well-Typed’s blog</a>. If you’re interested in garbage collection or liked my <a href="/posts/2018-03-16-gc-optimizations.html">previous post</a> you should check it out.</p>]]></summary>
</entry>
<entry>
    <title>Debugging #15038</title>
    <link href="http://osa1.net/posts/2018-04-28-debugging-15038.html" />
    <id>http://osa1.net/posts/2018-04-28-debugging-15038.html</id>
    <published>2018-04-28T00:00:00Z</published>
    <updated>2018-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently spent some time debugging GHC bug <a href="https://ghc.haskell.org/trac/ghc/ticket/15038">#15038</a> and to help with context switching between debugging and other tasks I took notes during debugging. After successfully debugging it and reading my notes from the beginning I thought it may be an interesting read, so I’m publishing it. It may not make much sense to anyone other than me, and it’s very lightly edited, so keep your expectations low :)</p>
<hr />
<p>Crashes at this point:</p>
<pre><code>&gt;&gt;&gt; bt
#11 0x00000000008d6650 in
    barf (s=0x94fe90 &quot;evacuate(static): strange closure type %d&quot;) at rts/RtsMessages.c:47
#12 0x00000000008e7e83 in
    evacuate (p=0x981640) at rts/sm/Evac.c:574
#13 0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#14 0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#15 0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#16 0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#17 0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#18 0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#19 0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#20 0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#21 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#22 0x000000000040d7da in
    main ()</code></pre>
<p>While evacuating object at location</p>
<pre><code>p = (StgClosure **) 0x981640</code></pre>
<p>Info table of the object:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl(q)
$5 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>Untagged object:</p>
<pre><code>q = (StgClosure *) 0x981618</code></pre>
<p>Tagged:</p>
<pre><code>*p = (StgClosure *) 0x981619</code></pre>
<p>Where does this object appear? Tagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981619
(nothing)</code></pre>
<p>Untagged:</p>
<pre><code>&gt;&gt;&gt; find 0x4200000000, 0x14200000000, (void*)0x981618
(nothing)</code></pre>
<p>Not in the heap!</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981618
rctv_closure in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>According to STG output references should be</p>
<pre><code>lvl4_rctv referenced by
lvl5_rctw referenced by
lvl6_rctx referenced by
$wbyteParserBadOnce</code></pre>
<p>Looking at each closure:</p>
<pre><code>rctv :: ([Char], Packed.Bytes.Parser.Parser Word)

&gt;&gt;&gt; print (StgClosure)rctv_closure (0x981618)
{
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctv_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 0,
  code = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt; &quot;H\377\303\377e&quot;
}


rctw :: [([Char], Packed.Bytes.Parser.Parser Word)]

&gt;&gt;&gt; print (StgClosure)rctw_closure (0x981638)
{
  header = {
    info = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt;
  },
  payload = [0x0, 0x0] -- not evaluated yet?
}
&gt;&gt;&gt; print *get_itbl(&amp;rctw_closure)
{
  layout = {
    payload = {
      ptrs = 2,
      nptrs = 0
    },
    bitmap = 2,
    large_bitmap_offset = 2,
    __pad_large_bitmap_offset = 2,
    selector_offset = 2
  },
  type = 4, -- CONSTR_2_0
  srt_bitmap = 1,
  code = 0x8c3b80 &lt;ghczmprim_GHCziTypes_ZC_con_info&gt; &quot;H\203\303\002\377e&quot;
}


rctx :: Packed.Bytes.Parser.Parser Word

&gt;&gt;&gt; print (StgClosure)rctx_closure (0x981658)
{
  header = {
    info = 0x40ca10 &lt;rctx_info&gt;
        -- Packed.Bytes.Parser.Parser GHC.Types.Word
  },
  payload = []
}
&gt;&gt;&gt; print *get_itbl(&amp;rctx_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 21, -- THUNK_STATIC
  srt_bitmap = 3,
  code = 0x40ca10 &lt;rctx_info&gt; &quot;H\215E\350L9\370r@H\203\354\bL\211\350H\211\336H\211\307\061\300\350S\314M&quot;
}

$wbyteParserBadOnce :: Int -&gt; Int#

&gt;&gt;&gt; print (StgClosure)Parser_zdwbyteParserBadOnce_closure (0x981680)
{
  header = {
    info = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;Parser_zdwbyteParserBadOnce_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 113,
  code = 0x40d0b0 &lt;Parser_zdwbyteParserBadOnce_info&gt; &quot;H\215E\320L9\370\017\202\342\001&quot;
}</code></pre>
<p>Back to the backtrace. Adding watchpoints makes it run too slow, so first figure out when this happens:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 2 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 2 10000000
Will ignore next 10000000 crossings of breakpoint 2.
&gt;&gt;&gt; c
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 6 times
        ignore next 9999994 hits</code></pre>
<p>So 6th time we run GC we see this error. Let’s see if 0x981640 is a valid closure by the beginning of 6th GC:</p>
<pre><code>&gt;&gt;&gt; call LOOKS_LIKE_CLOSURE_PTR(0x981640)
$5 = true</code></pre>
<p>However at this point it already has wrong type:</p>
<pre><code>&gt;&gt;&gt; print *get_itbl((StgClosure*)0x981640)
$4 = {
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 134217728
    },
    bitmap = 576460752303423488,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 576460752303423488
  },
  type = 16585,
  srt_bitmap = 419430400,
  code = 0x981619 &quot;\026\230&quot;
}</code></pre>
<p>In fact, this object has this type since the beginning.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981640
rctw_closure + 8 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>This object is in <code>payload[0]</code> of <code>rctw</code>?</p>
<pre><code>lvl5_rctw
  :: [(GHC.Base.String, Packed.Bytes.Parser.Parser GHC.Types.Word)]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [lvl4_rctv GHC.Types.[]];</code></pre>
<p>So it should be <code>rctv</code>. Something is wrong with first payload of <code>rctw</code>. We should focus on evacuation/scavenging of <code>rctw</code>.</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981638
&gt;&gt;&gt; c
** hits breakpoint **
&gt;&gt;&gt; call printClosure(q)
ghc-prim:GHC.Types.:(0x981619, 0xace111)
&gt;&gt;&gt; info symbol 0x981619
rctv_closure + 1 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>So indeed we have <code>rctv_closure</code> in first payload (but tagged).</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)
&gt;&gt;&gt; call printClosure(0xace111)
ghc-prim:GHC.Types.[](0x8c3450#)</code></pre>
<p>It looks OK. Let’s see if it breaks after this GC.</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981638)
ghc-prim:GHC.Types.:(0x981619, 0xace111)</code></pre>
<p>Nope. Continue until first payload of 0x981638 (<code>rctw</code>) changes.</p>
<p>It turns out the payload doesn’t change. So <code>rctv</code> itself changes!</p>
<p>On 4th <code>GarbageCollect()</code> this fails:</p>
<pre><code>&gt;&gt;&gt; call printClosure(0x981619)
*** printClosure: unknown type 16585 ****
Main: internal error: printClosure 16585
    (GHC version 8.5.20180425 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
<p>So break at 3rd:</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
Breakpoint 1 at 0x8e2144: file rts/sm/GC.c, line 226.
&gt;&gt;&gt; ignore 1 2
Will ignore next 2 crossings of breakpoint 1.
&gt;&gt;&gt; c
&gt;&gt;&gt; call printClosure(0x981619)
ghc-prim:GHC.Tuple.(,)(0x9815f0, 0x981616)</code></pre>
<p>(Remember that 0x981619 is tagged 0x981618 which is <code>rctv</code>)</p>
<p>Now watch the closure:</p>
<pre><code>&gt;&gt;&gt; watch (StgClosure)rctv_closure
Watchpoint 2: (StgClosure)rctv_closure
&gt;&gt;&gt; disable breakpoint 1
&gt;&gt;&gt; c</code></pre>
<p>This takes forever, gdb starts leaking memory, fills 16G and swaps.</p>
<p>Let’s take a look at static objects again. <code>rctv</code>’s info table pointer somehow gets overwritten. What could cause this? Perhaps an object before <code>rctv</code> has an overlapping field.</p>
<pre><code>&gt;&gt;&gt; info symbol 0x981617
rctu_closure + 7 in section .data of /home/omer/.local/share/rr/Main-31/mmap_hardlink_3_Main</code></pre>
<p>It seems like we have <code>rctu</code> before <code>rctv</code>.</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)

&gt;&gt;&gt; print (StgClosure)rctu_closure
{
  header = {
    info = 0x40c908 &lt;rctu_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; print *get_itbl(&amp;rctu_closure)
{
  layout = {
    payload = {
      ptrs = 0,
      nptrs = 0
    },
    bitmap = 0,
    large_bitmap_offset = 0,
    __pad_large_bitmap_offset = 0,
    selector_offset = 0
  },
  type = 14, -- FUN_STATIC
  srt_bitmap = 1,
  code = 0x40c908 &lt;rctu_info&gt; &quot;H\215E\370L9\370\017\202\277&quot;
}</code></pre>
<p>So locations of <code>rctu</code> and <code>rctv</code></p>
<pre><code>rctu: 0x981610
rctv: 0x981618</code></pre>
<p>There’s only 8 bytes in between. This doesn’t look right. Because <code>rctu</code> is a static object with no payload, so it needs at least two words: info table pointer and static link field. Static link field is missing in the layout, so info table pointer of <code>rctv</code> is used as static link.</p>
<p>At this point I remember different types of objects have link fields in different places so let’s check:</p>
<pre><code>#define FUN_STATIC_LINK(p)   (&amp;(p)-&gt;payload[0])</code></pre>
<p>Because I can’t add watchpoint to this location so I do this:</p>
<pre><code>&gt;&gt;&gt; break evacuate_static_object if q == 0x981610</code></pre>
<p>Just to count which GC we’re at</p>
<pre><code>&gt;&gt;&gt; break GarbageCollect
&gt;&gt;&gt; ignore 2 10000</code></pre>
<p>First hit</p>
<pre><code>&gt;&gt;&gt; print (StgClosure)rctv_closure
$1 = {
  header = {
    info = 0x8c2960 &lt;ghczmprim_GHCziTuple_Z2T_con_info&gt;
  },
  payload = 0x8
}
&gt;&gt;&gt; info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000008e7a73 in evacuate_static_object at rts/sm/Evac.c:340
        stop only if q == 0x981610 (target evals)
        breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000008e2144 in GarbageCollect at rts/sm/GC.c:226
        breakpoint already hit 3 times
        ignore next 9997 hits</code></pre>
<p>Let’s see if this breaks it:</p>
<pre><code>&gt;&gt;&gt; fin
&gt;&gt;&gt; print (StgClosure)rctv_closure
$2 = {
  header = {
    info = 0x981561
  },
  payload = 0x8
}</code></pre>
<p>Yep! So this function call breaks rctv:</p>
<pre><code>&gt;&gt;&gt; bt
#0  evacuate_static_object (link_field=0x981618, q=0x981610 (rctu)) at rts/sm/Evac.c:340
#1  0x00000000008e7e20 in
    evacuate (p=0x981628) at rts/sm/Evac.c:546
#2  0x0000000000911069 in
    scavenge_static () at rts/sm/Scav.c:1831
#3  0x0000000000911638 in
    scavenge_loop () at rts/sm/Scav.c:2185
#4  0x00000000008e38fb in
    scavenge_until_all_done () at rts/sm/GC.c:1092
#5  0x00000000008e2558 in
    GarbageCollect (collect_gen=1, do_heap_census=false, gc_type=0,
                    cap=0xad40c0 &lt;MainCapability&gt;, idle_cap=0x0) at rts/sm/GC.c:418
#6  0x00000000008d523b in
    scheduleDoGC (pcap=0x7ffeced3a4a0, task=0x2620cc0, force_major=false) at rts/Schedule.c:1799
#7  0x00000000008d4787 in
    schedule (initialCapability=0xad40c0 &lt;MainCapability&gt;, task=0x2620cc0) at rts/Schedule.c:545
#8  0x00000000008d5be1 in
    scheduleWaitThread (tso=0x4200105388, ret=0x0, pcap=0x7ffeced3a590) at rts/Schedule.c:2533
#9  0x00000000008d7dd7 in
    rts_evalLazyIO (cap=0x7ffeced3a590, p=0x981730, ret=0x0) at rts/RtsAPI.c:530
#10 0x00000000008d84ca in
    hs_main (argc=1, argv=0x7ffeced3a788, main_closure=0x981730, rts_config=...) at rts/RtsMain.c:72
#11 0x000000000040d7da in
    main ()</code></pre>
<p>I’m convinced that layout of <code>rctu</code> is wrong. I’ll add some debug prints to GHC to see why the layout is generated this way, but before that I’m saving all the binaries and dump files of this session.</p>
<p>The bug should be in <code>cgTopRhsClosure</code>, the Cmm code generator for top-level closures.</p>
<p>Good thing GHC is deterministic enough these days so I get the same symbols when I recompile (later I realized that top-level symbols are deterministic enough but local ids usually change).</p>
<pre><code>gen_code
  closure_label: lvl3_rctu_closure
  descr: &lt;Parser.lvl3_rctu&gt;
  info_tbl: label: lvl3_rctu_info
            rep:HeapRep static {
                  Fun {arity: 6 fun_type: ArgGen [True, False, False, True, True]} }
  fv_details: []</code></pre>
<p>This looks fine. Let’s check <code>mkStaticClosureFields</code>:</p>
<pre><code>mkStaticClosureFields
  caf_refs: NoCafRefs
  info_lbl: lvl3_rctu_info
  is_caf: False
  padding: []
  static_link_field: []
  saved_info_field: []
  static_link_value: 3</code></pre>
<p>So this object doesn’t get a static link field. This is because the condition</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">staticClosureNeedsLink (mayHaveCafRefs caf_refs) info_tbl</a></code></pre></div>
<p>doesn’t hold.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">staticClosureNeedsLink ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">CmmInfoTable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="co">-- A static closure needs a link field to aid the GC when traversing</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="co">-- the static closure graph.  But it only needs such a field if either</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="co">--        a) it has an SRT</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="co">--        b) it&#39;s a constructor with one or more pointer fields</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6"><span class="co">-- In case (b), the constructor&#39;s fields themselves play the role</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="co">-- of the SRT.</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">staticClosureNeedsLink has_srt <span class="dt">CmmInfoTable</span>{ cit_rep <span class="fu">=</span> smrep }</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">  <span class="fu">|</span> isConRep smrep         <span class="fu">=</span> not (isStaticNoCafCon smrep)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">  <span class="fu">|</span> otherwise              <span class="fu">=</span> has_srt <span class="co">-- needsSRT (cit_srt info_tbl)</span></a></code></pre></div>
<p>So <code>has_srt</code> is <code>False</code> for this object and <code>idCafInfo</code> of this closure says it’s not caffy.</p>
<p>Just to make sure this is the problem, I modify the code to treat all top-level closures as caffy. Indeed that fixes the bug.</p>
<p>CAFness of bindings are decided in <code>hasCafRefs</code> in <code>TidyPgm</code>. Two conditions for CAFness are</p>
<ul>
<li>Top level and no arguments</li>
<li>Mentions CAFs</li>
</ul>
<p>First one obviously doesn’t hold becasue <code>rctu</code> is a function. I don’t know why the second condition doesn’t hold yet.</p>
<p><code>TidyPgm</code> operates on Core so let’s look at Core of <code>rctu</code>:</p>
<pre><code>-- RHS size: {terms: 80, types: 1,207, coercions: 0, joins: 0/0}
lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s, Packed.Bytes.Parser.Result# s Word #)
[GblId, Arity=2, Caf=NoCafRefs, Str=&lt;S,1*U&gt;&lt;S,U&gt;, Unf=OtherCon []]
lvl3_rctu
  = \ (@ s_a6Ca)
      (leftovers0_a691
         :: Packed.Bytes.Parser.Maybe#
              (Packed.Bytes.Parser.Leftovers# s_a6Ca))
      (s0_a692 :: GHC.Prim.State# s_a6Ca) -&gt;
      case leftovers0_a691 of {
        (#_|#) ds_d6Km -&gt;
          (# s0_a692,
             (# GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ (&#39;GHC.Types.TupleRep
                       &#39;[&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                         &#39;GHC.Types.LiftedRep])
                  @ (# #)
                  @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                  GHC.Prim.(##),
                GHC.Prim.(#_|#)
                  @ (&#39;GHC.Types.TupleRep &#39;[])
                  @ &#39;GHC.Types.LiftedRep
                  @ (# #)
                  @ Word
                  GHC.Prim.(##) #) #);
        (#|_#) ds_d6Kn -&gt;
          case ds_d6Kn of { (# bytes0_scqD, stream0_scqE #) -&gt;
          case bytes0_scqD of { (# arr0_scqH, off0_scqI, len0_scqJ #) -&gt;
          case GHC.Prim.&gt;# len0_scqJ 0# of {
            __DEFAULT -&gt;
              case Packed.Bytes.Parser.nextNonEmpty @ s_a6Ca stream0_scqE s0_a692
              of
              { (# ipv_s6NZ, ipv1_s6O0 #) -&gt;
              case ipv1_s6O0 of {
                (#_|#) ds3_d6JW -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          GHC.Prim.(##),
                        GHC.Prim.(#_|#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          GHC.Prim.(##) #) #);
                (#|_#) ds3_d6JX -&gt;
                  case ds3_d6JX of { (# bytes1_scqM, stream1_scqN #) -&gt;
                  case bytes1_scqM of { (# arr1_scqQ, off1_scqR, ds4_scqS #) -&gt;
                  (# ipv_s6NZ,
                     (# GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ (&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.TupleRep
                                   &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                                 &#39;GHC.Types.LiftedRep])
                          @ (# #)
                          @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                          (# (# arr1_scqQ, GHC.Prim.+# off1_scqR 1#,
                                GHC.Prim.-# ds4_scqS 1# #),
                             stream1_scqN #),
                        GHC.Prim.(#|_#)
                          @ (&#39;GHC.Types.TupleRep &#39;[])
                          @ &#39;GHC.Types.LiftedRep
                          @ (# #)
                          @ Word
                          a1_rcbR #) #)
                  }
                  }
              }
              };
            1# -&gt;
              (# s0_a692,
                 (# GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ (&#39;GHC.Types.TupleRep
                           &#39;[&#39;GHC.Types.TupleRep
                               &#39;[&#39;GHC.Types.UnliftedRep, &#39;GHC.Types.IntRep, &#39;GHC.Types.IntRep],
                             &#39;GHC.Types.LiftedRep])
                      @ (# #)
                      @ (Packed.Bytes.Parser.Leftovers# s_a6Ca)
                      (# (# arr0_scqH, GHC.Prim.+# off0_scqI 1#,
                            GHC.Prim.-# len0_scqJ 1# #),
                         stream0_scqE #),
                    GHC.Prim.(#|_#)
                      @ (&#39;GHC.Types.TupleRep &#39;[])
                      @ &#39;GHC.Types.LiftedRep
                      @ (# #)
                      @ Word
                      a1_rcbR #) #)
          }
          }
          }
      }</code></pre>
<p>This is huge and I’m not going to check this by hand. However at this point I realize that the condition for evacuating a <code>FUN_STATIC</code> is</p>
<pre><code>case FUN_STATIC:
    if (info-&gt;srt_bitmap != 0) {
        evacuate_static_object(FUN_STATIC_LINK((StgClosure *)q), q);
    }
    return;</code></pre>
<p>So this is not marked as CAF, but its SRT bitmap is not empty. Perhaps the bug is in the SRT bitmap.</p>
<p>I also try this in gdb:</p>
<pre><code>&gt;&gt;&gt; set get_itbl(&amp;rctu_closure)-&gt;srt_bitmap = 0</code></pre>
<p>This also fixes it. Now let’s figure out why SRT bitmap of <code>rctu</code> (which is supposed to be a non-CAF) is 1.</p>
<p>I look again at the definition of <code>rctu</code> and it seems like <code>a1_rcbR</code> is a free variable.</p>
<pre><code>a1_rcbR :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [5##];</code></pre>
<p>However because this is not a CAF it shouldn’t make <code>rctu</code> CAF.</p>
<p>I stare at the code aimlessly for a while until I realize something interesting. This is the STG for <code>rctu</code> after unarisation:</p>
<pre><code>lvl3_rctu
  :: forall s.
     Packed.Bytes.Parser.Maybe# (Packed.Bytes.Parser.Leftovers# s)
     -&gt; GHC.Prim.State# s
     -&gt; (# GHC.Prim.State# s,
           Packed.Bytes.Parser.Result# s GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=&lt;S,1*U&gt;&lt;S,U&gt;,
 Unf=OtherCon []] =
    [] \r [us_gcwc us_gcwd us_gcwe us_gcwf us_gcwg void_0E]
        case us_gcwc of tag_gcwh {
          __DEFAULT -&gt;
              (#,,,,,,#) [1#
                          Control.Exception.Base.absentError
                          Control.Exception.Base.absentError
                          0##
                          0##
                          1#
                          Control.Exception.Base.absentError];
          2# -&gt;
              case &gt;# [us_gcwg 0#] of {
                __DEFAULT -&gt;
                    case Packed.Bytes.Parser.nextNonEmpty us_gcwe GHC.Prim.void# of {
                      (#,,,,#) us_gcwi us_gcwj us_gcwk us_gcwl us_gcwm -&gt;
                          case us_gcwi of tag_gcwn {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [1#
                                            Control.Exception.Base.absentError
                                            Control.Exception.Base.absentError
                                            0##
                                            0##
                                            1#
                                            Control.Exception.Base.absentError];
                            2# -&gt;
                                case -# [us_gcwm 1#] of sat_scuk {
                                  __DEFAULT -&gt;
                                      case +# [us_gcwl 1#] of sat_scuj {
                                        __DEFAULT -&gt;
                                            (#,,,,,,#) [2#
                                                        us_gcwj
                                                        us_gcwk
                                                        sat_scuj
                                                        sat_scuk
                                                        2#
                                                        a1_rcbR];
                                      };
                                };
                          };
                    };
                1# -&gt;
                    case -# [us_gcwg 1#] of sat_scur {
                      __DEFAULT -&gt;
                          case +# [us_gcwf 1#] of sat_scuq {
                            __DEFAULT -&gt;
                                (#,,,,,,#) [2# us_gcwd us_gcwe sat_scuq sat_scur 2# a1_rcbR];
                          };
                    };
              };
        };</code></pre>
<p>This has two free variables: <code>a1_rcbR</code> and <code>Control.Exception.Base.absentError</code>. <code>a1_rcbR</code> is clearly not a CAF, but maybe <code>absentError</code> is? Because <code>absentError</code> references are generated in unarise, which happens much later than <code>TidyPgm</code> (right before generating Cmm), <code>TidyPgm</code> can’t take those into account.</p>
<p><code>Id</code> for <code>absentError</code> is generated using <code>vanillaIdInfo</code> which sets the CAF-ness field as <code>MayHaveCafRefs</code>. So clearly <code>absentError</code> is a CAFFY.</p>
<p>So in summary, we introduce references to CAFs in <code>UnariseStg</code> which happens later than <code>TidyPgm</code>. The code generator is somehow handles this correctly by generating a SRT for this function and setting the info table bitmap correctly. However object layout generator (in <code>cgTopRhsClosure</code>) only uses the information generated in <code>TidyPgm</code>, so we get this mismatch of SRT information of this function.</p>
<p>Some ways to fix this:</p>
<ul>
<li>Update binder ids in unarise if we introduced an <code>absentError</code></li>
<li>Conservatively treat unboxed sums as CAFFY in <code>TidyPgm</code></li>
<li>Mark <code>absentError</code> as non-CAF (I don’t know if it has to be a CAF, I think error ids are conservatively marked as CAFs)</li>
</ul>
<p>The whole thing took 4:47 hours.</p>]]></summary>
</entry>
<entry>
    <title>Three runtime optimizations done by GHC's GC</title>
    <link href="http://osa1.net/posts/2018-03-16-gc-optimizations.html" />
    <id>http://osa1.net/posts/2018-03-16-gc-optimizations.html</id>
    <published>2018-03-16T00:00:00Z</published>
    <updated>2018-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>While working on GHC’s GC code I realized that it does some runtime optimizations. One of those I already knew from another language, but the other two were quite interesting to me because they’re related with laziness. I wouldn’t think consequences of laziness reach this far into the runtime system. It turns out it does; disabling those optimizations make programs run significantly slower.</p>
<p>Because I almost read the whole code line by line, I believe this list is exhaustive. The code is taken from the source code but significantly simplified.</p>
<p>If you’re not familiar with GHC’s heap object layout and info tables etc., I suggest reading <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">the wiki page</a> before moving on the rest of the post.</p>
<h1 id="replacing-small-int-and-char-closures-with-statically-initialized-shared-closures">1. Replacing small Int and Char closures with statically initialized, shared closures</h1>
<p><code>Int</code> and <code>Char</code> closures have one non-pointer field for the actual integer and character values, as can be seen in GHCi:</p>
<pre><code>λ&gt; :info Int
data Int = GHC.Types.I# GHC.Prim.Int#     -- Defined in ‘GHC.Types’
λ&gt; :info Char
data Char = GHC.Types.C# GHC.Prim.Char#   -- Defined in ‘GHC.Types’</code></pre>
<p>The corresponding closure type for closures with one non-pointer and no pointers is <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/includes/rts/storage/ClosureTypes.h#L25"><code>CONSTR_0_1</code></a>. The garbage collector <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L656">needs to check closure type before copying an object</a> to decide how many bytes to copy (and also to decide what pointers to follow and copy the pointed object, but this happens in a later stage). When it finds a <code>CONSTR_0_1</code> it checks if it’s actually an <code>Int</code> or <code>Char</code> closure, if it is, it checks if the payload (the actual <code>Int</code> and <code>Char</code> values) is within a range. If it is then we know that we have statically-allocated <code>Int</code> or <code>Char</code> closure what is identical to the one we’re copying, so we return address to the statically allocated one rather than copying the closure and returning the new address of the copied closure. This way we avoid having multiple closures for <code>1 :: Int</code>, for example. The code (simplified, some comments by me):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="cf">case</span> CONSTR_0_1:</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="co">// Constructor with one non-pointer field. Read the field.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    StgWord w = (StgWord)q-&gt;payload[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="cf">if</span> (<span class="co">// is it a Char?</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        info == Czh_con_info &amp;&amp;</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="co">// is the value in range?</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        (StgChar)w &lt;= MAX_CHARLIKE)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    {</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="co">// return address to statically allocated Char closure</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        *p =  TAG_CLOSURE(tag, (StgClosure *)CHARLIKE_CLOSURE((StgChar)w));</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="cf">else</span> <span class="cf">if</span> (<span class="co">// is it an Int?</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">             info == Izh_con_info &amp;&amp;</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">             <span class="co">// is the value in range?</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">             (StgInt)w &gt;= MIN_INTLIKE &amp;&amp; (StgInt)w &lt;= MAX_INTLIKE)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    {</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">        <span class="co">// return address to statically allocated Int closure</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        *p = TAG_CLOSURE(tag, (StgClosure *)INTLIKE_CLOSURE((StgInt)w));</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">    <span class="co">// otherwise copy the object</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24">    {</a>
<a class="sourceLine" id="cb2-25" data-line-number="25">        copy_tag_nolock(p,info,q,sizeofW(StgHeader)+<span class="dv">1</span>,gen_no,tag);</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">}</a></code></pre></div>
<p>What are the ranges here? Looking at the <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/StgMiscClosures.cmm#L679-L974">definition</a>, we see that integers in range [-16, 16] and the whole ASCII character set is covered.</p>
<p>Here’s a small program that shows the effect of this optimization:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">GHC.Stats</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Mem</span> (performMajorGC)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">seqIntList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">seqIntList []       a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">seqIntList (i <span class="fu">:</span> is) a <span class="fu">=</span> i <span class="ot">`seq`</span> is <span class="ot">`seqIntList`</span> a</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">let</span> lst <span class="fu">=</span> [ <span class="dv">0</span> <span class="fu">..</span> <span class="dv">15</span> ]</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="co">-- let lst = [ 17 .. 32 ] -- enable this on the second run</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="co">-- evaluate the list</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    lst <span class="ot">`seqIntList`</span> return ()</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="co">-- collect any thunks, do the optimization if possible, update stats</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    performMajorGC</a>
<a class="sourceLine" id="cb3-20" data-line-number="20"></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    rts_stats <span class="ot">&lt;-</span> getRTSStats</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    putStrLn (<span class="st">&quot;Live data: &quot;</span> <span class="fu">++</span> show (gcdetails_live_bytes (gc rts_stats)) <span class="fu">++</span> <span class="st">&quot; bytes&quot;</span>)</a>
<a class="sourceLine" id="cb3-23" data-line-number="23"></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    <span class="co">-- to make sure our list won&#39;t be collected</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">    lst <span class="ot">`seqIntList`</span> return ()</a></code></pre></div>
<p>Run it with:</p>
<pre><code>ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T</code></pre>
<p>On the second run, disable the first list and enable the second one. You’ll see this output:</p>
<pre><code>$ ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T
[1 of 1] Compiling Main             ( eq.hs, eq.o )
Linking eq ...
Live data: 2224 bytes

$ ghc eq.hs -rtsopts -O0 &amp;&amp; ./eq +RTS -T
[1 of 1] Compiling Main             ( eq.hs, eq.o )
Linking eq ...
Live data: 2480 bytes</code></pre>
<p>So second program has 256 bytes more live data. Let’s check if that makes sense. The first program doesn’t have any heap-allocated <code>Int</code> closures, because all of the <code>Int</code> in the program are within the range of statically allocated <code>Int</code> closures. Second one has 16 <code>Int</code> closures. An <code>Int</code> closure is two words: a pointer to the <code>I#</code> info table, and an actual integer value in the payload, so that’s 16 bytes. 16 (number of <code>Int</code> closures) * 16 (<code>Int</code> closure size) = 256.</p>
<p>I know at least one another language, Python, does this as well:</p>
<pre><code>Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 1
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; x = 100000000000
&gt;&gt;&gt; y = 100000000000
&gt;&gt;&gt; x is y
False</code></pre>
<p>Although I’m not sure if it does this during garbage collection.</p>
<h1 id="shorting-out-indirections">2. Shorting out indirections</h1>
<p>This is related with how lazy evaluation is implemented so we’ll first take a look at the generated code for a simple thunk update. When we compile the following program: (to keep things simple we disable optimizations)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    i <span class="ot">&lt;-</span> readLn</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    print (fib i)</a></code></pre></div>
<p>in STG level we get this function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sat_s31Q <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    \r [i_s31O]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="kw">let</span> { sat_s31P <span class="fu">=</span> \u [] fib_rqh i_s31O;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        } <span class="kw">in</span>  print <span class="fu">$</span>fShowInt sat_s31P;</a></code></pre></div>
<p>Here <code>fib_rqh</code> is the <code>fib</code> function, and <code>sat_s31P</code> is the thunk for <code>fib i</code>. First let’s take a look at how this thunk is evaluated in the use site: (Cmm syntax)</p>
<pre><code>I64[Sp - 16] = stg_upd_frame_info;
P64[Sp - 8] = _s31P::P64;
_s31O::P64 = P64[_s31P::P64 + 16];
R2 = _s31O::P64;
Sp = Sp - 16;
call fib_rqh_info(R2) args: 24, res: 0, upd: 24;</code></pre>
<p>So we push the thunk (<code>_s31P</code>), then <code>stg_upd_frame_info</code> to the stack, and jump to the code for the <code>fib</code> function, passing the argument in <code>R2</code>.</p>
<p>I won’t show the code (because it’s large and complex), but the code for <code>fib</code> puts the return value in <code>R1</code>, pops the stack, and jump to the code for the popped stack frame, which is <code>stg_upd_frame_info</code>.</p>
<p>At this point we have the return value of <code>fib</code> in <code>R1</code>, and thunk to update at the bottom of the stack.</p>
<p>The code for <code>stg_upd_frame_info</code> is as follows: (simplified, see the original version <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/Updates.cmm#L28-L38">here</a>)</p>
<pre><code>INFO_TABLE_RET ( stg_upd_frame, // label
                 UPDATE_FRAME,  // frame type
                 w_ info_ptr,   // info ptr
                 p_ updatee )   // thunk to update at the bottom of the stack
    return (P_ ret) // in R1 we expect the value to update the thunk with
{
    StgInd_indirectee(updatee) = ret;       // (1)
    SET_INFO(updatee, stg_BLACKHOLE_info);  // (2)
    ...
    return (ret);
}</code></pre>
<p>This basically replaces the thunk’s (<code>_s31P</code>) info table pointer with <code>stg_BLACKHOLE_info</code> in line (2) (effectively making the thunk an indirection), and writes pointer to the evaluated object to the payload in line (1).</p>
<p>Now any code that uses this value needs to follow the pointer written to what was originally a thunk in line (1). This is done by the <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/StgMiscClosures.cmm#L295">entry code of <code>stg_BLACKHOLE_info</code></a>.</p>
<p>Now, because the GC copies objects from one heap to another, and updates any references to these moved objects in thread stacks (and in other roots), we can follow any indirections when copying blackhole objects, and replace references in thread stacks to the blackhole object with a reference to the object pointed to by the blackhole object. <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L732-L755">The code</a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="cf">case</span> BLACKHOLE:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    StgClosure *r;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">const</span> StgInfoTable *i;</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    r = ((StgInd*)q)-&gt;indirectee;</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="cf">if</span> (GET_CLOSURE_TAG(r) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        i = r-&gt;header.info;</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="cf">if</span> (IS_FORWARDING_PTR(i)) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">            r = (StgClosure *)UN_FORWARDING_PTR(i);</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">            i = r-&gt;header.info;</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        }</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        <span class="cf">if</span> (i == &amp;stg_TSO_info</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">            || i == &amp;stg_WHITEHOLE_info</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">            || i == &amp;stg_BLOCKING_QUEUE_CLEAN_info</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">            || i == &amp;stg_BLOCKING_QUEUE_DIRTY_info) {</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">            copy(p,info,q,sizeofW(StgInd),gen_no);</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">            <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">        ASSERT(i != &amp;stg_IND_info);</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    q = r;</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">    *p = r;</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">    <span class="cf">goto</span> loop;</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">}</a></code></pre></div>
<p>I don’t understand all the details in this code, but I think the important bits are the <code>q-&gt;indirectee</code> line which follows the pointer written in line (1) above, and <code>goto loop</code> which makes the garbage collector copy and return the object pointed by the blackhole.</p>
<p>After this we no longer have to follow a pointer to our evaluated thunk. Instead references to the thunk become references to the evaluated object.</p>
<h1 id="selector-thunk-evaluation">3. Selector thunk evaluation</h1>
<p>A selector thunk is a thunk of this form: (<a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/compiler/codeGen/StgCmmBind.hs#L267-L297">code</a>)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="dt">C</span> x1 <span class="fu">...</span> xn <span class="ot">-&gt;</span> xm</a></code></pre></div>
<p>where <code>1 &lt;= m &lt;= n</code>, and <code>x</code> is a variable. The problem with such a thunk is that it keeps all of the fields of <code>x</code> live until the selector thunk is evaluated, even when <code>x</code> is evaluated by some other code. As an example where this happens, suppose we have this record:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">R</span> <span class="fu">=</span> <span class="dt">R</span> {<span class="ot"> _i1 ::</span> <span class="dt">Int</span>,<span class="ot"> _i2 ::</span> <span class="dt">Int</span>, <span class="fu">...</span> other fields <span class="fu">...</span> }</a></code></pre></div>
<p>then in a function we take <code>R</code> as parameter, and use the fields:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f r <span class="fu">=</span> _i1 r <span class="fu">+</span> _i2 r</a></code></pre></div>
<p>Here <code>_i1 r</code> and <code>_i2 r</code> are selector thunks. Now suppose that the parameter to this function was already evaluated before the function is called. In this case the thunk that holds the this function application will keep all of <code>r</code> live even though only <code>_i1</code> and <code>_i2</code> are needed.</p>
<p>It turns out this problem was known since around <del>1985</del> 1981. <del>To my knowledge, Wadler was the first one to suggest solving these kind of “leaks” in the garbage collector</del> <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> (see <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> for correction). The idea is that while the GC copies these thunks it checks if the “selectee” is already evaluated. If so the GC evaluates the selector thunk during copying, and copies the evaluated form. Because selectors thunks are so simple (the exact shape of a selector thunk is well specified and it can’t do anything other than accessing a field) evaluation of these are just a matter of indexing the selectee’s payload. The function that does this is <a href="https://github.com/ghc/ghc/blob/cb6d8589c83247ec96d5faa82df3e93f419bbfe0/rts/sm/Evac.c#L1002">here</a>. The whole story is complicated because of concurrency concerns (e.g. another GC thread can also evaluate the thunk at the same time), but the actual optimization starts around line 1104 by looking at info table at the selectee. If it’s a constructor, then we access to the field and return it. Otherwise it’s a thunk and we copy it as usual.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In each cycle a copying garbage collector copies live data in a heap to another heap and abandons the old heap. It turns out this kind of garbage collection is really convenient for implementing optimizations described above. The code that traverses all live data, copies it, and updates the roots is already there. Doing updates on objects while copying is just a matter of adding a few more lines in the copying function.</p>
<p>In a non-copying collector this is much trickier, because the collector doesn’t actually need to update roots or the data. For example, to implement optimizations (2) in a mark-sweep collector we have to somehow keep track of the location where we found the pointer to the object we’re currently marking. Then, if the object became an indirection, we have to update the source location and should not mark the indirection object, because some other object may have a reference to it, and we have to update that reference too. In short, it’s certainly possible, but much trickier. Mark phase gets more complicated.</p>
<p>In summary,</p>
<ul>
<li><p>Generational copying collectors are known to be a good fit for functional languages. It turns out if your language is also lazy they’re even better fit.</p></li>
<li><p>Laziness have far-reaching consequences. The optimizations (2) and (3) are really essential to get good performance out of lazy programs (try commenting out those lines in the GC!), and they require support from the GC.</p></li>
</ul>
<hr />
<p>This post is submitted to <a href="https://www.reddit.com/r/haskell/comments/852jfc/three_runtime_optimizations_done_by_ghcs_gc/">/r/haskell</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>“Fixing some space leaks with a garbage collector”, Wadler, 1987.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Correction: Wadler was the first one to write about it in 1987, but Lennart Augustsson came up with this solution around 1981, and <a href="https://www.reddit.com/r/haskell/comments/852jfc/three_runtime_optimizations_done_by_ghcs_gc/dvuwtl0/">according him him</a> David Turner came up with the solution even before him.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Unboxed sums FAQ</title>
    <link href="http://osa1.net/posts/2016-07-22-unboxed-sums-faq.html" />
    <id>http://osa1.net/posts/2016-07-22-unboxed-sums-faq.html</id>
    <published>2016-07-22T00:00:00Z</published>
    <updated>2016-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The unboxed sums patch that implements unlifted, unboxed sum types (as described in <a href="https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes">this Wiki page</a>) was merged yesterday, and a <a href="https://www.reddit.com/r/haskell/comments/4txuo7/unboxed_sum_types_with_unpack_support_will_be_in/">/r/haskell discussion</a> emerged shortly after. As the implementor, I tried to answer questions there, but to keep answers more organized I wanted to write a blog post about it.</p>
<p>The reason I’m not writing this to the Wiki page is because this is about current plans and status of the feature. The wiki page may be updated in the future as the feature evolves and/or may be edited by others. This page reflects the current status as of today, future plans, and my own ideas.</p>
<hr />
<h2 id="syntax-is-awful-why">Syntax is awful, why?</h2>
<p>This feature is designed to complement the similar feature for product types (tuples), called <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-tuples">“unboxed tuples”</a>. The syntax is thus chosen to reflect this idea. Instead of commas in the unboxed tuple syntax, we used bars (similar to how bars used in sum type declarations). The syntax looks bad for several reasons:</p>
<ul>
<li><p>Type argument of an alternative have to be a single type. If we want multiple types in an alternative, we have to use an unboxed tuple. For example, unboxed sum version of the type <code>data T = T1 Int | T2 String Bool</code> is <code>(# Int | (# String, Bool #) #)</code>. That’s a lot of parens and hashes.</p></li>
<li><p>Similarly, for nullary alternatives (alternatives/constructors with no arguments) we have to use empty unboxed tuples. So a bool-like type looks like <code>(# (# #) | (# #) #)</code>.</p></li>
<li><p>Data constructors use the same syntax, except we have to put spaces between bars. For example, if you have a type with 10 alternatives, you do something like <code>(# | | | | value | | | | | #)</code>. Space between bars is optional in the type syntax, but not optional in the term syntax. The reason is because otherwise we’d have to steal some existing syntax. For example, <code>(# ||| a #)</code> can be parsed as singleton unboxed tuple of <code>Control.Arrow.|||</code> applied to an argument, or an unboxed sum with 4 alternatives.</p></li>
</ul>
<p>Note that the original Wiki page for unboxed sums included a “design questions” section that discussed some alterantive syntax (see <a href="https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes?version=32">this version</a>). Nobody made any progress to flesh out the ideas, and I updated the Wiki page to reflect the implementation. So it was known that the syntax is not good, but it just wasn’t a major concern.</p>
<p>Answer to the second question is also an answer to this question.</p>
<h2 id="how-is-this-supposed-to-be-used-by-users">How is this supposed to be used by users?</h2>
<p>We’re not expecting users to use this type extensively. It’ll mostly be used by the compiler, for optimizations. In fact, we could have skipped the front-end syntax entirely, and it’d be OK for the most part. If you haven’t used unboxed tuples before, you probably won’t be using unboxed sums.</p>
<p>The only place you may want to use this syntax is when you’re writing a high-performance library or program, and you have a sum type that’s used strictly and can take advantage of removing a level of indirection.</p>
<h2 id="how-is-this-used-by-the-compiler">How is this used by the compiler?</h2>
<p>A detailed answer would take too long, but here’s a summary:</p>
<ul>
<li><p><a href="research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/cpr.ps.gz">Constructed product analysis</a> can now be used for returning sums efficiently. Note that this feature was left as “future work” in the paper (which is from 2004. See section 3.2). The high-level idea is that if a function returns a value that <em>it constructs</em>, then instead of boxing the components of the value and returning a boxed object, it can just return the components instead. In the case where the function result is directly scrutinized (i.e. case expressions), this usually reduces allocations. In other cases, it moves the allocation from the callee to the call site, which in turn leads to stack allocation is some cases (when the object doesn’t escape from the scope).</p>
<p>For product types, unboxed tuples are used for returning the value without heap allocation. For sum types, we use unboxed sums.</p></li>
<li><p>Result of strictness (or “demand”) analysis can now be used to pass sums efficiently. As a result worker/wrapper transformations can now be done for functions that take sum arguments. See <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">this Wiki page for demand analysis</a> and <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/usage-types/cardinality-popl14.pdf">this 2014 paper</a>.</p></li>
<li><p><code>{-# UNPACK #-}</code> pragmas now work on sum types, using unboxed sums under the hood.</p></li>
</ul>
<p>Note that none of these need a concrete syntax for unboxed sums.</p>
<hr />
<p>Hopefully this clarifies some questions and concerns, especially about the syntax. We have plenty of time until the first RC for 8.2 (<a href="https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.2.1">mid-February 2017</a>), so it’s certainly possible to improve the syntax, and I’ll be working on that part once I’m done with the optimizations.</p>]]></summary>
</entry>
<entry>
    <title>Stack traces in GHCJS</title>
    <link href="http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html" />
    <id>http://osa1.net/posts/2014-06-20-stack-traces-in-ghcjs.html</id>
    <published>2014-06-20T00:00:00Z</published>
    <updated>2014-06-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m about to finish the first part of my GSoC project and as a part of my project I have implemented stack traces for GHCJS. Currently <code>GHC.Stack</code> functions should work in GHCJS, except for some cases I explain below.</p>
<p>As a demo, I set up <a href="http://osa1.net/files/stacktrace.jsexe/index.html">this page</a>, it runs the Haskell program rendered on the page (some part of the code is copied from Simon Marlow’s <a href="http://www.youtube.com/watch?v=J0c4L-AURDQ">“Why can’t I get stack traces?” presentation</a>). Output is printed to the console. You should be seeing something like this:</p>
<p><img src="http://osa1.net/images/ghcjs-stacktrace.png" /></p>
<p>My main goal is to implement profiling features of GHC (cost-centres, SCC annotations, reporting allocations/ticks etc.) for GHCJS. It turns out that cost-centre stacks and call stacks are same thing. <code>GHC.Stack.currentCallStack</code> returns the current cost-centre stack, and cost attribution is done to current call-stack(or current cost-centre stack, since they’re exactly the same thing). Similarly, <code>GHC.Stack.whoCreated</code> returns the cost centre stack that was active when the heap object was created.</p>
<p><a href="https://github.com/osa1/ghcjs/compare/ghcjs:master...work3">20 changed files with 810 additions and 527 deletions</a> later, I had <code>GHC.Stack</code> working. You won’t need to do anything different once it’s merged into GHCJS, but for now it requires some effort to install. It also still has some bugs and differences from GHC version. Rest of the post explains how to test it, bugs, and differences from GHC.</p>
<h1 id="how-to-use">How to use</h1>
<p>Because of a horrible bug(see bugs section), you need a 32bit system to use profiling features of GHCJS. You should clone my fork of <a href="https://github.com/osa1/ghcjs">GHCJS</a> and <a href="https://github.com/osa1/shims">shims</a>. For GHCJS, switch to <code>work3</code> branch(that 3 represents how many times I started from scratch :) and for shims switch to <code>work2</code> branch. You need to install <a href="https://github.com/ghcjs/Cabal">modified Cabal for GHCJS</a>. After installing Cabal, install GHCJS and run <code>ghcjs-boot --init -q --prof</code>. This takes about 20 minutes on my system and compiles <code>base</code> and some other libraries. <code>--prof</code> is used to generate profiled versions of libraries.</p>
<p>After GHCJS has been booted, replace ~/.ghcjs/&lt;your platform&gt;/shims folder with my fork of shims(make sure you switched to work2 branch). Now you should be able to compile and run programs with profiling options of GHC. For example, to compile and run the example program given above, run <code>ghcjs stacktrace.hs -prof -fprof-auto</code> and then run generated <code>stacktrace.jsexe/all.js</code> using nodejs. Enabling profiling gives you a debug executable, with more metadata (object names) and longer (non-renamed) variable names.</p>
<h1 id="differences">Differences</h1>
<p>Because GHCJS represents some objects as unboxed numbers and currently we don’t associate any cost-centres with this type of objects, <code>whoCreated</code> returns an empty list. If there’s demand, we can disable unboxing with a command line switch and <code>whoCreated</code> on these values would work. In the example program, second and third lines are printing empty lists because of this.</p>
<h1 id="bugs">Bugs</h1>
<p>Currently we discovered two bugs:</p>
<ol type="1">
<li><p>There’s a horrible bug happening outside of GHCJS code, see my <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">blog post</a> and <a href="http://www.haskell.org/pipermail/ghc-devs/2014-May/005059.html">ghc-devs mail</a>. Because of this bug, booting GHCJS with profiling enabled is resulting with a segfault on 64bit systems. I’m developing this project on a 32bit VM, running on a VPS :) I need to make some more progress before tracking this bug.</p></li>
<li><p>We’re having a bug that makes stack traces sometimes a bit different than the ones generated by GHC compiled programs. For example, the example program should have printed this stack trace:</p>
<pre><code>Main.errorM.\ (stacktrace.hs:13:22-54)
Main.errorM (stacktrace.hs:13:1-54)
Main.foo.\.\ (stacktrace.hs:27:23-30)
Main.foo.\ (stacktrace.hs:27:16-33)
Main.foo (stacktrace.hs:27:1-36)
Main.bar (stacktrace.hs:24:1-20)
Main.runM.(...) (stacktrace.hs:16:20-31)
Main.runM (stacktrace.hs:16:1-36)
Main.main (stacktrace.hs:(29,1)-(38,36))
Main.CAF (&lt;entire-module&gt;)</code></pre>
<p>.. but <code>runM</code> calls are missing in GHCJS output. I have no idea what could be the reason for this and I’m currently working to fix this. After fixing this, I think we’ll have exactly same stack traces as the ones produced by GHC compiled programs.</p></li>
</ol>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>I’d like to thank my mentor Luite Stegeman for answering my endless questions, helping me understanding GHC and GHCJS internals and reviewing this blog post.</p>]]></summary>
</entry>
<entry>
    <title>GHC RTS notes</title>
    <link href="http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html" />
    <id>http://osa1.net/posts/2014-05-30-ghc-internals-reading-material.html</id>
    <published>2014-05-30T00:00:00Z</published>
    <updated>2014-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://news.ycombinator.com/item?id=7818768">Someone on HN</a> shared <a href="http://stanford.edu/~adebray/240h_notes.pdf">this class notes</a> of Stanford’s “Functional Systems in Haskell” class. Most of the stuff is very basic but sections 16 and 17 are very useful for me since they’re related with GHC internals which I’m currently studying.</p>
<p>You can see slides of Section 17 <a href="http://ezyang.tumblr.com/post/87048816817/cs240h-lecture-on-the-ghc-runtime-system">here</a>.</p>
<p>These are probably only up-to-date reading materials about GHC RTS you can find. (unless you count source code as a reading material ;_; )</p>
<p>Some other useful GHC Wiki pages that I find useful: (validness of these for current GHC is not guaranteed, but theoretic stuff should be still valid)</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps">PrimOps</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply">Function calls</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#ThreadStateObjects">The layout of heap objects</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Stack">Layout of the stack</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution">The Haskell Execution Model</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode">STG by example</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode">Debugging GHC-compiled code with gdb</a> (I hope you don’t really need this!)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Debugging/RuntimeSystem">Debugging the runtime system</a> (same as above)</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">The Garbage Collector</a></li>
<li><a href="http://www.mono-project.com/Generational_GC">Generational GC page of Mono project</a> – not really Haskell, but I think it’s a good source to understand GC concepts that is related with GHC’s GC implementation.</li>
</ul>
<p>Now I can close my browser tabs in peace…</p>
<p>Bonus content: Here’s a <a href="http://osa1.net/posts/2014-05-27-worst-bug.html">horror story</a> that is probably related with a GHC RTS bug and making progress in my work impossible.</p>
<p>EDIT: Someone on GHC IRC channel shared <a href="http://arashrouhani.com/papers/master-thesis.pdf">his masters thesis about GHC stack traces</a>, even if you’re not interested in stack traces I think it contains lots of useful information about GHC compilation pipeline.</p>]]></summary>
</entry>
<entry>
    <title>The GHC bug that ruined my day</title>
    <link href="http://osa1.net/posts/2014-05-27-worst-bug.html" />
    <id>http://osa1.net/posts/2014-05-27-worst-bug.html</id>
    <published>2014-05-27T00:00:00Z</published>
    <updated>2014-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just came across a very serious GHC bug that prevents me from making progress on my GHCJS project. It looks like it’s very hard to come up with a minimal program that reproduces the bug. Here’s a very long way to reproduce it:</p>
<ul>
<li><p>Install <a href="https://github.com/ghcjs/Cabal">patched Cabal for GHCJS</a>.</p></li>
<li><p>Clone <a href="https://github.com/osa1/ghcjs">my fork of GHCJS</a>, switch to <code>work</code> branch and install it.</p></li>
<li><p>Delete <code>~/.ghcjs</code> folder if you already have one.</p></li>
<li><p>Run <code>ghcjs-boot --init --prof -v</code> and wait for it to fail with segmentation fault while compiling profiling object files for <code>base</code> library. Segmentation fault is reported as <code>ExitFailure (-11)</code> by Cabal.</p></li>
<li><p>Since we run <code>ghcjs-boot</code> in verbose mode(using <code>-v</code> parameter), at this point it should have printed what command it was running when the error occured. It should be a very very long command, starting with something like <code>/home/omer/.cabal/bin/ghcjs --make -fbuilding-cabal-package -O -prof ...</code>. Copy that command because that’s how we reproduce the error.</p></li>
<li><p>Now to trace the bug, we need to compile GHCJS for debugging. Note that booting GHCJS with debugging build takes forever, so we first installed GHCJS and built some libraries using that fast build. To compile for debugging, first run <code>cabal clean</code> and then <code>cabal install --disable-executable-stripping --ghc-options=-debug</code>.</p></li>
<li><p>Move to <code>~/.ghcjs/&lt;your platform&gt;/ghcjs-boot/boot/base</code> and run the command you copied from <code>ghcjs-boot</code> verbose output when the error happened for first time. You should get the same error very fast.</p></li>
<li><p>At that point you can use gdb and friends. On my system gdb backtrace gives this:</p></li>
</ul>
<pre><code>[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
Detaching after fork from child process 3382.
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
Detaching after fork from child process 3383.
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
Detaching after fork from child process 3384.
[ 51 of 202] Compiling GHC.Fingerprint[boot] ( GHC/Fingerprint.hs-boot, dist/build/GHC/Fingerprint.js_p_o-boot )
Detaching after fork from child process 3385.
[ 55 of 202] Compiling GHC.IO.Exception[boot] ( GHC/IO/Exception.hs-boot, dist/build/GHC/IO/Exception.js_p_o-boot )
Detaching after fork from child process 3386.
[ 75 of 202] Compiling Foreign.C.Types  ( Foreign/C/Types.hs, dist/build/Foreign/C/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x000000000425d5c4 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x000000000425f776 in scavenge_mutable_list1 (bd=0x7fffe5c02a00, gen=0x4d1fd48) at rts/sm/Scav.c:1400
#2  0x000000000425fa13 in scavenge_capability_mut_Lists1 (cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x0000000004256b66 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2,
    cap=0x4cfe5c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x00000000042454a3 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d32b60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x0000000004243de4 in schedule (initialCapability=0x4cfe5c0 &lt;MainCapability&gt;, task=0x4d32b60)
    at rts/Schedule.c:553
#6  0x0000000004246436 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x000000000423e9b4 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x477f850, ret=0x0) at rts/RtsAPI.c:500
#8  0x0000000004241666 in real_main () at rts/RtsMain.c:63
#9  0x0000000004241759 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x477f850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Thanks to Luite Stegeman for helping me with debugging. We could reproduce this error on 64bit Linux and 64bit OS X. I don’t know how to track down this bug but it just made making progress in my project impossible.</p>
<hr />
<p>EDIT: I just found a workaround: run GHCJS with <code>+RTS -G1</code>. I was reading code of functions in the backtrace and I realized some RTS parameters are used. By playing with them changing randomly, I found this. Some details about this parameter is explained in <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC">GHC Trac GC section</a>(see “generational gc” parts). Unfortunately with this RTS parameter GHCJS runs at least 100x slower(at least in debug build) so even though I can boot GHCJS with my changes it’s not very usable since I sometimes boot it 10 times a day in this stage of the development.</p>
<hr />
<p>EDIT 2: My workaround did not work great – now compilation is failing in some other stage:</p>
<pre><code>Failed to install base-4.7.0.0
Last 10 lines of the build log ( /home/omer/.cabal/logs/base-4.7.0.0.log ):
[  4 of 202] Compiling Unsafe.Coerce    ( Unsafe/Coerce.hs, dist/build/Unsafe/Coerce.js_p_o )
[  5 of 202] Compiling GHC.Unicode[boot] ( GHC/Unicode.hs-boot, dist/build/GHC/Unicode.js_p_o-boot )
[  6 of 202] Compiling GHC.IO[boot]     ( GHC/IO.hs-boot, dist/build/GHC/IO.js_p_o-boot )
[  7 of 202] Compiling GHC.Exception[boot] ( GHC/Exception.lhs-boot, dist/build/GHC/Exception.js_p_o-boot )
[  8 of 202] Compiling GHC.Err          ( GHC/Err.lhs, dist/build/GHC/Err.js_p_o )
[  9 of 202] Compiling GHC.Base         ( GHC/Base.lhs, dist/build/GHC/Base.js_p_o )
[ 10 of 202] Compiling Data.Maybe       ( Data/Maybe.hs, dist/build/Data/Maybe.js_p_o )
[ 11 of 202] Compiling GHC.List         ( GHC/List.lhs, dist/build/GHC/List.js_p_o )
[ 12 of 202] Compiling GHC.Num          ( GHC/Num.lhs, dist/build/GHC/Num.js_p_o )
[ 13 of 202] Compiling GHC.Show         ( GHC/Show.lhs, dist/build/GHC/Show.js_p_o )
cabal: Error: some packages failed to install:
base-4.7.0.0 failed during the building phase. The exception was:
ExitFailure (-11)</code></pre>
<p>However, when I tried to run the command that led to this segfault in gdb to see if it gives a different backtrace, it worked fine and no segfaults happened.</p>
<hr />
<p>EDIT 3: There has been some changes in GHCJS codegen and I wanted to try to reproduce this bug using that new codegen, hoping that it may be a workaround for the segfault(I rebased my patches for new version). It’s still happening, but now in different file:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )

Program received signal SIGSEGV, Segmentation fault.
0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
258     includes/rts/storage/ClosureMacros.h: No such file or directory.
(gdb) bt
#0  0x0000000004254434 in LOOKS_LIKE_CLOSURE_PTR (p=0x0) at includes/rts/storage/ClosureMacros.h:258
#1  0x00000000042565e6 in scavenge_mutable_list1 (bd=0x7fffe5800c40, gen=0x4d17d48) at rts/sm/Scav.c:1400
#2  0x0000000004256883 in scavenge_capability_mut_Lists1 (cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#3  0x000000000424d9d6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf6340 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#4  0x000000000423c313 in scheduleDoGC (pcap=0x7fffffffc198, task=0x4d2ab60, force_major=rtsFalse)
    at rts/Schedule.c:1650
#5  0x000000000423ac54 in schedule (initialCapability=0x4cf6340 &lt;MainCapability&gt;, task=0x4d2ab60)
    at rts/Schedule.c:553
#6  0x000000000423d2a6 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2c0) at rts/Schedule.c:2346
#7  0x0000000004235824 in rts_evalLazyIO (cap=0x7fffffffc2c0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#8  0x00000000042384d6 in real_main () at rts/RtsMain.c:63
#9  0x00000000042385c9 in hs_main (argc=237, argv=0x7fffffffc448, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#10 0x0000000000408ea7 in main ()</code></pre>
<p>Backtrace is same. I think it’s interesting that this problem is happening while compiling <code>Types</code> modules in 2/3 of the cases(<code>Foreign.C.Types</code> and <code>System.Posix.Types</code>). As far as I can see this two modules are using <code>INTEGRAL_TYPE</code> extensively, which creates a newtype and implements <code>Read</code> and <code>Show</code> instances. Other problematic module, <code>GHC.Show</code> also implements same instances, but does that manually instead of calling <code>INTEGRAL_TYPE</code>. I wonder if it could be related with that.</p>
<hr />
<p>EDIT 4: When I run GHCJS using <code>--no-native</code>, it failed with an assertion error rather than a segfault:</p>
<pre><code>[112 of 202] Compiling System.Posix.Types ( System/Posix/Types.hs, dist/build/System/Posix/Types.js_p_o )
ghcjs: internal error: ASSERTION FAILED: file rts/sm/Scav.c, line 1400

    (GHC version 7.8.2 for x86_64_unknown_linux)
    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug

Program received signal SIGABRT, Aborted.
0x00007ffff687f849 in raise () from /lib64/libc.so.6
(gdb) bt
#0  0x00007ffff687f849 in raise () from /lib64/libc.so.6
#1  0x00007ffff6880cd8 in abort () from /lib64/libc.so.6
#2  0x0000000004238a27 in rtsFatalInternalErrorFn (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;, 
    ap=0x7fffffffbe58) at rts/RtsMessages.c:170
#3  0x000000000423865f in barf (s=0x4554e60 &quot;ASSERTION FAILED: file %s, line %u\n&quot;) at rts/RtsMessages.c:42
#4  0x00000000042386c2 in _assertFail (filename=0x4559fbd &quot;rts/sm/Scav.c&quot;, linenum=1400) at rts/RtsMessages.c:57
#5  0x00000000042565e9 in scavenge_mutable_list1 (bd=0x7fffe7402dc0, gen=0x4d15d88) at rts/sm/Scav.c:1400
#6  0x0000000004256873 in scavenge_capability_mut_Lists1 (cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/Scav.c:1493
#7  0x000000000424d9c6 in GarbageCollect (collect_gen=0, do_heap_census=rtsFalse, gc_type=2, 
    cap=0x4cf49c0 &lt;MainCapability&gt;) at rts/sm/GC.c:342
#8  0x000000000423c303 in scheduleDoGC (pcap=0x7fffffffc188, task=0x4d28ba0, force_major=rtsFalse)
    at rts/Schedule.c:1650
#9  0x000000000423ac44 in schedule (initialCapability=0x4cf49c0 &lt;MainCapability&gt;, task=0x4d28ba0)
    at rts/Schedule.c:553
#10 0x000000000423d296 in scheduleWaitThread (tso=0x7ffff6708d60, ret=0x0, pcap=0x7fffffffc2b0) at rts/Schedule.c:2346
#11 0x0000000004235814 in rts_evalLazyIO (cap=0x7fffffffc2b0, p=0x4776850, ret=0x0) at rts/RtsAPI.c:500
#12 0x00000000042384c6 in real_main () at rts/RtsMain.c:63
#13 0x00000000042385b9 in hs_main (argc=238, argv=0x7fffffffc438, main_closure=0x4776850, rts_config=...)
    at rts/RtsMain.c:114
#14 0x0000000000408ea7 in main ()</code></pre>
<p>Not passing <code>--not-native</code> is resulting with a segfault and same backtrace as before.</p>]]></summary>
</entry>

</feed>
