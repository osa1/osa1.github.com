<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>osa1 - Common Lisp için Clojure usulü multimethodlar</title>
        <link href="http://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" type="text/css">
        <link href="http://fonts.googleapis.com/css?family=Monda" rel="stylesheet" type="text/css">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="alternate" type="application/rss+xml" title="osa1.net blog" href="../rss.xml" />
    </head>
    <body>
        <div id="column">
            <div id="header-inner">
                <span id="blog-title"><a href="../">osa1</a></span>
            </div>
            <div class="inner">
                <h1 id="post-title">Common Lisp için Clojure usulü multimethodlar</h1>

<p><strong>January  8, 2012</strong> - Tagged as: <a href="../tags/lisp.html">lisp</a>, <a href="../tags/tr.html">tr</a>.</p>

<p>Bir önceki yazımda biraz bahsetmiştim Clojure ve Common Lisp multimethodları arasındaki farklardan. Bugün Common Lisp için olabilecek en basit Clojure usulü multimethod implementasyonu yaptım. 2 macro ve toplamda 14 satır sürdü. Örnek olarak Joy of Clojure kitabındaki bir kod parçasını Common Lisp ile yazacağım. Clojure hali şöyle:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defmulti</span><span class="fu"> compiler </span><span class="kw">:os</span>)
(<span class="kw">defmethod</span><span class="fu"> compiler </span><span class="kw">::unix</span> [m] (<span class="kw">get</span> m <span class="kw">:c-compiler</span>))
(<span class="kw">defmethod</span><span class="fu"> compiler </span><span class="kw">::osx</span>  [m] (<span class="kw">get</span> m <span class="kw">:c-compiler</span>))</code></pre>
<p>Burda yapılan şey şu, <code>compiler</code> adlı bir multimethod oluşturuluyor ve dispatch fonksiyonunu seçmek için kullanılacak fonksiyon olarak <code>:os</code> keywordu olarak belirleniyor<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Daha sonra iki tane method tanımlanıyor, ilkinde test fonksiyonumuz(yani <code>:os</code> fonksiyonu) <code>:unix</code> keywordünü dönerse çalıştırılacak fonksiyon, ikincisinde de <code>:osx</code> keywordünü dönerse çalıştırılacak fonksiyonu belirleniyor. Test fonksiyonuna da <code>m</code> parametresinin aktarıldığına dikkat. Yani <code>m</code> önce test fonksiyonu tarafından kullanılıyor, sonra da dönüş değerine göre dispatch fonksiyonlarından biri tarafından.</p>
<p>Kullanımı şöyle:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> unix </span>{<span class="kw">:os</span> <span class="kw">::unix</span>, <span class="kw">:c-compiler</span> <span class="st">&quot;cc&quot;</span>})
(<span class="kw">def</span><span class="fu"> osx  </span>{<span class="kw">:os</span> <span class="kw">::osx</span>,  <span class="kw">:c-compiler</span> <span class="st">&quot;gcc&quot;</span>})
(compiler unix)
=&gt; <span class="st">&quot;cc&quot;</span>
(compiler osx)
=&gt; <span class="st">&quot;gcc&quot;</span></code></pre>
<p>multimethodların test fonksiyonunu ve bunun dönüş değerlerine karşılık gelen dispatch fonksiyonlarını tutmaları lazım. dönüş değeri-dispatch fonksiyonu ikililerini bir hash-table’da tuttum. Her bir multimethod için 2 tane closure oluşturdum, bir tanesi yeni methodlar eklemek istediğimizde çağırılık dönüş değeri-dispatch fonksiyonları ikililerini tutan hash-table’ı güncelleyecek, diğeri de testi yapıp hash-table’dan fonksiyonu çekip çağıracak.</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defmacro</span><span class="fu"> defmulti </span>(name (&amp;<span class="kw">rest</span> args) dispatch-fn)
  (<span class="kw">let</span> ((dispatch-table (<span class="kw">gensym</span>)))
    `(<span class="kw">let</span> ((,dispatch-table (<span class="kw">make-hash-table</span> <span class="kw">:test</span> #'equal)))
       (<span class="kw">defun</span><span class="fu"> </span>,name (,@args)
         (<span class="kw">funcall</span> (<span class="kw">gethash</span> (<span class="kw">funcall</span> ,dispatch-fn ,@args) ,dispatch-table)
                  ,@args))
       (<span class="kw">defun</span><span class="fu"> </span>,(<span class="kw">intern</span> (<span class="kw">concatenate</span> 'string (<span class="kw">string</span> name) <span class="st">&quot;-ADD-METHOD&quot;</span>))
           (dispatch-fn-return-val <span class="kw">method</span>)
         (<span class="kw">setf</span> (<span class="kw">gethash</span> dispatch-fn-return-val ,dispatch-table) <span class="kw">method</span>)))))</code></pre>
<p>Görüldüğü gibi multimethodlar aslında normal fonksiyonlar(aslında closure, <code>dispatch-table</code>ı tutuyor). Bu sayede herhangi bir fonksiyona aktarılabilirler. Özel bir yapı yok yani ortada. Bir de aslında çaktırmadan tanımladığımız multimethod’a <code>-add-method</code> eki getirerek bir fonksiyon daha oluşturuyoyruz. Bunu kullanıcının çağırmasına hiç gerek yok, sadece yeni method ekleme işlemini kolaylaştırmak için.</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defmacro</span><span class="fu"> defmulmethod </span>(name dispatch-fn-return-val <span class="kw">method</span>)
  `(,(<span class="kw">intern</span> (<span class="kw">concatenate</span> 'string (<span class="kw">string</span> name) <span class="st">&quot;-ADD-METHOD&quot;</span>))
    ,dispatch-fn-return-val
    ,<span class="kw">method</span>))</code></pre>
<p><code>defmethod</code> adı Common Lisp’e ait olduğundan adını <code>defmulmethod</code> yaptım. Önceki macroda oluşturulan <code>-add-method</code> fonksiyonu yardımıyla <code>dispatch-table</code>a yeni fonksiyonu ekliyor. Bundan sonra aynı örneği Common Lisp ile şöyle yapabiliriz.</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(defmulti compiler (x) (<span class="kw">lambda</span> (x) (<span class="kw">gethash</span> :os x)))
(defmulmethod compiler :unix (<span class="kw">lambda</span> (x) (<span class="kw">gethash</span> :c-compiler x)))
(defmulmethod compiler :osx (<span class="kw">lambda</span> (x) (<span class="kw">gethash</span> :c-compiler x)))

(<span class="kw">setf</span> unix (<span class="kw">make-hash-table</span>))
(<span class="kw">setf</span> (<span class="kw">gethash</span> :os unix) :unix)
(<span class="kw">setf</span> (<span class="kw">gethash</span> :c-compiler unix) :cc)


(<span class="kw">setf</span> osx (<span class="kw">make-hash-table</span>))
(<span class="kw">setf</span> (<span class="kw">gethash</span> :os osx) :osx)
(<span class="kw">setf</span> (<span class="kw">gethash</span> :c-compiler osx) :gcc)</code></pre>
<pre><code>CL-USER&gt; (compiler unix)
:CC

CL-USER&gt; (compiler osx)
:GCC</code></pre>
<p>Common Lisp halinin çok daha uzun olmasının birkaç sebebi var: Birincisi, Common Lisp hash-tablelarının başlangıç değerlerini belirlemenin bir yolu yok. hash-table’ların özel bir syntax’ı da yok. <code>make-hash-table</code> ile oluşturup teker teker elemanları koymamız gerekiyor. İkincisi, <sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> notta yazdığım şey.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Clojure hakkında sevdiğim bir özellik, keywordler aynı zamanda fonksiyon, çağırıldıklarında parametre olarak bir map alıyorlar ve anahtar görevi görerek değeri dönüyorlar.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Clojure hakkında sevdiğim bir özellik, keywordler aynı zamanda fonksiyon, çağırıldıklarında parametre olarak bir map alıyorlar ve anahtar görevi görerek değeri dönüyorlar.<a href="#fnref2">↩</a></p></li>
</ol>
</div>

<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'osa1'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

            </div>
        </div>
    </body>
</html>
