<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>osa1 - Ramblings on monads</title>
        <link rel="icon" href="data:,">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="alternate" type="application/rss+xml" title="osa1.net blog" href="../rss.xml" />
    </head>
    <body>
        <div id="column">
            <div id="header-inner">
                <span id="blog-title"><a href="../">osa1</a></span>
                <span class="menu-item"><a href="https://github.com/osa1">github</a></span>
                <span class="menu-item"><a href="https://gitlab.haskell.org/osa1">gitlab</a></span>
                <span class="menu-item"><a href="../rss.xml">rss</a></span>
            </div>
            <div class="inner">
                <h1 id="post-title">Ramblings on monads</h1>

<p><strong>April  9, 2012</strong> - Tagged as: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/en.html">en</a>.</p>

<p>I had written a short post about Haskell and monads to <a href="http://nathansuniversity.com/">Nathan’s University</a> forum as a first homework, and I wanted to add it to my blog too:</p>
<hr />
<p>I know lots of people here have already given Haskell as an example, but I want to mention to a different point of Haskell. Monads and DSL capabilities.</p>
<p>Every monad in Haskell is potentially a DSL. You can define commands(ie. functions) in a syntax that looks almost like syntax in imperative languages even if you’re doing a purely functional computation(for imperative computations, see IO monad). When you write a monad and some functions working with this monad, you basically write operations of a kind of computations, and a way to combine this computations(with <code>&gt;&gt;=</code> function, read as bind).</p>
<p>This gives you two great advantages. First, monads give you an elegant way to separate combination and calculation logic, and second, it gives you an opportunity to create syntactic abstractions.</p>
<p>For example, you don’t have to pass some states around functions thank to monads. You can just create a monad with functions getting a state and returning some values and the new state. Then you can define your combination logic(bind functions) and with the help of <code>do</code> notation, you can write almost imperative looking code, passing states automatically. See example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Control.Monad.State</span>
<span class="kw">import</span> <span class="dt">Control.Monad</span>
<span class="kw">type</span> <span class="dt">AvgState</span> <span class="fu">=</span> <span class="dt">State</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Int</span>
state0 <span class="fu">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)
 
<span class="ot">addAvg ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AvgState</span>
addAvg x <span class="fu">=</span> <span class="kw">do</span>
    (count, total) <span class="ot">&lt;-</span> get
    put (count<span class="fu">+</span><span class="dv">1</span>, total<span class="fu">+</span>x)
    <span class="fu">return</span> <span class="fu">$</span> (total<span class="fu">+</span>x) <span class="ot">`div`</span> (count<span class="fu">+</span><span class="dv">1</span>)
 
<span class="ot">test ::</span> <span class="dt">AvgState</span>
test <span class="fu">=</span> <span class="kw">do</span>
    addAvg <span class="dv">10</span>
    addAvg <span class="dv">20</span>
    addAvg <span class="dv">30</span>
 
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">print</span> <span class="fu">$</span> evalState test state0</code></pre></div>
<p>Here I’m calculating arithmetic average of some integers. <code>type AvgState</code> is my data type representing the sum of the numbers I give and the total count of numbers. Here I don’t write a new monad, instead I use Haskell’s State monad, contained in <code>Control.Monad.State</code> package.</p>
<p><code>addAvg</code> functions is the main logic. If you look at it, it almost looks like an imperative program, I’m reading some values and changing them by adding them one, and returning a new value(note that I’m not returning any new states, it’s being handled my the monad itself), but still it’s purely functional.</p>
<p>Now how’s that a DSL? Look at <code>test</code> function and hopefully you’ll see :) .</p>
<p>I want to give another example about DSL-like monads: <code>Parsec</code>.</p>
<p>I’ve been working on a Websocket based chat protocol written in Haskell lately and this code is directly from my project:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chanName ::</span> <span class="dt">Parser</span> <span class="dt">ChanName</span>
chanName <span class="fu">=</span> many1 (letter <span class="fu">&lt;|&gt;</span> oneOf <span class="st">&quot;-&quot;</span> <span class="fu">&lt;|&gt;</span> digit)
 
<span class="ot">msgCmd ::</span> <span class="dt">Parser</span> <span class="dt">Cmd</span>
msgCmd <span class="fu">=</span> <span class="kw">do</span>
    string <span class="st">&quot;msg&quot;</span>
    spaces
    chan <span class="ot">&lt;-</span> chanName
    spaces
    msg <span class="ot">&lt;-</span> many1 anyChar
    eof
    <span class="fu">return</span> <span class="fu">$</span> <span class="dt">MsgCmd</span> chan msg</code></pre></div>
<p>I’m using Parsec’s <code>Parser</code> monads with <code>do</code> notation and it looks almost like Backus–Naur Form. chanName mathes list of letters, ‘-’ character, or digits with at least one element. This is a parser. And then I’m using this parser in my <code>msgCmd</code> parser. It matches a string “msg”, then arbitrary number of spaces, then <code>chanName</code>, then spaces again, and at last any characters.</p>

<hr />

<div id="disqus_thread">
    <a href="#" onclick="loadDisqus(); return false;">
        (Show comments)
    </a>
</div>

<script>
    function loadDisqus() {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = 'https://osa1.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] ||
            document.getElementsByTagName('body')[0]).appendChild(dsq);
    };
</script>

            </div>
        </div>
    </body>
</html>
