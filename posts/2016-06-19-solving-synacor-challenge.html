<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>osa1 - How I solved the Synacor Challenge</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="alternate" type="application/rss+xml" title="osa1.net blog" href="../rss.xml" />
    </head>
    <body>
        <div id="column">
            <div id="header-inner">
                <span id="blog-title"><a href="../">osa1</a></span>
                <span id="feed"><a href="../rss.xml">feed</a></span>
            </div>
            <div class="inner">
                <h1 id="post-title">How I solved the Synacor Challenge</h1>

<p><strong>June 19, 2016</strong> - Tagged as: <a href="../tags/en.html">en</a>, <a href="../tags/rust.html">rust</a>.</p>

<p>It took 4 attempts at various coffee shops in Cambridge/UK (where I’m spending this summer – more on this later) but I finally solved the <a href="https://challenge.synacor.com/">Synacor Challenge</a>. Here’s how I did it.</p>
<p>WARNING: This post spoils everything! Do not read further if you’re interested in solving it yourself. It’s a lot of fun, so I highly recommend that.</p>
<h2 id="first-attempt">First attempt</h2>
<p>Initial VM implementation took about an hour. It worked well until I was eaten by a grue. At that point I realized that I need a save/load system.</p>
<p>The game looks like a classic text-based adventure where you interact by typing commands. So I thought saving the commands should be enough for “save game”. To load, VM would just load the input from the save file to its input buffer (which is used when <code>in</code> instruction is executed). Indeed it works nicely.</p>
<p>The game is very easy until you make it to the “office”. IIRC, you collect 6 out of 8 codes until that point. At the office you learn about the teleporter, which is the first real challenge in the game…</p>
<h2 id="second-attempt">Second attempt</h2>
<p>At this point I implemented about 20 debugger commands, for things like stepping, breaking at an instruction, breaking at an address, breaking on a specific register read, setting the instruction pointer etc. Just by using these commands I was able to teleport to the right place. However, the code I found there did not really work. It turns out the code is generated dynamically, based on the value in R8. Which is kind of expected, otherwise we could find all the codes just by looking at strings in the binary.</p>
<p>So at this point I realize I need a disassembler…</p>
<h2 id="third-attempt">Third attempt</h2>
<p>The disassembler was trivial to implement. I implement it as a part of VM because 1) in theory the program can generate code in runtime (although I don’t think this is the case in practice) 2) code and data is in the same address space and instruction boundaries are not clearly known. I guess I could do something like: Start with address 0, at each jump disassemble the jump target etc. but I’m not sure if that works as some jump targets are generated dynamically.</p>
<p>Anyway, the debugger has a disassembler now, and I start disassembling functions.</p>
<p>When I step instruction by instruction after using the teleporter, I see that it’s checking R8, if it’s not 0, then calling a function which is the “confimation process” that’s supposed to take 1 billion years. The function has very complex control flow so I try to avoid actually debugging it.</p>
<p>I look at the code that this function returns to. It’s checking if R1 (which has the return value) is 6. So I think, why not just set R1 6 and return from the function? Indeed, it works, but not really how I expected. I already knew that the code I’m searching is generated dynamically, but it’s actually generated using R8, and only when R1 is 6. So as it turns out, I need to guess a value of R8 that makes the validation function return 6. Just making the function return 6 doesn’t really work.</p>
<p>However, I said “it kinda worked”. Because the teleporter actually teleports me to the right place. It’s just that the generated code is not valid.</p>
<h2 id="fourth-attempt">Fourth attempt</h2>
<p>Before disassembling the verification function, I decide to solve the rest of the challenge. I realize that we’re now in a maze, 4x4. Each tile in the maze has either a number, or an operation (<code>+</code>, <code>-</code>, <code>*</code>). There’s an orb in the south-west corner, and there’s a door in the north-east corner. “30” is written on the door, and “22” is printed on the Orb. It’s easy to see what’s going on. Two things to realize are that every time we return to the first tile things get reset, and the goal tile can be visited only once (the orb disappears on visit).</p>
<p>I implement a program that does breadth-first search on this state space, see <code>maze.rs</code>. It then prints directions. When we follow those directions we find the final code and the challenge is completed.</p>
<p>However, since I by-passed the previous challenge, I need to solve that now.</p>
<p>This is the most fun part, it involves lots of debugging, and some programming. Here’s the disassembly of the verification function:</p>
<pre><code>                                         -- fn(reg0 = 4, reg1 = 1, reg7 = our value) {
[6027] Jt [Reg(0), Num(6035)]            --   if reg0 == 0 {
[6030] Add [Reg(0), Reg(1), Num(1)]      --     reg0 = reg1 + 1;
[6034] Ret []                            --     return; }
[6035] Jt [Reg(1), Num(6048)]            --   if reg1 == 0 {
[6038] Add [Reg(0), Reg(0), Num(32767)]  --     reg0 -= 1;
[6042] Set [Reg(1), Reg(7)]              --     reg1 = reg7;
[6045] Call [Num(6027)] ------ loop      --     fn();
[6047] Ret []                            --     return; }
[6048] Push [Reg(0)]                     --   push(reg0);
[6050] Add [Reg(1), Reg(1), Num(32767)]  --   reg1 -= 1;
[6054] Call [Num(6027)] ------ loop      --   fn();
[6056] Set [Reg(1), Reg(0)]              --   reg1 = reg0;
[6059] Pop [Reg(0)]                      --   reg0 = pop();
[6061] Add [Reg(0), Reg(0), Num(32767)]  --   reg0 -= 1;
[6065] Call [Num(6027)] ------ loop      --   fn();
[6067] Ret [] -- end of function at 6027 --   return;
                                         -- }</code></pre>
<p>I added next to each instruction how they would look like in a C-like language. It’s hard to understand what’s going on. So to experiment with it I implement it in Rust. Since registers are shared in each call, I use shared state in my initial implementation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>inline<span class="at">]</span>
<span class="kw">fn</span> add(i1 : <span class="dt">u16</span>, i2 : <span class="dt">u16</span>) -&gt; <span class="dt">u16</span> <span class="op">{</span>
    (i1 + i2) % <span class="dv">32768</span>
<span class="op">}</span>

<span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
<span class="kw">struct</span> FnState <span class="op">{</span>
    reg0  : <span class="dt">u16</span>,
    reg1  : <span class="dt">u16</span>,
    reg7  : <span class="dt">u16</span>,
    stack : <span class="dt">Vec</span>&lt;<span class="dt">u16</span>&gt;,
<span class="op">}</span>

<span class="kw">impl</span> FnState <span class="op">{</span>
    <span class="kw">fn</span> init(reg0 : <span class="dt">u16</span>, reg1 : <span class="dt">u16</span>, reg7 : <span class="dt">u16</span>) -&gt; FnState <span class="op">{</span>
        FnState <span class="op">{</span>
            reg0: reg0,
            reg1: reg1,
            reg7: reg7,
            stack: <span class="dt">Vec</span>::new(),
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">fn</span> f(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span>
        <span class="kw">if</span> <span class="kw">self</span>.reg0 == <span class="dv">0</span> <span class="op">{</span>
            <span class="kw">self</span>.reg0 = add(<span class="kw">self</span>.reg1, <span class="dv">1</span>);
            <span class="kw">return</span>;
        <span class="op">}</span>
        <span class="kw">if</span> <span class="kw">self</span>.reg1 == <span class="dv">0</span> <span class="op">{</span>
            <span class="co">// self.reg0 = add(self.reg0, 32767);</span>
            <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;
            <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg7;
            <span class="kw">self</span>.f();
            <span class="kw">return</span>;
        <span class="op">}</span>
        <span class="kw">self</span>.stack.push(<span class="kw">self</span>.reg0);
        <span class="co">// self.reg1 = add(self.reg1, 32767);</span>
        <span class="kw">self</span>.reg1 -= <span class="dv">1</span>;
        <span class="kw">self</span>.f();
        <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg0;
        <span class="kw">self</span>.reg0 = <span class="kw">self</span>.stack.pop().unwrap();
        <span class="co">// self.reg0 = add(self.reg0, 32767);</span>
        <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;
        <span class="kw">self</span>.f();
        <span class="kw">return</span>;
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Now, this function grows really fast. Even for very small inputs it takes minutes to compute. I try to think some well-known functions that grow very fast. Ackermann comes to my mind and I check the Wiki page. Indeed, this looks quite similar, but the third argument makes it different than Ackermann. In any case, it doesn’t really matter for the solution.</p>
<p>So the problem is coming up with a <code>reg7</code> in this code so that <code>f(4, 1, reg7)</code> returns <code>6</code>. For that I need to implement a search but this is basically impossible with this slow function. I start simplifying the function a little bit. My first attempt:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> FnState <span class="op">{</span>
    <span class="kw">fn</span> f(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span>
        <span class="co">// When reg0 hits zero, restart it from reg1 + 1</span>
        <span class="kw">if</span> <span class="kw">self</span>.reg0 == <span class="dv">0</span> <span class="op">{</span>
            <span class="kw">self</span>.reg0 = add(<span class="kw">self</span>.reg1, <span class="dv">1</span>);
            <span class="kw">return</span>;
        <span class="op">}</span>

        <span class="co">// When reg1 hits zero, decrement reg0, restart reg1 from reg7</span>
        <span class="kw">if</span> <span class="kw">self</span>.reg1 == <span class="dv">0</span> <span class="op">{</span>
            <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;
            <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg7;
            <span class="kw">self</span>.f();
            <span class="kw">return</span>;
        <span class="op">}</span>

        <span class="kw">let</span> save_reg0 = <span class="kw">self</span>.reg0;

        <span class="kw">self</span>.reg1 -= <span class="dv">1</span>;
        <span class="kw">self</span>.f();
        <span class="kw">self</span>.reg1 = <span class="kw">self</span>.reg0;

        <span class="kw">self</span>.reg0 = save_reg0;
        <span class="kw">self</span>.reg0 -= <span class="dv">1</span>;

        <span class="kw">self</span>.f();
        <span class="kw">return</span>;
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>This version doesn’t use an explicit stack, instead uses a temporary in the call frame. This works because in the original version each push corresponds to a pop done in the same call frame.</p>
<p>It’s still too complicated. I keep simplifying.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> f(<span class="kw">mut</span> reg0 : <span class="dt">u16</span>, <span class="kw">mut</span> reg1 : <span class="dt">u16</span>, <span class="kw">mut</span> reg7 : <span class="dt">u16</span>) -&gt; (<span class="dt">u16</span>, <span class="dt">u16</span>) <span class="op">{</span>
    <span class="kw">if</span> reg0 == <span class="dv">0</span> <span class="op">{</span>
        reg0 = add(reg1, <span class="dv">1</span>);
        <span class="kw">return</span> (reg0, reg1);
    <span class="op">}</span>

    <span class="kw">if</span> reg1 == <span class="dv">0</span> <span class="op">{</span>
        reg0 -= <span class="dv">1</span>;
        reg1 = reg7;
        <span class="kw">return</span> f(reg0, reg1, reg7);
    <span class="op">}</span>

    <span class="kw">let</span> save_reg0 = reg0;
    reg1 -= <span class="dv">1</span>;

    <span class="kw">let</span> (reg0_, reg1_) = f(reg0, reg1, reg7);
    reg0 = reg0_;
    reg1 = reg1_;

    reg1 = reg0;

    reg0 = save_reg0;
    reg0 -= <span class="dv">1</span>;

    <span class="kw">return</span> f(reg0, reg1, reg7);
<span class="op">}</span></code></pre></div>
<p>This version doesn’t have any shared mutable state. At this point I realize that it may be possible to remove internal mutable state too:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> f(reg0 : <span class="dt">u16</span>, reg1 : <span class="dt">u16</span>, reg7 : <span class="dt">u16</span>) -&gt; (<span class="dt">u16</span>, <span class="dt">u16</span>) <span class="op">{</span>
    <span class="kw">if</span> reg0 == <span class="dv">0</span> <span class="op">{</span>
        <span class="kw">return</span> (add(reg1, <span class="dv">1</span>), reg1);
    <span class="op">}</span>

    <span class="kw">if</span> reg1 == <span class="dv">0</span> <span class="op">{</span>
        <span class="kw">return</span> f(reg0 - <span class="dv">1</span>, reg7, reg7);
    <span class="op">}</span>

    <span class="kw">let</span> (reg1, _) = f(reg0, reg1 - <span class="dv">1</span>, reg7);

    <span class="kw">return</span> f(reg0 - <span class="dv">1</span>, reg1, reg7);
<span class="op">}</span></code></pre></div>
<p>Now, this is a function I can read and understand. One advantage of this version is that this could be easily memoized:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> f_memo(reg0 : <span class="dt">u16</span>, reg1 : <span class="dt">u16</span>, reg7 : <span class="dt">u16</span>, memo : &amp;<span class="kw">mut</span> HashMap&lt;(<span class="dt">u16</span>, <span class="dt">u16</span>), (<span class="dt">u16</span>, <span class="dt">u16</span>)&gt;) -&gt; (<span class="dt">u16</span>, <span class="dt">u16</span>) <span class="op">{</span>
    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(ret) = memo.get(&amp;(reg0, reg1)) <span class="op">{</span>
        <span class="kw">return</span> *ret;
    <span class="op">}</span>

    <span class="kw">if</span> reg0 == <span class="dv">0</span> <span class="op">{</span>
        <span class="kw">let</span> ret = (add(reg1, <span class="dv">1</span>), reg1);
        memo.insert((reg0, reg1), ret);
        <span class="kw">return</span> ret;
    <span class="op">}</span>

    <span class="kw">if</span> reg1 == <span class="dv">0</span> <span class="op">{</span>
        <span class="kw">let</span> ret = f_memo(reg0 - <span class="dv">1</span>, reg7, reg7, memo);
        memo.insert((reg0, reg1), ret);
        <span class="kw">return</span> ret;
    <span class="op">}</span>

    <span class="co">// careful there</span>
    <span class="kw">let</span> (reg1_new, _) = f_memo(reg0, reg1 - <span class="dv">1</span>, reg7, memo);

    <span class="kw">let</span> ret = f_memo(reg0 - <span class="dv">1</span>, reg1_new, reg7, memo);
    memo.insert((reg0, reg1), ret);
    <span class="kw">return</span> ret;
<span class="op">}</span></code></pre></div>
<p>This version is super fast when compared to the original version. I feel like I can just search the whole space in a few hours. I start the search and as it searches through the search space I start wondering about how to further improve it. I think, why not split search space into pieces and search in parallel?</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> search(start_range : <span class="dt">u16</span>, end_range : <span class="dt">u16</span>) -&gt; <span class="dt">Option</span>&lt;<span class="dt">u16</span>&gt; <span class="op">{</span>
    <span class="kw">for</span> i <span class="kw">in</span> start_range .. end_range <span class="op">{</span>
        <span class="co">// println!(&quot;i = {}&quot;, i);</span>
        <span class="kw">let</span> <span class="kw">mut</span> tbl = HashMap::new();
        <span class="kw">let</span> ret = f_memo(<span class="dv">4</span>, <span class="dv">1</span>, i, &amp;<span class="kw">mut</span> tbl);
        <span class="kw">if</span> ret.<span class="dv">0</span> == <span class="dv">6</span> <span class="op">{</span>
            <span class="pp">println!</span>(<span class="st">&quot;Found an answer: {:?} {}&quot;</span>, ret, i);
            <span class="kw">return</span> <span class="cn">Some</span>(i);
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="cn">None</span>
<span class="op">}</span>

<span class="kw">fn</span> search_in_parallel(n : <span class="dt">i32</span>) <span class="op">{</span>
    <span class="kw">let</span> increment = <span class="dt">u16</span>::MAX / (n <span class="kw">as</span> <span class="dt">u16</span>);
    <span class="kw">let</span> <span class="kw">mut</span> threads = <span class="dt">Vec</span>::with_capacity(n <span class="kw">as</span> <span class="dt">usize</span>);

    <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0</span> .. n <span class="op">{</span>
        <span class="kw">let</span> range_start = increment * (i <span class="kw">as</span> <span class="dt">u16</span>);
        <span class="kw">let</span> range_end   = increment * ((i <span class="kw">as</span> <span class="dt">u16</span>) + <span class="dv">1</span>) + <span class="dv">1</span>;
        threads.push(thread::Builder::new().stack_size(<span class="dv">1000000000</span>).spawn(<span class="kw">move</span> || <span class="op">{</span>
            search(range_start, range_end)
        <span class="op">}</span>).unwrap());
    <span class="op">}</span>

    <span class="kw">for</span> thread <span class="kw">in</span> threads <span class="op">{</span>
        thread.join();
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">fn</span> main() <span class="op">{</span>
    search_in_parallel(<span class="dv">8</span>);
<span class="op">}</span></code></pre></div>
<p>This parallel search takes a couple of seconds until it prints:</p>
<pre><code>Found an answer: (6, 5) 25734</code></pre>
<p>So <code>25734</code> returns 6! This is the R8 value we were looking for.</p>
<p>I modify my VM to return when this function is called (I know it lives in address <code>6027</code> so I just check instruction pointer in the main loop) and drop to debugger prompt. In the debugger, I set R1 (return value register) 6, and set R8 25734, and continue running the program.</p>
<p>It works perfectly, with a working code printed to the screen!</p>
<h2 id="code-and-conclusion">Code and conclusion</h2>
<p>Overall I enjoyed this a lot. My favorite part was definitely debugging the verification function. I don’t really enjoy text adventures but that’s really a very small part of the challenge, so it wasn’t a big deal.</p>
<p><a href="https://github.com/osa1/synacor-challenge">My code is on Github</a>. I didn’t organize the code at all, so you can see my inline notes, logs, and commented out code with their improved/changed versions, and have a feeling of how I developed my solutions. In the repo you’ll also see the original binary and challenge spec. I pushed those in case the original challenge page disappears in the future.</p>
<p>The Rust compiler I used was <code>rustc 1.11.0-nightly (0554abac6 2016-06-10)</code>.</p>
<p>If you know similar challenges let me know in the comment section below. One challenge that looks similar is ICFP’06 programming contest <a href="http://www.boundvariable.org/">“The Cult of the Bound Variable”</a>, which I always wanted to solve but never really got a chance. Maybe I should try it next.</p>

<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://osa1.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

            </div>
        </div>
    </body>
</html>
