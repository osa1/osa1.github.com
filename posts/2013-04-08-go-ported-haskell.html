<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>osa1 - Go channel examples ported to Haskell</title>
        <link rel="icon" href="data:,">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="alternate" type="application/rss+xml" title="osa1.net blog" href="../rss.xml" />
    </head>
    <body>
        <div id="column">
            <div id="header-inner">
                <span id="blog-title"><a href="../">osa1</a></span>
                <span class="menu-item"><a href="https://github.com/osa1">github</a></span>
                <span class="menu-item"><a href="https://gitlab.haskell.org/osa1">gitlab</a></span>
                <span class="menu-item"><a href="../rss.xml">rss</a></span>
            </div>
            <div class="inner">
                <h1 id="post-title">Go channel examples ported to Haskell</h1>

<p><strong>April  8, 2013</strong> - Tagged as: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/en.html">en</a>.</p>

<p>I’ve been skimming over <a href="http://tour.golang.org/">gotour</a> recently. I think it’s great introduction to language; it’s short, but concise and it shows some of the interesting features of language.</p>
<p>Last part of the tour is about goroutines and channels. My concurrent programming experience is very limited, and since Haskell is my favorite language, I decided to port goroutine examples to Haskell as a learning exercise.</p>
<p>Any criticism would be appreciated.</p>
<h3 id="goroutines"><a href="http://tour.golang.org/#62">62 - Goroutines</a></h3>
<p>This is a very basic example of a program creating two threads and printing some strings.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">Control.Concurrent</span>
<span class="kw">import</span> <span class="dt">Control.Monad</span>

<span class="ot">say ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
say s <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] <span class="fu">$</span> \ _ <span class="ot">-&gt;</span> <span class="kw">do</span>
  threadDelay <span class="dv">100000</span>
  <span class="fu">putStrLn</span> s

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  forkIO <span class="fu">$</span> say <span class="st">&quot;world&quot;</span>
  say <span class="st">&quot;hello&quot;</span></code></pre></div>
<h3 id="channels"><a href="http://tour.golang.org/#63">63 - Channels</a></h3>
<p>Simple channels example</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">Control.Concurrent</span>

<span class="ot">sum' ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Chan</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
sum' ints chan <span class="fu">=</span> writeChan chan (<span class="fu">sum</span> ints)
<span class="co">-- alternative, `pointfree` style: </span>
<span class="co">-- sum' = flip writeChan . sum</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> lst <span class="fu">=</span> [<span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="fu">-</span><span class="dv">9</span>, <span class="dv">4</span>, <span class="dv">0</span>]
  chan <span class="ot">&lt;-</span> newChan
  <span class="kw">let</span> (l1, l2) <span class="fu">=</span> <span class="fu">splitAt</span> (<span class="fu">floor</span> <span class="fu">$</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> lst) <span class="fu">/</span> <span class="dv">2</span>) lst
  forkIO <span class="fu">$</span> sum' l1 chan
  forkIO <span class="fu">$</span> sum' l2 chan
  x <span class="ot">&lt;-</span> readChan chan
  y <span class="ot">&lt;-</span> readChan chan
  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">unwords</span> [ <span class="fu">show</span> x, <span class="fu">show</span> y, <span class="fu">show</span> <span class="fu">$</span> x <span class="fu">+</span> y ]</code></pre></div>
<h3 id="buffered-channels"><a href="http://tour.golang.org/#64">64 - Buffered Channels</a></h3>
<p>This is where porting started getting tricky. Haskell channels are basically linked lists, and do not have length or size. In order to get a similar effect, I created a new channel type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">Control.Concurrent</span>

<span class="co">-- Buffered chan</span>
<span class="kw">data</span> <span class="dt">BChan</span> a <span class="fu">=</span> <span class="dt">BChan</span> {<span class="ot"> chan ::</span> <span class="dt">Chan</span> a,<span class="ot"> size ::</span> <span class="dt">MVar</span> <span class="dt">Int</span>,<span class="ot"> limit ::</span> <span class="dt">Int</span> }

<span class="ot">newBChan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">BChan</span> a)
newBChan bufsize <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newChan
  bvar <span class="ot">&lt;-</span> newMVar <span class="dv">0</span>
  <span class="fu">return</span> <span class="dt">BChan</span>{chan<span class="fu">=</span>chan, size<span class="fu">=</span>bvar, limit<span class="fu">=</span>bufsize}

<span class="ot">readBChan ::</span> <span class="dt">BChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
readBChan <span class="dt">BChan</span>{chan, size, limit} <span class="fu">=</span> <span class="kw">do</span>
  ret <span class="ot">&lt;-</span> readChan chan
  modifyMVar_ size <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="fu">return</span> (i<span class="fu">-</span><span class="dv">1</span>)
  <span class="fu">return</span> ret

<span class="ot">writeBChan ::</span> <span class="dt">BChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeBChan bchan<span class="fu">@</span><span class="dt">BChan</span>{chan, size, limit} val <span class="fu">=</span> <span class="kw">do</span>
  size' <span class="ot">&lt;-</span> readMVar size
  <span class="kw">if</span> size' <span class="fu">==</span> limit
    <span class="kw">then</span> <span class="kw">do</span>
      threadDelay <span class="dv">100000</span>
      writeBChan bchan val
    <span class="kw">else</span> <span class="kw">do</span>
      modifyMVar_ size <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="fu">return</span> (i<span class="fu">+</span><span class="dv">1</span>)
      writeChan chan val

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newBChan <span class="dv">2</span>
  writeBChan chan <span class="dv">1</span>
  writeBChan chan <span class="dv">2</span>

  v1 <span class="ot">&lt;-</span> readBChan chan
  <span class="fu">print</span> v1

  v2 <span class="ot">&lt;-</span> readBChan chan
  <span class="fu">print</span> v2</code></pre></div>
<p>Here one difference is that Haskell doesn’t fail with a “deadlock!!” error when an extra <code>writeBChan</code> operation is added(or one of them is removed), but just waits forever(like in a <em>real</em> deadlock :-P ). I wonder whether there is a way to get an exception like that, it’s awesome.</p>
<h3 id="range-and-close"><a href="http://tour.golang.org/#65">65 - Range and Close</a></h3>
<p>Same as above, Haskell channels are not working like Go channels. I had to simulate Go channels’ behavior.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns, MultiWayIf #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">Control.Concurrent</span>
<span class="kw">import</span> <span class="dt">Control.Monad</span> (liftM)

<span class="co">-- Closable channel</span>
<span class="kw">data</span> <span class="dt">CChan</span> a <span class="fu">=</span> <span class="dt">CChan</span> (<span class="dt">MVar</span> ([a], <span class="dt">Int</span>, <span class="dt">Bool</span>))

<span class="ot">newCChan ::</span> <span class="dt">IO</span> (<span class="dt">CChan</span> a)
newCChan <span class="fu">=</span> liftM <span class="dt">CChan</span> (newMVar ([], <span class="dv">0</span>, <span class="dt">False</span>))

<span class="ot">readCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)
readCChan (<span class="dt">CChan</span> mvar) <span class="fu">=</span> <span class="kw">do</span>
  (contents, size, closed) <span class="ot">&lt;-</span> takeMVar mvar
  <span class="kw">if</span> <span class="fu">|</span> size <span class="fu">==</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> <span class="fu">not</span> closed <span class="ot">-&gt;</span> <span class="kw">do</span>
         putMVar mvar (contents, size, closed)
         readCChan (<span class="dt">CChan</span> mvar)
     <span class="fu">|</span> size <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
         putMVar mvar (contents, size, closed)
         <span class="fu">return</span> <span class="dt">Nothing</span>
     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
         <span class="kw">let</span> r <span class="fu">=</span> <span class="fu">head</span> contents
         putMVar mvar (<span class="fu">tail</span> contents, size<span class="fu">-</span><span class="dv">1</span>, closed)
         <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Just</span> r

<span class="ot">writeCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeCChan (<span class="dt">CChan</span> mvar) val <span class="fu">=</span> <span class="kw">do</span>
  (contents, size, closed) <span class="ot">&lt;-</span> takeMVar mvar
  <span class="kw">if</span> closed
    <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;writing to a closed chan&quot;</span>
    <span class="kw">else</span> putMVar mvar (val <span class="fu">:</span> contents, size<span class="fu">+</span><span class="dv">1</span>, closed)

<span class="ot">forChan_ ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
forChan_ cchan f <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> readCChan cchan
  <span class="kw">case</span> v <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()
    <span class="dt">Just</span> v' <span class="ot">-&gt;</span> f v' <span class="fu">&gt;&gt;</span> forChan_ cchan f

<span class="ot">closeCChan ::</span> <span class="dt">CChan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
closeCChan (<span class="dt">CChan</span> mvar) <span class="fu">=</span>
    modifyMVar_ mvar <span class="fu">$</span> \(contents, size, closed) <span class="ot">-&gt;</span> <span class="fu">return</span> (contents, size, <span class="dt">True</span>)

<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CChan</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
fib i chan <span class="fu">=</span> <span class="kw">do</span>
    iter i <span class="dv">0</span> <span class="dv">1</span>
    closeCChan chan
  <span class="kw">where</span> iter <span class="dv">1</span> x y <span class="fu">=</span> writeCChan chan x
        iter n x y <span class="fu">=</span> <span class="kw">do</span>
          writeCChan chan x
          iter (n<span class="fu">-</span><span class="dv">1</span>) y (x<span class="fu">+</span>y)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  chan <span class="ot">&lt;-</span> newCChan
  forkIO <span class="fu">$</span> fib <span class="dv">10</span> chan
  forChan_ chan <span class="fu">print</span></code></pre></div>
<p>This example still doesn’t quite work like Go code. This is because I used a stack instead of a queue. It should be trivial to fix this code though.</p>
<h3 id="select-and-67---default-selection"><a href="http://tour.golang.org/#66">66 - Select</a> and <a href="http://tour.golang.org/#67">67 - Default Selection</a></h3>
<p>Now this is hard. In 66, example program listens multiple channels, and runs some code when any of the channels is ready. If multiple channels are ready at the same time, one of them is chosen randomly. 67 is similar, only difference is when none of the channels are ready, some default action is taken.</p>
<p>I’m actually not sure if it’s implementable with Haskell Chans, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Concurrent-Chan.html#v:isEmptyChan"><code>isEmptyChan :: Chan a -&gt; IO Bool</code></a> is deprecated, and users are directed to TChans(I think it’s mostly same as a Chan, but working on STM).</p>
<p>Anyway, that’s it for now. I’ll go learn(pun intended) some STM, why we need them and what’s different about them, and then maybe I can implement this last two examples.</p>

<hr />

<div id="disqus_thread">
    <a href="#" onclick="loadDisqus(); return false;">
        (Show comments)
    </a>
</div>

<script>
    function loadDisqus() {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = 'https://osa1.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] ||
            document.getElementsByTagName('body')[0]).appendChild(dsq);
    };
</script>

            </div>
        </div>
    </body>
</html>
