<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>osa1 - Memoized parsing in continuation-passing style</title>
        <link rel="icon" href="data:,">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="alternate" type="application/rss+xml" title="osa1.net blog" href="../rss.xml" />
    </head>
    <body>
        <div id="column">
            <div id="header-inner">
                <span id="blog-title"><a href="../">osa1</a></span>
                <span class="menu-item"><a href="https://github.com/osa1">github</a></span>
                <span class="menu-item"><a href="https://gitlab.haskell.org/osa1">gitlab</a></span>
                <span class="menu-item"><a href="../rss.xml">rss</a></span>
            </div>
            <div class="inner">
                <h1 id="post-title">Memoized parsing in continuation-passing style</h1>

<p><strong>October 21, 2013</strong> - Tagged as: <a href="../tags/en.html">en</a>, <a href="../tags/parsing.html">parsing</a>, <a href="../tags/cps.html">cps</a>.</p>

<p>Continuations are truly magical things. They’re the “ultimate abstractions of control flow”. Even without using any fancy language features like <code>call/cc</code>, you can have seriously cool and mind-boggling programs.</p>
<p>In <a href="http://arxiv.org/pdf/cmp-lg/9504016">“Memoization in Top-Down Parsing”</a> paper, Mark Johnson builds up from memoizing top-down parsers and describes a way to handle left recursion in top-down parsers by combining memoization techniques with continuations.</p>
<p>I ported the code to Lua to experiment, you can see it <a href="https://gist.github.com/osa1/7089333">here</a>. Most interesting part is the memoized CPS parser generator from a normal CPS parser function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> memo<span class="op">(</span>parser<span class="op">)</span>
    <span class="co">-- </span><span class="al">WARNING</span><span class="co">: this function is badly implemented in the sense that</span>
    <span class="co">-- if you parser generated by this function on two different streams</span>
    <span class="co">-- it will generate wrong results</span>
    <span class="kw">local</span> tbl <span class="op">=</span> <span class="op">{}</span>
    <span class="cf">return</span> <span class="kw">function</span> <span class="op">(</span>stream<span class="op">,</span> idx<span class="op">,</span> cont<span class="op">)</span>
        <span class="cf">if</span> tbl<span class="op">[</span>idx<span class="op">]</span> <span class="op">==</span> <span class="kw">nil</span> <span class="cf">then</span>
            tbl<span class="op">[</span>idx<span class="op">]</span> <span class="op">=</span> <span class="op">{</span> results <span class="op">=</span> <span class="op">{},</span> conts <span class="op">=</span> <span class="op">{}</span> <span class="op">}</span>
            <span class="fu">table.insert</span><span class="op">(</span>tbl<span class="op">[</span>idx<span class="op">].</span>conts<span class="op">,</span> cont<span class="op">)</span>
            parser<span class="op">(</span>stream<span class="op">,</span> idx<span class="op">,</span> <span class="kw">function</span> <span class="op">(</span>parse_result<span class="op">)</span>
                <span class="co">-- check if same parse_result is already in the table</span>
                <span class="kw">local</span> exists <span class="op">=</span> <span class="kw">false</span>
                <span class="cf">for</span> <span class="cn">_</span><span class="op">,</span> result <span class="kw">in</span> <span class="fu">ipairs</span><span class="op">(</span>tbl<span class="op">[</span>idx<span class="op">].</span>results<span class="op">)</span> <span class="cf">do</span>
                    <span class="cf">if</span> result <span class="op">==</span> parse_result <span class="cf">then</span> <span class="co">-- </span><span class="al">TODO</span><span class="co">: this equality is probably wrong</span>
                        exists <span class="op">=</span> <span class="kw">true</span>
                        <span class="cf">break</span>
                    <span class="cf">end</span>
                <span class="cf">end</span>
 
                <span class="cf">if</span> <span class="kw">not</span> exists <span class="cf">then</span>
                    <span class="fu">table.insert</span><span class="op">(</span>tbl<span class="op">[</span>idx<span class="op">].</span>results<span class="op">,</span> parse_result<span class="op">)</span>
                    <span class="cf">for</span> <span class="cn">_</span><span class="op">,</span> cont <span class="kw">in</span> <span class="fu">ipairs</span><span class="op">(</span>tbl<span class="op">[</span>idx<span class="op">].</span>conts<span class="op">)</span> <span class="cf">do</span>
                        cont<span class="op">(</span>parse_result<span class="op">)</span>
                    <span class="cf">end</span>
                <span class="cf">end</span>
            <span class="cf">end</span><span class="op">)</span>
        <span class="cf">else</span>
            <span class="fu">table.insert</span><span class="op">(</span>tbl<span class="op">[</span>idx<span class="op">].</span>conts<span class="op">,</span> cont<span class="op">)</span>
            <span class="cf">for</span> <span class="cn">_</span><span class="op">,</span> result <span class="kw">in</span> <span class="fu">ipairs</span><span class="op">(</span>tbl<span class="op">[</span>idx<span class="op">].</span>results<span class="op">)</span> <span class="cf">do</span>
                cont<span class="op">(</span>result<span class="op">)</span>
            <span class="cf">end</span>
        <span class="cf">end</span>
        <span class="cf">return</span> tbl<span class="op">[</span>idx<span class="op">]</span>
    <span class="cf">end</span>
<span class="cf">end</span></code></pre></div>
<p>(btw, I found porting this code to a purely functional setting very hard thing to do. If you find a way to do this, please send me your code. Thanks.)</p>
<p>This piece of code didn’t make sense to me for a while. I think the key to understand this function is to find answer to this question:</p>
<p>How is this different from keeping a set of productions visited without consuming any input from input stream and when you come to the same production, just failing instead of trying to parse? Because trying to derive same production without consuming any input means you’ll end up with infinite loop.</p>
<p>This function different in that it accounts for parsing same production after following a different path of production. Think this CFG as an example:</p>
<pre><code>T ::= T + T
    | int</code></pre>
<p>In order to derive first production, it first needs to parse a <code>T</code>. But then it will be already noted that it was already trying to parse <code>T</code>, and add the continuation to the list of continuations to be called when a T at input position 1 is parsed.</p>
<p>While trying alternatives, it will parse an <code>int</code>, and derive <code>T -&gt; int</code> at input position 1. And since it had saved the continuations to call when it successfully parse a <code>T</code> at location 1, it will call this continuations and thus parsing will continue.</p>
<p>I hope this helps other people to understand the trick.</p>

<hr />

<div id="disqus_thread">
    <a href="#" onclick="loadDisqus(); return false;">
        (Show comments)
    </a>
</div>

<script>
    function loadDisqus() {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = 'https://osa1.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] ||
            document.getElementsByTagName('body')[0]).appendChild(dsq);
    };
</script>

            </div>
        </div>
    </body>
</html>
