<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>osa1 - Papers I read in 2015-2016</title>
        <link rel="icon" href="data:,">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="alternate" type="application/rss+xml" title="osa1.net blog" href="../rss.xml" />
    </head>
    <body>
        <div id="column">
            <div id="header-inner">
                <span id="blog-title"><a href="../">osa1</a></span>
                <span class="menu-item"><a href="https://github.com/osa1">github</a></span>
                <span class="menu-item"><a href="https://gitlab.haskell.org/osa1">gitlab</a></span>
                <span class="menu-item"><a href="../rss.xml">rss</a></span>
            </div>
            <div class="inner">
                <h1 id="post-title">Papers I read in 2015-2016</h1>

<p><strong>November 15, 2016</strong> - Tagged as: <a href="../tags/en.html">en</a>.</p>

<p>This is my last week at Indiana University. It’ll be almost two years (1 year 11 months) since I came here, and it’s time for me to move on. While cleaning my messy desk covered with papers today I thought maybe I should make list of papers that I read (or at least printed) during this two-year period, so here it is.</p>
<p>Papers are sorted by publication dates. <code>???</code> indicates that the publication date is unknown (or may not be published at all), and those are listed last. I’ve added some very brief notes below some of the papers. Only last names of authors are listed.</p>
<hr />
<ul>
<li><p>On computable numbers, with an application to Entscheidungsproblem – Turing. 1936.</p></li>
<li><p>Computing Machinery and Intelligence – Turing. 1950.</p>
<p>Defines “the imitation game” aka. “Turing test”. Tries to answer some philosophical questions. I remember finding some of the arguments pretty weak.</p></li>
<li><p>Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I – McCarthy. 1960.</p>
<p>A classic. Defines “garbage collection”, “free list” and “stack” for the first time, without actually using those words.</p></li>
<li><p>A basis for a mathematical theory of computation – McCarthy. 1963.</p>
<p>Haven’t read.</p></li>
<li><p>The Next 700 Programming Languages – Landin. 1966.</p>
<p>Classic.</p></li>
<li><p>A Nonrecursive List Compacting Algorithm – Cheney. 1970.</p>
<p>A classic. Only two pages. Algorithm can easily be generalized to collect arbitrary heap objects. Known as “Cheney’s algorithm” in GC literature.</p></li>
<li><p>Monotone Data Flow Analysis Frameworks – Kam, Ullman. 1975.</p></li>
<li><p>Global Data Flow Analysis and Iterative Algorithms – Kam, Ullman. 1976.</p></li>
<li><p>Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints – Cousot, Cousot. 1977.</p>
<p>Cousot &amp; Cousot, so avoid. Read “Principles of Program Analysis” (book) by Nielson, Nielson and Hanking.</p></li>
<li><p>A Real-Time Garbage Collector Based on the Lifetimes of Objects – Lieberman, Hewitt. 1983.</p>
<p>An early generational GC paper. Defines “scavenging” and “evacuation”, some of the terms used in GHC’s GC.</p></li>
<li><p>Generation Scavenging: A Non-disruptive High Performance Storage Reclamation Algorithm – Ungar. 1984.</p></li>
<li><p>Compiling Pattern Matching – Augustsson. 1985.</p>
<p>A very early paper on lazy pattern matching in LML. IIRC the idea is very simple and maybe even obvious, but this is a very early publication on the topic.</p></li>
<li><p>How to Replace Failure by a List of Successes - A method for exception handling, backtracking, and pattern matching in lazy functional languages – Wadler. 1985.</p>
<p>I don’t remember reading this.</p></li>
<li><p>Multilisp: A anguage for Concurrent Symbolic Computation – Halstead. 1985.</p>
<p>Haven’t read this.</p></li>
<li><p>Programming as Theory Building – Naur. 1985.</p>
<p>All I remember about this paper is that I disagreed very strongly with the points made. I see some notes on the paper about why analogies don’t work and are harmful.</p></li>
<li><p>Control Operators, the SECD-Machine, and the λ-Calculus – Felleisen, Friedman. 1986.</p></li>
<li><p>Hygienic Macro Expansion – Kohlbecker, Friedman, Felleisen, Duba. 1986.</p></li>
<li><p>No Silver Bullet - Essence and Accident in Software Engineering – Brooks. 1986.</p></li>
<li><p>ORBIT: An Optimizing Compiler for Scheme. Kranz, Kelsey, Rees, Hudak, Philbin, Adams. 1986.</p></li>
<li><p>The Concept of a Supercompiler – Turchin. 1986.</p>
<p>This is one of the earliest supercompilation papers published in English.</p>
<p>First supercompilation papers were in Russian. First supercompilation paper in English was “A supercompiler system based on the langauge Refal”, Turchin, 1979. I don’t know what happened in the 7 year period, but I think the next paper was this one.</p></li>
<li><p>Efficient Compilation of Pattern-Matching (The Implementation of Functional Programming Languages book chapter) – Wadler. 1987.</p></li>
<li><p>Re-opening Closures – Appel. 1987.</p>
<p>The idea is to optimize closures in runtime using captured variables. I’ve heard that Mu uses some variant of this idea.</p></li>
<li><p>The Concatenate Vanishes – Wadler, 1987.</p>
<p>An even earlier work than the deforestation one. Wadler shows how to “deforest” intermediate lists in some programs. I don’t remember how the idea worked, but it must be just a very simple case-of-case transformation.</p></li>
<li><p>Theorems for free! – Wadler. 1989.</p>
<p>Great paper, shows how parametricity leads to theorems.</p></li>
<li><p>Deforestation: Transforming programs to eliminate trees – Wadler. 1990.</p>
<p>I think this is another classic and coined the term “deforestation”. The paper makes a huge simplifying assumption and assumes that variables are used linearly in function bodies, which makes beta reduction safe in terms of work duplication. So not very useful for practical purposes.</p></li>
<li><p>Linear types can change the world! – Wadler. 1990.</p></li>
<li><p>Implementing Projection-based Strictness Analysis – Kubiak, Hughes, Launchbury. 1992.</p></li>
<li><p>Undecidability of Static Analysis – Landi. 1992.</p>
<p>IIRC this paper shows how interesting static analysis problems are undecidable, by means of reductions from known undecidable problems like the halting problem.</p></li>
<li><p>Unboxed objects and polymorphic typing – Leroy. 1992.</p></li>
<li><p>A Short Cut to Deforestation – Gill, Launchbury, Jones. 1993.</p>
<p>Introduces fold/build rules. Still in use today in GHC.</p></li>
<li><p>Metaobject protocols: Why we want them and what else they can do – Kiczales, Ashley, Rodriguez, Vahdat, Bobrow. 1993.</p></li>
<li><p>Occam’s Razor in Metacomputation: the Notion of a Perfect Process Tree – Glück, Klimov. 1993.</p>
<p>An even earlier paper on “perfect information propagation”. Uses “process trees” which are only used in very early supercompilation papers (including Turchin ones IIRC).</p></li>
<li><p>Syntactic Abstraction in Scheme – Dybvig, Hieb, Bruggeman. 1993.</p>
<p>Go IU!</p></li>
<li><p>What is a Purely Functional Language? – Sabry. 1993.</p></li>
<li><p>Partial Deduction and Driving are Equivalent – Glück, Sørensen. 1994.</p></li>
<li><p>Mix Ten Years Later – Jones. 1995.</p>
<p>I love Neil Jones’s partial evaluation work (and especially the book “Partial Evaluation and Automatic Program Generation” by Jones, Gomard, Sestoft).</p></li>
<li><p>The Design of a Pretty-printing Library – Hughes. 1995.</p></li>
<li><p>A Roadmap to Metacomputation by Supercompilation – Glück, Sørensen. 1996.</p>
<p>Shows how to use supercompilation for metaprogramming tasks “specialization”, “composition” and “inversion”. I don’t even remember what are the latter two though.</p></li>
<li><p>Building Domain-Specific Embedded Languages – Hudak. 1996.</p></li>
<li><p>On Perfect Supercompilation – Secher, Sørensen. 1996.</p>
<p>This paper shows how to do “negative information propagation” during “driving” (see Jones, 2000). “Negative” means “what forms a value cannot take”.</p>
<p>Now that I think about this idea again, I’m wondering in what sense “negative” information is special. Assuming the set of values of a type is finite, you can always express negative information as positive information, e.g. if the set contains <code>{X, Y, Z}</code> <code>cannot be X =&gt; is one of {Y, Z}</code>.</p></li>
<li><p>Realistic Compilation by Partial Evaluator – Sperber, Thiemann. 1996.</p>
<p>I love this paper. It inspired <a href="http://osa1.net/posts/2015-05-13-comp-through-interp.html">a project of mine</a>. I met the first author at ICFP’16 after coincidentally sitting next to him at lunch :) .</p></li>
<li><p>A transformation-based optimiser for Haskell – Jones, Santos. 1997.</p>
<p>Describes “let-no-escape” optimizations that is still in used today in GHC.</p></li>
<li><p>Improvement Theory and its Application – Sands. 1997.</p>
<p>The idea is used in Bolingbroke’s PhD thesis, that’s why I printed this, but I haven’t read it yet.</p></li>
<li><p>MetaML and Multi-Stage Programming with Explicit Annotations – Taha, Sheard. 1997.</p>
<p>Introduction to MetaML.</p></li>
<li><p>Definitional Interpreters for Higher-Order Programming Languages – Reynolds. 1998.</p>
<p>Classic.</p></li>
<li><p>Growing a Language – Steele. 1998.</p>
<p>Watch his talk with the same title instead, it’s awesome.</p></li>
<li><p>Positive supercompilation for a higher-order call-by-value language – Jonsson, Nordlander. 1998.</p>
<p>Funny how the pages are full of notes, yet I don’t remember anything about this paper.</p></li>
<li><p>Type Inference with Constrained Types – Odersky, Sulzmann, Wehr. 1998.</p></li>
<li><p>On the Power of Homeomorphic Embedding for Online Termination – Leuschel, 1998.</p></li>
<li><p>A semantics for imprecise exceptions – Jones, Reid, Hoare, Marlow, Henderson. 1999.</p></li>
<li><p>Call-By-Push-Value: A Subsuming Paradigm (extended abstract) – Levy. 1999.</p>
<p>Another paper that I just couldn’t finish.</p></li>
<li><p>Introduction to Supercompilation – Sørensen, Glück. 1999.</p>
<p>This is a really good introduction. It uses “process trees” which help a lot when trying to understand the idea for the first time. I made a presentation here at IU using process trees in this paper.</p></li>
<li><p>Linear Scan Register Allocation – Poletto, Sarkar. 1999.</p>
<p>Very famous algorithm, used in many JIT compilers. I think GHC also has a variant of this (see <code>compiler/nativeGen/RegAlloc/Linear</code> directory).</p></li>
<li><p>Partial Evaluation and Automatic Program Generation – Jones, Gomard, Sestoft. 1999.</p>
<p>I really like this book. I tried to implement every language in this book, but it became tiresome real quick. Best introduction to partial evaluation.</p></li>
<li><p>Secrets of the Glasgow Haskell Compiler inliner – Jones, Marlow. 1999.</p></li>
<li><p>The STG runtime system (revised) – Jones, Marlow. 1999.</p></li>
<li><p>Compiling Embedded Languages – Elliott, Finne, de Moor. 2000.</p></li>
<li><p>Type-Preserving Garbage Collectors – Wang, Appel. 2001.</p>
<p>Haven’t read this.</p></li>
<li><p>The Essence of Program Transformation by Partial Evaluation and Driving – Jones. 2000.</p>
<p>This paper defines the concept of “driving” which IIRC is also used in some early (before Mitchell and Bolingbroke papers) supercompilation papers.</p></li>
<li><p>Composable and Compilable Macros - When Want it When? – Flatt. 2002.</p></li>
<li><p>Template Meta-programming for Haskell – Sheard, Jones. 2002.</p></li>
<li><p>A Functional Correspondence between Evaluators and Abstract Machines – Ager, Biernacki, Danvy, Midtgaard. 2003.</p></li>
<li><p>From Interpreter to Compiler and Virtual Machine: A Functional Derivation – Ager, Biernacki, Danvy, Midtgaard. 2003.</p></li>
<li><p>Garbage-First Garbage Collection – Detlefts, Flood, Heller, Printezis. 2004.</p></li>
<li><p>Self-Adjusting Computation (PhD thesis) – Acar. 2005.</p>
<p>I started reading this a couple of time, failed every time. I was looking for some “automated” way of getting incremental compilation out of compiler passes that don’t take incremental compilation into account.</p></li>
<li><p>Gaussian Elimination: a case study in efficient genericity with MetaOCaml – Carette. 2005.</p></li>
<li><p>Fast and Loose Reasoning is Morally Correct – Danielsson, Hughes, Hansson, Gibbons. 2006.</p></li>
<li><p>Haskell Is Not Not ML – Rudiak-Gould, Mycroft, Jones. 2006.</p>
<p>I remember trying to read this paper many times, but I couldn’t succeed. I was thinking about an intermediate language that support both lazy and strict programs equally well.</p></li>
<li><p>Out of the Tar Pit – Moseley, Marks. 2006.</p>
<p>Defines “essential complexity” and “accidental complexity”.</p></li>
<li><p>The Development of Chez Scheme – Dybvig. 2006.</p>
<p>Chez in <a href="https://github.com/cisco/ChezScheme">now open source</a>. The runtime performance of Chez programs is good, but the compiler was a huge disappointment for me. Unreadable, undocumented mess, and the passes I was expecting to see is not there (sub-0CFA).</p></li>
<li><p>Call-pattern Specialisation for Haskell Programs – Jones. 2007.</p></li>
<li><p>Faster Laziness Using Dynamic Pointer Tagging – Marlow, Yakushev, Jones. 2007.</p>
<p>The idea is very simple and very effective. It’s in use in GHC today, and it’s saving us a lot of jumps. One of the reasons why unpacking sum types are not as useful as one might expect.</p>
<p>Over the summer 2016 one of the projects I worked on was to improve this in some cases. The problem was that in some cases (when strict fields are involved) GHC is currently not tagging some pointers even though in theory it could and that’d save us some instructions in the binaries. Unfortunately the rabbit hole goes quite deep and I had to drop it to focus on unboxed sums.</p></li>
<li><p>System F with Type Equality Coercions – Sulzmann, Chakravarty, Jones, Donnelly. 2007.</p></li>
<li><p>Generational Real-Time Garbage Collection - A Three-Part Invention for Young Objects – Frampton, Bacon, Cheng, Grove. 2007.</p>
<p>Haven’t read yet.</p></li>
<li><p>Bitcoin: A Peer-to-Peer Electronic Cash System – Satoshi Nakamoto. 2008.</p></li>
<li><p>Computation and State Machines – Lamport. 2008.</p></li>
<li><p>Finally Tagless, Partially Evaluate - Tagless Staged Interpreters for Simpler Typed Languages – Carette, Kiselyov, Shan. 2009.</p></li>
<li><p>Idempotent Work Stealing – Michael, Vechev, Saraswat. 2009.</p>
<p>This idea is used in LVish.</p></li>
<li><p>Positive Supercompilation for a Higher Order Call-By-Value Language – Jonsson, Nordlander. 2009.</p>
<p>An attempt at supercompiling a call-by-value language.</p></li>
<li><p>Supercompiler HOSC 1.0: under the hood – Klyuchnikov, 2009.</p>
<p>The author’s another paper (also listed here) is my favorite introduction to supercompilation.</p></li>
<li><p>Tracing the Meta-Level: PyPy’s Tracing JIT Compiler – Bolz, Cuni, Fijalkowski, Rigo. 2009.</p>
<p>Everything done by RPython/PyPy team is great.</p></li>
<li><p>Types are calling conventions – Bolingbroke, Jones. 2009.</p>
<p>Yet another great Bolingbroke work. I worked on a variant of this during the summer of 2016.</p></li>
<li><p>Abstracting Abstract Machines – Horn, Might. 2010.</p>
<p>I was told that this is very cool work, but I haven’t read it yet.</p></li>
<li><p>A Play on Regular Expressions – Fischer, Huch, Wilke. 2010.</p></li>
<li><p>Lightweight Modular Staging: A Pragmatic Approach to Runtime Code Generation and Compiled DSLs – Rompf, Odersky. 2010.</p>
<p>Scala LMS paper.</p></li>
<li><p>Proving the Equivalence of Higher-Order Terms by Means of Supercompilation – Klyuchnikov, Romanenko. 2010.</p></li>
<li><p>Rethinking Supercompilation – Mitchell. 2010.</p>
<p>I remember that I really liked this paper at the time. Unlike most other papers, this paper can be implemented in a couple of hours, and it works good enough. IIRC the main novelty here was the tag-bag based termination criterion, which was later developed further by Bolingbroke in first “Supercompilation by evaluation” and then in his PhD thesis.</p></li>
<li><p>Scrapping your Inefficient Engine: Using Partial Evaluation to Improve Domain-Specific Language Implementation – Brady, Hammond. 2010.</p>
<p>Introduces Idris’s partial evaluator.</p></li>
<li><p>Supercompilation by Evaluation – Bolingbroke, Jones. 2010.</p>
<p>Best supercompilation paper at the time. The record was later broken again by the author of this paper in his PhD thesis (also listed here). The author is amazing and I was depressed for a very long time after reading his papers (another notable one is “Termination Combinators Forever” which is also listed here). I’ll never be this good as a researcher.</p></li>
<li><p>Ur: Statically-Typed Metaprogramming with Type-Level Record Computation – Chilpala. 2010.</p></li>
<li><p>C4: The Continuously Concurrent Compacting Collector – Tene, Iyengar, Wolf. 2011.</p>
<p>Haven’t read yet.</p></li>
<li><p>Flow-Sensitive Type Recovery in Linear-Log Time – Adams, Keep, Midtgaard, Might, Chauhan, Dybvig. 2011.</p>
<p>Sub-0CFA for type inference. Not used in current Chez implementation as far as I can see. Goal is to eliminate runtime type checks.</p></li>
<li><p>How To Write Shared Libraries – Drepper. 2011.</p></li>
<li><p>Practical aspects of evidence-based compilation in System FC – Vytiniotis, Jones. 2011.</p>
<p>IIRC this stuff was introduced with GHC 7.2. For some reason that I can’t recall, it’s sometimes useful to return coercions in functions. This paper is about that. I don’t remember much although the paper has some notes on it.</p></li>
<li><p>Termination Combinators Forever – Bolingbroke, Jones, Vytiniotis. 2011.</p>
<p>Shows how to build online termination checkers using some primitives and combinators. Checkers are correct by construction. The implementation is used in the author’s implementation of his PhD thesis.</p></li>
<li><p>Challenges for a Trace-Based Just-In-Time Compiler for Haskell – Schilling. 2012.</p>
<p>Read his PhD thesis instead.</p></li>
<li><p>Chaperones and Impersonators: Run-time Support for Reasonable Interposition – Strickland, Tobin-Hochstadt, Findler, Flatt. 2012.</p>
<p>I have a big “NO” marked on the paper in red.</p></li>
<li><p>Explicitly Heterogeneous Metaprogramming with MetaHaskell – Mainland. 2012.</p></li>
<li><p>Self-Optimizing AST Interpreters – Würthinger, Wöß, Stadler, Duboscq, Simon, Wimmer. 2012.</p></li>
<li><p>The HERMIT in the Machine - A Plugin for the Interactive Transformation of GHC Core Language Programs – Farmer, Gill, Komp, Sculthorpe. 2012.</p></li>
<li><p>Call-by-need supercompilation (PhD thesis) – Bolingbroke. 2013.</p></li>
<li><p>Forge: Generating a High Performance DSL Implementation from a Declarative Specification – Sujeeth, Gibbons, Brown, Lee, Rompf, Odersky, Olukotun. 2013.</p>
<p>After having played with LMS and Delite a little bit, I have nothing good to say about this work. Things may be improved since then though.</p></li>
<li><p>Hybrid Partial Evaluation – Shali, Cook. 2013.</p>
<p>Cook has an introductory blog post / web page about partial evaluation which is pretty good.</p></li>
<li><p>Optimizing Data Structures in High-Level Programs – Rompf, Sujeeth, Amin, Brown, Jovanovic, Lee, Jonnalagedda, Olukotun, Odersky. 2013.</p>
<p>A Scala LMS paper. All I remember about these papers is that I didn’t like them.</p></li>
<li><p>One VM to Rule Them All – Würthinger, Wimmer, Wöß, Stadler, Duboscq, Humer, Richards, Simon, Wolczko. 2013.</p>
<p>Has 9 authors.</p></li>
<li><p>Simple and Efficient Construction of Static Single Assignment Form – Braun, Buchwalk, Hack, Leißa, Malloc, Zwinkau. 2013.</p>
<p>I think the algorithm was already known in the compilers community, but this paper publishes it first and benchmarks it.</p></li>
<li><p>Supercompiling Erlang (MSc thesis) – Weinholt. 2013.</p></li>
<li><p>Terra: A Multi-Stage Language for High-Performance Computing – DeVito, Hegarty, Aiken, Hanrahan, Vitek. 2013.</p>
<p>Terra is awesome. I talked a little bit about it in my blog posts <a href="http://osa1.net/posts/2015-05-17-staging-is-not-just-codegen.html">1</a>, <a href="http://osa1.net/posts/2015-08-09-sufficiently-smart-compiler.html">2</a>.</p></li>
<li><p>Trace-based Just-in-time Compilation for Lazy Functional Programming Languages (PhD thesis) – Schilling, 2013.</p>
<p>Two good theses published in 2013, Bolingbroke and this one. Too bad neither of them were pursued further.</p>
<p>IIRC the JIT introduction in this thesis is very easy to read, doesn’t assume a lot of background.</p></li>
<li><p>Combinators for Impure yet Hygienic Code Generation – Kameyama, Kiselyov, Shan. 2014.</p></li>
<li><p>Compiling a Reflective Language using MetaOCaml – Asai. 2014.</p>
<p>I love everything related with MetaOCaml.</p></li>
<li><p>Freeze After Writing - Quasi-Deterministic Parallel Programming with LVars – Kuper, Turon, Krishnaswami, Newton. 2014.</p></li>
<li><p>Macros that Work Together - Compile-Time Bindings, Partial Expression, and Definition Contexts – Flatt, Culpepper, Darais, Findler. 2014.</p></li>
<li><p>Modular, Higher-Order Cardinality Analysis in Theory and Practice – Sergey, Vytiniotis, Jones. 2014.</p>
<p>This is still in use in GHC today. Cardinality analysis is done as a part of demand analysis (lattice is extended to handle cardinalities).</p></li>
<li><p>Optimizing SYB Is Easy! – Adams, Farmer, Magalhaes. 2014.</p></li>
<li><p>Safe Zero-cost Coercions for Haskell (extended edition) – Breitner, Eisenberg, Jones, Weirich. 2014.</p>
<p>Another paper full of notes yet I don’t remember anything.</p></li>
<li><p>Supercompilation: Ideas and Methods – Klyuchnikov, Krustev. 2014.</p>
<p>Published in “The Monad.Reader” issue 23, this is without a doubt the best introduction to supercompilation. It’s very well written, provides great bibliography for further reading, and comes with a simple implementation. Great stuff, although the language is too simple to be useful.</p></li>
<li><p>Taming the Parallel Effect Zoo – Kuper, Todd, Tobin-Hochstadt, Newton. 2014.</p></li>
<li><p>The Kansas University Rewrite Engine - A Haskell-Embedded Strategic Programming Language with Custom Closed Universes – Sculthorpe, Frisby, Gill. 2014.</p>
<p>This is about KURE, rewrite engine that powers HERMIT. I remember that at the time I decided to implement my own rewrite combinators than fighting HERMIT API to do whatever I wanted to do.</p></li>
<li><p>Go 1.5 concurrent garbage collector pacing – Celements. 2015.</p></li>
<li><p>Static Program Analysis (lecture notes) – Møller, Schwartzbach. 2015.</p>
<p><a href="https://cs.au.dk/~amoeller/spa/" class="uri">https://cs.au.dk/~amoeller/spa/</a></p></li>
<li><p>Static Single Assignment Book (in-progress book) – “Lots of authors”. 2015 (ongoing)</p>
<p>I’m still reading this.</p></li>
<li><p>Shallow Embedding of DSLs via Online Partial Evaluation – Leißa, Boesche, Hack, Membarth, Slusallek. 2015.</p></li>
<li><p>The Design of Terra: Harnessing the Best Features of High-Level and Low-Level Languages – DeVito, Hanrahan. 2015.</p></li>
<li><p>Improving Implicit Parallelism – Trilla, Runciman. 2015.</p></li>
<li><p>K-Java: A Complete Semantics of Java – Bogdanas, Rosu. 2015.</p></li>
<li><p>Zero-Overhead Metaprogramming – Marr, Seaton, Ducasse. 2015.</p>
<p>Related with JITs, partial evaluation, and metaobject protocols. I don’t remember reading this.</p></li>
<li><p>GADTs Meet Their Match: Pattern-Matching Warnings That Account for GADTs, Guards, and Laziness – Karachalias, Schrivers, Vytiniotis, Jones. 2016.</p></li>
<li><p>Staging Generic Programming – Yallop. 2016.</p></li>
<li><p>State Machines All The Way Down - An Architecture for Dependently Typed Applications – Brady. 2016.</p></li>
</ul>
<hr />
<ul>
<li><p>Common Subexpression Elimination in a Lazy Functional Language – Chitil. ???</p>
<p>Shows how CSE can lead to more memory residency and is not always beneficial.</p></li>
<li><p>Constructed Product Result Analysis for Haskell – Baker-Finch, Glynn, Jones. ???</p>
<p>This is still a part of GHC, done during demand analysis. We recently extended this to work on sum types.</p></li>
<li><p>Demand analysis (draft, not published) – Jones, Sestoft, Hughes</p>
<p>I hate this paper because it wasted so much of my time. GHC wiki links to that, even though this is not relevant to the implementation. Read Sergey et al. instead.</p></li>
<li><p>Lecture Notes: Control Flow Analysis for Functional Languages (lecture notes) – Aldrich. ???</p></li>
<li><p>Supercompiling with Staging – Inoue. ???</p>
<p>Shows how to use MetaOCaml’s staging operators to do supercompilation-like transformations.</p></li>
<li><p>Space and Time Efficient Supercompilation (PhD thesis) – Jonsson. ???.</p></li>
<li><p>The Design and Implementation of BER MetaOCaml – Kiselyov. ???</p></li>
<li><p>The Next Stage of Staging – Inoue, Kiselyov, Kameyama. ???</p></li>
<li><p>Two Techniques for Compiling Lazy Pattern Matching – Maranget. ???</p></li>
<li><p>Warnings for pattern matching – Maranget. ???</p></li>
</ul>

<!--

<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://osa1.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

-->

            </div>
        </div>
    </body>
</html>
